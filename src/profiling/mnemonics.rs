//! Opcode-to-mnemonic lookup tables for instruction annotation.

use super::stats::OpcodeKey;

/// Legacy single-byte opcode mnemonics (0x00-0xFF).
pub const LEGACY_MNEMONICS: [&str; 256] = [
    // 0x00-0x0F
    "ADD r/m8,r8",
    "ADD r/m,r",
    "ADD r8,r/m8",
    "ADD r,r/m",
    "ADD AL,imm8",
    "ADD rAX,imm",
    "PUSH ES",
    "POP ES",
    "OR r/m8,r8",
    "OR r/m,r",
    "OR r8,r/m8",
    "OR r,r/m",
    "OR AL,imm8",
    "OR rAX,imm",
    "PUSH CS",
    "2-byte escape",
    // 0x10-0x1F
    "ADC r/m8,r8",
    "ADC r/m,r",
    "ADC r8,r/m8",
    "ADC r,r/m",
    "ADC AL,imm8",
    "ADC rAX,imm",
    "PUSH SS",
    "POP SS",
    "SBB r/m8,r8",
    "SBB r/m,r",
    "SBB r8,r/m8",
    "SBB r,r/m",
    "SBB AL,imm8",
    "SBB rAX,imm",
    "PUSH DS",
    "POP DS",
    // 0x20-0x2F
    "AND r/m8,r8",
    "AND r/m,r",
    "AND r8,r/m8",
    "AND r,r/m",
    "AND AL,imm8",
    "AND rAX,imm",
    "ES: prefix",
    "DAA",
    "SUB r/m8,r8",
    "SUB r/m,r",
    "SUB r8,r/m8",
    "SUB r,r/m",
    "SUB AL,imm8",
    "SUB rAX,imm",
    "CS: prefix",
    "DAS",
    // 0x30-0x3F
    "XOR r/m8,r8",
    "XOR r/m,r",
    "XOR r8,r/m8",
    "XOR r,r/m",
    "XOR AL,imm8",
    "XOR rAX,imm",
    "SS: prefix",
    "AAA",
    "CMP r/m8,r8",
    "CMP r/m,r",
    "CMP r8,r/m8",
    "CMP r,r/m",
    "CMP AL,imm8",
    "CMP rAX,imm",
    "DS: prefix",
    "AAS",
    // 0x40-0x4F (REX prefixes in 64-bit mode, INC/DEC in 32-bit)
    "INC/REX",
    "INC/REX.B",
    "INC/REX.X",
    "INC/REX.XB",
    "INC/REX.R",
    "INC/REX.RB",
    "INC/REX.RX",
    "INC/REX.RXB",
    "DEC/REX.W",
    "DEC/REX.WB",
    "DEC/REX.WX",
    "DEC/REX.WXB",
    "DEC/REX.WR",
    "DEC/REX.WRB",
    "DEC/REX.WRX",
    "DEC/REX.WRXB",
    // 0x50-0x5F
    "PUSH rAX",
    "PUSH rCX",
    "PUSH rDX",
    "PUSH rBX",
    "PUSH rSP",
    "PUSH rBP",
    "PUSH rSI",
    "PUSH rDI",
    "POP rAX",
    "POP rCX",
    "POP rDX",
    "POP rBX",
    "POP rSP",
    "POP rBP",
    "POP rSI",
    "POP rDI",
    // 0x60-0x6F
    "PUSHA/PUSHAD",
    "POPA/POPAD",
    "BOUND",
    "MOVSXD/ARPL",
    "FS: prefix",
    "GS: prefix",
    "OpSize prefix",
    "AddrSize prefix",
    "PUSH imm",
    "IMUL r,r/m,imm",
    "PUSH imm8",
    "IMUL r,r/m,imm8",
    "INS m8,DX",
    "INS m,DX",
    "OUTS DX,m8",
    "OUTS DX,m",
    // 0x70-0x7F (Jcc short)
    "JO rel8",
    "JNO rel8",
    "JB/JNAE rel8",
    "JNB/JAE rel8",
    "JZ/JE rel8",
    "JNZ/JNE rel8",
    "JBE/JNA rel8",
    "JNBE/JA rel8",
    "JS rel8",
    "JNS rel8",
    "JP/JPE rel8",
    "JNP/JPO rel8",
    "JL/JNGE rel8",
    "JNL/JGE rel8",
    "JLE/JNG rel8",
    "JNLE/JG rel8",
    // 0x80-0x8F
    "GRP1 r/m8,imm8",
    "GRP1 r/m,imm",
    "GRP1 r/m8,imm8",
    "GRP1 r/m,imm8",
    "TEST r/m8,r8",
    "TEST r/m,r",
    "XCHG r8,r/m8",
    "XCHG r,r/m",
    "MOV r/m8,r8",
    "MOV r/m,r",
    "MOV r8,r/m8",
    "MOV r,r/m",
    "MOV r/m,Sreg",
    "LEA r,m",
    "MOV Sreg,r/m",
    "POP r/m",
    // 0x90-0x9F
    "NOP/XCHG",
    "XCHG rCX,rAX",
    "XCHG rDX,rAX",
    "XCHG rBX,rAX",
    "XCHG rSP,rAX",
    "XCHG rBP,rAX",
    "XCHG rSI,rAX",
    "XCHG rDI,rAX",
    "CBW/CWDE/CDQE",
    "CWD/CDQ/CQO",
    "CALL FAR",
    "FWAIT",
    "PUSHF",
    "POPF",
    "SAHF",
    "LAHF",
    // 0xA0-0xAF
    "MOV AL,moffs",
    "MOV rAX,moffs",
    "MOV moffs,AL",
    "MOV moffs,rAX",
    "MOVSB",
    "MOVSW/D/Q",
    "CMPSB",
    "CMPSW/D/Q",
    "TEST AL,imm8",
    "TEST rAX,imm",
    "STOSB",
    "STOSW/D/Q",
    "LODSB",
    "LODSW/D/Q",
    "SCASB",
    "SCASW/D/Q",
    // 0xB0-0xBF
    "MOV AL,imm8",
    "MOV CL,imm8",
    "MOV DL,imm8",
    "MOV BL,imm8",
    "MOV AH,imm8",
    "MOV CH,imm8",
    "MOV DH,imm8",
    "MOV BH,imm8",
    "MOV rAX,imm",
    "MOV rCX,imm",
    "MOV rDX,imm",
    "MOV rBX,imm",
    "MOV rSP,imm",
    "MOV rBP,imm",
    "MOV rSI,imm",
    "MOV rDI,imm",
    // 0xC0-0xCF
    "GRP2 r/m8,imm8",
    "GRP2 r/m,imm8",
    "RET imm16",
    "RET",
    "LES/VEX3",
    "LDS/VEX2",
    "MOV r/m8,imm8",
    "MOV r/m,imm",
    "ENTER",
    "LEAVE",
    "RETF imm16",
    "RETF",
    "INT 3",
    "INT imm8",
    "INTO",
    "IRET/IRETD/IRETQ",
    // 0xD0-0xDF
    "GRP2 r/m8,1",
    "GRP2 r/m,1",
    "GRP2 r/m8,CL",
    "GRP2 r/m,CL",
    "AAM",
    "AAD",
    "SALC",
    "XLAT",
    "FPU D8",
    "FPU D9",
    "FPU DA",
    "FPU DB",
    "FPU DC",
    "FPU DD",
    "FPU DE",
    "FPU DF",
    // 0xE0-0xEF
    "LOOPNE rel8",
    "LOOPE rel8",
    "LOOP rel8",
    "JRCXZ rel8",
    "IN AL,imm8",
    "IN eAX,imm8",
    "OUT imm8,AL",
    "OUT imm8,eAX",
    "CALL rel",
    "JMP rel",
    "JMP FAR",
    "JMP rel8",
    "IN AL,DX",
    "IN eAX,DX",
    "OUT DX,AL",
    "OUT DX,eAX",
    // 0xF0-0xFF
    "LOCK prefix",
    "INT1/ICEBP",
    "REPNE prefix",
    "REP prefix",
    "HLT",
    "CMC",
    "GRP3 r/m8",
    "GRP3 r/m",
    "CLC",
    "STC",
    "CLI",
    "STI",
    "CLD",
    "STD",
    "GRP4 r/m8",
    "GRP5 r/m",
];

/// Two-byte opcode mnemonics (0x0F XX).
pub const TWOBYTE_MNEMONICS: [&str; 256] = [
    // 0x0F 0x00-0x0F
    "GRP6",
    "GRP7",
    "LAR",
    "LSL",
    "???",
    "SYSCALL",
    "CLTS",
    "SYSRET",
    "INVD",
    "WBINVD",
    "???",
    "UD2",
    "???",
    "prefetch",
    "FEMMS",
    "3DNow!",
    // 0x0F 0x10-0x1F
    "MOVUPS/MOVSS/MOVUPD/MOVSD",
    "MOVUPS/MOVSS/MOVUPD/MOVSD",
    "MOVLPS/MOVHLPS/MOVLPD/MOVSLDUP/MOVDDUP",
    "MOVLPS/MOVLPD",
    "UNPCKLPS/UNPCKLPD",
    "UNPCKHPS/UNPCKHPD",
    "MOVHPS/MOVLHPS/MOVHPD/MOVSHDUP",
    "MOVHPS/MOVHPD",
    "prefetch",
    "NOP",
    "NOP",
    "NOP",
    "NOP",
    "NOP",
    "NOP",
    "NOP",
    // 0x0F 0x20-0x2F
    "MOV r,CR",
    "MOV r,DR",
    "MOV CR,r",
    "MOV DR,r",
    "???",
    "???",
    "???",
    "???",
    "MOVAPS/MOVAPD",
    "MOVAPS/MOVAPD",
    "CVTPI2PS/CVTSI2SS/CVTPI2PD/CVTSI2SD",
    "MOVNTPS/MOVNTPD",
    "CVTTPS2PI/CVTTSS2SI/CVTTPD2PI/CVTTSD2SI",
    "CVTPS2PI/CVTSS2SI/CVTPD2PI/CVTSD2SI",
    "UCOMISS/UCOMISD",
    "COMISS/COMISD",
    // 0x0F 0x30-0x3F
    "WRMSR",
    "RDTSC",
    "RDMSR",
    "RDPMC",
    "SYSENTER",
    "SYSEXIT",
    "???",
    "GETSEC",
    "3-byte escape 38",
    "???",
    "3-byte escape 3A",
    "???",
    "???",
    "???",
    "???",
    "???",
    // 0x0F 0x40-0x4F (CMOVcc)
    "CMOVO",
    "CMOVNO",
    "CMOVB/CMOVNAE",
    "CMOVNB/CMOVAE",
    "CMOVZ/CMOVE",
    "CMOVNZ/CMOVNE",
    "CMOVBE/CMOVNA",
    "CMOVNBE/CMOVA",
    "CMOVS",
    "CMOVNS",
    "CMOVP/CMOVPE",
    "CMOVNP/CMOVPO",
    "CMOVL/CMOVNGE",
    "CMOVNL/CMOVGE",
    "CMOVLE/CMOVNG",
    "CMOVNLE/CMOVG",
    // 0x0F 0x50-0x5F
    "MOVMSKPS/MOVMSKPD",
    "SQRTPS/SQRTSS/SQRTPD/SQRTSD",
    "RSQRTPS/RSQRTSS",
    "RCPPS/RCPSS",
    "ANDPS/ANDPD",
    "ANDNPS/ANDNPD",
    "ORPS/ORPD",
    "XORPS/XORPD",
    "ADDPS/ADDSS/ADDPD/ADDSD",
    "MULPS/MULSS/MULPD/MULSD",
    "CVTPS2PD/CVTSS2SD/CVTPD2PS/CVTSD2SS",
    "CVTDQ2PS/CVTPS2DQ/CVTTPS2DQ",
    "SUBPS/SUBSS/SUBPD/SUBSD",
    "MINPS/MINSS/MINPD/MINSD",
    "DIVPS/DIVSS/DIVPD/DIVSD",
    "MAXPS/MAXSS/MAXPD/MAXSD",
    // 0x0F 0x60-0x6F
    "PUNPCKLBW",
    "PUNPCKLWD",
    "PUNPCKLDQ",
    "PACKSSWB",
    "PCMPGTB",
    "PCMPGTW",
    "PCMPGTD",
    "PACKUSWB",
    "PUNPCKHBW",
    "PUNPCKHWD",
    "PUNPCKHDQ",
    "PACKSSDW",
    "PUNPCKLQDQ",
    "PUNPCKHQDQ",
    "MOVD/MOVQ",
    "MOVQ/MOVDQA/MOVDQU",
    // 0x0F 0x70-0x7F
    "PSHUFW/PSHUFD/PSHUFHW/PSHUFLW",
    "GRP12",
    "GRP13",
    "GRP14",
    "PCMPEQB",
    "PCMPEQW",
    "PCMPEQD",
    "EMMS",
    "VMREAD",
    "VMWRITE",
    "???",
    "???",
    "HADDPD/HADDPS",
    "HSUBPD/HSUBPS",
    "MOVD/MOVQ",
    "MOVQ/MOVDQA/MOVDQU",
    // 0x0F 0x80-0x8F (Jcc near)
    "JO rel",
    "JNO rel",
    "JB/JNAE rel",
    "JNB/JAE rel",
    "JZ/JE rel",
    "JNZ/JNE rel",
    "JBE/JNA rel",
    "JNBE/JA rel",
    "JS rel",
    "JNS rel",
    "JP/JPE rel",
    "JNP/JPO rel",
    "JL/JNGE rel",
    "JNL/JGE rel",
    "JLE/JNG rel",
    "JNLE/JG rel",
    // 0x0F 0x90-0x9F (SETcc)
    "SETO",
    "SETNO",
    "SETB/SETNAE",
    "SETNB/SETAE",
    "SETZ/SETE",
    "SETNZ/SETNE",
    "SETBE/SETNA",
    "SETNBE/SETA",
    "SETS",
    "SETNS",
    "SETP/SETPE",
    "SETNP/SETPO",
    "SETL/SETNGE",
    "SETNL/SETGE",
    "SETLE/SETNG",
    "SETNLE/SETG",
    // 0x0F 0xA0-0xAF
    "PUSH FS",
    "POP FS",
    "CPUID",
    "BT r/m,r",
    "SHLD r/m,r,imm8",
    "SHLD r/m,r,CL",
    "???",
    "???",
    "PUSH GS",
    "POP GS",
    "RSM",
    "BTS r/m,r",
    "SHRD r/m,r,imm8",
    "SHRD r/m,r,CL",
    "GRP15",
    "IMUL r,r/m",
    // 0x0F 0xB0-0xBF
    "CMPXCHG r/m8,r8",
    "CMPXCHG r/m,r",
    "LSS",
    "BTR r/m,r",
    "LFS",
    "LGS",
    "MOVZX r,r/m8",
    "MOVZX r,r/m16",
    "POPCNT/JMPE",
    "GRP10/UD1",
    "GRP8 r/m,imm8",
    "BTC r/m,r",
    "BSF/TZCNT",
    "BSR/LZCNT",
    "MOVSX r,r/m8",
    "MOVSX r,r/m16",
    // 0x0F 0xC0-0xCF
    "XADD r/m8,r8",
    "XADD r/m,r",
    "CMPPS/CMPSS/CMPPD/CMPSD",
    "MOVNTI",
    "PINSRW",
    "PEXTRW",
    "SHUFPS/SHUFPD",
    "GRP9",
    "BSWAP rAX",
    "BSWAP rCX",
    "BSWAP rDX",
    "BSWAP rBX",
    "BSWAP rSP",
    "BSWAP rBP",
    "BSWAP rSI",
    "BSWAP rDI",
    // 0x0F 0xD0-0xDF
    "ADDSUBPD/ADDSUBPS",
    "PSRLW",
    "PSRLD",
    "PSRLQ",
    "PADDQ",
    "PMULLW",
    "MOVQ/MOVQ2DQ/MOVDQ2Q",
    "PMOVMSKB",
    "PSUBUSB",
    "PSUBUSW",
    "PMINUB",
    "PAND",
    "PADDUSB",
    "PADDUSW",
    "PMAXUB",
    "PANDN",
    // 0x0F 0xE0-0xEF
    "PAVGB",
    "PSRAW",
    "PSRAD",
    "PAVGW",
    "PMULHUW",
    "PMULHW",
    "CVTPD2DQ/CVTTPD2DQ/CVTDQ2PD",
    "MOVNTQ/MOVNTDQ",
    "PSUBSB",
    "PSUBSW",
    "PMINSW",
    "POR",
    "PADDSB",
    "PADDSW",
    "PMAXSW",
    "PXOR",
    // 0x0F 0xF0-0xFF
    "LDDQU",
    "PSLLW",
    "PSLLD",
    "PSLLQ",
    "PMULUDQ",
    "PMADDWD",
    "PSADBW",
    "MASKMOVQ/MASKMOVDQU",
    "PSUBB",
    "PSUBW",
    "PSUBD",
    "PSUBQ",
    "PADDB",
    "PADDW",
    "PADDD",
    "UD0",
];

/// Get the mnemonic for an opcode key.
pub fn get_mnemonic(key: &OpcodeKey) -> &'static str {
    match key {
        OpcodeKey::Legacy(op) => LEGACY_MNEMONICS[*op as usize],
        OpcodeKey::TwoByte(op) => TWOBYTE_MNEMONICS[*op as usize],
        OpcodeKey::ThreeByte38(op) => get_threebyte_38_mnemonic(*op),
        OpcodeKey::ThreeByte3A(op) => get_threebyte_3a_mnemonic(*op),
        OpcodeKey::Vex { map, opcode } => get_vex_mnemonic(*map, *opcode),
        OpcodeKey::Evex { map, opcode } => get_evex_mnemonic(*map, *opcode),
        OpcodeKey::Fpu { escape, modrm_reg } => get_fpu_mnemonic(*escape, *modrm_reg),
    }
}

/// Get mnemonic for 0x0F 0x38 XX opcodes.
fn get_threebyte_38_mnemonic(op: u8) -> &'static str {
    match op {
        0x00 => "PSHUFB",
        0x01 => "PHADDW",
        0x02 => "PHADDD",
        0x03 => "PHADDSW",
        0x04 => "PMADDUBSW",
        0x05 => "PHSUBW",
        0x06 => "PHSUBD",
        0x07 => "PHSUBSW",
        0x08 => "PSIGNB",
        0x09 => "PSIGNW",
        0x0A => "PSIGND",
        0x0B => "PMULHRSW",
        0x10 => "PBLENDVB",
        0x14 => "BLENDVPS",
        0x15 => "BLENDVPD",
        0x17 => "PTEST",
        0x1C => "PABSB",
        0x1D => "PABSW",
        0x1E => "PABSD",
        0x20 => "PMOVSXBW",
        0x21 => "PMOVSXBD",
        0x22 => "PMOVSXBQ",
        0x23 => "PMOVSXWD",
        0x24 => "PMOVSXWQ",
        0x25 => "PMOVSXDQ",
        0x28 => "PMULDQ",
        0x29 => "PCMPEQQ",
        0x2A => "MOVNTDQA",
        0x2B => "PACKUSDW",
        0x30 => "PMOVZXBW",
        0x31 => "PMOVZXBD",
        0x32 => "PMOVZXBQ",
        0x33 => "PMOVZXWD",
        0x34 => "PMOVZXWQ",
        0x35 => "PMOVZXDQ",
        0x37 => "PCMPGTQ",
        0x38 => "PMINSB",
        0x39 => "PMINSD",
        0x3A => "PMINUW",
        0x3B => "PMINUD",
        0x3C => "PMAXSB",
        0x3D => "PMAXSD",
        0x3E => "PMAXUW",
        0x3F => "PMAXUD",
        0x40 => "PMULLD",
        0x41 => "PHMINPOSUW",
        0xF0 => "MOVBE/CRC32",
        0xF1 => "MOVBE/CRC32",
        0xF6 => "ADCX/ADOX",
        _ => "0F38 ???",
    }
}

/// Get mnemonic for 0x0F 0x3A XX opcodes.
fn get_threebyte_3a_mnemonic(op: u8) -> &'static str {
    match op {
        0x08 => "ROUNDPS",
        0x09 => "ROUNDPD",
        0x0A => "ROUNDSS",
        0x0B => "ROUNDSD",
        0x0C => "BLENDPS",
        0x0D => "BLENDPD",
        0x0E => "PBLENDW",
        0x0F => "PALIGNR",
        0x14 => "PEXTRB",
        0x15 => "PEXTRW",
        0x16 => "PEXTRD/PEXTRQ",
        0x17 => "EXTRACTPS",
        0x20 => "PINSRB",
        0x21 => "INSERTPS",
        0x22 => "PINSRD/PINSRQ",
        0x40 => "DPPS",
        0x41 => "DPPD",
        0x42 => "MPSADBW",
        0x44 => "PCLMULQDQ",
        0x60 => "PCMPESTRM",
        0x61 => "PCMPESTRI",
        0x62 => "PCMPISTRM",
        0x63 => "PCMPISTRI",
        _ => "0F3A ???",
    }
}

/// Get mnemonic for VEX-encoded instructions.
fn get_vex_mnemonic(map: u8, opcode: u8) -> &'static str {
    match (map, opcode) {
        // VEX.0F (map 1) - common AVX instructions
        (1, 0x10) => "VMOVUPS/VMOVSS/VMOVUPD/VMOVSD",
        (1, 0x11) => "VMOVUPS/VMOVSS/VMOVUPD/VMOVSD",
        (1, 0x12) => "VMOVLPS/VMOVHLPS/VMOVLPD/VMOVSLDUP/VMOVDDUP",
        (1, 0x13) => "VMOVLPS/VMOVLPD",
        (1, 0x14) => "VUNPCKLPS/VUNPCKLPD",
        (1, 0x15) => "VUNPCKHPS/VUNPCKHPD",
        (1, 0x16) => "VMOVHPS/VMOVLHPS/VMOVHPD/VMOVSHDUP",
        (1, 0x17) => "VMOVHPS/VMOVHPD",
        (1, 0x28) => "VMOVAPS/VMOVAPD",
        (1, 0x29) => "VMOVAPS/VMOVAPD",
        (1, 0x2B) => "VMOVNTPS/VMOVNTPD",
        (1, 0x2E) => "VUCOMISS/VUCOMISD",
        (1, 0x2F) => "VCOMISS/VCOMISD",
        (1, 0x50) => "VMOVMSKPS/VMOVMSKPD",
        (1, 0x51) => "VSQRTPS/VSQRTSS/VSQRTPD/VSQRTSD",
        (1, 0x52) => "VRSQRTPS/VRSQRTSS",
        (1, 0x53) => "VRCPPS/VRCPSS",
        (1, 0x54) => "VANDPS/VANDPD",
        (1, 0x55) => "VANDNPS/VANDNPD",
        (1, 0x56) => "VORPS/VORPD",
        (1, 0x57) => "VXORPS/VXORPD",
        (1, 0x58) => "VADDPS/VADDSS/VADDPD/VADDSD",
        (1, 0x59) => "VMULPS/VMULSS/VMULPD/VMULSD",
        (1, 0x5C) => "VSUBPS/VSUBSS/VSUBPD/VSUBSD",
        (1, 0x5D) => "VMINPS/VMINSS/VMINPD/VMINSD",
        (1, 0x5E) => "VDIVPS/VDIVSS/VDIVPD/VDIVSD",
        (1, 0x5F) => "VMAXPS/VMAXSS/VMAXPD/VMAXSD",
        (1, 0x77) => "VZEROUPPER/VZEROALL",
        (1, 0xC2) => "VCMPPS/VCMPSS/VCMPPD/VCMPSD",
        (1, 0xC6) => "VSHUFPS/VSHUFPD",
        // VEX.0F38 (map 2)
        (2, 0x00) => "VPSHUFB",
        (2, 0x01) => "VPHADDW",
        (2, 0x02) => "VPHADDD",
        (2, 0x17) => "VPTEST",
        (2, 0x18) => "VBROADCASTSS",
        (2, 0x19) => "VBROADCASTSD",
        (2, 0x1A) => "VBROADCASTF128",
        (2, 0x2C) => "VMASKMOVPS",
        (2, 0x2D) => "VMASKMOVPD",
        (2, 0x2E) => "VMASKMOVPS",
        (2, 0x2F) => "VMASKMOVPD",
        // VEX.0F3A (map 3)
        (3, 0x04) => "VPERMILPS",
        (3, 0x05) => "VPERMILPD",
        (3, 0x06) => "VPERM2F128",
        (3, 0x08) => "VROUNDPS",
        (3, 0x09) => "VROUNDPD",
        (3, 0x0A) => "VROUNDSS",
        (3, 0x0B) => "VROUNDSD",
        (3, 0x0C) => "VBLENDPS",
        (3, 0x0D) => "VBLENDPD",
        (3, 0x0E) => "VPBLENDW",
        (3, 0x0F) => "VPALIGNR",
        (3, 0x18) => "VINSERTF128",
        (3, 0x19) => "VEXTRACTF128",
        _ => "VEX ???",
    }
}

/// Get mnemonic for EVEX-encoded instructions (AVX-512).
fn get_evex_mnemonic(map: u8, opcode: u8) -> &'static str {
    match (map, opcode) {
        (1, 0x10) => "VMOVUPS/VMOVSS/VMOVUPD/VMOVSD (AVX-512)",
        (1, 0x11) => "VMOVUPS/VMOVSS/VMOVUPD/VMOVSD (AVX-512)",
        (1, 0x28) => "VMOVAPS/VMOVAPD (AVX-512)",
        (1, 0x29) => "VMOVAPS/VMOVAPD (AVX-512)",
        (1, 0x58) => "VADDPS/VADDPD (AVX-512)",
        (1, 0x59) => "VMULPS/VMULPD (AVX-512)",
        (1, 0x5C) => "VSUBPS/VSUBPD (AVX-512)",
        (1, 0x5E) => "VDIVPS/VDIVPD (AVX-512)",
        _ => "EVEX ???",
    }
}

/// Get mnemonic for FPU instructions (D8-DF escape).
fn get_fpu_mnemonic(escape: u8, modrm_reg: u8) -> &'static str {
    match (escape, modrm_reg) {
        // D8 - arithmetic with memory/ST(i)
        (0xD8, 0) => "FADD",
        (0xD8, 1) => "FMUL",
        (0xD8, 2) => "FCOM",
        (0xD8, 3) => "FCOMP",
        (0xD8, 4) => "FSUB",
        (0xD8, 5) => "FSUBR",
        (0xD8, 6) => "FDIV",
        (0xD8, 7) => "FDIVR",
        // D9 - load/store/control
        (0xD9, 0) => "FLD",
        (0xD9, 1) => "FXCH",
        (0xD9, 2) => "FST/FNOP",
        (0xD9, 3) => "FSTP",
        (0xD9, 4) => "FLDENV/FCHS/FABS",
        (0xD9, 5) => "FLDCW/FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ",
        (0xD9, 6) => "FNSTENV/F2XM1/FYL2X/FPTAN/FPATAN/FXTRACT/FPREM1/FDECSTP/FINCSTP",
        (0xD9, 7) => "FNSTCW/FPREM/FYL2XP1/FSQRT/FSINCOS/FRNDINT/FSCALE/FSIN/FCOS",
        // DA - integer arithmetic
        (0xDA, 0) => "FIADD",
        (0xDA, 1) => "FIMUL",
        (0xDA, 2) => "FICOM",
        (0xDA, 3) => "FICOMP",
        (0xDA, 4) => "FISUB",
        (0xDA, 5) => "FISUBR",
        (0xDA, 6) => "FIDIV",
        (0xDA, 7) => "FIDIVR",
        // DB - integer load/store/misc
        (0xDB, 0) => "FILD",
        (0xDB, 1) => "FISTTP",
        (0xDB, 2) => "FIST",
        (0xDB, 3) => "FISTP",
        (0xDB, 4) => "FCLEX/FINIT",
        (0xDB, 5) => "FLD (extended)",
        (0xDB, 6) => "FCOMI",
        (0xDB, 7) => "FSTP (extended)",
        // DC - arithmetic (64-bit memory)
        (0xDC, 0) => "FADD (64-bit)",
        (0xDC, 1) => "FMUL (64-bit)",
        (0xDC, 2) => "FCOM (64-bit)",
        (0xDC, 3) => "FCOMP (64-bit)",
        (0xDC, 4) => "FSUB (64-bit)",
        (0xDC, 5) => "FSUBR (64-bit)",
        (0xDC, 6) => "FDIV (64-bit)",
        (0xDC, 7) => "FDIVR (64-bit)",
        // DD - load/store/control (64-bit)
        (0xDD, 0) => "FLD (64-bit)",
        (0xDD, 1) => "FISTTP (64-bit)",
        (0xDD, 2) => "FST (64-bit)",
        (0xDD, 3) => "FSTP (64-bit)",
        (0xDD, 4) => "FRSTOR/FUCOM",
        (0xDD, 5) => "FUCOMP",
        (0xDD, 6) => "FNSAVE",
        (0xDD, 7) => "FNSTSW",
        // DE - arithmetic with pop
        (0xDE, 0) => "FADDP/FIADD (16-bit)",
        (0xDE, 1) => "FMULP/FIMUL (16-bit)",
        (0xDE, 2) => "FICOM (16-bit)",
        (0xDE, 3) => "FICOMP (16-bit)/FCOMPP",
        (0xDE, 4) => "FSUBRP/FISUB (16-bit)",
        (0xDE, 5) => "FSUBP/FISUBR (16-bit)",
        (0xDE, 6) => "FDIVRP/FIDIV (16-bit)",
        (0xDE, 7) => "FDIVP/FIDIVR (16-bit)",
        // DF - BCD/integer
        (0xDF, 0) => "FILD (16-bit)",
        (0xDF, 1) => "FISTTP (16-bit)",
        (0xDF, 2) => "FIST (16-bit)",
        (0xDF, 3) => "FISTP (16-bit)",
        (0xDF, 4) => "FBLD/FNSTSW AX",
        (0xDF, 5) => "FILD (64-bit)",
        (0xDF, 6) => "FBSTP",
        (0xDF, 7) => "FISTP (64-bit)",
        _ => "FPU ???",
    }
}

/// Instruction category for grouping in reports.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum InstructionCategory {
    Arithmetic,
    Logic,
    DataMovement,
    ControlFlow,
    Simd,
    Fpu,
    System,
    StringOp,
    Io,
    Other,
}

/// Categorize an opcode for summary statistics.
pub fn categorize(key: &OpcodeKey) -> InstructionCategory {
    match key {
        OpcodeKey::Legacy(op) => categorize_legacy(*op),
        OpcodeKey::TwoByte(op) => categorize_twobyte(*op),
        OpcodeKey::ThreeByte38(_) | OpcodeKey::ThreeByte3A(_) => InstructionCategory::Simd,
        OpcodeKey::Vex { .. } | OpcodeKey::Evex { .. } => InstructionCategory::Simd,
        OpcodeKey::Fpu { .. } => InstructionCategory::Fpu,
    }
}

fn categorize_legacy(op: u8) -> InstructionCategory {
    match op {
        // ADD, ADC, SUB, SBB, CMP, INC, DEC, MUL, IMUL, DIV, IDIV
        0x00..=0x05 | 0x10..=0x15 | 0x18..=0x1D | 0x28..=0x2D | 0x38..=0x3D => {
            InstructionCategory::Arithmetic
        }
        0x40..=0x4F => InstructionCategory::Arithmetic, // INC/DEC (or REX in 64-bit)
        // AND, OR, XOR, NOT, TEST
        0x08..=0x0D | 0x20..=0x25 | 0x30..=0x35 | 0x84..=0x85 => InstructionCategory::Logic,
        // MOV, LEA, PUSH, POP, XCHG
        0x50..=0x5F | 0x88..=0x8E | 0xA0..=0xA3 | 0xB0..=0xBF | 0xC6..=0xC7 => {
            InstructionCategory::DataMovement
        }
        // JMP, CALL, RET, Jcc, LOOP
        0x70..=0x7F | 0xE0..=0xE3 | 0xE8..=0xEB | 0xC2..=0xC3 | 0xCA..=0xCB => {
            InstructionCategory::ControlFlow
        }
        // String operations
        0xA4..=0xAF => InstructionCategory::StringOp,
        // I/O
        0xE4..=0xE7 | 0xEC..=0xEF | 0x6C..=0x6F => InstructionCategory::Io,
        // FPU escape
        0xD8..=0xDF => InstructionCategory::Fpu,
        // System instructions
        0x0F | 0xF4 | 0xFA..=0xFB => InstructionCategory::System,
        _ => InstructionCategory::Other,
    }
}

fn categorize_twobyte(op: u8) -> InstructionCategory {
    match op {
        // SIMD moves, arithmetic, logic
        0x10..=0x17 | 0x28..=0x2F | 0x50..=0x7F | 0xC2..=0xC6 | 0xD0..=0xFF => {
            InstructionCategory::Simd
        }
        // CMOVcc, SETcc
        0x40..=0x4F | 0x90..=0x9F => InstructionCategory::ControlFlow,
        // Jcc near
        0x80..=0x8F => InstructionCategory::ControlFlow,
        // CPUID, WRMSR, RDMSR, RDTSC, etc.
        0x00..=0x09 | 0x30..=0x35 => InstructionCategory::System,
        // Bit operations
        0xA3..=0xAF | 0xB0..=0xBF => InstructionCategory::Logic,
        // MOV to/from CR/DR
        0x20..=0x24 => InstructionCategory::System,
        _ => InstructionCategory::Other,
    }
}
