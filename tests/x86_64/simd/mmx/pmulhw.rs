//! Tests for PMULHW instruction.
//!
//! PMULHW - Packed Multiply High (MMX)
//!
//! Performs SIMD signed multiply of 4 packed 16-bit word integers.
//! Stores the high 16 bits of each 32-bit result.
//!
//! Flags affected: None
//!
//! Reference: docs/pmulhw.txt

use crate::common::*;

fn write_mm_via_mem(mem: &vm_memory::GuestMemoryMmap, addr: u64, value: u64) {
    write_mem_at_u64(mem, addr, value);
}

// ============================================================================
// PMULHW mm, mm/m64 (opcode 0F E5 /r)
// ============================================================================

#[test]
fn test_pmulhw_mm_mm_basic() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,                               // PMULHW MM0, MM1
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    // 0x1000 * 0x1000 = 0x01000000, high 16 bits = 0x0100
    write_mm_via_mem(&mem, 0x2000, 0x1000100010001000);
    write_mm_via_mem(&mem, 0x2008, 0x1000100010001000);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x0100010001000100, "PMULHW: basic multiplication");
}

#[test]
fn test_pmulhw_high_16_bits() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    // 0x7FFF * 0x7FFF = 0x3FFF0001, high 16 = 0x3FFF
    write_mm_via_mem(&mem, 0x2000, 0x7FFF7FFF7FFF7FFF);
    write_mm_via_mem(&mem, 0x2008, 0x7FFF7FFF7FFF7FFF);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x3FFF3FFF3FFF3FFF, "PMULHW: high 16 bits");
}

#[test]
fn test_pmulhw_signed_positive() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x4000400040004000);
    write_mm_via_mem(&mem, 0x2008, 0x0002000200020002);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // 0x4000 * 0x0002 = 0x00008000, high = 0x0000
    assert_eq!(result, 0x0000000000000000, "PMULHW: signed positive");
}

#[test]
fn test_pmulhw_signed_negative() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    // -1 (0xFFFF) * 2 = -2 (0xFFFFFFFE), high = 0xFFFF
    write_mm_via_mem(&mem, 0x2000, 0xFFFFFFFFFFFFFFFF);
    write_mm_via_mem(&mem, 0x2008, 0x0002000200020002);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0xFFFFFFFFFFFFFFFF, "PMULHW: negative * positive");
}

#[test]
fn test_pmulhw_negative_negative() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    // -32768 (0x8000) * -32768 = 1073741824 (0x40000000), high = 0x4000
    write_mm_via_mem(&mem, 0x2000, 0x8000800080008000);
    write_mm_via_mem(&mem, 0x2008, 0x8000800080008000);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x4000400040004000, "PMULHW: negative * negative");
}

#[test]
fn test_pmulhw_zero() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x1234567890ABCDEF);
    write_mm_via_mem(&mem, 0x2008, 0x0000000000000000);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x0000000000000000, "PMULHW: multiply by zero");
}

#[test]
fn test_pmulhw_by_one() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x1234567890ABCDEF);
    write_mm_via_mem(&mem, 0x2008, 0x0001000100010001);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x00000000FFFFFFFF, "PMULHW: multiply by 1 preserves sign in high bits");
}

#[test]
fn test_pmulhw_mm_m64() {
    let code = vec![
        0x0f, 0x6f, 0x14, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0x14, 0x25, 0x08, 0x20, 0x00, 0x00, // PMULHW MM2, [0x2008]
        0x0f, 0x7f, 0x14, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x2000200020002000);
    write_mm_via_mem(&mem, 0x2008, 0x2000200020002000);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // 0x2000 * 0x2000 = 0x04000000, high = 0x0400
    assert_eq!(result, 0x0400040004000400, "PMULHW: memory operand");
}

#[test]
fn test_pmulhw_large_values() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x7FFF7FFF7FFF7FFF);
    write_mm_via_mem(&mem, 0x2008, 0x0002000200020002);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // 0x7FFF * 0x0002 = 0x0000FFFE, high = 0x0000
    assert_eq!(result, 0x0000000000000000, "PMULHW: large positive");
}

#[test]
fn test_pmulhw_mixed_signs() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x80007FFF80007FFF);
    write_mm_via_mem(&mem, 0x2008, 0x0002000200020002);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // 0x7FFF * 0x0002 = 0xFFFE (high=0), 0x8000*0x0002=0xFFFF0000 (high=0xFFFF)
    assert_eq!(result, 0xFFFF0000FFFF0000, "PMULHW: mixed signs");
}

#[test]
fn test_pmulhw_mm5_mm6() {
    let code = vec![
        0x0f, 0x6f, 0x2c, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x34, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xee,                               // PMULHW MM5, MM6
        0x0f, 0x7f, 0x2c, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x4000400040004000);
    write_mm_via_mem(&mem, 0x2008, 0x4000400040004000);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // 0x4000 * 0x4000 = 0x10000000, high = 0x1000
    assert_eq!(result, 0x1000100010001000, "PMULHW: MM5 * MM6");
}

#[test]
fn test_pmulhw_powers_of_two() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x0100008000400020);
    write_mm_via_mem(&mem, 0x2008, 0x0100008000400020);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x0001000000000000, "PMULHW: powers of two");
}

#[test]
fn test_pmulhw_sequential() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x1000100010001000);
    write_mm_via_mem(&mem, 0x2008, 0x0100010001000100);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // First: 0x1000*0x0100=0x100000, high=0x0010
    // Second: 0x0010*0x0100=0x001000, high=0x0000
    assert_eq!(result, 0x0000000000000000, "PMULHW: sequential");
}

#[test]
fn test_pmulhw_small_results() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x0010001000100010);
    write_mm_via_mem(&mem, 0x2008, 0x0010001000100010);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    // 0x10 * 0x10 = 0x100, high = 0x0000
    assert_eq!(result, 0x0000000000000000, "PMULHW: small results");
}

#[test]
fn test_pmulhw_by_negative_one() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x0001000200030004);
    write_mm_via_mem(&mem, 0x2008, 0xFFFFFFFFFFFFFFFF);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0xFFFFFFFFFFFFFFFF, "PMULHW: multiply by -1");
}

#[test]
fn test_pmulhw_asymmetric() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x1000200030004000);
    write_mm_via_mem(&mem, 0x2008, 0x4000300020001000);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x0400060006000400, "PMULHW: asymmetric values");
}

#[test]
fn test_pmulhw_max_positive() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x7FFF7FFF7FFF7FFF);
    write_mm_via_mem(&mem, 0x2008, 0x7FFF7FFF7FFF7FFF);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x3FFF3FFF3FFF3FFF, "PMULHW: max positive");
}

#[test]
fn test_pmulhw_combined_operations() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x14, 0x25, 0x10, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,                               // PMULHW MM0, MM1
        0x0f, 0xe5, 0xca,                               // PMULHW MM1, MM2
        0x0f, 0x7f, 0x04, 0x25, 0x18, 0x20, 0x00, 0x00,
        0x0f, 0x7f, 0x0c, 0x25, 0x20, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x2000200020002000);
    write_mm_via_mem(&mem, 0x2008, 0x2000200020002000);
    write_mm_via_mem(&mem, 0x2010, 0x2000200020002000);

    run_until_hlt(&mut vcpu).unwrap();

    let mm0_result = read_mem_at_u64(&mem, 0x2018);
    let mm1_result = read_mem_at_u64(&mem, 0x2020);
    assert_eq!(mm0_result, 0x0400040004000400, "PMULHW: MM0 result");
    assert_eq!(mm1_result, 0x0400040004000400, "PMULHW: MM1 result");
}

#[test]
fn test_pmulhw_all_mm_registers() {
    let code = vec![
        0x0f, 0x6f, 0x3c, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x04, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xf8,                               // PMULHW MM7, MM0
        0x0f, 0x7f, 0x3c, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x8000800080008000);
    write_mm_via_mem(&mem, 0x2008, 0x0002000200020002);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0xFFFFFFFFFFFFFFFF, "PMULHW: MM7 * MM0");
}

#[test]
fn test_pmulhw_compare_with_pmullw() {
    // Demonstrates difference between PMULHW and PMULLW
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x14, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x1c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,                               // PMULHW MM0, MM1
        0x0f, 0xd5, 0xd3,                               // PMULLW MM2, MM3
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0x0f, 0x7f, 0x14, 0x25, 0x18, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x1000100010001000);
    write_mm_via_mem(&mem, 0x2008, 0x1000100010001000);

    run_until_hlt(&mut vcpu).unwrap();

    let high = read_mem_at_u64(&mem, 0x2010);
    let low = read_mem_at_u64(&mem, 0x2018);
    assert_eq!(high, 0x0100010001000100, "PMULHW: high bits");
    assert_eq!(low, 0x0000000000000000, "PMULLW: low bits");
}

#[test]
fn test_pmulhw_boundary_values() {
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xe5, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let (mut vcpu, mem) = setup_vm(&code, None);

    write_mm_via_mem(&mem, 0x2000, 0x80007FFF00018000);
    write_mm_via_mem(&mem, 0x2008, 0x80007FFF80007FFF);

    run_until_hlt(&mut vcpu).unwrap();

    let result = read_mem_at_u64(&mem, 0x2010);
    assert_eq!(result, 0x40003FFFFFFFC000, "PMULHW: boundary values");
}
