use crate::common::{run_until_hlt, setup_vm};

// PMULLQ - Multiply Packed Signed Quadword Integers and Store Low Result
//
// Performs a SIMD signed multiply of the packed signed qword integers from
// each element of the first source operand with the corresponding element in
// the second source operand. The low 64 bits of each 128-bit intermediate
// result are stored to the destination operand.
//
// This is an AVX-512DQ instruction available in EVEX encoding only.
//
// Opcodes (AVX-512):
//   EVEX.128.66.0F38.W1 40 /r    VPMULLQ xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst
//   EVEX.256.66.0F38.W1 40 /r    VPMULLQ ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst
//   EVEX.512.66.0F38.W1 40 /r    VPMULLQ zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst

const ALIGNED_ADDR: u64 = 0x3000;

// ============================================================================
// VPMULLQ XMM Tests (128-bit, 2 qwords)
// ============================================================================

#[test]
fn test_vpmullq_xmm_basic() {
    // VPMULLQ XMM0, XMM1, XMM2 - Basic multiplication
    // XMM1: [5, 3]
    // XMM2: [7, 2]
    // Result: [35, 6]
    let code = [
        // Setup XMM1 = [5, 3]
        0x48, 0xc7, 0xc0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 5
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 3
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [7, 2]
        0x48, 0xc7, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 7
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
    // Note: Full verification would require reading XMM registers
}

#[test]
fn test_vpmullq_xmm_zero() {
    // Test multiplication by zero
    // XMM1: [100, 200]
    // XMM2: [0, 0]
    // Result: [0, 0]
    let code = [
        // Setup XMM1 = [100, 200]
        0x48, 0xc7, 0xc0, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 100
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 200
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // XMM2 = [0, 0] (already zero)
        0x66, 0x0f, 0xef, 0xd2, // PXOR XMM2, XMM2

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_xmm_one() {
    // Test multiplication by one (identity)
    // XMM1: [42, 99]
    // XMM2: [1, 1]
    // Result: [42, 99]
    let code = [
        // Setup XMM1 = [42, 99]
        0x48, 0xc7, 0xc0, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 42
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 99
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [1, 1]
        0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 1
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 1
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_xmm_negative() {
    // Test with negative numbers (signed multiplication)
    // XMM1: [-5, 10]
    // XMM2: [3, -2]
    // Result: [-15, -20]
    let code = [
        // Setup XMM1 = [-5, 10]
        0x48, 0xc7, 0xc0, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -5
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 10
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [3, -2]
        0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 3
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xc7, 0xc0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -2
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_xmm_overflow() {
    // Test overflow (low 64 bits only)
    // XMM1: [0x8000000000000000, 0x7FFFFFFFFFFFFFFF]
    // XMM2: [2, 2]
    // Result: [0 (overflow), 0xFFFFFFFFFFFFFFFE]
    let code = [
        // Setup XMM1
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // MOV RAX, 0x8000000000000000
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, // MOV RAX, 0x7FFFFFFFFFFFFFFF
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [2, 2]
        0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_xmm_powers_of_two() {
    // Test with powers of two
    // XMM1: [16, 256]
    // XMM2: [4, 8]
    // Result: [64, 2048]
    let code = [
        // Setup XMM1 = [16, 256]
        0x48, 0xc7, 0xc0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 16
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RCX, 256
        0x66, 0x48, 0x0f, 0xc4, 0xc9, 0x01, // PINSRQ XMM1, RCX, 1

        // Setup XMM2 = [4, 8]
        0x48, 0xc7, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 4
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xc7, 0xc1, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RCX, 8
        0x66, 0x48, 0x0f, 0xc4, 0xd1, 0x01, // PINSRQ XMM2, RCX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_xmm_large_values() {
    // Test with large values
    // XMM1: [0x0000000100000000, 0x0000000200000000]
    // XMM2: [0x0000000300000000, 0x0000000400000000]
    let code = [
        // Setup XMM1
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, // MOV RAX, 0x0000000100000000
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // MOV RAX, 0x0000000200000000
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, // MOV RAX, 0x0000000300000000
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, // MOV RAX, 0x0000000400000000
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

// ============================================================================
// VPMULLQ Memory Operand Tests
// ============================================================================

#[test]
fn test_vpmullq_xmm_memory() {
    // VPMULLQ with memory operand
    let code = [
        // Setup memory at 0x3000 with values [11, 13]
        0x48, 0xc7, 0xc0, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 11
        0x48, 0xa3, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x3000], RAX
        0x48, 0xc7, 0xc0, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 13
        0x48, 0xa3, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x3008], RAX

        // Setup XMM1 = [2, 3]
        0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 3
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // VPMULLQ XMM0, XMM1, [0x3000]
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0x04, 0x25, 0x00, 0x30, 0x00, 0x00, // VPMULLQ XMM0, XMM1, [0x3000]

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

// ============================================================================
// VPMULLQ Different Register Combinations
// ============================================================================

#[test]
fn test_vpmullq_xmm_reg_combinations() {
    // Test various register combinations
    let code = [
        // Setup XMM3 = [7, 9]
        0x48, 0xc7, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 7
        0x66, 0x48, 0x0f, 0x6e, 0xd8, // MOVQ XMM3, RAX
        0x48, 0xc7, 0xc0, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 9
        0x66, 0x48, 0x0f, 0xc4, 0xd8, 0x01, // PINSRQ XMM3, RAX, 1

        // Setup XMM4 = [11, 13]
        0x48, 0xc7, 0xc0, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 11
        0x66, 0x48, 0x0f, 0x6e, 0xe0, // MOVQ XMM4, RAX
        0x48, 0xc7, 0xc0, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 13
        0x66, 0x48, 0x0f, 0xc4, 0xe0, 0x01, // PINSRQ XMM4, RAX, 1

        // VPMULLQ XMM5, XMM3, XMM4
        0x62, 0xf2, 0xe5, 0x08, 0x40, 0xec, // VPMULLQ XMM5, XMM3, XMM4

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_xmm_same_register() {
    // VPMULLQ with same source registers (square)
    // XMM1: [5, 7]
    // XMM1: [5, 7]
    // Result: [25, 49]
    let code = [
        // Setup XMM1 = [5, 7]
        0x48, 0xc7, 0xc0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 5
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 7
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM1 (square)
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc1, // VPMULLQ XMM0, XMM1, XMM1

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

// ============================================================================
// VPMULLQ YMM Tests (256-bit, 4 qwords)
// ============================================================================

#[test]
fn test_vpmullq_ymm_basic() {
    // VPMULLQ YMM0, YMM1, YMM2
    // Test with 4 quadwords
    let code = [
        // This would require setting up 4 qwords in each YMM register
        // For now, just test that the instruction executes without error

        // VPMULLQ YMM0, YMM1, YMM2
        0x62, 0xf2, 0xf5, 0x28, 0x40, 0xc2, // VPMULLQ YMM0, YMM1, YMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_ymm_different_regs() {
    // VPMULLQ with different YMM register combinations
    let code = [
        // VPMULLQ YMM3, YMM4, YMM5
        0x62, 0xf2, 0xdd, 0x28, 0x40, 0xdd, // VPMULLQ YMM3, YMM4, YMM5

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

// ============================================================================
// VPMULLQ ZMM Tests (512-bit, 8 qwords)
// ============================================================================

#[test]
fn test_vpmullq_zmm_basic() {
    // VPMULLQ ZMM0, ZMM1, ZMM2
    // Test with 8 quadwords
    let code = [
        // VPMULLQ ZMM0, ZMM1, ZMM2
        0x62, 0xf2, 0xf5, 0x48, 0x40, 0xc2, // VPMULLQ ZMM0, ZMM1, ZMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_zmm_different_regs() {
    // VPMULLQ with different ZMM register combinations
    let code = [
        // VPMULLQ ZMM7, ZMM6, ZMM5
        0x62, 0xf2, 0xcd, 0x48, 0x40, 0xfd, // VPMULLQ ZMM7, ZMM6, ZMM5

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

// ============================================================================
// Edge Cases and Special Values
// ============================================================================

#[test]
fn test_vpmullq_all_ones() {
    // Test with all bits set (0xFFFFFFFFFFFFFFFF = -1)
    // XMM1: [-1, -1]
    // XMM2: [-1, -1]
    // Result: [1, 1]
    let code = [
        // Setup XMM1 = [-1, -1]
        0x48, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -1
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [-1, -1]
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_mixed_signs() {
    // Test with mixed positive and negative values
    // XMM1: [-100, 100]
    // XMM2: [50, -50]
    // Result: [-5000, -5000]
    let code = [
        // Setup XMM1 = [-100, 100]
        0x48, 0xc7, 0xc0, 0x9c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -100
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 100
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [50, -50]
        0x48, 0xc7, 0xc0, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 50
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xc7, 0xc0, 0xce, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -50
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_sequential_operations() {
    // Multiple VPMULLQ operations in sequence
    let code = [
        // Setup XMM1 = [2, 3]
        0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 3
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [4, 5]
        0x48, 0xc7, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 4
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x48, 0xc7, 0xc0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 5
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // First multiplication: XMM0 = XMM1 * XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        // Second multiplication: XMM3 = XMM0 * XMM1
        0x62, 0xf2, 0xfd, 0x08, 0x40, 0xd9, // VPMULLQ XMM3, XMM0, XMM1

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_high_registers() {
    // Test with high XMM registers (XMM8-XMM15)
    let code = [
        // VPMULLQ XMM8, XMM9, XMM10
        0x62, 0x72, 0xb5, 0x08, 0x40, 0xc2, // VPMULLQ XMM8, XMM9, XMM10

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}

#[test]
fn test_vpmullq_max_min_values() {
    // Test with maximum and minimum signed 64-bit values
    // XMM1: [0x7FFFFFFFFFFFFFFF, 0x8000000000000000]
    // XMM2: [1, 1]
    // Result: [0x7FFFFFFFFFFFFFFF, 0x8000000000000000]
    let code = [
        // Setup XMM1
        0x48, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, // MOV RAX, 0x7FFFFFFFFFFFFFFF
        0x66, 0x48, 0x0f, 0x6e, 0xc8, // MOVQ XMM1, RAX
        0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // MOV RAX, 0x8000000000000000
        0x66, 0x48, 0x0f, 0xc4, 0xc8, 0x01, // PINSRQ XMM1, RAX, 1

        // Setup XMM2 = [1, 1]
        0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 1
        0x66, 0x48, 0x0f, 0x6e, 0xd0, // MOVQ XMM2, RAX
        0x66, 0x48, 0x0f, 0xc4, 0xd0, 0x01, // PINSRQ XMM2, RAX, 1

        // VPMULLQ XMM0, XMM1, XMM2
        0x62, 0xf2, 0xf5, 0x08, 0x40, 0xc2, // VPMULLQ XMM0, XMM1, XMM2

        0xf4, // HLT
    ];
    let (mut vcpu, _) = setup_vm(&code, None);
    run_until_hlt(&mut vcpu).unwrap();
}
