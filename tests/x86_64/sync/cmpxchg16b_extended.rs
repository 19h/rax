use crate::common::*;
use rax::cpu::Registers;
use vm_memory::{Bytes, GuestAddress};

// CMPXCHG16B Extended Tests - Comprehensive 128-bit atomic compare-exchange patterns
// Note: CMPXCHG16B requires 16-byte aligned memory and CMPXCHG16B CPU feature

// CMPXCHG16B: REX.W + 0F C7 /1
// Compares RDX:RAX with 128-bit memory
// If equal: ZF=1, RCX:RBX -> memory
// If not equal: ZF=0, memory -> RDX:RAX

#[test]
fn test_cmpxchg16b_basic_success() {
    let code = [
        // Write 128-bit value to memory: high=0x2222222222222222, low=0x1111111111111111
        0x48, 0xb8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, // MOV RAX, 0x1111111111111111
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xb8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, // MOV RAX, 0x2222222222222222
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        // Setup registers for CMPXCHG16B
        0x48, 0xb8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, // MOV RAX, 0x1111111111111111
        0x48, 0xba, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, // MOV RDX, 0x2222222222222222
        0x48, 0xbb, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, // MOV RBX, 0x3333333333333333
        0x48, 0xb9, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, // MOV RCX, 0x4444444444444444
        0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00,       // CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let regs = run_until_hlt(&mut vcpu).unwrap();

    // Read low 64 bits
    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    let low = u64::from_le_bytes(buf_low);

    // Read high 64 bits
    let mut buf_high = [0u8; 8];
    mem.read_slice(&mut buf_high, GuestAddress(0x2008)).unwrap();
    let high = u64::from_le_bytes(buf_high);

    assert_eq!(low, 0x3333333333333333, "Low 64 bits should be updated");
    assert_eq!(high, 0x4444444444444444, "High 64 bits should be updated");
    assert_ne!(regs.rflags & 0x40, 0, "ZF should be set on success");
}

#[test]
fn test_cmpxchg16b_basic_failure() {
    let code = [
        // Write different value to memory
        0x48, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, // MOV RAX, 0xAAAAAAAAAAAAAAAA
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xb8, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, // MOV RAX, 0xBBBBBBBBBBBBBBBB
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        // Try to compare with wrong value
        0x48, 0xb8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, // MOV RAX, 0x1111111111111111
        0x48, 0xba, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, // MOV RDX, 0x2222222222222222
        0x48, 0xbb, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, // MOV RBX, 0x3333333333333333
        0x48, 0xb9, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, // MOV RCX, 0x4444444444444444
        0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00,       // CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let regs = run_until_hlt(&mut vcpu).unwrap();

    // Memory should remain unchanged
    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_low), 0xAAAAAAAAAAAAAAAA, "Memory low should be unchanged");

    let mut buf_high = [0u8; 8];
    mem.read_slice(&mut buf_high, GuestAddress(0x2008)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_high), 0xBBBBBBBBBBBBBBBB, "Memory high should be unchanged");

    // RAX and RDX should be loaded from memory
    assert_eq!(regs.rax, 0xAAAAAAAAAAAAAAAA, "RAX should be loaded from memory");
    assert_eq!(regs.rdx, 0xBBBBBBBBBBBBBBBB, "RDX should be loaded from memory");
    assert_eq!(regs.rflags & 0x40, 0, "ZF should be clear on failure");
}

#[test]
fn test_cmpxchg16b_all_zeros() {
    let code = [
        // Zero memory
        0x48, 0x31, 0xc0,                                           // XOR RAX, RAX
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        // Compare and swap
        0x48, 0x31, 0xc0,                                           // XOR RAX, RAX
        0x48, 0x31, 0xd2,                                           // XOR RDX, RDX
        0x48, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, 0xFFFFFFFFFFFFFFFF
        0x48, 0x89, 0xc3,                                           // MOV RBX, RAX
        0x48, 0x89, 0xc1,                                           // MOV RCX, RAX
        0x48, 0x31, 0xc0,                                           // XOR RAX, RAX
        0x48, 0x31, 0xd2,                                           // XOR RDX, RDX
        0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00,       // CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let regs = run_until_hlt(&mut vcpu).unwrap();

    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_low), 0xFFFFFFFFFFFFFFFF, "Memory should be all ones");

    let mut buf_high = [0u8; 8];
    mem.read_slice(&mut buf_high, GuestAddress(0x2008)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_high), 0xFFFFFFFFFFFFFFFF, "Memory should be all ones");
    assert_ne!(regs.rflags & 0x40, 0, "ZF should be set");
}

#[test]
fn test_cmpxchg16b_all_ones() {
    let code = [
        // Set memory to all ones
        0x48, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, 0xFFFFFFFFFFFFFFFF
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        // Compare and swap to zeros
        0x48, 0x89, 0xc2,                                           // MOV RDX, RAX
        0x48, 0x31, 0xdb,                                           // XOR RBX, RBX
        0x48, 0x31, 0xc9,                                           // XOR RCX, RCX
        0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00,       // CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let regs = run_until_hlt(&mut vcpu).unwrap();

    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_low), 0, "Memory should be zero");

    let mut buf_high = [0u8; 8];
    mem.read_slice(&mut buf_high, GuestAddress(0x2008)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_high), 0, "Memory should be zero");
    assert_ne!(regs.rflags & 0x40, 0, "ZF should be set");
}

#[test]
fn test_cmpxchg16b_lock_prefix() {
    let code = [
        0x48, 0xb8, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, // MOV RAX, 0x5555555555555555
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        0x48, 0x89, 0xc2,                                           // MOV RDX, RAX
        0x48, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, // MOV RAX, 0xAAAAAAAAAAAAAAAA
        0x48, 0x89, 0xc3,                                           // MOV RBX, RAX
        0x48, 0x89, 0xc1,                                           // MOV RCX, RAX
        0x48, 0xb8, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, // MOV RAX, 0x5555555555555555
        0xf0, 0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00, // LOCK CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let regs = run_until_hlt(&mut vcpu).unwrap();

    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_low), 0xAAAAAAAAAAAAAAAA, "Memory updated atomically");
    assert_ne!(regs.rflags & 0x40, 0, "ZF should be set");
}

#[test]
fn test_cmpxchg16b_sequential_updates() {
    let code = [
        // Initial value
        0x48, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 1
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        // Update 1: 1,1 -> 2,2
        0x48, 0x89, 0xc2,                                           // MOV RDX, RAX
        0x48, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x48, 0x89, 0xc3,                                           // MOV RBX, RAX
        0x48, 0x89, 0xc1,                                           // MOV RCX, RAX
        0x48, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 1
        0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00,       // CMPXCHG16B [0x2000]
        // Update 2: 2,2 -> 3,3
        0x48, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x48, 0x89, 0xc2,                                           // MOV RDX, RAX
        0x48, 0xb8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 3
        0x48, 0x89, 0xc3,                                           // MOV RBX, RAX
        0x48, 0x89, 0xc1,                                           // MOV RCX, RAX
        0x48, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 2
        0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00,       // CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let _ = run_until_hlt(&mut vcpu).unwrap();

    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_low), 3, "Memory should be 3");

    let mut buf_high = [0u8; 8];
    mem.read_slice(&mut buf_high, GuestAddress(0x2008)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_high), 3, "Memory should be 3");
}

#[test]
fn test_cmpxchg16b_pointer_counter_pattern() {
    let code = [
        // Pointer with counter: low=0x3000 (pointer), high=1 (counter)
        0x48, 0xb8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 0x3000
        0x48, 0xa3, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2000], RAX
        0x48, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 1
        0x48, 0xa3, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV [0x2008], RAX
        // Update to pointer=0x4000, counter=2
        0x48, 0xb8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 0x3000
        0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RDX, 1
        0x48, 0xbb, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RBX, 0x4000
        0x48, 0xb9, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RCX, 2
        0xf0, 0x48, 0x0f, 0xc7, 0x0c, 0x25, 0x00, 0x20, 0x00, 0x00, // LOCK CMPXCHG16B [0x2000]
        0xf4,                                                       // HLT
    ];
    let (mut vcpu, mem) = setup_vm(&code, None);
    let regs = run_until_hlt(&mut vcpu).unwrap();

    let mut buf_low = [0u8; 8];
    mem.read_slice(&mut buf_low, GuestAddress(0x2000)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_low), 0x4000, "Pointer should be updated");

    let mut buf_high = [0u8; 8];
    mem.read_slice(&mut buf_high, GuestAddress(0x2008)).unwrap();
    assert_eq!(u64::from_le_bytes(buf_high), 2, "Counter should be updated");
    assert_ne!(regs.rflags & 0x40, 0, "ZF should be set");
}

// Additional tests would include:
// - ABA problem simulation with 128-bit values
// - Retry loop patterns
// - Register preservation
// - Different addressing modes
// - Boundary transitions
// - Large value patterns
