use crate::common::{setup_vm_legacy as setup_vm, run_until_hlt_legacy as run_until_hlt, VM, Bytes};

// STOS/STOSB/STOSW/STOSD/STOSQ - Store String
// Stores AL/AX/EAX/RAX to [RDI], increments/decrements RDI based on DF
// Opcodes:
//   AA - STOSB (store AL)
//   AB - STOSW (store AX, 66h prefix)
//   AB - STOSD (store EAX)
//   REX.W AB - STOSQ (store RAX)

#[test]
fn test_stosb_basic() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xb0, 0x42, // MOV AL, 0x42
        0xfc, // CLD
        0xaa, // STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0x42);
    assert_eq!(vm.rdi, 0x4001); // RDI incremented
}

#[test]
fn test_stosb_with_std() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xb0, 0x99, // MOV AL, 0x99
        0xfd, // STD
        0xaa, // STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0x99);
    assert_eq!(vm.rdi, 0x3FFF); // RDI decremented
}

#[test]
fn test_rep_stosb_fill() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x08, 0x00, 0x00, 0x00, // MOV RCX, 8
        0xb0, 0xaa, // MOV AL, 0xAA
        0xfc, // CLD
        0xf3, 0xaa, // REP STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 8);
    assert_eq!(&data, &[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]);
    assert_eq!(vm.rcx, 0);
    assert_eq!(vm.rdi, 0x4008);
}

#[test]
fn test_stosw_basic() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x66, 0xb8, 0x34, 0x12, // MOV AX, 0x1234
        0xfc, // CLD
        0x66, 0xab, // STOSW
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 2);
    assert_eq!(data, &[0x34, 0x12]); // Little endian
    assert_eq!(vm.rdi, 0x4002);
}

#[test]
fn test_stosd_basic() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xb8, 0x78, 0x56, 0x34, 0x12, // MOV EAX, 0x12345678
        0xfc, // CLD
        0xab, // STOSD
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 4);
    assert_eq!(data, &[0x78, 0x56, 0x34, 0x12]);
    assert_eq!(vm.rdi, 0x4004);
}

#[test]
fn test_stosq_basic() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xb8, 0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12, // MOV RAX, 0x1234567890ABCDEF
        0xfc, // CLD
        0x48, 0xab, // STOSQ
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 8);
    assert_eq!(data, &[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]);
    assert_eq!(vm.rdi, 0x4008);
}

#[test]
fn test_rep_stosb_memset_pattern() {
    // Typical memset usage: memset(buf, 0, size)
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, buffer
        0x48, 0xc7, 0xc1, 0x10, 0x00, 0x00, 0x00, // MOV RCX, 16 (size)
        0x31, 0xc0, // XOR EAX, EAX (value = 0)
        0xfc, // CLD
        0xf3, 0xaa, // REP STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 16);
    assert_eq!(&data, &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
}

#[test]
fn test_rep_stosw_fill() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x04, 0x00, 0x00, 0x00, // MOV RCX, 4
        0x66, 0xb8, 0xff, 0xff, // MOV AX, 0xFFFF
        0xfc, // CLD
        0xf3, 0x66, 0xab, // REP STOSW
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 8);
    assert_eq!(&data, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
}

#[test]
fn test_rep_stosd_fill() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x04, 0x00, 0x00, 0x00, // MOV RCX, 4
        0xb8, 0x11, 0x22, 0x33, 0x44, // MOV EAX, 0x44332211
        0xfc, // CLD
        0xf3, 0xab, // REP STOSD
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 16);
    for i in 0..4 {
        assert_eq!(&data[i*4..(i+1)*4], &[0x11, 0x22, 0x33, 0x44]);
    }
}

#[test]
fn test_rep_stosq_fill() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x03, 0x00, 0x00, 0x00, // MOV RCX, 3
        0x48, 0xc7, 0xc0, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -1
        0xfc, // CLD
        0xf3, 0x48, 0xab, // REP STOSQ
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 24);
    assert_eq!(&data, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
}

#[test]
fn test_stosb_preserves_other_registers() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xb0, 0x42, // MOV AL, 0x42
        0x48, 0xc7, 0xc3, 0x99, 0x00, 0x00, 0x00, // MOV RBX, 0x99
        0x48, 0xc7, 0xc2, 0xaa, 0x00, 0x00, 0x00, // MOV RDX, 0xAA
        0xfc, // CLD
        0xaa, // STOSB
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax & 0xFF, 0x42); // AL preserved
    assert_eq!(vm.rbx, 0x99); // Preserved
    assert_eq!(vm.rdx, 0xAA); // Preserved
}

#[test]
fn test_stosb_empty_rep() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, // MOV RCX, 0
        0xb0, 0x42, // MOV AL, 0x42
        0xfc, // CLD
        0xf3, 0xaa, // REP STOSB (no iterations)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rdi, 0x4000); // Unchanged
}

#[test]
fn test_stosb_backward_fill() {
    let code = [
        0x48, 0xc7, 0xc7, 0x07, 0x40, 0x00, 0x00, // MOV RDI, 0x4007 (end)
        0x48, 0xc7, 0xc1, 0x08, 0x00, 0x00, 0x00, // MOV RCX, 8
        0xb0, 0xbb, // MOV AL, 0xBB
        0xfd, // STD
        0xf3, 0xaa, // REP STOSB (backward)
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 8);
    assert_eq!(&data, &[0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB]);
    assert_eq!(vm.rdi, 0x3FFF);
}

#[test]
fn test_stosb_buffer_initialization() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x20, 0x00, 0x00, 0x00, // MOV RCX, 32
        0xb0, 0x20, // MOV AL, ' ' (space)
        0xfc, // CLD
        0xf3, 0xaa, // REP STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 32);
    assert_eq!(&data, &[0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20]); // All spaces
}

#[test]
fn test_stosd_array_initialization() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x05, 0x00, 0x00, 0x00, // MOV RCX, 5
        0xb8, 0xff, 0xff, 0xff, 0xff, // MOV EAX, -1
        0xfc, // CLD
        0xf3, 0xab, // REP STOSD
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 20);
    assert_eq!(&data, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
}

#[test]
fn test_stosq_fast_clear() {
    // Using STOSQ for fast 64-bit clear
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x08, 0x00, 0x00, 0x00, // MOV RCX, 8 (64 bytes total)
        0x48, 0x31, 0xc0, // XOR RAX, RAX
        0xfc, // CLD
        0xf3, 0x48, 0xab, // REP STOSQ
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 64);
    assert_eq!(&data, &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
}

#[test]
fn test_stosb_single_byte() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xb0, 0x7f, // MOV AL, 0x7F
        0xfc, // CLD
        0xaa, // STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0x7F);
}

#[test]
fn test_stosw_alignment() {
    // Verify STOSW works on aligned addresses
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000 (aligned)
        0x66, 0xb8, 0xaa, 0xbb, // MOV AX, 0xBBAA
        0xfc, // CLD
        0x66, 0xab, // STOSW
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 2);
    assert_eq!(data, &[0xAA, 0xBB]);
}

#[test]
fn test_stosb_pattern_fill() {
    // Fill with pattern using multiple STOSB
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xfc, // CLD
        0xb0, 0x01, // MOV AL, 1
        0xaa, // STOSB
        0xb0, 0x02, // MOV AL, 2
        0xaa, // STOSB
        0xb0, 0x03, // MOV AL, 3
        0xaa, // STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 3);
    assert_eq!(&data, &[1, 2, 3]);
}

#[test]
fn test_rep_stosb_large_fill() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x00, 0x01, 0x00, 0x00, // MOV RCX, 256
        0xb0, 0x55, // MOV AL, 0x55
        0xfc, // CLD
        0xf3, 0xaa, // REP STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 256);
    assert_eq!(&data, &[0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55]);
    assert_eq!(vm.rcx, 0);
    assert_eq!(vm.rdi, 0x4100);
}

#[test]
fn test_stosb_with_high_byte() {
    // Verify only AL is used, not full RAX
    let code = [
        0x48, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x42, // MOV RAX, 0x42FF...
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xfc, // CLD
        0xaa, // STOSB (should only store AL = 0xFF)
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0xFF); // Only low byte
}

#[test]
fn test_stosw_with_high_word() {
    let code = [
        0x48, 0xb8, 0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // MOV RAX, 0xFF...FFBBAA
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xfc, // CLD
        0x66, 0xab, // STOSW (should only store AX = 0xBBAA)
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 2);
    assert_eq!(data, &[0xAA, 0xBB]); // Only low word
}

#[test]
fn test_stosd_with_high_dword() {
    let code = [
        0x48, 0xb8, 0x11, 0x22, 0x33, 0x44, 0xff, 0xff, 0xff, 0xff, // MOV RAX, 0xFF...44332211
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xfc, // CLD
        0xab, // STOSD (should only store EAX = 0x44332211)
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 4);
    assert_eq!(data, &[0x11, 0x22, 0x33, 0x44]); // Only low dword
}

#[test]
fn test_rep_stosb_one_iteration() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x01, 0x00, 0x00, 0x00, // MOV RCX, 1
        0xb0, 0xcc, // MOV AL, 0xCC
        0xfc, // CLD
        0xf3, 0xaa, // REP STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0xCC);
    assert_eq!(vm.rcx, 0);
    assert_eq!(vm.rdi, 0x4001);
}

#[test]
fn test_stosb_consecutive() {
    let code = [
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xfc, // CLD
        0xb0, 0xaa, // MOV AL, 0xAA
        0xaa, // STOSB
        0xaa, // STOSB
        0xaa, // STOSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x4000, 3);
    assert_eq!(&data, &[0xAA, 0xAA, 0xAA]);
    assert_eq!(vm.rdi, 0x4003);
}
