use crate::common::{setup_vm_legacy as setup_vm, run_until_hlt_legacy as run_until_hlt, VM, Bytes};

// MOVS/MOVSB/MOVSW/MOVSD/MOVSQ - Move Data from String to String
// Moves data from [RSI] to [RDI], increments/decrements both based on DF
// Opcodes:
//   A4 - MOVSB (move byte)
//   A5 - MOVSW (move word, 66h prefix)
//   A5 - MOVSD (move doubleword)
//   REX.W A5 - MOVSQ (move quadword)

#[test]
fn test_movsb_basic() {
    let code = [
        // Setup source data
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000 (source)
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000 (dest)
        0xc6, 0x06, 0x42, // MOV BYTE PTR [RSI], 0x42
        0xfc, // CLD (clear direction flag, increment mode)
        0xa4, // MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0x42); // Data moved
    assert_eq!(vm.rsi, 0x3001); // RSI incremented
    assert_eq!(vm.rdi, 0x4001); // RDI incremented
}

#[test]
fn test_movsb_with_std() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xc6, 0x06, 0x99, // MOV BYTE PTR [RSI], 0x99
        0xfd, // STD (set direction flag, decrement mode)
        0xa4, // MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0x99);
    assert_eq!(vm.rsi, 0x2FFF); // RSI decremented
    assert_eq!(vm.rdi, 0x3FFF); // RDI decremented
}

#[test]
fn test_movsb_multiple_with_rep() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x05, 0x00, 0x00, 0x00, // MOV RCX, 5
        // Setup source data
        0xc6, 0x06, 0x41, // MOV BYTE PTR [RSI], 'A'
        0xc6, 0x46, 0x01, 0x42, // MOV BYTE PTR [RSI+1], 'B'
        0xc6, 0x46, 0x02, 0x43, // MOV BYTE PTR [RSI+2], 'C'
        0xc6, 0x46, 0x03, 0x44, // MOV BYTE PTR [RSI+3], 'D'
        0xc6, 0x46, 0x04, 0x45, // MOV BYTE PTR [RSI+4], 'E'
        0xfc, // CLD
        0xf3, 0xa4, // REP MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 5);
    assert_eq!(&dest, &[0x41, 0x42, 0x43, 0x44, 0x45]); // "ABCDE"
    assert_eq!(vm.rcx, 0); // Counter decremented to 0
    assert_eq!(vm.rsi, 0x3005);
    assert_eq!(vm.rdi, 0x4005);
}

#[test]
fn test_movsw_basic() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x66, 0xc7, 0x06, 0x34, 0x12, // MOV WORD PTR [RSI], 0x1234
        0xfc, // CLD
        0x66, 0xa5, // MOVSW
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 2);
    assert_eq!(dest, &[0x34, 0x12]); // Little endian
    assert_eq!(vm.rsi, 0x3002); // Incremented by 2
    assert_eq!(vm.rdi, 0x4002);
}

#[test]
fn test_movsd_basic() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xc7, 0x06, 0x78, 0x56, 0x34, 0x12, // MOV DWORD PTR [RSI], 0x12345678
        0xfc, // CLD
        0xa5, // MOVSD
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 4);
    assert_eq!(dest, &[0x78, 0x56, 0x34, 0x12]);
    assert_eq!(vm.rsi, 0x3004); // Incremented by 4
    assert_eq!(vm.rdi, 0x4004);
}

#[test]
fn test_movsq_basic() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xb8, 0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12, // MOV RAX, 0x1234567890ABCDEF
        0x48, 0x89, 0x06, // MOV [RSI], RAX
        0xfc, // CLD
        0x48, 0xa5, // MOVSQ
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 8);
    assert_eq!(dest, &[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]);
    assert_eq!(vm.rsi, 0x3008); // Incremented by 8
    assert_eq!(vm.rdi, 0x4008);
}

#[test]
fn test_movsb_preserves_data() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xc6, 0x06, 0xaa, // MOV BYTE PTR [RSI], 0xAA
        0xfc, // CLD
        0xa4, // MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x3000, 1)[0], 0xAA); // Source preserved
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0xAA); // Dest set
}

#[test]
fn test_rep_movsb_empty() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, // MOV RCX, 0
        0xfc, // CLD
        0xf3, 0xa4, // REP MOVSB (no iterations)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rsi, 0x3000); // Unchanged
    assert_eq!(vm.rdi, 0x4000); // Unchanged
}

#[test]
fn test_rep_movsd_copy_array() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x04, 0x00, 0x00, 0x00, // MOV RCX, 4
        // Setup source array
        0xc7, 0x06, 0x01, 0x00, 0x00, 0x00, // MOV DWORD PTR [RSI], 1
        0xc7, 0x46, 0x04, 0x02, 0x00, 0x00, 0x00, // MOV DWORD PTR [RSI+4], 2
        0xc7, 0x46, 0x08, 0x03, 0x00, 0x00, 0x00, // MOV DWORD PTR [RSI+8], 3
        0xc7, 0x46, 0x0c, 0x04, 0x00, 0x00, 0x00, // MOV DWORD PTR [RSI+12], 4
        0xfc, // CLD
        0xf3, 0xa5, // REP MOVSD
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 16);
    assert_eq!(&dest[0..4], &[1, 0, 0, 0]);
    assert_eq!(&dest[4..8], &[2, 0, 0, 0]);
    assert_eq!(&dest[8..12], &[3, 0, 0, 0]);
    assert_eq!(&dest[12..16], &[4, 0, 0, 0]);
}

#[test]
fn test_movsb_backward_copy() {
    let code = [
        0x48, 0xc7, 0xc6, 0x04, 0x30, 0x00, 0x00, // MOV RSI, 0x3004 (end)
        0x48, 0xc7, 0xc7, 0x04, 0x40, 0x00, 0x00, // MOV RDI, 0x4004
        0x48, 0xc7, 0xc1, 0x05, 0x00, 0x00, 0x00, // MOV RCX, 5
        // Setup source data
        0xc6, 0x46, 0xfc, 0x41, // MOV BYTE PTR [RSI-4], 'A'
        0xc6, 0x46, 0xfd, 0x42, // MOV BYTE PTR [RSI-3], 'B'
        0xc6, 0x46, 0xfe, 0x43, // MOV BYTE PTR [RSI-2], 'C'
        0xc6, 0x46, 0xff, 0x44, // MOV BYTE PTR [RSI-1], 'D'
        0xc6, 0x06, 0x45, // MOV BYTE PTR [RSI], 'E'
        0xfd, // STD
        0xf3, 0xa4, // REP MOVSB (backward)
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 5);
    assert_eq!(&dest, &[0x41, 0x42, 0x43, 0x44, 0x45]); // "ABCDE"
}

#[test]
fn test_movsb_preserves_other_registers() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc0, 0x42, 0x00, 0x00, 0x00, // MOV RAX, 0x42
        0x48, 0xc7, 0xc3, 0x99, 0x00, 0x00, 0x00, // MOV RBX, 0x99
        0xc6, 0x06, 0xaa, // MOV BYTE PTR [RSI], 0xAA
        0xfc, // CLD
        0xa4, // MOVSB
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0x42); // Preserved
    assert_eq!(vm.rbx, 0x99); // Preserved
}

#[test]
fn test_movsb_overlapping_forward() {
    // Copy within same buffer (forward)
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000 (source)
        0x48, 0xc7, 0xc7, 0x02, 0x30, 0x00, 0x00, // MOV RDI, 0x3002 (dest, overlaps)
        0x48, 0xc7, 0xc1, 0x03, 0x00, 0x00, 0x00, // MOV RCX, 3
        0xc6, 0x06, 0x41, // MOV BYTE PTR [RSI], 'A'
        0xc6, 0x46, 0x01, 0x42, // MOV BYTE PTR [RSI+1], 'B'
        0xc6, 0x46, 0x02, 0x43, // MOV BYTE PTR [RSI+2], 'C'
        0xfc, // CLD
        0xf3, 0xa4, // REP MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let data = vm.read_memory(0x3000, 5);
    // Original: A B C ? ?
    // After: A B A B C (forward copy works correctly)
    assert_eq!(data[2], 0x41); // 'A'
    assert_eq!(data[3], 0x42); // 'B'
    assert_eq!(data[4], 0x43); // 'C'
}

#[test]
fn test_rep_movsw_copy() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x03, 0x00, 0x00, 0x00, // MOV RCX, 3
        0x66, 0xc7, 0x06, 0x11, 0x11, // MOV WORD PTR [RSI], 0x1111
        0x66, 0xc7, 0x46, 0x02, 0x22, 0x22, // MOV WORD PTR [RSI+2], 0x2222
        0x66, 0xc7, 0x46, 0x04, 0x33, 0x33, // MOV WORD PTR [RSI+4], 0x3333
        0xfc, // CLD
        0xf3, 0x66, 0xa5, // REP MOVSW
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 6);
    assert_eq!(&dest[0..2], &[0x11, 0x11]);
    assert_eq!(&dest[2..4], &[0x22, 0x22]);
    assert_eq!(&dest[4..6], &[0x33, 0x33]);
}

#[test]
fn test_rep_movsq_copy() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x02, 0x00, 0x00, 0x00, // MOV RCX, 2
        0x48, 0xb8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, // MOV RAX, 0x1111...
        0x48, 0x89, 0x06, // MOV [RSI], RAX
        0x48, 0xb8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, // MOV RAX, 0x2222...
        0x48, 0x89, 0x46, 0x08, // MOV [RSI+8], RAX
        0xfc, // CLD
        0xf3, 0x48, 0xa5, // REP MOVSQ
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 16);
    assert_eq!(&dest[0..8], &[0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11]);
    assert_eq!(&dest[8..16], &[0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22]);
}

#[test]
fn test_movsb_memcpy_pattern() {
    // Typical memcpy usage
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, src
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, dst
        0x48, 0xc7, 0xc1, 0x08, 0x00, 0x00, 0x00, // MOV RCX, 8 (count)
        // Setup source "HELLO!!\0"
        0xc6, 0x06, 0x48, // H
        0xc6, 0x46, 0x01, 0x45, // E
        0xc6, 0x46, 0x02, 0x4c, // L
        0xc6, 0x46, 0x03, 0x4c, // L
        0xc6, 0x46, 0x04, 0x4f, // O
        0xc6, 0x46, 0x05, 0x21, // !
        0xc6, 0x46, 0x06, 0x21, // !
        0xc6, 0x46, 0x07, 0x00, // \0
        0xfc, // CLD
        0xf3, 0xa4, // REP MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    let dest = vm.read_memory(0x4000, 8);
    assert_eq!(&dest, &[0x48, 0x45, 0x4C, 0x4C, 0x4F, 0x21, 0x21, 0x00]);
}

#[test]
fn test_movs_with_different_sizes() {
    // Ensure each size moves correct amount
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0xc6, 0x06, 0xff, // MOV BYTE PTR [RSI], 0xFF
        0xfc, // CLD
        // MOVSB
        0xa4, // MOVSB (moves 1 byte)
        // MOVSW
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // Reset RSI
        0x66, 0xa5, // MOVSW (moves 2 bytes)
        // MOVSD
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // Reset RSI
        0xa5, // MOVSD (moves 4 bytes)
        // MOVSQ
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // Reset RSI
        0x48, 0xa5, // MOVSQ (moves 8 bytes)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    // After MOVSB: RDI = 0x4001
    // After MOVSW: RDI = 0x4003
    // After MOVSD: RDI = 0x4007
    // After MOVSQ: RDI = 0x400F
    assert_eq!(vm.rdi, 0x400F);
}

#[test]
fn test_movsb_large_copy() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x40, 0x00, 0x00, 0x00, // MOV RCX, 64
        0xfc, // CLD
        0xf3, 0xa4, // REP MOVSB
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rcx, 0);
    assert_eq!(vm.rsi, 0x3040);
    assert_eq!(vm.rdi, 0x4040);
}

#[test]
fn test_movsb_single_byte_rep() {
    let code = [
        0x48, 0xc7, 0xc6, 0x00, 0x30, 0x00, 0x00, // MOV RSI, 0x3000
        0x48, 0xc7, 0xc7, 0x00, 0x40, 0x00, 0x00, // MOV RDI, 0x4000
        0x48, 0xc7, 0xc1, 0x01, 0x00, 0x00, 0x00, // MOV RCX, 1
        0xc6, 0x06, 0xaa, // MOV BYTE PTR [RSI], 0xAA
        0xfc, // CLD
        0xf3, 0xa4, // REP MOVSB
        0xf4, // HLT
    ];
    let mut vm = setup_vm(&code);
    vm = run_until_hlt(vm);
    assert_eq!(vm.read_memory(0x4000, 1)[0], 0xAA);
    assert_eq!(vm.rcx, 0);
}
