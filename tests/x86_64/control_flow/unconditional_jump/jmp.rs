use crate::common::{setup_vm_legacy as setup_vm, run_until_hlt_legacy as run_until_hlt, VM};

// JMP - Unconditional Jump
// Transfers control to target location
// Opcodes:
//   EB cb - JMP rel8 (short jump)
//   E9 cw/cd - JMP rel16/rel32 (near jump)
//   FF /4 - JMP r/m64 (indirect jump)

#[test]
fn test_jmp_short_forward() {
    let code = [
        0xeb, 0x03, // JMP +3
        0xf4, 0xf4, 0xf4, // HLT, HLT, HLT (should not execute)
        0xf4, // HLT (target)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
    assert_eq!(vm.executed_instructions, 2); // JMP, HLT
}

#[test]
fn test_jmp_short_backward() {
    let code = [
        0x48, 0xc7, 0xc1, 0x03, 0x00, 0x00, 0x00, // MOV RCX, 3
        // loop_start (offset 7):
        0x48, 0xff, 0xc9, // DEC RCX
        0x75, 0x02, // JNZ +2 (skip JMP if RCX!=0)
        0xeb, 0x02, // JMP +2 (exit loop)
        0xeb, 0xf7, // JMP -9 (back to loop_start)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rcx, 0);
}

#[test]
fn test_jmp_short_max_forward_offset() {
    let mut code = vec![
        0xeb, 0x7f, // JMP +127 (max positive offset)
    ];
    code.extend(vec![0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90]); // 127 NOPs
    code.push(0xf4); // HLT at offset +127

    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
}

#[test]
fn test_jmp_short_max_backward_offset() {
    let mut code = vec![
        0xeb, 0x7e, // JMP +126 (skip to backward jump)
        0xf4, // HLT (target)
    ];
    code.extend(vec![0x90; 125]); // padding to land on HLT with JMP -128
    code.extend([
        0xeb, 0x80, // JMP -128 (max negative offset)
    ]);

    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x1003);
}


#[test]
fn test_jmp_short_zero_offset() {
    let code = [
        0xeb, 0x00, // JMP +0 (jump to next instruction)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
}

#[test]
fn test_jmp_near_forward() {
    let code = [
        0xe9, 0x05, 0x00, 0x00, 0x00, // JMP +5 (near relative)
        0xf4, 0xf4, 0xf4, 0xf4, 0xf4, // HLT * 5 (should not execute)
        0xf4, // HLT (target)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
    assert_eq!(vm.executed_instructions, 2); // JMP, HLT
}

#[test]
fn test_jmp_near_backward() {
    let code = [
        0x48, 0xc7, 0xc1, 0x02, 0x00, 0x00, 0x00, // MOV RCX, 2
        // loop_start (offset 7):
        0x48, 0xff, 0xc9, // DEC RCX
        0x75, 0x05, // JNZ +5 (skip JMP if RCX!=0)
        0xe9, 0x02, 0x00, 0x00, 0x00, // JMP +2 (exit loop)
        0xe9, 0xf1, 0xff, 0xff, 0xff, // JMP -15 (back to loop_start)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rcx, 0);
}

#[test]
fn test_jmp_near_large_forward() {
    let mut code = vec![
        0xe9, 0x00, 0x02, 0x00, 0x00, // JMP +512
    ];
    code.extend(vec![0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90]); // 512 NOPs
    code.push(0xf4); // HLT

    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
}

#[test]
fn test_jmp_indirect_register() {
    let code = [
        0x48, 0xb8, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, 0x100C
        0xff, 0xe0, // JMP RAX
        0xf4, 0xf4, // HLT, HLT (should not execute)
        0xf4, // HLT (target at 0x100C)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x100D);
    assert_eq!(vm.executed_instructions, 3); // MOV, JMP, HLT
}

#[test]
fn test_jmp_indirect_all_registers() {
    // Test JMP with different registers
    fn get_rax(vm: &crate::common::VM) -> u64 { vm.rax }
    fn get_rbx(vm: &crate::common::VM) -> u64 { vm.rbx }
    fn get_rcx(vm: &crate::common::VM) -> u64 { vm.rcx }
    fn get_rdx(vm: &crate::common::VM) -> u64 { vm.rdx }
    for (reg_code, reg_name, reg_value) in [
        (0xe0u8, "RAX", get_rax as fn(&crate::common::VM) -> u64),
        (0xe3, "RBX", get_rbx as fn(&crate::common::VM) -> u64),
        (0xe1, "RCX", get_rcx as fn(&crate::common::VM) -> u64),
        (0xe2, "RDX", get_rdx as fn(&crate::common::VM) -> u64),
    ] {
        let target = 0x101bu64;
        let code = [
            0x48, 0xb8, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, target
            0x48, 0x89, 0xc3, // MOV RBX, RAX
            0x48, 0x89, 0xc1, // MOV RCX, RAX
            0x48, 0x89, 0xc2, // MOV RDX, RAX
            0xff, reg_code, // JMP reg
            0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, // HLT * 6 (padding)
            0xf4, // HLT (target at 0x101B)
        ];
        let vm = setup_vm(&code);
        let vm = run_until_hlt(vm);
        assert_eq!(vm.rip, target + 1, "JMP {} failed", reg_name);
        assert_eq!(reg_value(&vm), target, "Register {} not set correctly", reg_name);
    }
}

#[test]
fn test_jmp_preserves_all_registers() {
    let code = [
        0x48, 0xc7, 0xc0, 0x11, 0x00, 0x00, 0x00, // MOV RAX, 0x11
        0x48, 0xc7, 0xc3, 0x22, 0x00, 0x00, 0x00, // MOV RBX, 0x22
        0x48, 0xc7, 0xc1, 0x33, 0x00, 0x00, 0x00, // MOV RCX, 0x33
        0x48, 0xc7, 0xc2, 0x44, 0x00, 0x00, 0x00, // MOV RDX, 0x44
        0x48, 0xc7, 0xc6, 0x55, 0x00, 0x00, 0x00, // MOV RSI, 0x55
        0x48, 0xc7, 0xc7, 0x66, 0x00, 0x00, 0x00, // MOV RDI, 0x66
        0xeb, 0x03, // JMP +3
        0xf4, 0xf4, 0xf4, // HLT * 3
        0xf4, // HLT (target)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0x11);
    assert_eq!(vm.rbx, 0x22);
    assert_eq!(vm.rcx, 0x33);
    assert_eq!(vm.rdx, 0x44);
    assert_eq!(vm.rsi, 0x55);
    assert_eq!(vm.rdi, 0x66);
}

#[test]
fn test_jmp_preserves_flags() {
    let code = [
        0x48, 0xc7, 0xc0, 0xff, 0xff, 0xff, 0xff, // MOV RAX, -1
        0x48, 0x83, 0xc0, 0x01, // ADD RAX, 1 (sets ZF=1, CF=1)
        0xeb, 0x03, // JMP +3 (should not affect flags)
        0xf4, 0xf4, 0xf4, // HLT * 3
        0x75, 0x01, // JNZ +1 (should not jump because ZF=1)
        0xf4, // HLT (should execute)
        0xf4, // HLT (should not reach)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0);
    assert_eq!(vm.rip, (0x1000 + code.len() - 1) as u64);
}

#[test]
fn test_jmp_switch_statement_pattern() {
    // Simulate a jump table / switch statement
    let code = [
        0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, // MOV RAX, 2 (case selector)
        0x48, 0xc1, 0xe0, 0x03, // SHL RAX, 3 (multiply by 8 for jump table entry size)
        0x48, 0x05, 0x14, 0x10, 0x00, 0x00, // ADD RAX, jump_table (0x1014)
        0xff, 0xe0, // JMP RAX
        0xf4, // HLT (should not reach)
        // jump_table at 0x1014:
        0x48, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x90, // case 0: MOV RCX, 0
        0x48, 0xc7, 0xc1, 0x01, 0x00, 0x00, 0x00, 0x90, // case 1: MOV RCX, 1
        0x48, 0xc7, 0xc1, 0x02, 0x00, 0x00, 0x00, 0x90, // case 2: MOV RCX, 2 (should execute)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rcx, 2);
}

#[test]
fn test_jmp_function_epilogue_pattern() {
    // Common pattern: unconditional jump to shared epilogue
    let code = [
        0x48, 0xc7, 0xc0, 0x42, 0x00, 0x00, 0x00, // MOV RAX, 0x42
        0xeb, 0x07, // JMP +7 (to epilogue)
        // alternate_path:
        0x48, 0xc7, 0xc0, 0x99, 0x00, 0x00, 0x00, // MOV RAX, 0x99 (not executed)
        // epilogue:
        0x48, 0x83, 0xc0, 0x01, // ADD RAX, 1
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0x43);
}

#[test]
fn test_jmp_infinite_loop_with_counter() {
    let code = [
        0x48, 0xc7, 0xc1, 0x05, 0x00, 0x00, 0x00, // MOV RCX, 5
        // loop_start (offset 7):
        0x48, 0xff, 0xc9, // DEC RCX
        0x75, 0x02, // JNZ +2 (continue loop if RCX!=0)
        0xeb, 0x02, // JMP +2 (exit)
        0xeb, 0xf7, // JMP -9 (infinite loop back)
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rcx, 0);
}

#[test]
fn test_jmp_nested_jumps() {
    let code = [
        0xeb, 0x02, // JMP +2
        0xf4, 0xf4, // HLT, HLT
        0xeb, 0x02, // JMP +2
        0xf4, 0xf4, // HLT, HLT
        0xeb, 0x02, // JMP +2
        0xf4, 0xf4, // HLT, HLT
        0xf4, // HLT (target)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
    assert_eq!(vm.executed_instructions, 4); // 3 JMPs + 1 HLT
}

#[test]
fn test_jmp_skip_data_section() {
    let code = [
        0xeb, 0x08, // JMP +8 (skip over data)
        // data section:
        0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
        // code continues:
        0x48, 0xc7, 0xc0, 0x42, 0x00, 0x00, 0x00, // MOV RAX, 0x42
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0x42);
}

#[test]
fn test_jmp_chained_forward_backward() {
    let code = [
        0xeb, 0x05, // JMP +5 (forward)
        // location_a (offset 2):
        0x48, 0xff, 0xc0, // INC RAX
        0xeb, 0x09, // JMP +9 (to end)
        // location_b (offset 7):
        0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, // MOV RAX, 1
        0xeb, 0xf2, // JMP -14 (back to location_a)
        // end:
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 2); // MOV 1, INC -> 2
}

#[test]
fn test_jmp_boundary_alignment() {
    // Test jump across different alignments
    let mut code = vec![
        0xeb, 0x10, // JMP +16
    ];
    code.extend(vec![0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90]); // 16 NOPs
    code.push(0xf4); // HLT

    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, (0x1000 + code.len()) as u64);
}

#[test]
fn test_jmp_with_computation() {
    // Compute jump target dynamically
    let code = [
        0x48, 0xc7, 0xc0, 0x0a, 0x10, 0x00, 0x00, // MOV RAX, 0x100A (base)
        0x48, 0x83, 0xc0, 0x05, // ADD RAX, 5 (compute target 0x100F)
        0xff, 0xe0, // JMP RAX
        0xf4, 0xf4, 0xf4, 0xf4, 0xf4, // HLT * 5 (padding)
        0xf4, // HLT (target at 0x100F)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x1010);
    assert_eq!(vm.rax, 0x100F);
}

#[test]
fn test_jmp_indirect_computed_offset() {
    // Dynamic jump based on index
    let code = [
        0x48, 0xc7, 0xc1, 0x01, 0x00, 0x00, 0x00, // MOV RCX, 1 (index)
        0x48, 0xc7, 0xc0, 0x12, 0x10, 0x00, 0x00, // MOV RAX, 0x1012 (base)
        0x48, 0x01, 0xc8, // ADD RAX, RCX (target = base + index)
        0xff, 0xe0, // JMP RAX
        0xf4, // case 0 (should not execute)
        0xf4, // case 1 (should execute at 0x1013)
        0xf4, // case 2 (should not execute)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x1014);
}

#[test]
fn test_jmp_return_address_pattern() {
    // Simulate storing and jumping to return address
    let code = [
        0x48, 0xb8, 0x0f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RAX, return_addr
        0x48, 0x89, 0xc3, // MOV RBX, RAX (save return address)
        0xeb, 0x09, // JMP +9 (call function)
        // return_point (0x100F):
        0x48, 0xc7, 0xc1, 0x99, 0x00, 0x00, 0x00, // MOV RCX, 0x99
        0xeb, 0x09, // JMP +9 (to end)
        // function:
        0x48, 0xc7, 0xc0, 0x42, 0x00, 0x00, 0x00, // MOV RAX, 0x42
        0xff, 0xe3, // JMP RBX (return)
        // end:
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0x42);
    assert_eq!(vm.rcx, 0x99);
}

#[test]
fn test_jmp_short_vs_near_same_target() {
    // Both should reach the same target
    let code1 = [
        0xeb, 0x05, // JMP +5 (short)
        0xf4, 0xf4, 0xf4, 0xf4, 0xf4, // HLT * 5
        0xf4, // HLT (target)
    ];
    let vm1 = setup_vm(&code1);
    let vm1 = run_until_hlt(vm1);

    let code2 = [
        0xe9, 0x05, 0x00, 0x00, 0x00, // JMP +5 (near)
        0xf4, 0xf4, 0xf4, 0xf4, 0xf4, // HLT * 5
        0xf4, // HLT (target)
    ];
    let vm2 = setup_vm(&code2);
    let vm2 = run_until_hlt(vm2);

    // Both should end at equivalent positions relative to their start
    assert_eq!(vm1.executed_instructions, 2);
    assert_eq!(vm2.executed_instructions, 2);
}

#[test]
fn test_jmp_multiple_consecutive() {
    let code = [
        0xeb, 0x00, // JMP +0
        0xeb, 0x00, // JMP +0
        0xeb, 0x00, // JMP +0
        0xeb, 0x00, // JMP +0
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.executed_instructions, 5); // 4 JMPs + HLT
}

#[test]
fn test_jmp_over_conditional() {
    // Unconditional jump over conditional code
    let code = [
        0x48, 0x31, 0xc0, // XOR RAX, RAX (RAX=0, sets ZF=1)
        0xeb, 0x07, // JMP +7 (skip conditional)
        // conditional section (should not execute):
        0x74, 0x02, // JE +2 (would jump if executed)
        0x48, 0xc7, 0xc0, 0x99, 0x00, 0x00, 0x00, // MOV RAX, 0x99
        // continue:
        0x48, 0xc7, 0xc1, 0x42, 0x00, 0x00, 0x00, // MOV RCX, 0x42
        0xf4, // HLT
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rax, 0);
    assert_eq!(vm.rcx, 0x42);
}

#[test]
fn test_jmp_table_three_cases() {
    // More elaborate jump table
    for case in 0..3 {
        let mut code = vec![
            0x48, 0xc7, 0xc0,
        ];
        code.push(case); // MOV RAX, case
        code.extend([
            0x00, 0x00, 0x00,
            0x48, 0xc1, 0xe0, 0x03, // SHL RAX, 3
            0x48, 0x05, 0x14, 0x10, 0x00, 0x00, // ADD RAX, 0x1014
            0xff, 0xe0, // JMP RAX
            0xf4, // padding
            // jump table at 0x1014:
            0x48, 0xc7, 0xc1, 0xaa, 0x00, 0x00, 0x00, 0x90, // case 0: MOV RCX, 0xAA
            0x48, 0xc7, 0xc1, 0xbb, 0x00, 0x00, 0x00, 0x90, // case 1: MOV RCX, 0xBB
            0x48, 0xc7, 0xc1, 0xcc, 0x00, 0x00, 0x00, 0x90, // case 2: MOV RCX, 0xCC
            0xf4, // HLT
        ]);

        let vm = setup_vm(&code);
        let vm = run_until_hlt(vm);
        let expected_rcx = [0xAA, 0xBB, 0xCC][case as usize];
        assert_eq!(vm.rcx, expected_rcx, "Case {} failed", case);
    }
}

#[test]
fn test_jmp_indirect_rbx() {
    let code = [
        0x48, 0xbb, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RBX, 0x100C
        0xff, 0xe3, // JMP RBX
        0xf4, 0xf4, // HLT, HLT (should not execute)
        0xf4, // HLT (target at 0x100C)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x100D);
    assert_eq!(vm.rbx, 0x100C);
}

#[test]
fn test_jmp_indirect_rcx() {
    let code = [
        0x48, 0xb9, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RCX, 0x100C
        0xff, 0xe1, // JMP RCX
        0xf4, 0xf4, // HLT, HLT (should not execute)
        0xf4, // HLT (target at 0x100C)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x100D);
    assert_eq!(vm.rcx, 0x100C);
}

#[test]
fn test_jmp_indirect_rdx() {
    let code = [
        0x48, 0xba, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RDX, 0x100C
        0xff, 0xe2, // JMP RDX
        0xf4, 0xf4, // HLT, HLT (should not execute)
        0xf4, // HLT (target at 0x100C)
    ];
    let vm = setup_vm(&code);
    let vm = run_until_hlt(vm);
    assert_eq!(vm.rip, 0x100D);
    assert_eq!(vm.rdx, 0x100C);
}
