//! A32 system system tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_MRS_br_AS Tests
// ============================================================================

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_0_min_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, M=0, cond=0, R=0, M1=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_1_poweroftwo_200_11000200() {
    // Encoding: 0x11000200
    // Test aarch32_MRS_br_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, M1=0, M=0, cond=1
    let encoding: u32 = 0x11000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_2_poweroftwo_200_21000200() {
    // Encoding: 0x21000200
    // Test aarch32_MRS_br_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: M1=0, cond=2, Rd=0, M=0, R=0
    let encoding: u32 = 0x21000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_3_poweroftwo_200_31000200() {
    // Encoding: 0x31000200
    // Test aarch32_MRS_br_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, R=0, M=0, Rd=0, M1=0
    let encoding: u32 = 0x31000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_4_poweroftwo_200_41000200() {
    // Encoding: 0x41000200
    // Test aarch32_MRS_br_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=4, M1=0, R=0, Rd=0
    let encoding: u32 = 0x41000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_5_poweroftwo_200_51000200() {
    // Encoding: 0x51000200
    // Test aarch32_MRS_br_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, R=0, M=0, Rd=0, M1=0
    let encoding: u32 = 0x51000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_6_poweroftwo_200_61000200() {
    // Encoding: 0x61000200
    // Test aarch32_MRS_br_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: M1=0, cond=6, R=0, Rd=0, M=0
    let encoding: u32 = 0x61000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_7_poweroftwo_200_71000200() {
    // Encoding: 0x71000200
    // Test aarch32_MRS_br_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=7, M1=0, R=0, Rd=0
    let encoding: u32 = 0x71000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_8_poweroftwo_200_81000200() {
    // Encoding: 0x81000200
    // Test aarch32_MRS_br_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: M1=0, cond=8, M=0, Rd=0, R=0
    let encoding: u32 = 0x81000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_9_poweroftwo_200_91000200() {
    // Encoding: 0x91000200
    // Test aarch32_MRS_br_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: M1=0, cond=9, M=0, R=0, Rd=0
    let encoding: u32 = 0x91000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_10_poweroftwo_200_a1000200() {
    // Encoding: 0xA1000200
    // Test aarch32_MRS_br_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, M=0, cond=10, M1=0
    let encoding: u32 = 0xA1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_11_poweroftwo_200_b1000200() {
    // Encoding: 0xB1000200
    // Test aarch32_MRS_br_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, M1=0, Rd=0, cond=11, R=0
    let encoding: u32 = 0xB1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_12_poweroftwo_200_c1000200() {
    // Encoding: 0xC1000200
    // Test aarch32_MRS_br_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, M1=0, cond=12, M=0
    let encoding: u32 = 0xC1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_13_poweroftwo_200_d1000200() {
    // Encoding: 0xD1000200
    // Test aarch32_MRS_br_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, M=0, R=0, Rd=0, M1=0
    let encoding: u32 = 0xD1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_14_poweroftwo_200_e1000200() {
    // Encoding: 0xE1000200
    // Test aarch32_MRS_br_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: M1=0, cond=14, Rd=0, M=0, R=0
    let encoding: u32 = 0xE1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_mrs_br_a1_as_field_cond_15_max_200_f1000200() {
    // Encoding: 0xF1000200
    // Test aarch32_MRS_br_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=15, M=0, M1=0, R=0
    let encoding: u32 = 0xF1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_br_a1_as_field_r_0_min_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS field R = 0 (Min)
    // ISET: A32
    // Fields: R=0, cond=0, M1=0, Rd=0, M=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_mrs_br_a1_as_field_r_1_max_200_01400200() {
    // Encoding: 0x01400200
    // Test aarch32_MRS_br_A1_AS field R = 1 (Max)
    // ISET: A32
    // Fields: M1=0, R=1, cond=0, Rd=0, M=0
    let encoding: u32 = 0x01400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_br_a1_as_field_m1_0_min_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS field M1 = 0 (Min)
    // ISET: A32
    // Fields: M1=0, Rd=0, R=0, M=0, cond=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_mrs_br_a1_as_field_m1_1_poweroftwo_200_01010200() {
    // Encoding: 0x01010200
    // Test aarch32_MRS_br_A1_AS field M1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=0, R=0, M1=1, Rd=0
    let encoding: u32 = 0x01010200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_mrs_br_a1_as_field_m1_7_poweroftwominusone_200_01070200() {
    // Encoding: 0x01070200
    // Test aarch32_MRS_br_A1_AS field M1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: M1=7, R=0, Rd=0, M=0, cond=0
    let encoding: u32 = 0x01070200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_mrs_br_a1_as_field_m1_15_max_200_010f0200() {
    // Encoding: 0x010F0200
    // Test aarch32_MRS_br_A1_AS field M1 = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, M=0, cond=0, M1=15, R=0
    let encoding: u32 = 0x010F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mrs_br_a1_as_field_rd_0_min_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS field Rd = 0 (Min)
    // ISET: A32
    // Fields: R=0, Rd=0, M=0, cond=0, M1=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mrs_br_a1_as_field_rd_1_poweroftwo_200_01001200() {
    // Encoding: 0x01001200
    // Test aarch32_MRS_br_A1_AS field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, M1=0, Rd=1, cond=0, R=0
    let encoding: u32 = 0x01001200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field M 8 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_br_a1_as_field_m_0_min_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS field M = 0 (Min)
    // ISET: A32
    // Fields: R=0, cond=0, M1=0, Rd=0, M=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field M 8 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_mrs_br_a1_as_field_m_1_max_200_01000300() {
    // Encoding: 0x01000300
    // Test aarch32_MRS_br_A1_AS field M = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, R=0, M1=0, M=1
    let encoding: u32 = 0x01000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_mrs_br_a1_as_combo_0_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS field combination: cond=0, R=0, M1=0, Rd=0, M=0
    // ISET: A32
    // Fields: Rd=0, M=0, cond=0, M1=0, R=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_0_condition_eq_512_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: M=0, M1=0, R=0, cond=0, Rd=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_1_condition_ne_512_11000200() {
    // Encoding: 0x11000200
    // Test aarch32_MRS_br_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: R=0, Rd=0, M1=0, M=0, cond=1
    let encoding: u32 = 0x11000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_2_condition_cs_hs_512_21000200() {
    // Encoding: 0x21000200
    // Test aarch32_MRS_br_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, R=0, Rd=0, M=0, M1=0
    let encoding: u32 = 0x21000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_3_condition_cc_lo_512_31000200() {
    // Encoding: 0x31000200
    // Test aarch32_MRS_br_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=3, M=0, M1=0
    let encoding: u32 = 0x31000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_4_condition_mi_512_41000200() {
    // Encoding: 0x41000200
    // Test aarch32_MRS_br_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, M1=0, R=0, M=0
    let encoding: u32 = 0x41000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_5_condition_pl_512_51000200() {
    // Encoding: 0x51000200
    // Test aarch32_MRS_br_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: R=0, M=0, cond=5, M1=0, Rd=0
    let encoding: u32 = 0x51000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_6_condition_vs_512_61000200() {
    // Encoding: 0x61000200
    // Test aarch32_MRS_br_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: R=0, Rd=0, M=0, cond=6, M1=0
    let encoding: u32 = 0x61000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_7_condition_vc_512_71000200() {
    // Encoding: 0x71000200
    // Test aarch32_MRS_br_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: R=0, cond=7, M1=0, Rd=0, M=0
    let encoding: u32 = 0x71000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_8_condition_hi_512_81000200() {
    // Encoding: 0x81000200
    // Test aarch32_MRS_br_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: M=0, cond=8, Rd=0, M1=0, R=0
    let encoding: u32 = 0x81000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_9_condition_ls_512_91000200() {
    // Encoding: 0x91000200
    // Test aarch32_MRS_br_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, M1=0, M=0, R=0, Rd=0
    let encoding: u32 = 0x91000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_10_condition_ge_512_a1000200() {
    // Encoding: 0xA1000200
    // Test aarch32_MRS_br_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, M=0, M1=0, R=0
    let encoding: u32 = 0xA1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_11_condition_lt_512_b1000200() {
    // Encoding: 0xB1000200
    // Test aarch32_MRS_br_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: M=0, M1=0, cond=11, R=0, Rd=0
    let encoding: u32 = 0xB1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_12_condition_gt_512_c1000200() {
    // Encoding: 0xC1000200
    // Test aarch32_MRS_br_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: M=0, Rd=0, R=0, M1=0, cond=12
    let encoding: u32 = 0xC1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_13_condition_le_512_d1000200() {
    // Encoding: 0xD1000200
    // Test aarch32_MRS_br_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, M1=0, M=0, R=0
    let encoding: u32 = 0xD1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_14_condition_al_512_e1000200() {
    // Encoding: 0xE1000200
    // Test aarch32_MRS_br_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: M=0, cond=14, M1=0, Rd=0, R=0
    let encoding: u32 = 0xE1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_mrs_br_a1_as_special_cond_15_condition_nv_512_f1000200() {
    // Encoding: 0xF1000200
    // Test aarch32_MRS_br_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: M1=0, cond=15, Rd=0, M=0, R=0
    let encoding: u32 = 0xF1000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_br_a1_as_invalid_0_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, M=0, R=0, M1=0, cond=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_br_a1_as_invalid_1_200_01000200() {
    // Encoding: 0x01000200
    // Test aarch32_MRS_br_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, cond=0, M1=0, R=0, M=0
    let encoding: u32 = 0x01000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_br_t1_as_field_r_0_min_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS field R = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, M1=0, M=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_mrs_br_t1_as_field_r_1_max_8020_f3f08020() {
    // Thumb encoding (32): 0xF3F08020
    // Test aarch32_MRS_br_T1_AS field R = 1 (Max)
    // ISET: T32
    // Fields: M=0, R=1, M1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3F08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_br_t1_as_field_m1_0_min_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS field M1 = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rd=0, M=0, M1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_mrs_br_t1_as_field_m1_1_poweroftwo_8020_f3e18020() {
    // Thumb encoding (32): 0xF3E18020
    // Test aarch32_MRS_br_T1_AS field M1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, M1=1, R=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E18020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_mrs_br_t1_as_field_m1_7_poweroftwominusone_8020_f3e78020() {
    // Thumb encoding (32): 0xF3E78020
    // Test aarch32_MRS_br_T1_AS field M1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M1=7, M=0, Rd=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E78020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_mrs_br_t1_as_field_m1_15_max_8020_f3ef8020() {
    // Thumb encoding (32): 0xF3EF8020
    // Test aarch32_MRS_br_T1_AS field M1 = 15 (Max)
    // ISET: T32
    // Fields: R=0, M=0, M1=15, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3EF8020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mrs_br_t1_as_field_rd_0_min_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS field Rd = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rd=0, R=0, M1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mrs_br_t1_as_field_rd_1_poweroftwo_8020_f3e08120() {
    // Thumb encoding (32): 0xF3E08120
    // Test aarch32_MRS_br_T1_AS field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, R=0, M1=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08120;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_br_t1_as_field_m_0_min_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS field M = 0 (Min)
    // ISET: T32
    // Fields: M1=0, Rd=0, R=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_mrs_br_t1_as_field_m_1_max_8020_f3e08030() {
    // Thumb encoding (32): 0xF3E08030
    // Test aarch32_MRS_br_T1_AS field M = 1 (Max)
    // ISET: T32
    // Fields: R=0, M=1, M1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=0 (minimum value)
#[test]
fn test_aarch32_mrs_br_t1_as_combo_0_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS field combination: R=0, M1=0, Rd=0, M=0
    // ISET: T32
    // Fields: M1=0, Rd=0, R=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_br_t1_as_invalid_0_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: M1=0, M=0, Rd=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_br_t1_as_invalid_1_8020_f3e08020() {
    // Thumb encoding (32): 0xF3E08020
    // Test aarch32_MRS_br_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rd=0, R=0, M1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_br_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_br_a1_as_exception_0_01000200() {
    // Test aarch32_MRS_br_A1_AS exception: Unpredictable
    // Encoding: 0x01000200
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_MRS_br_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_br_t1_as_exception_0_f3e08020() {
    // Test aarch32_MRS_br_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_MRS_AS Tests
// ============================================================================

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_0_min_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_1_poweroftwo_0_11000000() {
    // Encoding: 0x11000000
    // Test aarch32_MRS_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, R=0, Rd=0
    let encoding: u32 = 0x11000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_2_poweroftwo_0_21000000() {
    // Encoding: 0x21000000
    // Test aarch32_MRS_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, R=0, Rd=0
    let encoding: u32 = 0x21000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_3_poweroftwo_0_31000000() {
    // Encoding: 0x31000000
    // Test aarch32_MRS_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=3, R=0
    let encoding: u32 = 0x31000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_4_poweroftwo_0_41000000() {
    // Encoding: 0x41000000
    // Test aarch32_MRS_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=4
    let encoding: u32 = 0x41000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_5_poweroftwo_0_51000000() {
    // Encoding: 0x51000000
    // Test aarch32_MRS_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=5
    let encoding: u32 = 0x51000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_6_poweroftwo_0_61000000() {
    // Encoding: 0x61000000
    // Test aarch32_MRS_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, R=0, Rd=0
    let encoding: u32 = 0x61000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_7_poweroftwo_0_71000000() {
    // Encoding: 0x71000000
    // Test aarch32_MRS_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=7
    let encoding: u32 = 0x71000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_8_poweroftwo_0_81000000() {
    // Encoding: 0x81000000
    // Test aarch32_MRS_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, R=0, Rd=0
    let encoding: u32 = 0x81000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_9_poweroftwo_0_91000000() {
    // Encoding: 0x91000000
    // Test aarch32_MRS_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=9
    let encoding: u32 = 0x91000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_10_poweroftwo_0_a1000000() {
    // Encoding: 0xA1000000
    // Test aarch32_MRS_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=10
    let encoding: u32 = 0xA1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_11_poweroftwo_0_b1000000() {
    // Encoding: 0xB1000000
    // Test aarch32_MRS_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=11
    let encoding: u32 = 0xB1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_12_poweroftwo_0_c1000000() {
    // Encoding: 0xC1000000
    // Test aarch32_MRS_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, R=0, Rd=0
    let encoding: u32 = 0xC1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_13_poweroftwo_0_d1000000() {
    // Encoding: 0xD1000000
    // Test aarch32_MRS_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, R=0
    let encoding: u32 = 0xD1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_14_poweroftwo_0_e1000000() {
    // Encoding: 0xE1000000
    // Test aarch32_MRS_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=14
    let encoding: u32 = 0xE1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_mrs_a1_as_field_cond_15_max_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_MRS_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, R=0, Rd=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_a1_as_field_r_0_min_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS field R = 0 (Min)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_mrs_a1_as_field_r_1_max_0_01400000() {
    // Encoding: 0x01400000
    // Test aarch32_MRS_A1_AS field R = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, R=1
    let encoding: u32 = 0x01400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mrs_a1_as_field_rd_0_min_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, R=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mrs_a1_as_field_rd_1_poweroftwo_0_01001000() {
    // Encoding: 0x01001000
    // Test aarch32_MRS_A1_AS field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=1, cond=0
    let encoding: u32 = 0x01001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_mrs_a1_as_combo_0_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS field combination: cond=0, R=0, Rd=0
    // ISET: A32
    // Fields: cond=0, Rd=0, R=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_mrs_a1_as_special_cond_0_condition_eq_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: R=0, cond=0, Rd=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_mrs_a1_as_special_cond_1_condition_ne_0_11000000() {
    // Encoding: 0x11000000
    // Test aarch32_MRS_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, cond=1, R=0
    let encoding: u32 = 0x11000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_mrs_a1_as_special_cond_2_condition_cs_hs_0_21000000() {
    // Encoding: 0x21000000
    // Test aarch32_MRS_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, R=0
    let encoding: u32 = 0x21000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_mrs_a1_as_special_cond_3_condition_cc_lo_0_31000000() {
    // Encoding: 0x31000000
    // Test aarch32_MRS_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=3
    let encoding: u32 = 0x31000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_mrs_a1_as_special_cond_4_condition_mi_0_41000000() {
    // Encoding: 0x41000000
    // Test aarch32_MRS_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, R=0
    let encoding: u32 = 0x41000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_mrs_a1_as_special_cond_5_condition_pl_0_51000000() {
    // Encoding: 0x51000000
    // Test aarch32_MRS_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, R=0, Rd=0
    let encoding: u32 = 0x51000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_mrs_a1_as_special_cond_6_condition_vs_0_61000000() {
    // Encoding: 0x61000000
    // Test aarch32_MRS_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, R=0, Rd=0
    let encoding: u32 = 0x61000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_mrs_a1_as_special_cond_7_condition_vc_0_71000000() {
    // Encoding: 0x71000000
    // Test aarch32_MRS_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=7
    let encoding: u32 = 0x71000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_mrs_a1_as_special_cond_8_condition_hi_0_81000000() {
    // Encoding: 0x81000000
    // Test aarch32_MRS_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: R=0, cond=8, Rd=0
    let encoding: u32 = 0x81000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_mrs_a1_as_special_cond_9_condition_ls_0_91000000() {
    // Encoding: 0x91000000
    // Test aarch32_MRS_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=9
    let encoding: u32 = 0x91000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_mrs_a1_as_special_cond_10_condition_ge_0_a1000000() {
    // Encoding: 0xA1000000
    // Test aarch32_MRS_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, R=0, Rd=0
    let encoding: u32 = 0xA1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_mrs_a1_as_special_cond_11_condition_lt_0_b1000000() {
    // Encoding: 0xB1000000
    // Test aarch32_MRS_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, cond=11, R=0
    let encoding: u32 = 0xB1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_mrs_a1_as_special_cond_12_condition_gt_0_c1000000() {
    // Encoding: 0xC1000000
    // Test aarch32_MRS_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, R=0, Rd=0
    let encoding: u32 = 0xC1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_mrs_a1_as_special_cond_13_condition_le_0_d1000000() {
    // Encoding: 0xD1000000
    // Test aarch32_MRS_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=13
    let encoding: u32 = 0xD1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_mrs_a1_as_special_cond_14_condition_al_0_e1000000() {
    // Encoding: 0xE1000000
    // Test aarch32_MRS_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, R=0
    let encoding: u32 = 0xE1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_mrs_a1_as_special_cond_15_condition_nv_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_MRS_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=15
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_a1_as_invalid_0_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, R=0, Rd=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_a1_as_invalid_1_0_01000000() {
    // Encoding: 0x01000000
    // Test aarch32_MRS_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, cond=0, R=0
    let encoding: u32 = 0x01000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mrs_t1_as_field_r_0_min_8000_f3e08000() {
    // Thumb encoding (32): 0xF3E08000
    // Test aarch32_MRS_T1_AS field R = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_mrs_t1_as_field_r_1_max_8000_f3f08000() {
    // Thumb encoding (32): 0xF3F08000
    // Test aarch32_MRS_T1_AS field R = 1 (Max)
    // ISET: T32
    // Fields: R=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3F08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mrs_t1_as_field_rd_0_min_8000_f3e08000() {
    // Thumb encoding (32): 0xF3E08000
    // Test aarch32_MRS_T1_AS field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mrs_t1_as_field_rd_1_poweroftwo_8000_f3e08100() {
    // Thumb encoding (32): 0xF3E08100
    // Test aarch32_MRS_T1_AS field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: R=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=0 (minimum value)
#[test]
fn test_aarch32_mrs_t1_as_combo_0_8000_f3e08000() {
    // Thumb encoding (32): 0xF3E08000
    // Test aarch32_MRS_T1_AS field combination: R=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_t1_as_invalid_0_8000_f3e08000() {
    // Thumb encoding (32): 0xF3E08000
    // Test aarch32_MRS_T1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: R=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_t1_as_invalid_1_8000_f3e08000() {
    // Thumb encoding (32): 0xF3E08000
    // Test aarch32_MRS_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: R=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3E08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_a1_as_exception_0_01000000() {
    // Test aarch32_MRS_A1_AS exception: Unpredictable
    // Encoding: 0x01000000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_MRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mrs_t1_as_exception_0_f3e08000() {
    // Test aarch32_MRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SEVL_A Tests
// ============================================================================

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_0_min_5_03200005() {
    // Encoding: 0x03200005
    // Test aarch32_SEVL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_1_poweroftwo_5_13200005() {
    // Encoding: 0x13200005
    // Test aarch32_SEVL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_2_poweroftwo_5_23200005() {
    // Encoding: 0x23200005
    // Test aarch32_SEVL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_3_poweroftwo_5_33200005() {
    // Encoding: 0x33200005
    // Test aarch32_SEVL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_4_poweroftwo_5_43200005() {
    // Encoding: 0x43200005
    // Test aarch32_SEVL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_5_poweroftwo_5_53200005() {
    // Encoding: 0x53200005
    // Test aarch32_SEVL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_6_poweroftwo_5_63200005() {
    // Encoding: 0x63200005
    // Test aarch32_SEVL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_7_poweroftwo_5_73200005() {
    // Encoding: 0x73200005
    // Test aarch32_SEVL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_8_poweroftwo_5_83200005() {
    // Encoding: 0x83200005
    // Test aarch32_SEVL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_9_poweroftwo_5_93200005() {
    // Encoding: 0x93200005
    // Test aarch32_SEVL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_10_poweroftwo_5_a3200005() {
    // Encoding: 0xA3200005
    // Test aarch32_SEVL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_11_poweroftwo_5_b3200005() {
    // Encoding: 0xB3200005
    // Test aarch32_SEVL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_12_poweroftwo_5_c3200005() {
    // Encoding: 0xC3200005
    // Test aarch32_SEVL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_13_poweroftwo_5_d3200005() {
    // Encoding: 0xD3200005
    // Test aarch32_SEVL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_14_poweroftwo_5_e3200005() {
    // Encoding: 0xE3200005
    // Test aarch32_SEVL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sevl_a1_a_field_cond_15_max_5_f3200005() {
    // Encoding: 0xF3200005
    // Test aarch32_SEVL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sevl_a1_a_combo_0_5_03200005() {
    // Encoding: 0x03200005
    // Test aarch32_SEVL_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sevl_a1_a_special_cond_0_condition_eq_5_03200005() {
    // Encoding: 0x03200005
    // Test aarch32_SEVL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sevl_a1_a_special_cond_1_condition_ne_5_13200005() {
    // Encoding: 0x13200005
    // Test aarch32_SEVL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sevl_a1_a_special_cond_2_condition_cs_hs_5_23200005() {
    // Encoding: 0x23200005
    // Test aarch32_SEVL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sevl_a1_a_special_cond_3_condition_cc_lo_5_33200005() {
    // Encoding: 0x33200005
    // Test aarch32_SEVL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sevl_a1_a_special_cond_4_condition_mi_5_43200005() {
    // Encoding: 0x43200005
    // Test aarch32_SEVL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sevl_a1_a_special_cond_5_condition_pl_5_53200005() {
    // Encoding: 0x53200005
    // Test aarch32_SEVL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sevl_a1_a_special_cond_6_condition_vs_5_63200005() {
    // Encoding: 0x63200005
    // Test aarch32_SEVL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sevl_a1_a_special_cond_7_condition_vc_5_73200005() {
    // Encoding: 0x73200005
    // Test aarch32_SEVL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sevl_a1_a_special_cond_8_condition_hi_5_83200005() {
    // Encoding: 0x83200005
    // Test aarch32_SEVL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sevl_a1_a_special_cond_9_condition_ls_5_93200005() {
    // Encoding: 0x93200005
    // Test aarch32_SEVL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sevl_a1_a_special_cond_10_condition_ge_5_a3200005() {
    // Encoding: 0xA3200005
    // Test aarch32_SEVL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sevl_a1_a_special_cond_11_condition_lt_5_b3200005() {
    // Encoding: 0xB3200005
    // Test aarch32_SEVL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sevl_a1_a_special_cond_12_condition_gt_5_c3200005() {
    // Encoding: 0xC3200005
    // Test aarch32_SEVL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sevl_a1_a_special_cond_13_condition_le_5_d3200005() {
    // Encoding: 0xD3200005
    // Test aarch32_SEVL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sevl_a1_a_special_cond_14_condition_al_5_e3200005() {
    // Encoding: 0xE3200005
    // Test aarch32_SEVL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sevl_a1_a_special_cond_15_condition_nv_5_f3200005() {
    // Encoding: 0xF3200005
    // Test aarch32_SEVL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200005;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_sevl_t1_a_basic_encoding_bf500000() {
    // Thumb encoding (32): 0xBF500000
    // Test aarch32_SEVL_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBF500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEVL_T2_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_sevl_t2_a_basic_encoding_f3a08005() {
    // Thumb encoding (32): 0xF3A08005
    // Test aarch32_SEVL_T2_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08005;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_sevl_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_32_0_bf520020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_64_0_bf520020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_32_1_bf520020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_64_1_bf520020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_32_2_bf520020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_64_2_bf520020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_32_3_bf520020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_64_3_bf520020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_32_4_bf520020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_64_4_bf520020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_32_5_bf520020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sevl_t1_a_lslv_oracle_64_5_bf520020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sevl_t1_a_t16_oracle_0_bf500000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sevl_t1_a_t16_oracle_1_bf500000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sevl_t1_a_t16_oracle_2_bf500000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SEVL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sevl_t1_a_t16_oracle_3_bf500000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_SMC_AS Tests
// ============================================================================

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smc_a1_as_field_cond_0_min_70_01600070() {
    // Encoding: 0x01600070
    // Test aarch32_SMC_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: imm4=0, cond=0
    let encoding: u32 = 0x01600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smc_a1_as_field_cond_1_poweroftwo_70_11600070() {
    // Encoding: 0x11600070
    // Test aarch32_SMC_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=1
    let encoding: u32 = 0x11600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smc_a1_as_field_cond_2_poweroftwo_70_21600070() {
    // Encoding: 0x21600070
    // Test aarch32_SMC_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm4=0
    let encoding: u32 = 0x21600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smc_a1_as_field_cond_3_poweroftwo_70_31600070() {
    // Encoding: 0x31600070
    // Test aarch32_SMC_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm4=0
    let encoding: u32 = 0x31600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smc_a1_as_field_cond_4_poweroftwo_70_41600070() {
    // Encoding: 0x41600070
    // Test aarch32_SMC_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, imm4=0
    let encoding: u32 = 0x41600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smc_a1_as_field_cond_5_poweroftwo_70_51600070() {
    // Encoding: 0x51600070
    // Test aarch32_SMC_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=5
    let encoding: u32 = 0x51600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smc_a1_as_field_cond_6_poweroftwo_70_61600070() {
    // Encoding: 0x61600070
    // Test aarch32_SMC_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, imm4=0
    let encoding: u32 = 0x61600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smc_a1_as_field_cond_7_poweroftwo_70_71600070() {
    // Encoding: 0x71600070
    // Test aarch32_SMC_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, imm4=0
    let encoding: u32 = 0x71600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smc_a1_as_field_cond_8_poweroftwo_70_81600070() {
    // Encoding: 0x81600070
    // Test aarch32_SMC_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm4=0
    let encoding: u32 = 0x81600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smc_a1_as_field_cond_9_poweroftwo_70_91600070() {
    // Encoding: 0x91600070
    // Test aarch32_SMC_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, imm4=0
    let encoding: u32 = 0x91600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smc_a1_as_field_cond_10_poweroftwo_70_a1600070() {
    // Encoding: 0xA1600070
    // Test aarch32_SMC_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=10
    let encoding: u32 = 0xA1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smc_a1_as_field_cond_11_poweroftwo_70_b1600070() {
    // Encoding: 0xB1600070
    // Test aarch32_SMC_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm4=0
    let encoding: u32 = 0xB1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smc_a1_as_field_cond_12_poweroftwo_70_c1600070() {
    // Encoding: 0xC1600070
    // Test aarch32_SMC_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm4=0
    let encoding: u32 = 0xC1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smc_a1_as_field_cond_13_poweroftwo_70_d1600070() {
    // Encoding: 0xD1600070
    // Test aarch32_SMC_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=13
    let encoding: u32 = 0xD1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smc_a1_as_field_cond_14_poweroftwo_70_e1600070() {
    // Encoding: 0xE1600070
    // Test aarch32_SMC_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, imm4=0
    let encoding: u32 = 0xE1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smc_a1_as_field_cond_15_max_70_f1600070() {
    // Encoding: 0xF1600070
    // Test aarch32_SMC_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm4=0
    let encoding: u32 = 0xF1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_smc_a1_as_field_imm4_0_zero_70_01600070() {
    // Encoding: 0x01600070
    // Test aarch32_SMC_A1_AS field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm4=0
    let encoding: u32 = 0x01600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_smc_a1_as_field_imm4_1_poweroftwo_70_01600071() {
    // Encoding: 0x01600071
    // Test aarch32_SMC_A1_AS field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=1, cond=0
    let encoding: u32 = 0x01600071;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_smc_a1_as_field_imm4_3_poweroftwominusone_70_01600073() {
    // Encoding: 0x01600073
    // Test aarch32_SMC_A1_AS field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=3
    let encoding: u32 = 0x01600073;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_smc_a1_as_field_imm4_4_poweroftwo_70_01600074() {
    // Encoding: 0x01600074
    // Test aarch32_SMC_A1_AS field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=4, cond=0
    let encoding: u32 = 0x01600074;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_smc_a1_as_field_imm4_7_poweroftwominusone_70_01600077() {
    // Encoding: 0x01600077
    // Test aarch32_SMC_A1_AS field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=7
    let encoding: u32 = 0x01600077;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_smc_a1_as_field_imm4_8_poweroftwo_70_01600078() {
    // Encoding: 0x01600078
    // Test aarch32_SMC_A1_AS field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=8, cond=0
    let encoding: u32 = 0x01600078;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_smc_a1_as_field_imm4_15_max_70_0160007f() {
    // Encoding: 0x0160007F
    // Test aarch32_SMC_A1_AS field imm4 = 15 (Max)
    // ISET: A32
    // Fields: cond=0, imm4=15
    let encoding: u32 = 0x0160007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smc_a1_as_combo_0_70_01600070() {
    // Encoding: 0x01600070
    // Test aarch32_SMC_A1_AS field combination: cond=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, cond=0
    let encoding: u32 = 0x01600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smc_a1_as_special_cond_0_condition_eq_112_01600070() {
    // Encoding: 0x01600070
    // Test aarch32_SMC_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm4=0
    let encoding: u32 = 0x01600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smc_a1_as_special_cond_1_condition_ne_112_11600070() {
    // Encoding: 0x11600070
    // Test aarch32_SMC_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4=0, cond=1
    let encoding: u32 = 0x11600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smc_a1_as_special_cond_2_condition_cs_hs_112_21600070() {
    // Encoding: 0x21600070
    // Test aarch32_SMC_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm4=0, cond=2
    let encoding: u32 = 0x21600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smc_a1_as_special_cond_3_condition_cc_lo_112_31600070() {
    // Encoding: 0x31600070
    // Test aarch32_SMC_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm4=0
    let encoding: u32 = 0x31600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smc_a1_as_special_cond_4_condition_mi_112_41600070() {
    // Encoding: 0x41600070
    // Test aarch32_SMC_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4=0, cond=4
    let encoding: u32 = 0x41600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smc_a1_as_special_cond_5_condition_pl_112_51600070() {
    // Encoding: 0x51600070
    // Test aarch32_SMC_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm4=0
    let encoding: u32 = 0x51600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smc_a1_as_special_cond_6_condition_vs_112_61600070() {
    // Encoding: 0x61600070
    // Test aarch32_SMC_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm4=0
    let encoding: u32 = 0x61600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smc_a1_as_special_cond_7_condition_vc_112_71600070() {
    // Encoding: 0x71600070
    // Test aarch32_SMC_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm4=0, cond=7
    let encoding: u32 = 0x71600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smc_a1_as_special_cond_8_condition_hi_112_81600070() {
    // Encoding: 0x81600070
    // Test aarch32_SMC_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm4=0
    let encoding: u32 = 0x81600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smc_a1_as_special_cond_9_condition_ls_112_91600070() {
    // Encoding: 0x91600070
    // Test aarch32_SMC_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, imm4=0
    let encoding: u32 = 0x91600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smc_a1_as_special_cond_10_condition_ge_112_a1600070() {
    // Encoding: 0xA1600070
    // Test aarch32_SMC_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, imm4=0
    let encoding: u32 = 0xA1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smc_a1_as_special_cond_11_condition_lt_112_b1600070() {
    // Encoding: 0xB1600070
    // Test aarch32_SMC_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm4=0, cond=11
    let encoding: u32 = 0xB1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smc_a1_as_special_cond_12_condition_gt_112_c1600070() {
    // Encoding: 0xC1600070
    // Test aarch32_SMC_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, imm4=0
    let encoding: u32 = 0xC1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smc_a1_as_special_cond_13_condition_le_112_d1600070() {
    // Encoding: 0xD1600070
    // Test aarch32_SMC_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm4=0
    let encoding: u32 = 0xD1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smc_a1_as_special_cond_14_condition_al_112_e1600070() {
    // Encoding: 0xE1600070
    // Test aarch32_SMC_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, imm4=0
    let encoding: u32 = 0xE1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smc_a1_as_special_cond_15_condition_nv_112_f1600070() {
    // Encoding: 0xF1600070
    // Test aarch32_SMC_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4=0, cond=15
    let encoding: u32 = 0xF1600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_smc_t1_as_field_imm4_0_zero_8000_f7f08000() {
    // Thumb encoding (32): 0xF7F08000
    // Test aarch32_SMC_T1_AS field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_smc_t1_as_field_imm4_1_poweroftwo_8000_f7f18000() {
    // Thumb encoding (32): 0xF7F18000
    // Test aarch32_SMC_T1_AS field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_smc_t1_as_field_imm4_3_poweroftwominusone_8000_f7f38000() {
    // Thumb encoding (32): 0xF7F38000
    // Test aarch32_SMC_T1_AS field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F38000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_smc_t1_as_field_imm4_4_poweroftwo_8000_f7f48000() {
    // Thumb encoding (32): 0xF7F48000
    // Test aarch32_SMC_T1_AS field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F48000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_smc_t1_as_field_imm4_7_poweroftwominusone_8000_f7f78000() {
    // Thumb encoding (32): 0xF7F78000
    // Test aarch32_SMC_T1_AS field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F78000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_smc_t1_as_field_imm4_8_poweroftwo_8000_f7f88000() {
    // Thumb encoding (32): 0xF7F88000
    // Test aarch32_SMC_T1_AS field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F88000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_smc_t1_as_field_imm4_15_max_8000_f7ff8000() {
    // Thumb encoding (32): 0xF7FF8000
    // Test aarch32_SMC_T1_AS field imm4 = 15 (Max)
    // ISET: T32
    // Fields: imm4=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7FF8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_smc_t1_as_combo_0_8000_f7f08000() {
    // Thumb encoding (32): 0xF7F08000
    // Test aarch32_SMC_T1_AS field combination: imm4=0
    // ISET: T32
    // Fields: imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smc_t1_as_invalid_0_8000_f7f08000() {
    // Thumb encoding (32): 0xF7F08000
    // Test aarch32_SMC_T1_AS invalid encoding: Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smc_t1_as_invalid_1_8000_f7f08000() {
    // Thumb encoding (32): 0xF7F08000
    // Test aarch32_SMC_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_smc_a1_as_exception_0_01600070() {
    // Test aarch32_SMC_A1_AS exception: Undefined
    // Encoding: 0x01600070
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01600070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SMC_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_smc_a1_as_exception_1_01600070() {
    // Test aarch32_SMC_A1_AS exception: Undefined
    // Encoding: 0x01600070
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01600070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_smc_t1_as_exception_0_f7f08000() {
    // Test aarch32_SMC_T1_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF7F08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SMC_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_smc_t1_as_exception_1_f7f08000() {
    // Test aarch32_SMC_T1_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF7F08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_PLD_r_A Tests
// ============================================================================

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_r_a1_a_field_u_0_min_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: type1=0, imm5=0, U=0, Rm=0, R=0, Rn=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_r_a1_a_field_u_1_max_0_f7900000() {
    // Encoding: 0xF7900000
    // Test aarch32_PLD_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, type1=0, R=0, Rm=0, imm5=0, Rn=0
    let encoding: u32 = 0xF7900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_r_a1_a_field_r_0_min_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field R = 0 (Min)
    // ISET: A32
    // Fields: R=0, Rn=0, type1=0, Rm=0, imm5=0, U=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_r_a1_a_field_r_1_max_0_f7500000() {
    // Encoding: 0xF7500000
    // Test aarch32_PLD_r_A1_A field R = 1 (Max)
    // ISET: A32
    // Fields: type1=0, Rm=0, U=0, R=1, Rn=0, imm5=0
    let encoding: u32 = 0xF7500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_r_a1_a_field_rn_0_min_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: type1=0, R=0, Rn=0, Rm=0, U=0, imm5=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_r_a1_a_field_rn_1_poweroftwo_0_f7110000() {
    // Encoding: 0xF7110000
    // Test aarch32_PLD_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, imm5=0, R=0, Rm=0, Rn=1, U=0
    let encoding: u32 = 0xF7110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_0_zero_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: U=0, imm5=0, Rm=0, type1=0, R=0, Rn=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_1_poweroftwo_0_f7100080() {
    // Encoding: 0xF7100080
    // Test aarch32_PLD_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=1, U=0, type1=0, R=0, Rm=0, Rn=0
    let encoding: u32 = 0xF7100080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_3_poweroftwominusone_0_f7100180() {
    // Encoding: 0xF7100180
    // Test aarch32_PLD_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=3, U=0, R=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0xF7100180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_4_poweroftwo_0_f7100200() {
    // Encoding: 0xF7100200
    // Test aarch32_PLD_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, type1=0, R=0, imm5=4, Rm=0, Rn=0
    let encoding: u32 = 0xF7100200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_7_poweroftwominusone_0_f7100380() {
    // Encoding: 0xF7100380
    // Test aarch32_PLD_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, U=0, imm5=7, type1=0, Rm=0, R=0
    let encoding: u32 = 0xF7100380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_8_poweroftwo_0_f7100400() {
    // Encoding: 0xF7100400
    // Test aarch32_PLD_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, type1=0, Rm=0, Rn=0, R=0, imm5=8
    let encoding: u32 = 0xF7100400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_15_poweroftwominusone_0_f7100780() {
    // Encoding: 0xF7100780
    // Test aarch32_PLD_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, U=0, imm5=15, R=0
    let encoding: u32 = 0xF7100780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_16_poweroftwo_0_f7100800() {
    // Encoding: 0xF7100800
    // Test aarch32_PLD_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, Rm=0, Rn=0, type1=0, U=0, R=0
    let encoding: u32 = 0xF7100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_pld_r_a1_a_field_imm5_31_max_0_f7100f80() {
    // Encoding: 0xF7100F80
    // Test aarch32_PLD_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, U=0, imm5=31, R=0
    let encoding: u32 = 0xF7100F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_r_a1_a_field_type1_0_min_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: type1=0, U=0, imm5=0, R=0, Rn=0, Rm=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_pld_r_a1_a_field_type1_1_poweroftwo_0_f7100020() {
    // Encoding: 0xF7100020
    // Test aarch32_PLD_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, R=0, imm5=0, Rn=0, U=0, type1=1
    let encoding: u32 = 0xF7100020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_pld_r_a1_a_field_type1_3_max_0_f7100060() {
    // Encoding: 0xF7100060
    // Test aarch32_PLD_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: imm5=0, U=0, type1=3, Rn=0, Rm=0, R=0
    let encoding: u32 = 0xF7100060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_r_a1_a_field_rm_0_min_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm5=0, U=0, type1=0, R=0, Rm=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_r_a1_a_field_rm_1_poweroftwo_0_f7100001() {
    // Encoding: 0xF7100001
    // Test aarch32_PLD_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, type1=0, Rm=1, U=0, R=0
    let encoding: u32 = 0xF7100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pld_r_a1_a_combo_0_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A field combination: U=0, R=0, Rn=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, R=0, Rn=0, imm5=0, Rm=0, type1=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "is_pldw" }) } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"is_pldw\" }) } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pld_r_a1_a_invalid_0_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "is_pldw" }) } } } }
    // ISET: A32
    // Fields: R=0, Rn=0, Rm=0, U=0, imm5=0, type1=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_PLD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pld_r_a1_a_invalid_1_0_f7100000() {
    // Encoding: 0xF7100000
    // Test aarch32_PLD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, imm5=0, type1=0, R=0, U=0, Rn=0
    let encoding: u32 = 0xF7100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_r_t1_a_field_w_0_min_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_r_t1_a_field_w_1_max_f000_f830f000() {
    // Thumb encoding (32): 0xF830F000
    // Test aarch32_PLD_r_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rm=0, W=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF830F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_r_t1_a_field_rn_0_min_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_r_t1_a_field_rn_1_poweroftwo_f000_f811f000() {
    // Thumb encoding (32): 0xF811F000
    // Test aarch32_PLD_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rm=0, Rn=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF811F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_r_t1_a_field_imm2_0_zero_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_r_t1_a_field_imm2_1_poweroftwo_f000_f810f010() {
    // Thumb encoding (32): 0xF810F010
    // Test aarch32_PLD_r_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=1, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_pld_r_t1_a_field_imm2_3_max_f000_f810f030() {
    // Thumb encoding (32): 0xF810F030
    // Test aarch32_PLD_r_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, imm2=3, Rm=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_r_t1_a_field_rm_0_min_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: W=0, Rn=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_r_t1_a_field_rm_1_poweroftwo_f000_f810f001() {
    // Thumb encoding (32): 0xF810F001
    // Test aarch32_PLD_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rm=1, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_pld_r_t1_a_combo_0_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A field combination: W=0, Rn=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, W=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pld_r_t1_a_invalid_0_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: W=0, Rn=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pld_r_t1_a_invalid_1_f000_f810f000() {
    // Thumb encoding (32): 0xF810F000
    // Test aarch32_PLD_r_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, W=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_pld_r_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_pld_r_t1_a_t32_oracle_0_f811f002() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF811F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_pld_r_t1_a_t32_oracle_1_f811f002() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF811F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_pld_r_t1_a_t32_oracle_2_f811f002() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF811F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_pld_r_t1_a_t32_oracle_3_f811f002() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0xF811F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_ISB_A Tests
// ============================================================================

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_isb_a1_a_field_option_0_min_60_f5700060() {
    // Encoding: 0xF5700060
    // Test aarch32_ISB_A1_A field option = 0 (Min)
    // ISET: A32
    // Fields: option=0
    let encoding: u32 = 0xF5700060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_isb_a1_a_field_option_1_poweroftwo_60_f5700061() {
    // Encoding: 0xF5700061
    // Test aarch32_ISB_A1_A field option = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: option=1
    let encoding: u32 = 0xF5700061;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_isb_a1_a_field_option_2_poweroftwo_60_f5700062() {
    // Encoding: 0xF5700062
    // Test aarch32_ISB_A1_A field option = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: option=2
    let encoding: u32 = 0xF5700062;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_isb_a1_a_field_option_3_poweroftwo_60_f5700063() {
    // Encoding: 0xF5700063
    // Test aarch32_ISB_A1_A field option = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: option=3
    let encoding: u32 = 0xF5700063;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_isb_a1_a_field_option_4_poweroftwo_60_f5700064() {
    // Encoding: 0xF5700064
    // Test aarch32_ISB_A1_A field option = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: option=4
    let encoding: u32 = 0xF5700064;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_isb_a1_a_field_option_5_poweroftwo_60_f5700065() {
    // Encoding: 0xF5700065
    // Test aarch32_ISB_A1_A field option = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: option=5
    let encoding: u32 = 0xF5700065;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_isb_a1_a_field_option_6_poweroftwo_60_f5700066() {
    // Encoding: 0xF5700066
    // Test aarch32_ISB_A1_A field option = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: option=6
    let encoding: u32 = 0xF5700066;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_isb_a1_a_field_option_7_poweroftwo_60_f5700067() {
    // Encoding: 0xF5700067
    // Test aarch32_ISB_A1_A field option = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: option=7
    let encoding: u32 = 0xF5700067;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_isb_a1_a_field_option_8_poweroftwo_60_f5700068() {
    // Encoding: 0xF5700068
    // Test aarch32_ISB_A1_A field option = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: option=8
    let encoding: u32 = 0xF5700068;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_isb_a1_a_field_option_9_poweroftwo_60_f5700069() {
    // Encoding: 0xF5700069
    // Test aarch32_ISB_A1_A field option = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: option=9
    let encoding: u32 = 0xF5700069;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_isb_a1_a_field_option_10_poweroftwo_60_f570006a() {
    // Encoding: 0xF570006A
    // Test aarch32_ISB_A1_A field option = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: option=10
    let encoding: u32 = 0xF570006A;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_isb_a1_a_field_option_11_poweroftwo_60_f570006b() {
    // Encoding: 0xF570006B
    // Test aarch32_ISB_A1_A field option = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: option=11
    let encoding: u32 = 0xF570006B;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_isb_a1_a_field_option_12_poweroftwo_60_f570006c() {
    // Encoding: 0xF570006C
    // Test aarch32_ISB_A1_A field option = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: option=12
    let encoding: u32 = 0xF570006C;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_isb_a1_a_field_option_13_poweroftwo_60_f570006d() {
    // Encoding: 0xF570006D
    // Test aarch32_ISB_A1_A field option = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: option=13
    let encoding: u32 = 0xF570006D;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_isb_a1_a_field_option_14_poweroftwo_60_f570006e() {
    // Encoding: 0xF570006E
    // Test aarch32_ISB_A1_A field option = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: option=14
    let encoding: u32 = 0xF570006E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_isb_a1_a_field_option_15_max_60_f570006f() {
    // Encoding: 0xF570006F
    // Test aarch32_ISB_A1_A field option = 15 (Max)
    // ISET: A32
    // Fields: option=15
    let encoding: u32 = 0xF570006F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_isb_a1_a_combo_0_60_f5700060() {
    // Encoding: 0xF5700060
    // Test aarch32_ISB_A1_A field combination: option=0
    // ISET: A32
    // Fields: option=0
    let encoding: u32 = 0xF5700060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_isb_t1_a_field_option_0_min_8060_f3b08060() {
    // Thumb encoding (32): 0xF3B08060
    // Test aarch32_ISB_T1_A field option = 0 (Min)
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_isb_t1_a_field_option_1_poweroftwo_8060_f3b08061() {
    // Thumb encoding (32): 0xF3B08061
    // Test aarch32_ISB_T1_A field option = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: option=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08061;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_isb_t1_a_field_option_2_poweroftwo_8060_f3b08062() {
    // Thumb encoding (32): 0xF3B08062
    // Test aarch32_ISB_T1_A field option = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: option=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08062;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_isb_t1_a_field_option_3_poweroftwo_8060_f3b08063() {
    // Thumb encoding (32): 0xF3B08063
    // Test aarch32_ISB_T1_A field option = 3 (PowerOfTwo)
    // ISET: T32
    // Fields: option=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08063;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_isb_t1_a_field_option_4_poweroftwo_8060_f3b08064() {
    // Thumb encoding (32): 0xF3B08064
    // Test aarch32_ISB_T1_A field option = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: option=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08064;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_isb_t1_a_field_option_5_poweroftwo_8060_f3b08065() {
    // Thumb encoding (32): 0xF3B08065
    // Test aarch32_ISB_T1_A field option = 5 (PowerOfTwo)
    // ISET: T32
    // Fields: option=5
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08065;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_isb_t1_a_field_option_6_poweroftwo_8060_f3b08066() {
    // Thumb encoding (32): 0xF3B08066
    // Test aarch32_ISB_T1_A field option = 6 (PowerOfTwo)
    // ISET: T32
    // Fields: option=6
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08066;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_isb_t1_a_field_option_7_poweroftwo_8060_f3b08067() {
    // Thumb encoding (32): 0xF3B08067
    // Test aarch32_ISB_T1_A field option = 7 (PowerOfTwo)
    // ISET: T32
    // Fields: option=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08067;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_isb_t1_a_field_option_8_poweroftwo_8060_f3b08068() {
    // Thumb encoding (32): 0xF3B08068
    // Test aarch32_ISB_T1_A field option = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: option=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08068;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_isb_t1_a_field_option_9_poweroftwo_8060_f3b08069() {
    // Thumb encoding (32): 0xF3B08069
    // Test aarch32_ISB_T1_A field option = 9 (PowerOfTwo)
    // ISET: T32
    // Fields: option=9
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08069;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_isb_t1_a_field_option_10_poweroftwo_8060_f3b0806a() {
    // Thumb encoding (32): 0xF3B0806A
    // Test aarch32_ISB_T1_A field option = 10 (PowerOfTwo)
    // ISET: T32
    // Fields: option=10
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0806A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_isb_t1_a_field_option_11_poweroftwo_8060_f3b0806b() {
    // Thumb encoding (32): 0xF3B0806B
    // Test aarch32_ISB_T1_A field option = 11 (PowerOfTwo)
    // ISET: T32
    // Fields: option=11
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0806B;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_isb_t1_a_field_option_12_poweroftwo_8060_f3b0806c() {
    // Thumb encoding (32): 0xF3B0806C
    // Test aarch32_ISB_T1_A field option = 12 (PowerOfTwo)
    // ISET: T32
    // Fields: option=12
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0806C;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_isb_t1_a_field_option_13_poweroftwo_8060_f3b0806d() {
    // Thumb encoding (32): 0xF3B0806D
    // Test aarch32_ISB_T1_A field option = 13 (PowerOfTwo)
    // ISET: T32
    // Fields: option=13
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0806D;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_isb_t1_a_field_option_14_poweroftwo_8060_f3b0806e() {
    // Thumb encoding (32): 0xF3B0806E
    // Test aarch32_ISB_T1_A field option = 14 (PowerOfTwo)
    // ISET: T32
    // Fields: option=14
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0806E;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_isb_t1_a_field_option_15_max_8060_f3b0806f() {
    // Thumb encoding (32): 0xF3B0806F
    // Test aarch32_ISB_T1_A field option = 15 (Max)
    // ISET: T32
    // Fields: option=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0806F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ISB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_isb_t1_a_combo_0_8060_f3b08060() {
    // Thumb encoding (32): 0xF3B08060
    // Test aarch32_ISB_T1_A field combination: option=0
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

// ============================================================================
// aarch32_DBG_A Tests
// ============================================================================

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_0_min_f0_032000f0() {
    // Encoding: 0x032000F0
    // Test aarch32_DBG_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: option=0, cond=0
    let encoding: u32 = 0x032000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_1_poweroftwo_f0_132000f0() {
    // Encoding: 0x132000F0
    // Test aarch32_DBG_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, option=0
    let encoding: u32 = 0x132000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_2_poweroftwo_f0_232000f0() {
    // Encoding: 0x232000F0
    // Test aarch32_DBG_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, option=0
    let encoding: u32 = 0x232000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_3_poweroftwo_f0_332000f0() {
    // Encoding: 0x332000F0
    // Test aarch32_DBG_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, option=0
    let encoding: u32 = 0x332000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_4_poweroftwo_f0_432000f0() {
    // Encoding: 0x432000F0
    // Test aarch32_DBG_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, option=0
    let encoding: u32 = 0x432000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_5_poweroftwo_f0_532000f0() {
    // Encoding: 0x532000F0
    // Test aarch32_DBG_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, option=0
    let encoding: u32 = 0x532000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_6_poweroftwo_f0_632000f0() {
    // Encoding: 0x632000F0
    // Test aarch32_DBG_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, option=0
    let encoding: u32 = 0x632000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_7_poweroftwo_f0_732000f0() {
    // Encoding: 0x732000F0
    // Test aarch32_DBG_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: option=0, cond=7
    let encoding: u32 = 0x732000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_8_poweroftwo_f0_832000f0() {
    // Encoding: 0x832000F0
    // Test aarch32_DBG_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, option=0
    let encoding: u32 = 0x832000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_9_poweroftwo_f0_932000f0() {
    // Encoding: 0x932000F0
    // Test aarch32_DBG_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, option=0
    let encoding: u32 = 0x932000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_10_poweroftwo_f0_a32000f0() {
    // Encoding: 0xA32000F0
    // Test aarch32_DBG_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: option=0, cond=10
    let encoding: u32 = 0xA32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_11_poweroftwo_f0_b32000f0() {
    // Encoding: 0xB32000F0
    // Test aarch32_DBG_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: option=0, cond=11
    let encoding: u32 = 0xB32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_12_poweroftwo_f0_c32000f0() {
    // Encoding: 0xC32000F0
    // Test aarch32_DBG_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, option=0
    let encoding: u32 = 0xC32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_13_poweroftwo_f0_d32000f0() {
    // Encoding: 0xD32000F0
    // Test aarch32_DBG_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: option=0, cond=13
    let encoding: u32 = 0xD32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_14_poweroftwo_f0_e32000f0() {
    // Encoding: 0xE32000F0
    // Test aarch32_DBG_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, option=0
    let encoding: u32 = 0xE32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_dbg_a1_a_field_cond_15_max_f0_f32000f0() {
    // Encoding: 0xF32000F0
    // Test aarch32_DBG_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: option=0, cond=15
    let encoding: u32 = 0xF32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_dbg_a1_a_field_option_0_min_f0_032000f0() {
    // Encoding: 0x032000F0
    // Test aarch32_DBG_A1_A field option = 0 (Min)
    // ISET: A32
    // Fields: cond=0, option=0
    let encoding: u32 = 0x032000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_dbg_a1_a_field_option_1_poweroftwo_f0_032000f1() {
    // Encoding: 0x032000F1
    // Test aarch32_DBG_A1_A field option = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=1
    let encoding: u32 = 0x032000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_dbg_a1_a_field_option_2_poweroftwo_f0_032000f2() {
    // Encoding: 0x032000F2
    // Test aarch32_DBG_A1_A field option = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=2
    let encoding: u32 = 0x032000F2;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_dbg_a1_a_field_option_3_poweroftwo_f0_032000f3() {
    // Encoding: 0x032000F3
    // Test aarch32_DBG_A1_A field option = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=3
    let encoding: u32 = 0x032000F3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_dbg_a1_a_field_option_4_poweroftwo_f0_032000f4() {
    // Encoding: 0x032000F4
    // Test aarch32_DBG_A1_A field option = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=4
    let encoding: u32 = 0x032000F4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_dbg_a1_a_field_option_5_poweroftwo_f0_032000f5() {
    // Encoding: 0x032000F5
    // Test aarch32_DBG_A1_A field option = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: option=5, cond=0
    let encoding: u32 = 0x032000F5;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_dbg_a1_a_field_option_6_poweroftwo_f0_032000f6() {
    // Encoding: 0x032000F6
    // Test aarch32_DBG_A1_A field option = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=6
    let encoding: u32 = 0x032000F6;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_dbg_a1_a_field_option_7_poweroftwo_f0_032000f7() {
    // Encoding: 0x032000F7
    // Test aarch32_DBG_A1_A field option = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=7
    let encoding: u32 = 0x032000F7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_dbg_a1_a_field_option_8_poweroftwo_f0_032000f8() {
    // Encoding: 0x032000F8
    // Test aarch32_DBG_A1_A field option = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=8
    let encoding: u32 = 0x032000F8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_dbg_a1_a_field_option_9_poweroftwo_f0_032000f9() {
    // Encoding: 0x032000F9
    // Test aarch32_DBG_A1_A field option = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: option=9, cond=0
    let encoding: u32 = 0x032000F9;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_dbg_a1_a_field_option_10_poweroftwo_f0_032000fa() {
    // Encoding: 0x032000FA
    // Test aarch32_DBG_A1_A field option = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: option=10, cond=0
    let encoding: u32 = 0x032000FA;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_dbg_a1_a_field_option_11_poweroftwo_f0_032000fb() {
    // Encoding: 0x032000FB
    // Test aarch32_DBG_A1_A field option = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=11
    let encoding: u32 = 0x032000FB;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_dbg_a1_a_field_option_12_poweroftwo_f0_032000fc() {
    // Encoding: 0x032000FC
    // Test aarch32_DBG_A1_A field option = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, option=12
    let encoding: u32 = 0x032000FC;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_dbg_a1_a_field_option_13_poweroftwo_f0_032000fd() {
    // Encoding: 0x032000FD
    // Test aarch32_DBG_A1_A field option = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: option=13, cond=0
    let encoding: u32 = 0x032000FD;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_dbg_a1_a_field_option_14_poweroftwo_f0_032000fe() {
    // Encoding: 0x032000FE
    // Test aarch32_DBG_A1_A field option = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: option=14, cond=0
    let encoding: u32 = 0x032000FE;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_dbg_a1_a_field_option_15_max_f0_032000ff() {
    // Encoding: 0x032000FF
    // Test aarch32_DBG_A1_A field option = 15 (Max)
    // ISET: A32
    // Fields: option=15, cond=0
    let encoding: u32 = 0x032000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_dbg_a1_a_combo_0_f0_032000f0() {
    // Encoding: 0x032000F0
    // Test aarch32_DBG_A1_A field combination: cond=0, option=0
    // ISET: A32
    // Fields: cond=0, option=0
    let encoding: u32 = 0x032000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_dbg_a1_a_special_cond_0_condition_eq_240_032000f0() {
    // Encoding: 0x032000F0
    // Test aarch32_DBG_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, option=0
    let encoding: u32 = 0x032000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_dbg_a1_a_special_cond_1_condition_ne_240_132000f0() {
    // Encoding: 0x132000F0
    // Test aarch32_DBG_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, option=0
    let encoding: u32 = 0x132000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_dbg_a1_a_special_cond_2_condition_cs_hs_240_232000f0() {
    // Encoding: 0x232000F0
    // Test aarch32_DBG_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, option=0
    let encoding: u32 = 0x232000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_dbg_a1_a_special_cond_3_condition_cc_lo_240_332000f0() {
    // Encoding: 0x332000F0
    // Test aarch32_DBG_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, option=0
    let encoding: u32 = 0x332000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_dbg_a1_a_special_cond_4_condition_mi_240_432000f0() {
    // Encoding: 0x432000F0
    // Test aarch32_DBG_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, option=0
    let encoding: u32 = 0x432000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_dbg_a1_a_special_cond_5_condition_pl_240_532000f0() {
    // Encoding: 0x532000F0
    // Test aarch32_DBG_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, option=0
    let encoding: u32 = 0x532000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_dbg_a1_a_special_cond_6_condition_vs_240_632000f0() {
    // Encoding: 0x632000F0
    // Test aarch32_DBG_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: option=0, cond=6
    let encoding: u32 = 0x632000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_dbg_a1_a_special_cond_7_condition_vc_240_732000f0() {
    // Encoding: 0x732000F0
    // Test aarch32_DBG_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, option=0
    let encoding: u32 = 0x732000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_dbg_a1_a_special_cond_8_condition_hi_240_832000f0() {
    // Encoding: 0x832000F0
    // Test aarch32_DBG_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, option=0
    let encoding: u32 = 0x832000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_dbg_a1_a_special_cond_9_condition_ls_240_932000f0() {
    // Encoding: 0x932000F0
    // Test aarch32_DBG_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, option=0
    let encoding: u32 = 0x932000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_dbg_a1_a_special_cond_10_condition_ge_240_a32000f0() {
    // Encoding: 0xA32000F0
    // Test aarch32_DBG_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, option=0
    let encoding: u32 = 0xA32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_dbg_a1_a_special_cond_11_condition_lt_240_b32000f0() {
    // Encoding: 0xB32000F0
    // Test aarch32_DBG_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, option=0
    let encoding: u32 = 0xB32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_dbg_a1_a_special_cond_12_condition_gt_240_c32000f0() {
    // Encoding: 0xC32000F0
    // Test aarch32_DBG_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, option=0
    let encoding: u32 = 0xC32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_dbg_a1_a_special_cond_13_condition_le_240_d32000f0() {
    // Encoding: 0xD32000F0
    // Test aarch32_DBG_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, option=0
    let encoding: u32 = 0xD32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_dbg_a1_a_special_cond_14_condition_al_240_e32000f0() {
    // Encoding: 0xE32000F0
    // Test aarch32_DBG_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, option=0
    let encoding: u32 = 0xE32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_dbg_a1_a_special_cond_15_condition_nv_240_f32000f0() {
    // Encoding: 0xF32000F0
    // Test aarch32_DBG_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: option=0, cond=15
    let encoding: u32 = 0xF32000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_dbg_t1_a_field_option_0_min_80f0_f3a080f0() {
    // Thumb encoding (32): 0xF3A080F0
    // Test aarch32_DBG_T1_A field option = 0 (Min)
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_dbg_t1_a_field_option_1_poweroftwo_80f0_f3a080f1() {
    // Thumb encoding (32): 0xF3A080F1
    // Test aarch32_DBG_T1_A field option = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: option=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_dbg_t1_a_field_option_2_poweroftwo_80f0_f3a080f2() {
    // Thumb encoding (32): 0xF3A080F2
    // Test aarch32_DBG_T1_A field option = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: option=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F2;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_dbg_t1_a_field_option_3_poweroftwo_80f0_f3a080f3() {
    // Thumb encoding (32): 0xF3A080F3
    // Test aarch32_DBG_T1_A field option = 3 (PowerOfTwo)
    // ISET: T32
    // Fields: option=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F3;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_dbg_t1_a_field_option_4_poweroftwo_80f0_f3a080f4() {
    // Thumb encoding (32): 0xF3A080F4
    // Test aarch32_DBG_T1_A field option = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: option=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F4;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_dbg_t1_a_field_option_5_poweroftwo_80f0_f3a080f5() {
    // Thumb encoding (32): 0xF3A080F5
    // Test aarch32_DBG_T1_A field option = 5 (PowerOfTwo)
    // ISET: T32
    // Fields: option=5
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F5;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_dbg_t1_a_field_option_6_poweroftwo_80f0_f3a080f6() {
    // Thumb encoding (32): 0xF3A080F6
    // Test aarch32_DBG_T1_A field option = 6 (PowerOfTwo)
    // ISET: T32
    // Fields: option=6
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F6;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_dbg_t1_a_field_option_7_poweroftwo_80f0_f3a080f7() {
    // Thumb encoding (32): 0xF3A080F7
    // Test aarch32_DBG_T1_A field option = 7 (PowerOfTwo)
    // ISET: T32
    // Fields: option=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F7;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_dbg_t1_a_field_option_8_poweroftwo_80f0_f3a080f8() {
    // Thumb encoding (32): 0xF3A080F8
    // Test aarch32_DBG_T1_A field option = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: option=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F8;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_dbg_t1_a_field_option_9_poweroftwo_80f0_f3a080f9() {
    // Thumb encoding (32): 0xF3A080F9
    // Test aarch32_DBG_T1_A field option = 9 (PowerOfTwo)
    // ISET: T32
    // Fields: option=9
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F9;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_dbg_t1_a_field_option_10_poweroftwo_80f0_f3a080fa() {
    // Thumb encoding (32): 0xF3A080FA
    // Test aarch32_DBG_T1_A field option = 10 (PowerOfTwo)
    // ISET: T32
    // Fields: option=10
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080FA;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_dbg_t1_a_field_option_11_poweroftwo_80f0_f3a080fb() {
    // Thumb encoding (32): 0xF3A080FB
    // Test aarch32_DBG_T1_A field option = 11 (PowerOfTwo)
    // ISET: T32
    // Fields: option=11
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080FB;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_dbg_t1_a_field_option_12_poweroftwo_80f0_f3a080fc() {
    // Thumb encoding (32): 0xF3A080FC
    // Test aarch32_DBG_T1_A field option = 12 (PowerOfTwo)
    // ISET: T32
    // Fields: option=12
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080FC;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_dbg_t1_a_field_option_13_poweroftwo_80f0_f3a080fd() {
    // Thumb encoding (32): 0xF3A080FD
    // Test aarch32_DBG_T1_A field option = 13 (PowerOfTwo)
    // ISET: T32
    // Fields: option=13
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080FD;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_dbg_t1_a_field_option_14_poweroftwo_80f0_f3a080fe() {
    // Thumb encoding (32): 0xF3A080FE
    // Test aarch32_DBG_T1_A field option = 14 (PowerOfTwo)
    // ISET: T32
    // Fields: option=14
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080FE;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_dbg_t1_a_field_option_15_max_80f0_f3a080ff() {
    // Thumb encoding (32): 0xF3A080FF
    // Test aarch32_DBG_T1_A field option = 15 (Max)
    // ISET: T32
    // Fields: option=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_dbg_t1_a_combo_0_80f0_f3a080f0() {
    // Thumb encoding (32): 0xF3A080F0
    // Test aarch32_DBG_T1_A field combination: option=0
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A080F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_DBG_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_dbg_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

// ============================================================================
// aarch32_YIELD_A Tests
// ============================================================================

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_yield_a1_a_field_cond_0_min_1_03200001() {
    // Encoding: 0x03200001
    // Test aarch32_YIELD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_yield_a1_a_field_cond_1_poweroftwo_1_13200001() {
    // Encoding: 0x13200001
    // Test aarch32_YIELD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_yield_a1_a_field_cond_2_poweroftwo_1_23200001() {
    // Encoding: 0x23200001
    // Test aarch32_YIELD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_yield_a1_a_field_cond_3_poweroftwo_1_33200001() {
    // Encoding: 0x33200001
    // Test aarch32_YIELD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_yield_a1_a_field_cond_4_poweroftwo_1_43200001() {
    // Encoding: 0x43200001
    // Test aarch32_YIELD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_yield_a1_a_field_cond_5_poweroftwo_1_53200001() {
    // Encoding: 0x53200001
    // Test aarch32_YIELD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_yield_a1_a_field_cond_6_poweroftwo_1_63200001() {
    // Encoding: 0x63200001
    // Test aarch32_YIELD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_yield_a1_a_field_cond_7_poweroftwo_1_73200001() {
    // Encoding: 0x73200001
    // Test aarch32_YIELD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_yield_a1_a_field_cond_8_poweroftwo_1_83200001() {
    // Encoding: 0x83200001
    // Test aarch32_YIELD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_yield_a1_a_field_cond_9_poweroftwo_1_93200001() {
    // Encoding: 0x93200001
    // Test aarch32_YIELD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_yield_a1_a_field_cond_10_poweroftwo_1_a3200001() {
    // Encoding: 0xA3200001
    // Test aarch32_YIELD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_yield_a1_a_field_cond_11_poweroftwo_1_b3200001() {
    // Encoding: 0xB3200001
    // Test aarch32_YIELD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_yield_a1_a_field_cond_12_poweroftwo_1_c3200001() {
    // Encoding: 0xC3200001
    // Test aarch32_YIELD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_yield_a1_a_field_cond_13_poweroftwo_1_d3200001() {
    // Encoding: 0xD3200001
    // Test aarch32_YIELD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_yield_a1_a_field_cond_14_poweroftwo_1_e3200001() {
    // Encoding: 0xE3200001
    // Test aarch32_YIELD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_yield_a1_a_field_cond_15_max_1_f3200001() {
    // Encoding: 0xF3200001
    // Test aarch32_YIELD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_yield_a1_a_combo_0_1_03200001() {
    // Encoding: 0x03200001
    // Test aarch32_YIELD_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_yield_a1_a_special_cond_0_condition_eq_1_03200001() {
    // Encoding: 0x03200001
    // Test aarch32_YIELD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_yield_a1_a_special_cond_1_condition_ne_1_13200001() {
    // Encoding: 0x13200001
    // Test aarch32_YIELD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_yield_a1_a_special_cond_2_condition_cs_hs_1_23200001() {
    // Encoding: 0x23200001
    // Test aarch32_YIELD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_yield_a1_a_special_cond_3_condition_cc_lo_1_33200001() {
    // Encoding: 0x33200001
    // Test aarch32_YIELD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_yield_a1_a_special_cond_4_condition_mi_1_43200001() {
    // Encoding: 0x43200001
    // Test aarch32_YIELD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_yield_a1_a_special_cond_5_condition_pl_1_53200001() {
    // Encoding: 0x53200001
    // Test aarch32_YIELD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_yield_a1_a_special_cond_6_condition_vs_1_63200001() {
    // Encoding: 0x63200001
    // Test aarch32_YIELD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_yield_a1_a_special_cond_7_condition_vc_1_73200001() {
    // Encoding: 0x73200001
    // Test aarch32_YIELD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_yield_a1_a_special_cond_8_condition_hi_1_83200001() {
    // Encoding: 0x83200001
    // Test aarch32_YIELD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_yield_a1_a_special_cond_9_condition_ls_1_93200001() {
    // Encoding: 0x93200001
    // Test aarch32_YIELD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_yield_a1_a_special_cond_10_condition_ge_1_a3200001() {
    // Encoding: 0xA3200001
    // Test aarch32_YIELD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_yield_a1_a_special_cond_11_condition_lt_1_b3200001() {
    // Encoding: 0xB3200001
    // Test aarch32_YIELD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_yield_a1_a_special_cond_12_condition_gt_1_c3200001() {
    // Encoding: 0xC3200001
    // Test aarch32_YIELD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_yield_a1_a_special_cond_13_condition_le_1_d3200001() {
    // Encoding: 0xD3200001
    // Test aarch32_YIELD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_yield_a1_a_special_cond_14_condition_al_1_e3200001() {
    // Encoding: 0xE3200001
    // Test aarch32_YIELD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_yield_a1_a_special_cond_15_condition_nv_1_f3200001() {
    // Encoding: 0xF3200001
    // Test aarch32_YIELD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_yield_t1_a_basic_encoding_bf100000() {
    // Thumb encoding (32): 0xBF100000
    // Test aarch32_YIELD_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBF100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_YIELD_T2_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_yield_t2_a_basic_encoding_f3a08001() {
    // Thumb encoding (32): 0xF3A08001
    // Test aarch32_YIELD_T2_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_yield_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_32_0_bf120020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_64_0_bf120020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_32_1_bf120020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_64_1_bf120020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_32_2_bf120020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_64_2_bf120020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_32_3_bf120020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_64_3_bf120020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_32_4_bf120020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_64_4_bf120020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_32_5_bf120020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_yield_t1_a_lslv_oracle_64_5_bf120020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_yield_t1_a_t16_oracle_0_bf100000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_yield_t1_a_t16_oracle_1_bf100000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_yield_t1_a_t16_oracle_2_bf100000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_YIELD_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_yield_t1_a_t16_oracle_3_bf100000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_CPS_AS Tests
// ============================================================================

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field imod 18 +: 2`
/// Requirement: FieldBoundary { field: "imod", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_a1_as_field_imod_0_min_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field imod = 0 (Min)
    // ISET: A32
    // Fields: M=0, F=0, A=0, imod=0, I=0, mode=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field imod 18 +: 2`
/// Requirement: FieldBoundary { field: "imod", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_cps_a1_as_field_imod_1_poweroftwo_0_f1040000() {
    // Encoding: 0xF1040000
    // Test aarch32_CPS_A1_AS field imod = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: A=0, I=0, mode=0, imod=1, F=0, M=0
    let encoding: u32 = 0xF1040000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field imod 18 +: 2`
/// Requirement: FieldBoundary { field: "imod", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_cps_a1_as_field_imod_3_max_0_f10c0000() {
    // Encoding: 0xF10C0000
    // Test aarch32_CPS_A1_AS field imod = 3 (Max)
    // ISET: A32
    // Fields: mode=0, A=0, F=0, imod=3, I=0, M=0
    let encoding: u32 = 0xF10C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field M 17 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_a1_as_field_m_0_min_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field M = 0 (Min)
    // ISET: A32
    // Fields: I=0, F=0, mode=0, M=0, A=0, imod=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field M 17 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_a1_as_field_m_1_max_0_f1020000() {
    // Encoding: 0xF1020000
    // Test aarch32_CPS_A1_AS field M = 1 (Max)
    // ISET: A32
    // Fields: F=0, A=0, M=1, I=0, imod=0, mode=0
    let encoding: u32 = 0xF1020000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field A 8 +: 1`
/// Requirement: FieldBoundary { field: "A", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_a1_as_field_a_0_min_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field A = 0 (Min)
    // ISET: A32
    // Fields: I=0, imod=0, mode=0, M=0, A=0, F=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field A 8 +: 1`
/// Requirement: FieldBoundary { field: "A", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_a1_as_field_a_1_max_0_f1000100() {
    // Encoding: 0xF1000100
    // Test aarch32_CPS_A1_AS field A = 1 (Max)
    // ISET: A32
    // Fields: F=0, I=0, mode=0, imod=0, M=0, A=1
    let encoding: u32 = 0xF1000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field I 7 +: 1`
/// Requirement: FieldBoundary { field: "I", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_a1_as_field_i_0_min_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field I = 0 (Min)
    // ISET: A32
    // Fields: imod=0, M=0, I=0, mode=0, A=0, F=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field I 7 +: 1`
/// Requirement: FieldBoundary { field: "I", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_a1_as_field_i_1_max_0_f1000080() {
    // Encoding: 0xF1000080
    // Test aarch32_CPS_A1_AS field I = 1 (Max)
    // ISET: A32
    // Fields: F=0, mode=0, imod=0, M=0, A=0, I=1
    let encoding: u32 = 0xF1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field F 6 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_a1_as_field_f_0_min_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field F = 0 (Min)
    // ISET: A32
    // Fields: F=0, mode=0, I=0, A=0, imod=0, M=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field F 6 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_a1_as_field_f_1_max_0_f1000040() {
    // Encoding: 0xF1000040
    // Test aarch32_CPS_A1_AS field F = 1 (Max)
    // ISET: A32
    // Fields: mode=0, M=0, imod=0, I=0, F=1, A=0
    let encoding: u32 = 0xF1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_a1_as_field_mode_0_min_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field mode = 0 (Min)
    // ISET: A32
    // Fields: I=0, imod=0, A=0, mode=0, F=0, M=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_cps_a1_as_field_mode_1_poweroftwo_0_f1000001() {
    // Encoding: 0xF1000001
    // Test aarch32_CPS_A1_AS field mode = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: mode=1, A=0, M=0, imod=0, I=0, F=0
    let encoding: u32 = 0xF1000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_cps_a1_as_field_mode_15_poweroftwominusone_0_f100000f() {
    // Encoding: 0xF100000F
    // Test aarch32_CPS_A1_AS field mode = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: F=0, imod=0, mode=15, I=0, M=0, A=0
    let encoding: u32 = 0xF100000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_cps_a1_as_field_mode_31_max_0_f100001f() {
    // Encoding: 0xF100001F
    // Test aarch32_CPS_A1_AS field mode = 31 (Max)
    // ISET: A32
    // Fields: imod=0, A=0, I=0, F=0, mode=31, M=0
    let encoding: u32 = 0xF100001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imod=0 (minimum value)
#[test]
fn test_aarch32_cps_a1_as_combo_0_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS field combination: imod=0, M=0, A=0, I=0, F=0, mode=0
    // ISET: A32
    // Fields: A=0, M=0, I=0, F=0, mode=0, imod=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mode" }), rhs: Binary { op: And, lhs: LitBits([false, false, false, false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"mode\" }), rhs: Binary { op: And, lhs: LitBits([false, false, false, false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"M\" }) } }, rhs: LitBits([false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_a1_as_invalid_0_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS invalid encoding: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mode" }), rhs: Binary { op: And, lhs: LitBits([false, false, false, false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: A=0, I=0, F=0, imod=0, mode=0, M=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_a1_as_invalid_1_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: I=0, imod=0, F=0, M=0, mode=0, A=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `Binary { op: Or, lhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } }, rhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"A\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"I\" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: LitBits([false, false, false]) } }, rhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"A\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"I\" }) }, rhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: LitBits([false, false, false]) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_a1_as_invalid_2_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS invalid encoding: Binary { op: Or, lhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } }, rhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } } }
    // ISET: A32
    // Fields: F=0, mode=0, M=0, imod=0, A=0, I=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_a1_as_invalid_3_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: mode=0, A=0, M=0, F=0, imod=0, I=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([false]) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }) }, rhs: LitBits([false, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"M\" }) } }, rhs: LitBits([false]) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }) }, rhs: LitBits([false, true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_a1_as_invalid_4_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([false]) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }) }, rhs: LitBits([false, true]) }
    // ISET: A32
    // Fields: I=0, M=0, mode=0, F=0, imod=0, A=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_a1_as_invalid_5_0_f1000000() {
    // Encoding: 0xF1000000
    // Test aarch32_CPS_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: F=0, A=0, M=0, I=0, mode=0, imod=0
    let encoding: u32 = 0xF1000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field im 20 +: 1`
/// Requirement: FieldBoundary { field: "im", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t1_as_field_im_0_min_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS field im = 0 (Min)
    // ISET: T32
    // Fields: F=0, I=0, A=0, im=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field im 20 +: 1`
/// Requirement: FieldBoundary { field: "im", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t1_as_field_im_1_max_0_b6700000() {
    // Thumb encoding (32): 0xB6700000
    // Test aarch32_CPS_T1_AS field im = 1 (Max)
    // ISET: T32
    // Fields: I=0, A=0, im=1, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field A 18 +: 1`
/// Requirement: FieldBoundary { field: "A", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t1_as_field_a_0_min_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS field A = 0 (Min)
    // ISET: T32
    // Fields: im=0, F=0, I=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field A 18 +: 1`
/// Requirement: FieldBoundary { field: "A", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t1_as_field_a_1_max_0_b6640000() {
    // Thumb encoding (32): 0xB6640000
    // Test aarch32_CPS_T1_AS field A = 1 (Max)
    // ISET: T32
    // Fields: im=0, F=0, A=1, I=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6640000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field I 17 +: 1`
/// Requirement: FieldBoundary { field: "I", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t1_as_field_i_0_min_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS field I = 0 (Min)
    // ISET: T32
    // Fields: I=0, im=0, F=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field I 17 +: 1`
/// Requirement: FieldBoundary { field: "I", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t1_as_field_i_1_max_0_b6620000() {
    // Thumb encoding (32): 0xB6620000
    // Test aarch32_CPS_T1_AS field I = 1 (Max)
    // ISET: T32
    // Fields: I=1, im=0, F=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6620000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field F 16 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t1_as_field_f_0_min_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS field F = 0 (Min)
    // ISET: T32
    // Fields: F=0, I=0, im=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field F 16 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t1_as_field_f_1_max_0_b6610000() {
    // Thumb encoding (32): 0xB6610000
    // Test aarch32_CPS_T1_AS field F = 1 (Max)
    // ISET: T32
    // Fields: I=0, F=1, im=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// im=0 (minimum value)
#[test]
fn test_aarch32_cps_t1_as_combo_0_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS field combination: im=0, A=0, I=0, F=0
    // ISET: T32
    // Fields: F=0, I=0, A=0, im=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"A\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"I\" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: LitBits([false, false, false]) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t1_as_invalid_0_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS invalid encoding: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } }
    // ISET: T32
    // Fields: im=0, I=0, A=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t1_as_invalid_1_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: F=0, A=0, I=0, im=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t1_as_invalid_2_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: I=0, im=0, A=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t1_as_invalid_3_0_b6600000() {
    // Thumb encoding (32): 0xB6600000
    // Test aarch32_CPS_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: I=0, F=0, A=0, im=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field imod 9 +: 2`
/// Requirement: FieldBoundary { field: "imod", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t2_as_field_imod_0_min_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field imod = 0 (Min)
    // ISET: T32
    // Fields: imod=0, F=0, A=0, M=0, I=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field imod 9 +: 2`
/// Requirement: FieldBoundary { field: "imod", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_cps_t2_as_field_imod_1_poweroftwo_8000_f3a08200() {
    // Thumb encoding (32): 0xF3A08200
    // Test aarch32_CPS_T2_AS field imod = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, imod=1, A=0, F=0, I=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field imod 9 +: 2`
/// Requirement: FieldBoundary { field: "imod", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_cps_t2_as_field_imod_3_max_8000_f3a08600() {
    // Thumb encoding (32): 0xF3A08600
    // Test aarch32_CPS_T2_AS field imod = 3 (Max)
    // ISET: T32
    // Fields: imod=3, F=0, I=0, M=0, mode=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field M 8 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t2_as_field_m_0_min_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field M = 0 (Min)
    // ISET: T32
    // Fields: imod=0, M=0, A=0, I=0, F=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field M 8 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t2_as_field_m_1_max_8000_f3a08100() {
    // Thumb encoding (32): 0xF3A08100
    // Test aarch32_CPS_T2_AS field M = 1 (Max)
    // ISET: T32
    // Fields: mode=0, imod=0, M=1, A=0, F=0, I=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field A 7 +: 1`
/// Requirement: FieldBoundary { field: "A", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t2_as_field_a_0_min_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field A = 0 (Min)
    // ISET: T32
    // Fields: M=0, I=0, mode=0, F=0, imod=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field A 7 +: 1`
/// Requirement: FieldBoundary { field: "A", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t2_as_field_a_1_max_8000_f3a08080() {
    // Thumb encoding (32): 0xF3A08080
    // Test aarch32_CPS_T2_AS field A = 1 (Max)
    // ISET: T32
    // Fields: imod=0, A=1, I=0, mode=0, F=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field I 6 +: 1`
/// Requirement: FieldBoundary { field: "I", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t2_as_field_i_0_min_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field I = 0 (Min)
    // ISET: T32
    // Fields: imod=0, M=0, mode=0, F=0, I=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field I 6 +: 1`
/// Requirement: FieldBoundary { field: "I", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t2_as_field_i_1_max_8000_f3a08040() {
    // Thumb encoding (32): 0xF3A08040
    // Test aarch32_CPS_T2_AS field I = 1 (Max)
    // ISET: T32
    // Fields: M=0, I=1, imod=0, F=0, mode=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field F 5 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t2_as_field_f_0_min_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field F = 0 (Min)
    // ISET: T32
    // Fields: M=0, imod=0, I=0, A=0, F=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field F 5 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_cps_t2_as_field_f_1_max_8000_f3a08020() {
    // Thumb encoding (32): 0xF3A08020
    // Test aarch32_CPS_T2_AS field F = 1 (Max)
    // ISET: T32
    // Fields: F=1, mode=0, imod=0, I=0, M=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_cps_t2_as_field_mode_0_min_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field mode = 0 (Min)
    // ISET: T32
    // Fields: M=0, imod=0, I=0, F=0, A=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_cps_t2_as_field_mode_1_poweroftwo_8000_f3a08001() {
    // Thumb encoding (32): 0xF3A08001
    // Test aarch32_CPS_T2_AS field mode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imod=0, A=0, mode=1, F=0, I=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_cps_t2_as_field_mode_15_poweroftwominusone_8000_f3a0800f() {
    // Thumb encoding (32): 0xF3A0800F
    // Test aarch32_CPS_T2_AS field mode = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: F=0, A=0, imod=0, M=0, I=0, mode=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A0800F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_cps_t2_as_field_mode_31_max_8000_f3a0801f() {
    // Thumb encoding (32): 0xF3A0801F
    // Test aarch32_CPS_T2_AS field mode = 31 (Max)
    // ISET: T32
    // Fields: F=0, mode=31, M=0, I=0, imod=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A0801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imod=0 (minimum value)
#[test]
fn test_aarch32_cps_t2_as_combo_0_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS field combination: imod=0, M=0, A=0, I=0, F=0, mode=0
    // ISET: T32
    // Fields: mode=0, M=0, I=0, imod=0, A=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mode" }), rhs: Binary { op: And, lhs: LitBits([false, false, false, false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"mode\" }), rhs: Binary { op: And, lhs: LitBits([false, false, false, false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"M\" }) } }, rhs: LitBits([false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t2_as_invalid_0_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS invalid encoding: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mode" }), rhs: Binary { op: And, lhs: LitBits([false, false, false, false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: imod=0, M=0, I=0, mode=0, A=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t2_as_invalid_1_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: F=0, I=0, imod=0, A=0, mode=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `Binary { op: Or, lhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } }, rhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"A\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"I\" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: LitBits([false, false, false]) } }, rhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"A\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"I\" }) }, rhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: LitBits([false, false, false]) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t2_as_invalid_2_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS invalid encoding: Binary { op: Or, lhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } }, rhs: Binary { op: BitConcat, lhs: Binary { op: BitConcat, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), indices: [Single(LitInt(1))] }, rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "A" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "I" }) }, rhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: LitBits([false, false, false]) } } }
    // ISET: T32
    // Fields: I=0, F=0, mode=0, imod=0, M=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t2_as_invalid_3_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: mode=0, I=0, A=0, imod=0, M=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), rhs: Binary { op: Or, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"imod\" }), rhs: Binary { op: Or, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t2_as_invalid_4_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "imod" }), rhs: Binary { op: Or, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: imod=0, M=0, I=0, mode=0, F=0, A=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T2_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_cps_t2_as_invalid_5_8000_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_CPS_T2_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: F=0, A=0, imod=0, I=0, mode=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_32_0_b6620020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_64_0_b6620020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_32_1_b6620020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_64_1_b6620020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_32_2_b6620020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_64_2_b6620020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_32_3_b6620020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_64_3_b6620020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_32_4_b6620020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_64_4_b6620020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_32_5_b6620020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_cps_t1_as_lslv_oracle_64_5_b6620020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_cps_t1_as_t16_oracle_0_b6600000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_cps_t1_as_t16_oracle_1_b6600000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_cps_t1_as_t16_oracle_2_b6600000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_CPS_T1_AS
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_cps_t1_as_t16_oracle_3_b6600000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_HLT_A Tests
// ============================================================================

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_0_min_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_1_poweroftwo_70_11000070() {
    // Encoding: 0x11000070
    // Test aarch32_HLT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=1
    let encoding: u32 = 0x11000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_2_poweroftwo_70_21000070() {
    // Encoding: 0x21000070
    // Test aarch32_HLT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm4=0, imm12=0
    let encoding: u32 = 0x21000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_3_poweroftwo_70_31000070() {
    // Encoding: 0x31000070
    // Test aarch32_HLT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm12=0, imm4=0
    let encoding: u32 = 0x31000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_4_poweroftwo_70_41000070() {
    // Encoding: 0x41000070
    // Test aarch32_HLT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=4
    let encoding: u32 = 0x41000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_5_poweroftwo_70_51000070() {
    // Encoding: 0x51000070
    // Test aarch32_HLT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=5, imm4=0
    let encoding: u32 = 0x51000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_6_poweroftwo_70_61000070() {
    // Encoding: 0x61000070
    // Test aarch32_HLT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, imm12=0, imm4=0
    let encoding: u32 = 0x61000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_7_poweroftwo_70_71000070() {
    // Encoding: 0x71000070
    // Test aarch32_HLT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=7, imm12=0
    let encoding: u32 = 0x71000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_8_poweroftwo_70_81000070() {
    // Encoding: 0x81000070
    // Test aarch32_HLT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=8, imm12=0
    let encoding: u32 = 0x81000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_9_poweroftwo_70_91000070() {
    // Encoding: 0x91000070
    // Test aarch32_HLT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=9, imm12=0
    let encoding: u32 = 0x91000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_10_poweroftwo_70_a1000070() {
    // Encoding: 0xA1000070
    // Test aarch32_HLT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=10, imm12=0
    let encoding: u32 = 0xA1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_11_poweroftwo_70_b1000070() {
    // Encoding: 0xB1000070
    // Test aarch32_HLT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=11, imm4=0
    let encoding: u32 = 0xB1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_12_poweroftwo_70_c1000070() {
    // Encoding: 0xC1000070
    // Test aarch32_HLT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=12
    let encoding: u32 = 0xC1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_13_poweroftwo_70_d1000070() {
    // Encoding: 0xD1000070
    // Test aarch32_HLT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=13
    let encoding: u32 = 0xD1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_14_poweroftwo_70_e1000070() {
    // Encoding: 0xE1000070
    // Test aarch32_HLT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=14
    let encoding: u32 = 0xE1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_hlt_a1_a_field_cond_15_max_70_f1000070() {
    // Encoding: 0xF1000070
    // Test aarch32_HLT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm12=0, cond=15, imm4=0
    let encoding: u32 = 0xF1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_0_zero_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_1_poweroftwo_70_01000170() {
    // Encoding: 0x01000170
    // Test aarch32_HLT_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, imm4=0, cond=0
    let encoding: u32 = 0x01000170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_3_poweroftwominusone_70_01000370() {
    // Encoding: 0x01000370
    // Test aarch32_HLT_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=3, imm4=0
    let encoding: u32 = 0x01000370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_4_poweroftwo_70_01000470() {
    // Encoding: 0x01000470
    // Test aarch32_HLT_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=4, cond=0
    let encoding: u32 = 0x01000470;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_7_poweroftwominusone_70_01000770() {
    // Encoding: 0x01000770
    // Test aarch32_HLT_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=7, cond=0, imm4=0
    let encoding: u32 = 0x01000770;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_8_poweroftwo_70_01000870() {
    // Encoding: 0x01000870
    // Test aarch32_HLT_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, imm4=0, cond=0
    let encoding: u32 = 0x01000870;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_15_poweroftwominusone_70_01000f70() {
    // Encoding: 0x01000F70
    // Test aarch32_HLT_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=15
    let encoding: u32 = 0x01000F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_16_poweroftwo_70_01001070() {
    // Encoding: 0x01001070
    // Test aarch32_HLT_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=16, imm4=0, cond=0
    let encoding: u32 = 0x01001070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_31_poweroftwominusone_70_01001f70() {
    // Encoding: 0x01001F70
    // Test aarch32_HLT_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, imm4=0, cond=0
    let encoding: u32 = 0x01001F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_32_poweroftwo_70_01002070() {
    // Encoding: 0x01002070
    // Test aarch32_HLT_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=32, cond=0, imm4=0
    let encoding: u32 = 0x01002070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_63_poweroftwominusone_70_01003f70() {
    // Encoding: 0x01003F70
    // Test aarch32_HLT_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=63
    let encoding: u32 = 0x01003F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_64_poweroftwo_70_01004070() {
    // Encoding: 0x01004070
    // Test aarch32_HLT_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=64, imm4=0
    let encoding: u32 = 0x01004070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_127_poweroftwominusone_70_01007f70() {
    // Encoding: 0x01007F70
    // Test aarch32_HLT_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=127
    let encoding: u32 = 0x01007F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_128_poweroftwo_70_01008070() {
    // Encoding: 0x01008070
    // Test aarch32_HLT_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=128, cond=0
    let encoding: u32 = 0x01008070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_255_poweroftwominusone_70_0100ff70() {
    // Encoding: 0x0100FF70
    // Test aarch32_HLT_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=255
    let encoding: u32 = 0x0100FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_256_poweroftwo_70_01010070() {
    // Encoding: 0x01010070
    // Test aarch32_HLT_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=256, imm4=0
    let encoding: u32 = 0x01010070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_511_poweroftwominusone_70_0101ff70() {
    // Encoding: 0x0101FF70
    // Test aarch32_HLT_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=511
    let encoding: u32 = 0x0101FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_512_poweroftwo_70_01020070() {
    // Encoding: 0x01020070
    // Test aarch32_HLT_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=512, imm4=0
    let encoding: u32 = 0x01020070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_1023_poweroftwominusone_70_0103ff70() {
    // Encoding: 0x0103FF70
    // Test aarch32_HLT_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=1023
    let encoding: u32 = 0x0103FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_1024_poweroftwo_70_01040070() {
    // Encoding: 0x01040070
    // Test aarch32_HLT_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=1024, cond=0
    let encoding: u32 = 0x01040070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_2047_poweroftwominusone_70_0107ff70() {
    // Encoding: 0x0107FF70
    // Test aarch32_HLT_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=2047, imm4=0
    let encoding: u32 = 0x0107FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_2048_poweroftwo_70_01080070() {
    // Encoding: 0x01080070
    // Test aarch32_HLT_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, cond=0, imm4=0
    let encoding: u32 = 0x01080070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_hlt_a1_a_field_imm12_4095_max_70_010fff70() {
    // Encoding: 0x010FFF70
    // Test aarch32_HLT_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=4095, imm4=0
    let encoding: u32 = 0x010FFF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_0_zero_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_1_poweroftwo_70_01000071() {
    // Encoding: 0x01000071
    // Test aarch32_HLT_A1_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=1
    let encoding: u32 = 0x01000071;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_3_poweroftwominusone_70_01000073() {
    // Encoding: 0x01000073
    // Test aarch32_HLT_A1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=3, cond=0, imm12=0
    let encoding: u32 = 0x01000073;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_4_poweroftwo_70_01000074() {
    // Encoding: 0x01000074
    // Test aarch32_HLT_A1_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=4
    let encoding: u32 = 0x01000074;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_7_poweroftwominusone_70_01000077() {
    // Encoding: 0x01000077
    // Test aarch32_HLT_A1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=0, cond=0, imm4=7
    let encoding: u32 = 0x01000077;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_8_poweroftwo_70_01000078() {
    // Encoding: 0x01000078
    // Test aarch32_HLT_A1_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=8
    let encoding: u32 = 0x01000078;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_hlt_a1_a_field_imm4_15_max_70_0100007f() {
    // Encoding: 0x0100007F
    // Test aarch32_HLT_A1_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: imm4=15, cond=0, imm12=0
    let encoding: u32 = 0x0100007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_hlt_a1_a_combo_0_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A field combination: cond=0, imm12=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_hlt_a1_a_special_cond_0_condition_eq_112_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_hlt_a1_a_special_cond_1_condition_ne_112_11000070() {
    // Encoding: 0x11000070
    // Test aarch32_HLT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=1
    let encoding: u32 = 0x11000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_hlt_a1_a_special_cond_2_condition_cs_hs_112_21000070() {
    // Encoding: 0x21000070
    // Test aarch32_HLT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm4=0, cond=2, imm12=0
    let encoding: u32 = 0x21000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_hlt_a1_a_special_cond_3_condition_cc_lo_112_31000070() {
    // Encoding: 0x31000070
    // Test aarch32_HLT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=3
    let encoding: u32 = 0x31000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_hlt_a1_a_special_cond_4_condition_mi_112_41000070() {
    // Encoding: 0x41000070
    // Test aarch32_HLT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm4=0, imm12=0
    let encoding: u32 = 0x41000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_hlt_a1_a_special_cond_5_condition_pl_112_51000070() {
    // Encoding: 0x51000070
    // Test aarch32_HLT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm12=0, imm4=0
    let encoding: u32 = 0x51000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_hlt_a1_a_special_cond_6_condition_vs_112_61000070() {
    // Encoding: 0x61000070
    // Test aarch32_HLT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm12=0, imm4=0
    let encoding: u32 = 0x61000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_hlt_a1_a_special_cond_7_condition_vc_112_71000070() {
    // Encoding: 0x71000070
    // Test aarch32_HLT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, imm12=0, imm4=0
    let encoding: u32 = 0x71000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_hlt_a1_a_special_cond_8_condition_hi_112_81000070() {
    // Encoding: 0x81000070
    // Test aarch32_HLT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm12=0, imm4=0
    let encoding: u32 = 0x81000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_hlt_a1_a_special_cond_9_condition_ls_112_91000070() {
    // Encoding: 0x91000070
    // Test aarch32_HLT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, cond=9, imm4=0
    let encoding: u32 = 0x91000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_hlt_a1_a_special_cond_10_condition_ge_112_a1000070() {
    // Encoding: 0xA1000070
    // Test aarch32_HLT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4=0, cond=10, imm12=0
    let encoding: u32 = 0xA1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_hlt_a1_a_special_cond_11_condition_lt_112_b1000070() {
    // Encoding: 0xB1000070
    // Test aarch32_HLT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, imm12=0, imm4=0
    let encoding: u32 = 0xB1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_hlt_a1_a_special_cond_12_condition_gt_112_c1000070() {
    // Encoding: 0xC1000070
    // Test aarch32_HLT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=12
    let encoding: u32 = 0xC1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_hlt_a1_a_special_cond_13_condition_le_112_d1000070() {
    // Encoding: 0xD1000070
    // Test aarch32_HLT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm12=0, imm4=0
    let encoding: u32 = 0xD1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_hlt_a1_a_special_cond_14_condition_al_112_e1000070() {
    // Encoding: 0xE1000070
    // Test aarch32_HLT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, imm12=0, imm4=0
    let encoding: u32 = 0xE1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_hlt_a1_a_special_cond_15_condition_nv_112_f1000070() {
    // Encoding: 0xF1000070
    // Test aarch32_HLT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, imm12=0, imm4=0
    let encoding: u32 = 0xF1000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `Binary { op: Eq, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "EDSCR" }), field: "HDE" }, rhs: Binary { op: Or, lhs: LitBits([false]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaltingAllowed" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"EDSCR\" }), field: \"HDE\" }, rhs: Binary { op: Or, lhs: LitBits([false]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaltingAllowed\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_hlt_a1_a_invalid_0_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A invalid encoding: Binary { op: Eq, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "EDSCR" }), field: "HDE" }, rhs: Binary { op: Or, lhs: LitBits([false]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaltingAllowed" }, args: [] } } } }
    // ISET: A32
    // Fields: imm12=0, cond=0, imm4=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_hlt_a1_a_invalid_1_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hlt_a1_a_invalid_2_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_HLT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hlt_a1_a_invalid_3_70_01000070() {
    // Encoding: 0x01000070
    // Test aarch32_HLT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=0
    let encoding: u32 = 0x01000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_0_zero_0_ba800000() {
    // Thumb encoding (32): 0xBA800000
    // Test aarch32_HLT_T1_A field imm6 = 0 (Zero)
    // ISET: T32
    // Fields: imm6=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_1_poweroftwo_0_ba810000() {
    // Thumb encoding (32): 0xBA810000
    // Test aarch32_HLT_T1_A field imm6 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm6=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_3_poweroftwominusone_0_ba830000() {
    // Thumb encoding (32): 0xBA830000
    // Test aarch32_HLT_T1_A field imm6 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm6=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA830000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_4_poweroftwo_0_ba840000() {
    // Thumb encoding (32): 0xBA840000
    // Test aarch32_HLT_T1_A field imm6 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm6=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA840000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_7_poweroftwominusone_0_ba870000() {
    // Thumb encoding (32): 0xBA870000
    // Test aarch32_HLT_T1_A field imm6 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm6=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA870000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_8_poweroftwo_0_ba880000() {
    // Thumb encoding (32): 0xBA880000
    // Test aarch32_HLT_T1_A field imm6 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm6=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA880000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_15_poweroftwominusone_0_ba8f0000() {
    // Thumb encoding (32): 0xBA8F0000
    // Test aarch32_HLT_T1_A field imm6 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm6=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA8F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_16_poweroftwo_0_ba900000() {
    // Thumb encoding (32): 0xBA900000
    // Test aarch32_HLT_T1_A field imm6 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm6=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_31_poweroftwominusone_0_ba9f0000() {
    // Thumb encoding (32): 0xBA9F0000
    // Test aarch32_HLT_T1_A field imm6 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm6=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA9F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_32_poweroftwo_0_baa00000() {
    // Thumb encoding (32): 0xBAA00000
    // Test aarch32_HLT_T1_A field imm6 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm6=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_aarch32_hlt_t1_a_field_imm6_63_max_0_babf0000() {
    // Thumb encoding (32): 0xBABF0000
    // Test aarch32_HLT_T1_A field imm6 = 63 (Max)
    // ISET: T32
    // Fields: imm6=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBABF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_aarch32_hlt_t1_a_combo_0_0_ba800000() {
    // Thumb encoding (32): 0xBA800000
    // Test aarch32_HLT_T1_A field combination: imm6=0
    // ISET: T32
    // Fields: imm6=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `Binary { op: Eq, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "EDSCR" }), field: "HDE" }, rhs: Binary { op: Or, lhs: LitBits([false]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaltingAllowed" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"EDSCR\" }), field: \"HDE\" }, rhs: Binary { op: Or, lhs: LitBits([false]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaltingAllowed\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_hlt_t1_a_invalid_0_0_ba800000() {
    // Thumb encoding (32): 0xBA800000
    // Test aarch32_HLT_T1_A invalid encoding: Binary { op: Eq, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "EDSCR" }), field: "HDE" }, rhs: Binary { op: Or, lhs: LitBits([false]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaltingAllowed" }, args: [] } } } }
    // ISET: T32
    // Fields: imm6=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_hlt_t1_a_invalid_1_0_ba800000() {
    // Thumb encoding (32): 0xBA800000
    // Test aarch32_HLT_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm6=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_32_0_ba820020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_64_0_ba820020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_32_1_ba820020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_64_1_ba820020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_32_2_ba820020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_64_2_ba820020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_32_3_ba820020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_64_3_ba820020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_32_4_ba820020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_64_4_ba820020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_32_5_ba820020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_hlt_t1_a_lslv_oracle_64_5_ba820020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_hlt_t1_a_t16_oracle_0_ba800000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_hlt_t1_a_t16_oracle_1_ba800000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_hlt_t1_a_t16_oracle_2_ba800000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_HLT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_hlt_t1_a_t16_oracle_3_ba800000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_MSR_r_AS Tests
// ============================================================================

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_0_min_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, R=0, mask=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_1_poweroftwo_0_11200000() {
    // Encoding: 0x11200000
    // Test aarch32_MSR_r_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, mask=0, R=0
    let encoding: u32 = 0x11200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_2_poweroftwo_0_21200000() {
    // Encoding: 0x21200000
    // Test aarch32_MSR_r_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, mask=0, Rn=0, cond=2
    let encoding: u32 = 0x21200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_3_poweroftwo_0_31200000() {
    // Encoding: 0x31200000
    // Test aarch32_MSR_r_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, R=0, mask=0
    let encoding: u32 = 0x31200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_4_poweroftwo_0_41200000() {
    // Encoding: 0x41200000
    // Test aarch32_MSR_r_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=4, Rn=0, mask=0
    let encoding: u32 = 0x41200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_5_poweroftwo_0_51200000() {
    // Encoding: 0x51200000
    // Test aarch32_MSR_r_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, mask=0, R=0, cond=5
    let encoding: u32 = 0x51200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_6_poweroftwo_0_61200000() {
    // Encoding: 0x61200000
    // Test aarch32_MSR_r_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, R=0, Rn=0, mask=0
    let encoding: u32 = 0x61200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_7_poweroftwo_0_71200000() {
    // Encoding: 0x71200000
    // Test aarch32_MSR_r_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, mask=0, R=0, Rn=0
    let encoding: u32 = 0x71200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_8_poweroftwo_0_81200000() {
    // Encoding: 0x81200000
    // Test aarch32_MSR_r_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: mask=0, R=0, Rn=0, cond=8
    let encoding: u32 = 0x81200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_9_poweroftwo_0_91200000() {
    // Encoding: 0x91200000
    // Test aarch32_MSR_r_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=0, cond=9, mask=0
    let encoding: u32 = 0x91200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_10_poweroftwo_0_a1200000() {
    // Encoding: 0xA1200000
    // Test aarch32_MSR_r_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, mask=0, R=0
    let encoding: u32 = 0xA1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_11_poweroftwo_0_b1200000() {
    // Encoding: 0xB1200000
    // Test aarch32_MSR_r_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, mask=0, R=0, cond=11
    let encoding: u32 = 0xB1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_12_poweroftwo_0_c1200000() {
    // Encoding: 0xC1200000
    // Test aarch32_MSR_r_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, mask=0, cond=12, Rn=0
    let encoding: u32 = 0xC1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_13_poweroftwo_0_d1200000() {
    // Encoding: 0xD1200000
    // Test aarch32_MSR_r_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, R=0, cond=13, mask=0
    let encoding: u32 = 0xD1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_14_poweroftwo_0_e1200000() {
    // Encoding: 0xE1200000
    // Test aarch32_MSR_r_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, mask=0, Rn=0, cond=14
    let encoding: u32 = 0xE1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_msr_r_a1_as_field_cond_15_max_0_f1200000() {
    // Encoding: 0xF1200000
    // Test aarch32_MSR_r_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, R=0, mask=0
    let encoding: u32 = 0xF1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_r_a1_as_field_r_0_min_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS field R = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, R=0, mask=0, cond=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_r_a1_as_field_r_1_max_0_01600000() {
    // Encoding: 0x01600000
    // Test aarch32_MSR_r_A1_AS field R = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, mask=0, R=1
    let encoding: u32 = 0x01600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_r_a1_as_field_mask_0_min_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS field mask = 0 (Min)
    // ISET: A32
    // Fields: R=0, Rn=0, cond=0, mask=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_msr_r_a1_as_field_mask_1_poweroftwo_0_01210000() {
    // Encoding: 0x01210000
    // Test aarch32_MSR_r_A1_AS field mask = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: mask=1, cond=0, Rn=0, R=0
    let encoding: u32 = 0x01210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_msr_r_a1_as_field_mask_7_poweroftwominusone_0_01270000() {
    // Encoding: 0x01270000
    // Test aarch32_MSR_r_A1_AS field mask = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, mask=7, Rn=0, R=0
    let encoding: u32 = 0x01270000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_msr_r_a1_as_field_mask_15_max_0_012f0000() {
    // Encoding: 0x012F0000
    // Test aarch32_MSR_r_A1_AS field mask = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, R=0, mask=15
    let encoding: u32 = 0x012F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_msr_r_a1_as_field_rn_0_min_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, mask=0, Rn=0, R=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_msr_r_a1_as_field_rn_1_poweroftwo_0_01200001() {
    // Encoding: 0x01200001
    // Test aarch32_MSR_r_A1_AS field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=1, mask=0, cond=0
    let encoding: u32 = 0x01200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_msr_r_a1_as_combo_0_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS field combination: cond=0, R=0, mask=0, Rn=0
    // ISET: A32
    // Fields: R=0, cond=0, mask=0, Rn=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_0_condition_eq_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, mask=0, R=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_1_condition_ne_0_11200000() {
    // Encoding: 0x11200000
    // Test aarch32_MSR_r_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, R=0, mask=0
    let encoding: u32 = 0x11200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_2_condition_cs_hs_0_21200000() {
    // Encoding: 0x21200000
    // Test aarch32_MSR_r_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, R=0, mask=0
    let encoding: u32 = 0x21200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_3_condition_cc_lo_0_31200000() {
    // Encoding: 0x31200000
    // Test aarch32_MSR_r_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: mask=0, Rn=0, cond=3, R=0
    let encoding: u32 = 0x31200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_4_condition_mi_0_41200000() {
    // Encoding: 0x41200000
    // Test aarch32_MSR_r_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, mask=0, Rn=0, R=0
    let encoding: u32 = 0x41200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_5_condition_pl_0_51200000() {
    // Encoding: 0x51200000
    // Test aarch32_MSR_r_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, mask=0, cond=5, R=0
    let encoding: u32 = 0x51200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_6_condition_vs_0_61200000() {
    // Encoding: 0x61200000
    // Test aarch32_MSR_r_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, R=0, mask=0, Rn=0
    let encoding: u32 = 0x61200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_7_condition_vc_0_71200000() {
    // Encoding: 0x71200000
    // Test aarch32_MSR_r_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: mask=0, R=0, Rn=0, cond=7
    let encoding: u32 = 0x71200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_8_condition_hi_0_81200000() {
    // Encoding: 0x81200000
    // Test aarch32_MSR_r_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, mask=0, cond=8, R=0
    let encoding: u32 = 0x81200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_9_condition_ls_0_91200000() {
    // Encoding: 0x91200000
    // Test aarch32_MSR_r_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, mask=0, R=0
    let encoding: u32 = 0x91200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_10_condition_ge_0_a1200000() {
    // Encoding: 0xA1200000
    // Test aarch32_MSR_r_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, R=0, mask=0
    let encoding: u32 = 0xA1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_11_condition_lt_0_b1200000() {
    // Encoding: 0xB1200000
    // Test aarch32_MSR_r_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: mask=0, R=0, Rn=0, cond=11
    let encoding: u32 = 0xB1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_12_condition_gt_0_c1200000() {
    // Encoding: 0xC1200000
    // Test aarch32_MSR_r_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: mask=0, Rn=0, R=0, cond=12
    let encoding: u32 = 0xC1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_13_condition_le_0_d1200000() {
    // Encoding: 0xD1200000
    // Test aarch32_MSR_r_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, mask=0, R=0, cond=13
    let encoding: u32 = 0xD1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_14_condition_al_0_e1200000() {
    // Encoding: 0xE1200000
    // Test aarch32_MSR_r_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: R=0, cond=14, Rn=0, mask=0
    let encoding: u32 = 0xE1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_msr_r_a1_as_special_cond_15_condition_nv_0_f1200000() {
    // Encoding: 0xF1200000
    // Test aarch32_MSR_r_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: R=0, mask=0, cond=15, Rn=0
    let encoding: u32 = 0xF1200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mask" }), rhs: LitBits([false, false, false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"mask\" }), rhs: LitBits([false, false, false, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_a1_as_invalid_0_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mask" }), rhs: LitBits([false, false, false, false]) }
    // ISET: A32
    // Fields: Rn=0, R=0, mask=0, cond=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_a1_as_invalid_1_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: R=0, Rn=0, mask=0, cond=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_a1_as_invalid_2_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, R=0, mask=0, Rn=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_a1_as_invalid_3_0_01200000() {
    // Encoding: 0x01200000
    // Test aarch32_MSR_r_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, mask=0, R=0
    let encoding: u32 = 0x01200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_r_t1_as_field_r_0_min_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS field R = 0 (Min)
    // ISET: T32
    // Fields: mask=0, R=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_r_t1_as_field_r_1_max_8000_f3908000() {
    // Thumb encoding (32): 0xF3908000
    // Test aarch32_MSR_r_T1_AS field R = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, R=1, mask=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3908000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_msr_r_t1_as_field_rn_0_min_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, mask=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_msr_r_t1_as_field_rn_1_poweroftwo_8000_f3818000() {
    // Thumb encoding (32): 0xF3818000
    // Test aarch32_MSR_r_T1_AS field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: mask=0, R=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3818000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field mask 8 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_r_t1_as_field_mask_0_min_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS field mask = 0 (Min)
    // ISET: T32
    // Fields: mask=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field mask 8 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_msr_r_t1_as_field_mask_1_poweroftwo_8000_f3808100() {
    // Thumb encoding (32): 0xF3808100
    // Test aarch32_MSR_r_T1_AS field mask = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: mask=1, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field mask 8 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_msr_r_t1_as_field_mask_7_poweroftwominusone_8000_f3808700() {
    // Thumb encoding (32): 0xF3808700
    // Test aarch32_MSR_r_T1_AS field mask = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: mask=7, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field mask 8 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_msr_r_t1_as_field_mask_15_max_8000_f3808f00() {
    // Thumb encoding (32): 0xF3808F00
    // Test aarch32_MSR_r_T1_AS field mask = 15 (Max)
    // ISET: T32
    // Fields: R=0, Rn=0, mask=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=0 (minimum value)
#[test]
fn test_aarch32_msr_r_t1_as_combo_0_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS field combination: R=0, Rn=0, mask=0
    // ISET: T32
    // Fields: R=0, Rn=0, mask=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mask" }), rhs: LitBits([false, false, false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"mask\" }), rhs: LitBits([false, false, false, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_t1_as_invalid_0_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mask" }), rhs: LitBits([false, false, false, false]) }
    // ISET: T32
    // Fields: R=0, Rn=0, mask=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_t1_as_invalid_1_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: mask=0, R=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_t1_as_invalid_2_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: R=0, Rn=0, mask=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_t1_as_invalid_3_8000_f3808000() {
    // Thumb encoding (32): 0xF3808000
    // Test aarch32_MSR_r_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: R=0, mask=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_r_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_a1_as_exception_0_01200000() {
    // Test aarch32_MSR_r_A1_AS exception: Unpredictable
    // Encoding: 0x01200000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_MSR_r_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_r_t1_as_exception_0_f3808000() {
    // Test aarch32_MSR_r_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_WFE_A Tests
// ============================================================================

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_0_min_2_03200002() {
    // Encoding: 0x03200002
    // Test aarch32_WFE_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_1_poweroftwo_2_13200002() {
    // Encoding: 0x13200002
    // Test aarch32_WFE_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_2_poweroftwo_2_23200002() {
    // Encoding: 0x23200002
    // Test aarch32_WFE_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_3_poweroftwo_2_33200002() {
    // Encoding: 0x33200002
    // Test aarch32_WFE_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_4_poweroftwo_2_43200002() {
    // Encoding: 0x43200002
    // Test aarch32_WFE_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_5_poweroftwo_2_53200002() {
    // Encoding: 0x53200002
    // Test aarch32_WFE_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_6_poweroftwo_2_63200002() {
    // Encoding: 0x63200002
    // Test aarch32_WFE_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_7_poweroftwo_2_73200002() {
    // Encoding: 0x73200002
    // Test aarch32_WFE_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_8_poweroftwo_2_83200002() {
    // Encoding: 0x83200002
    // Test aarch32_WFE_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_9_poweroftwo_2_93200002() {
    // Encoding: 0x93200002
    // Test aarch32_WFE_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_10_poweroftwo_2_a3200002() {
    // Encoding: 0xA3200002
    // Test aarch32_WFE_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_11_poweroftwo_2_b3200002() {
    // Encoding: 0xB3200002
    // Test aarch32_WFE_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_12_poweroftwo_2_c3200002() {
    // Encoding: 0xC3200002
    // Test aarch32_WFE_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_13_poweroftwo_2_d3200002() {
    // Encoding: 0xD3200002
    // Test aarch32_WFE_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_14_poweroftwo_2_e3200002() {
    // Encoding: 0xE3200002
    // Test aarch32_WFE_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_wfe_a1_a_field_cond_15_max_2_f3200002() {
    // Encoding: 0xF3200002
    // Test aarch32_WFE_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_wfe_a1_a_combo_0_2_03200002() {
    // Encoding: 0x03200002
    // Test aarch32_WFE_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_wfe_a1_a_special_cond_0_condition_eq_2_03200002() {
    // Encoding: 0x03200002
    // Test aarch32_WFE_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_wfe_a1_a_special_cond_1_condition_ne_2_13200002() {
    // Encoding: 0x13200002
    // Test aarch32_WFE_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_wfe_a1_a_special_cond_2_condition_cs_hs_2_23200002() {
    // Encoding: 0x23200002
    // Test aarch32_WFE_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_wfe_a1_a_special_cond_3_condition_cc_lo_2_33200002() {
    // Encoding: 0x33200002
    // Test aarch32_WFE_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_wfe_a1_a_special_cond_4_condition_mi_2_43200002() {
    // Encoding: 0x43200002
    // Test aarch32_WFE_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_wfe_a1_a_special_cond_5_condition_pl_2_53200002() {
    // Encoding: 0x53200002
    // Test aarch32_WFE_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_wfe_a1_a_special_cond_6_condition_vs_2_63200002() {
    // Encoding: 0x63200002
    // Test aarch32_WFE_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_wfe_a1_a_special_cond_7_condition_vc_2_73200002() {
    // Encoding: 0x73200002
    // Test aarch32_WFE_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_wfe_a1_a_special_cond_8_condition_hi_2_83200002() {
    // Encoding: 0x83200002
    // Test aarch32_WFE_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_wfe_a1_a_special_cond_9_condition_ls_2_93200002() {
    // Encoding: 0x93200002
    // Test aarch32_WFE_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_wfe_a1_a_special_cond_10_condition_ge_2_a3200002() {
    // Encoding: 0xA3200002
    // Test aarch32_WFE_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_wfe_a1_a_special_cond_11_condition_lt_2_b3200002() {
    // Encoding: 0xB3200002
    // Test aarch32_WFE_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_wfe_a1_a_special_cond_12_condition_gt_2_c3200002() {
    // Encoding: 0xC3200002
    // Test aarch32_WFE_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_wfe_a1_a_special_cond_13_condition_le_2_d3200002() {
    // Encoding: 0xD3200002
    // Test aarch32_WFE_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_wfe_a1_a_special_cond_14_condition_al_2_e3200002() {
    // Encoding: 0xE3200002
    // Test aarch32_WFE_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_wfe_a1_a_special_cond_15_condition_nv_2_f3200002() {
    // Encoding: 0xF3200002
    // Test aarch32_WFE_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200002;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_wfe_t1_a_basic_encoding_bf200000() {
    // Thumb encoding (32): 0xBF200000
    // Test aarch32_WFE_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBF200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_WFE_T2_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_wfe_t2_a_basic_encoding_f3a08002() {
    // Thumb encoding (32): 0xF3A08002
    // Test aarch32_WFE_T2_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_wfe_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_32_0_bf220020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_64_0_bf220020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_32_1_bf220020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_64_1_bf220020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_32_2_bf220020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_64_2_bf220020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_32_3_bf220020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_64_3_bf220020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_32_4_bf220020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_64_4_bf220020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_32_5_bf220020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_wfe_t1_a_lslv_oracle_64_5_bf220020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_wfe_t1_a_t16_oracle_0_bf200000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_wfe_t1_a_t16_oracle_1_bf200000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_wfe_t1_a_t16_oracle_2_bf200000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_WFE_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_wfe_t1_a_t16_oracle_3_bf200000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_PLI_i_A Tests
// ============================================================================

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pli_i_a1_a_field_u_0_min_0_f4500000() {
    // Encoding: 0xF4500000
    // Test aarch32_PLI_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=0
    let encoding: u32 = 0xF4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pli_i_a1_a_field_u_1_max_0_f4d00000() {
    // Encoding: 0xF4D00000
    // Test aarch32_PLI_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, imm12=0, Rn=0
    let encoding: u32 = 0xF4D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_i_a1_a_field_rn_0_min_0_f4500000() {
    // Encoding: 0xF4500000
    // Test aarch32_PLI_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0
    let encoding: u32 = 0xF4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_i_a1_a_field_rn_1_poweroftwo_0_f4510000() {
    // Encoding: 0xF4510000
    // Test aarch32_PLI_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, imm12=0, U=0
    let encoding: u32 = 0xF4510000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_0_zero_0_f4500000() {
    // Encoding: 0xF4500000
    // Test aarch32_PLI_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=0
    let encoding: u32 = 0xF4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_1_poweroftwo_0_f4500001() {
    // Encoding: 0xF4500001
    // Test aarch32_PLI_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=1
    let encoding: u32 = 0xF4500001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_3_poweroftwominusone_0_f4500003() {
    // Encoding: 0xF4500003
    // Test aarch32_PLI_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=3, Rn=0, U=0
    let encoding: u32 = 0xF4500003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_4_poweroftwo_0_f4500004() {
    // Encoding: 0xF4500004
    // Test aarch32_PLI_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, Rn=0, U=0
    let encoding: u32 = 0xF4500004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_7_poweroftwominusone_0_f4500007() {
    // Encoding: 0xF4500007
    // Test aarch32_PLI_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=7, U=0, Rn=0
    let encoding: u32 = 0xF4500007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_8_poweroftwo_0_f4500008() {
    // Encoding: 0xF4500008
    // Test aarch32_PLI_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=8
    let encoding: u32 = 0xF4500008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_15_poweroftwominusone_0_f450000f() {
    // Encoding: 0xF450000F
    // Test aarch32_PLI_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=15, Rn=0
    let encoding: u32 = 0xF450000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_16_poweroftwo_0_f4500010() {
    // Encoding: 0xF4500010
    // Test aarch32_PLI_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=16
    let encoding: u32 = 0xF4500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_31_poweroftwominusone_0_f450001f() {
    // Encoding: 0xF450001F
    // Test aarch32_PLI_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, U=0, Rn=0
    let encoding: u32 = 0xF450001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_32_poweroftwo_0_f4500020() {
    // Encoding: 0xF4500020
    // Test aarch32_PLI_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=32
    let encoding: u32 = 0xF4500020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_63_poweroftwominusone_0_f450003f() {
    // Encoding: 0xF450003F
    // Test aarch32_PLI_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=63, U=0
    let encoding: u32 = 0xF450003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_64_poweroftwo_0_f4500040() {
    // Encoding: 0xF4500040
    // Test aarch32_PLI_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=64
    let encoding: u32 = 0xF4500040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_127_poweroftwominusone_0_f450007f() {
    // Encoding: 0xF450007F
    // Test aarch32_PLI_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, Rn=0, U=0
    let encoding: u32 = 0xF450007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_128_poweroftwo_0_f4500080() {
    // Encoding: 0xF4500080
    // Test aarch32_PLI_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=128
    let encoding: u32 = 0xF4500080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_255_poweroftwominusone_0_f45000ff() {
    // Encoding: 0xF45000FF
    // Test aarch32_PLI_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=255, U=0
    let encoding: u32 = 0xF45000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_256_poweroftwo_0_f4500100() {
    // Encoding: 0xF4500100
    // Test aarch32_PLI_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=256, U=0, Rn=0
    let encoding: u32 = 0xF4500100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_511_poweroftwominusone_0_f45001ff() {
    // Encoding: 0xF45001FF
    // Test aarch32_PLI_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=511, U=0
    let encoding: u32 = 0xF45001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_512_poweroftwo_0_f4500200() {
    // Encoding: 0xF4500200
    // Test aarch32_PLI_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, Rn=0, U=0
    let encoding: u32 = 0xF4500200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_1023_poweroftwominusone_0_f45003ff() {
    // Encoding: 0xF45003FF
    // Test aarch32_PLI_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=1023
    let encoding: u32 = 0xF45003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_1024_poweroftwo_0_f4500400() {
    // Encoding: 0xF4500400
    // Test aarch32_PLI_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, U=0, Rn=0
    let encoding: u32 = 0xF4500400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_2047_poweroftwominusone_0_f45007ff() {
    // Encoding: 0xF45007FF
    // Test aarch32_PLI_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=2047, Rn=0
    let encoding: u32 = 0xF45007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_2048_poweroftwo_0_f4500800() {
    // Encoding: 0xF4500800
    // Test aarch32_PLI_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, U=0, Rn=0
    let encoding: u32 = 0xF4500800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pli_i_a1_a_field_imm12_4095_max_0_f4500fff() {
    // Encoding: 0xF4500FFF
    // Test aarch32_PLI_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=4095
    let encoding: u32 = 0xF4500FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pli_i_a1_a_combo_0_0_f4500000() {
    // Encoding: 0xF4500000
    // Test aarch32_PLI_i_A1_A field combination: U=0, Rn=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0
    let encoding: u32 = 0xF4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_i_t1_a_field_rn_0_min_f000_f990f000() {
    // Thumb encoding (32): 0xF990F000
    // Test aarch32_PLI_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_i_t1_a_field_rn_1_poweroftwo_f000_f991f000() {
    // Thumb encoding (32): 0xF991F000
    // Test aarch32_PLI_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF991F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_0_zero_f000_f990f000() {
    // Thumb encoding (32): 0xF990F000
    // Test aarch32_PLI_i_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_1_poweroftwo_f000_f990f001() {
    // Thumb encoding (32): 0xF990F001
    // Test aarch32_PLI_i_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_3_poweroftwominusone_f000_f990f003() {
    // Thumb encoding (32): 0xF990F003
    // Test aarch32_PLI_i_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_4_poweroftwo_f000_f990f004() {
    // Thumb encoding (32): 0xF990F004
    // Test aarch32_PLI_i_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_7_poweroftwominusone_f000_f990f007() {
    // Thumb encoding (32): 0xF990F007
    // Test aarch32_PLI_i_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_8_poweroftwo_f000_f990f008() {
    // Thumb encoding (32): 0xF990F008
    // Test aarch32_PLI_i_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_15_poweroftwominusone_f000_f990f00f() {
    // Thumb encoding (32): 0xF990F00F
    // Test aarch32_PLI_i_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_16_poweroftwo_f000_f990f010() {
    // Thumb encoding (32): 0xF990F010
    // Test aarch32_PLI_i_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_31_poweroftwominusone_f000_f990f01f() {
    // Thumb encoding (32): 0xF990F01F
    // Test aarch32_PLI_i_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_32_poweroftwo_f000_f990f020() {
    // Thumb encoding (32): 0xF990F020
    // Test aarch32_PLI_i_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_63_poweroftwominusone_f000_f990f03f() {
    // Thumb encoding (32): 0xF990F03F
    // Test aarch32_PLI_i_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F03F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_64_poweroftwo_f000_f990f040() {
    // Thumb encoding (32): 0xF990F040
    // Test aarch32_PLI_i_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_127_poweroftwominusone_f000_f990f07f() {
    // Thumb encoding (32): 0xF990F07F
    // Test aarch32_PLI_i_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F07F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_128_poweroftwo_f000_f990f080() {
    // Thumb encoding (32): 0xF990F080
    // Test aarch32_PLI_i_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_255_poweroftwominusone_f000_f990f0ff() {
    // Thumb encoding (32): 0xF990F0FF
    // Test aarch32_PLI_i_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F0FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_256_poweroftwo_f000_f990f100() {
    // Thumb encoding (32): 0xF990F100
    // Test aarch32_PLI_i_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=256, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_511_poweroftwominusone_f000_f990f1ff() {
    // Thumb encoding (32): 0xF990F1FF
    // Test aarch32_PLI_i_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F1FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_512_poweroftwo_f000_f990f200() {
    // Thumb encoding (32): 0xF990F200
    // Test aarch32_PLI_i_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_1023_poweroftwominusone_f000_f990f3ff() {
    // Thumb encoding (32): 0xF990F3FF
    // Test aarch32_PLI_i_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F3FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_1024_poweroftwo_f000_f990f400() {
    // Thumb encoding (32): 0xF990F400
    // Test aarch32_PLI_i_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1024, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_2047_poweroftwominusone_f000_f990f7ff() {
    // Thumb encoding (32): 0xF990F7FF
    // Test aarch32_PLI_i_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F7FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_2048_poweroftwo_f000_f990f800() {
    // Thumb encoding (32): 0xF990F800
    // Test aarch32_PLI_i_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pli_i_t1_a_field_imm12_4095_max_f000_f990ffff() {
    // Thumb encoding (32): 0xF990FFFF
    // Test aarch32_PLI_i_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rn=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990FFFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_pli_i_t1_a_combo_0_f000_f990f000() {
    // Thumb encoding (32): 0xF990F000
    // Test aarch32_PLI_i_T1_A field combination: Rn=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_i_t2_a_field_rn_0_min_fc00_f910fc00() {
    // Thumb encoding (32): 0xF910FC00
    // Test aarch32_PLI_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_i_t2_a_field_rn_1_poweroftwo_fc00_f911fc00() {
    // Thumb encoding (32): 0xF911FC00
    // Test aarch32_PLI_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF911FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_0_zero_fc00_f910fc00() {
    // Thumb encoding (32): 0xF910FC00
    // Test aarch32_PLI_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_1_poweroftwo_fc00_f910fc01() {
    // Thumb encoding (32): 0xF910FC01
    // Test aarch32_PLI_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_3_poweroftwominusone_fc00_f910fc03() {
    // Thumb encoding (32): 0xF910FC03
    // Test aarch32_PLI_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_4_poweroftwo_fc00_f910fc04() {
    // Thumb encoding (32): 0xF910FC04
    // Test aarch32_PLI_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_7_poweroftwominusone_fc00_f910fc07() {
    // Thumb encoding (32): 0xF910FC07
    // Test aarch32_PLI_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_8_poweroftwo_fc00_f910fc08() {
    // Thumb encoding (32): 0xF910FC08
    // Test aarch32_PLI_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_15_poweroftwominusone_fc00_f910fc0f() {
    // Thumb encoding (32): 0xF910FC0F
    // Test aarch32_PLI_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_16_poweroftwo_fc00_f910fc10() {
    // Thumb encoding (32): 0xF910FC10
    // Test aarch32_PLI_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_31_poweroftwominusone_fc00_f910fc1f() {
    // Thumb encoding (32): 0xF910FC1F
    // Test aarch32_PLI_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_32_poweroftwo_fc00_f910fc20() {
    // Thumb encoding (32): 0xF910FC20
    // Test aarch32_PLI_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_63_poweroftwominusone_fc00_f910fc3f() {
    // Thumb encoding (32): 0xF910FC3F
    // Test aarch32_PLI_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_64_poweroftwo_fc00_f910fc40() {
    // Thumb encoding (32): 0xF910FC40
    // Test aarch32_PLI_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_127_poweroftwominusone_fc00_f910fc7f() {
    // Thumb encoding (32): 0xF910FC7F
    // Test aarch32_PLI_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_128_poweroftwo_fc00_f910fc80() {
    // Thumb encoding (32): 0xF910FC80
    // Test aarch32_PLI_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_pli_i_t2_a_field_imm8_255_max_fc00_f910fcff() {
    // Thumb encoding (32): 0xF910FCFF
    // Test aarch32_PLI_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FCFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_pli_i_t2_a_combo_0_fc00_f910fc00() {
    // Thumb encoding (32): 0xF910FC00
    // Test aarch32_PLI_i_T2_A field combination: Rn=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pli_i_t3_a_field_u_0_min_f000_f91ff000() {
    // Thumb encoding (32): 0xF91FF000
    // Test aarch32_PLI_i_T3_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pli_i_t3_a_field_u_1_max_f000_f99ff000() {
    // Thumb encoding (32): 0xF99FF000
    // Test aarch32_PLI_i_T3_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF99FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_0_zero_f000_f91ff000() {
    // Thumb encoding (32): 0xF91FF000
    // Test aarch32_PLI_i_T3_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: imm12=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_1_poweroftwo_f000_f91ff001() {
    // Thumb encoding (32): 0xF91FF001
    // Test aarch32_PLI_i_T3_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_3_poweroftwominusone_f000_f91ff003() {
    // Thumb encoding (32): 0xF91FF003
    // Test aarch32_PLI_i_T3_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_4_poweroftwo_f000_f91ff004() {
    // Thumb encoding (32): 0xF91FF004
    // Test aarch32_PLI_i_T3_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_7_poweroftwominusone_f000_f91ff007() {
    // Thumb encoding (32): 0xF91FF007
    // Test aarch32_PLI_i_T3_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_8_poweroftwo_f000_f91ff008() {
    // Thumb encoding (32): 0xF91FF008
    // Test aarch32_PLI_i_T3_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_15_poweroftwominusone_f000_f91ff00f() {
    // Thumb encoding (32): 0xF91FF00F
    // Test aarch32_PLI_i_T3_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_16_poweroftwo_f000_f91ff010() {
    // Thumb encoding (32): 0xF91FF010
    // Test aarch32_PLI_i_T3_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_31_poweroftwominusone_f000_f91ff01f() {
    // Thumb encoding (32): 0xF91FF01F
    // Test aarch32_PLI_i_T3_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_32_poweroftwo_f000_f91ff020() {
    // Thumb encoding (32): 0xF91FF020
    // Test aarch32_PLI_i_T3_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=32, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_63_poweroftwominusone_f000_f91ff03f() {
    // Thumb encoding (32): 0xF91FF03F
    // Test aarch32_PLI_i_T3_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=63, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF03F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_64_poweroftwo_f000_f91ff040() {
    // Thumb encoding (32): 0xF91FF040
    // Test aarch32_PLI_i_T3_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_127_poweroftwominusone_f000_f91ff07f() {
    // Thumb encoding (32): 0xF91FF07F
    // Test aarch32_PLI_i_T3_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF07F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_128_poweroftwo_f000_f91ff080() {
    // Thumb encoding (32): 0xF91FF080
    // Test aarch32_PLI_i_T3_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_255_poweroftwominusone_f000_f91ff0ff() {
    // Thumb encoding (32): 0xF91FF0FF
    // Test aarch32_PLI_i_T3_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=255, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF0FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_256_poweroftwo_f000_f91ff100() {
    // Thumb encoding (32): 0xF91FF100
    // Test aarch32_PLI_i_T3_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_511_poweroftwominusone_f000_f91ff1ff() {
    // Thumb encoding (32): 0xF91FF1FF
    // Test aarch32_PLI_i_T3_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=511, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF1FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_512_poweroftwo_f000_f91ff200() {
    // Thumb encoding (32): 0xF91FF200
    // Test aarch32_PLI_i_T3_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_1023_poweroftwominusone_f000_f91ff3ff() {
    // Thumb encoding (32): 0xF91FF3FF
    // Test aarch32_PLI_i_T3_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF3FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_1024_poweroftwo_f000_f91ff400() {
    // Thumb encoding (32): 0xF91FF400
    // Test aarch32_PLI_i_T3_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_2047_poweroftwominusone_f000_f91ff7ff() {
    // Thumb encoding (32): 0xF91FF7FF
    // Test aarch32_PLI_i_T3_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=2047, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF7FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_2048_poweroftwo_f000_f91ff800() {
    // Thumb encoding (32): 0xF91FF800
    // Test aarch32_PLI_i_T3_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pli_i_t3_a_field_imm12_4095_max_f000_f91fffff() {
    // Thumb encoding (32): 0xF91FFFFF
    // Test aarch32_PLI_i_T3_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: U=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FFFFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pli_i_t3_a_combo_0_f000_f91ff000() {
    // Thumb encoding (32): 0xF91FF000
    // Test aarch32_PLI_i_T3_A field combination: U=0, imm12=0
    // ISET: T32
    // Fields: U=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_pli_i_t2_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_pli_i_t2_a_t32_oracle_0_f911fc00() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF911FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_pli_i_t2_a_t32_oracle_1_f911fc00() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF911FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_pli_i_t2_a_t32_oracle_2_f911fc00() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF911FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_pli_i_t2_a_t32_oracle_3_f911fc00() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF911FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_pli_i_t3_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_pli_i_t3_a_t32_oracle_0_f91ff000() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_pli_i_t3_a_t32_oracle_1_f91ff000() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_pli_i_t3_a_t32_oracle_2_f91ff000() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_pli_i_t3_a_t32_oracle_3_f91ff000() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0xF91FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_PLI_r_A Tests
// ============================================================================

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pli_r_a1_a_field_u_0_min_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: type1=0, U=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pli_r_a1_a_field_u_1_max_0_f6d00000() {
    // Encoding: 0xF6D00000
    // Test aarch32_PLI_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Rn=0, imm5=0, Rm=0, type1=0
    let encoding: u32 = 0xF6D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_r_a1_a_field_rn_0_min_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, type1=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_r_a1_a_field_rn_1_poweroftwo_0_f6510000() {
    // Encoding: 0xF6510000
    // Test aarch32_PLI_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=1, U=0, type1=0, Rm=0
    let encoding: u32 = 0xF6510000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_0_zero_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, U=0, Rm=0, imm5=0, type1=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_1_poweroftwo_0_f6500080() {
    // Encoding: 0xF6500080
    // Test aarch32_PLI_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, U=0, Rm=0, Rn=0, imm5=1
    let encoding: u32 = 0xF6500080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_3_poweroftwominusone_0_f6500180() {
    // Encoding: 0xF6500180
    // Test aarch32_PLI_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, imm5=3, Rm=0, type1=0
    let encoding: u32 = 0xF6500180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_4_poweroftwo_0_f6500200() {
    // Encoding: 0xF6500200
    // Test aarch32_PLI_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm5=4, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0xF6500200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_7_poweroftwominusone_0_f6500380() {
    // Encoding: 0xF6500380
    // Test aarch32_PLI_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, Rm=0, type1=0, imm5=7
    let encoding: u32 = 0xF6500380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_8_poweroftwo_0_f6500400() {
    // Encoding: 0xF6500400
    // Test aarch32_PLI_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, Rn=0, imm5=8, type1=0
    let encoding: u32 = 0xF6500400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_15_poweroftwominusone_0_f6500780() {
    // Encoding: 0xF6500780
    // Test aarch32_PLI_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, imm5=15, U=0
    let encoding: u32 = 0xF6500780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_16_poweroftwo_0_f6500800() {
    // Encoding: 0xF6500800
    // Test aarch32_PLI_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm5=16, Rm=0, Rn=0, type1=0
    let encoding: u32 = 0xF6500800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_pli_r_a1_a_field_imm5_31_max_0_f6500f80() {
    // Encoding: 0xF6500F80
    // Test aarch32_PLI_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: U=0, Rn=0, type1=0, Rm=0, imm5=31
    let encoding: u32 = 0xF6500F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pli_r_a1_a_field_type1_0_min_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, type1=0, U=0, Rm=0, imm5=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_pli_r_a1_a_field_type1_1_poweroftwo_0_f6500020() {
    // Encoding: 0xF6500020
    // Test aarch32_PLI_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, Rn=0, imm5=0, type1=1
    let encoding: u32 = 0xF6500020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_pli_r_a1_a_field_type1_3_max_0_f6500060() {
    // Encoding: 0xF6500060
    // Test aarch32_PLI_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: imm5=0, Rm=0, Rn=0, U=0, type1=3
    let encoding: u32 = 0xF6500060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_r_a1_a_field_rm_0_min_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, imm5=0, U=0, Rn=0, type1=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_r_a1_a_field_rm_1_poweroftwo_0_f6500001() {
    // Encoding: 0xF6500001
    // Test aarch32_PLI_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rn=0, type1=0, U=0, imm5=0
    let encoding: u32 = 0xF6500001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pli_r_a1_a_combo_0_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A field combination: U=0, Rn=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rn=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pli_r_a1_a_invalid_0_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rm=0, U=0, type1=0, imm5=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_PLI_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pli_r_a1_a_invalid_1_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_PLI_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, imm5=0, U=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_r_t1_a_field_rn_0_min_f000_f910f000() {
    // Thumb encoding (32): 0xF910F000
    // Test aarch32_PLI_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_r_t1_a_field_rn_1_poweroftwo_f000_f911f000() {
    // Thumb encoding (32): 0xF911F000
    // Test aarch32_PLI_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF911F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pli_r_t1_a_field_imm2_0_zero_f000_f910f000() {
    // Thumb encoding (32): 0xF910F000
    // Test aarch32_PLI_r_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pli_r_t1_a_field_imm2_1_poweroftwo_f000_f910f010() {
    // Thumb encoding (32): 0xF910F010
    // Test aarch32_PLI_r_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_pli_r_t1_a_field_imm2_3_max_f000_f910f030() {
    // Thumb encoding (32): 0xF910F030
    // Test aarch32_PLI_r_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, imm2=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pli_r_t1_a_field_rm_0_min_f000_f910f000() {
    // Thumb encoding (32): 0xF910F000
    // Test aarch32_PLI_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pli_r_t1_a_field_rm_1_poweroftwo_f000_f910f001() {
    // Thumb encoding (32): 0xF910F001
    // Test aarch32_PLI_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_pli_r_t1_a_combo_0_f000_f910f000() {
    // Thumb encoding (32): 0xF910F000
    // Test aarch32_PLI_r_T1_A field combination: Rn=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pli_r_t1_a_invalid_0_f000_f910f000() {
    // Thumb encoding (32): 0xF910F000
    // Test aarch32_PLI_r_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pli_r_t1_a_invalid_1_f000_f910f000() {
    // Thumb encoding (32): 0xF910F000
    // Test aarch32_PLI_r_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_pli_r_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_pli_r_t1_a_t32_oracle_0_f911f002() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF911F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_pli_r_t1_a_t32_oracle_1_f911f002() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF911F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_pli_r_t1_a_t32_oracle_2_f911f002() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF911F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLI_r_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_pli_r_t1_a_t32_oracle_3_f911f002() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF911F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_DSB_A Tests
// ============================================================================

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_dsb_a1_a_field_option_0_min_40_f5700040() {
    // Encoding: 0xF5700040
    // Test aarch32_DSB_A1_A field option = 0 (Min)
    // ISET: A32
    // Fields: option=0
    let encoding: u32 = 0xF5700040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_dsb_a1_a_field_option_1_poweroftwo_40_f5700041() {
    // Encoding: 0xF5700041
    // Test aarch32_DSB_A1_A field option = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: option=1
    let encoding: u32 = 0xF5700041;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_dsb_a1_a_field_option_2_poweroftwo_40_f5700042() {
    // Encoding: 0xF5700042
    // Test aarch32_DSB_A1_A field option = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: option=2
    let encoding: u32 = 0xF5700042;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_dsb_a1_a_field_option_3_poweroftwo_40_f5700043() {
    // Encoding: 0xF5700043
    // Test aarch32_DSB_A1_A field option = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: option=3
    let encoding: u32 = 0xF5700043;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_dsb_a1_a_field_option_4_poweroftwo_40_f5700044() {
    // Encoding: 0xF5700044
    // Test aarch32_DSB_A1_A field option = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: option=4
    let encoding: u32 = 0xF5700044;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_dsb_a1_a_field_option_5_poweroftwo_40_f5700045() {
    // Encoding: 0xF5700045
    // Test aarch32_DSB_A1_A field option = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: option=5
    let encoding: u32 = 0xF5700045;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_dsb_a1_a_field_option_6_poweroftwo_40_f5700046() {
    // Encoding: 0xF5700046
    // Test aarch32_DSB_A1_A field option = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: option=6
    let encoding: u32 = 0xF5700046;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_dsb_a1_a_field_option_7_poweroftwo_40_f5700047() {
    // Encoding: 0xF5700047
    // Test aarch32_DSB_A1_A field option = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: option=7
    let encoding: u32 = 0xF5700047;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_dsb_a1_a_field_option_8_poweroftwo_40_f5700048() {
    // Encoding: 0xF5700048
    // Test aarch32_DSB_A1_A field option = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: option=8
    let encoding: u32 = 0xF5700048;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_dsb_a1_a_field_option_9_poweroftwo_40_f5700049() {
    // Encoding: 0xF5700049
    // Test aarch32_DSB_A1_A field option = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: option=9
    let encoding: u32 = 0xF5700049;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_dsb_a1_a_field_option_10_poweroftwo_40_f570004a() {
    // Encoding: 0xF570004A
    // Test aarch32_DSB_A1_A field option = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: option=10
    let encoding: u32 = 0xF570004A;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_dsb_a1_a_field_option_11_poweroftwo_40_f570004b() {
    // Encoding: 0xF570004B
    // Test aarch32_DSB_A1_A field option = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: option=11
    let encoding: u32 = 0xF570004B;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_dsb_a1_a_field_option_12_poweroftwo_40_f570004c() {
    // Encoding: 0xF570004C
    // Test aarch32_DSB_A1_A field option = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: option=12
    let encoding: u32 = 0xF570004C;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_dsb_a1_a_field_option_13_poweroftwo_40_f570004d() {
    // Encoding: 0xF570004D
    // Test aarch32_DSB_A1_A field option = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: option=13
    let encoding: u32 = 0xF570004D;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_dsb_a1_a_field_option_14_poweroftwo_40_f570004e() {
    // Encoding: 0xF570004E
    // Test aarch32_DSB_A1_A field option = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: option=14
    let encoding: u32 = 0xF570004E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_dsb_a1_a_field_option_15_max_40_f570004f() {
    // Encoding: 0xF570004F
    // Test aarch32_DSB_A1_A field option = 15 (Max)
    // ISET: A32
    // Fields: option=15
    let encoding: u32 = 0xF570004F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_dsb_a1_a_combo_0_40_f5700040() {
    // Encoding: 0xF5700040
    // Test aarch32_DSB_A1_A field combination: option=0
    // ISET: A32
    // Fields: option=0
    let encoding: u32 = 0xF5700040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_dsb_t1_a_field_option_0_min_8040_f3b08040() {
    // Thumb encoding (32): 0xF3B08040
    // Test aarch32_DSB_T1_A field option = 0 (Min)
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_dsb_t1_a_field_option_1_poweroftwo_8040_f3b08041() {
    // Thumb encoding (32): 0xF3B08041
    // Test aarch32_DSB_T1_A field option = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: option=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08041;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_dsb_t1_a_field_option_2_poweroftwo_8040_f3b08042() {
    // Thumb encoding (32): 0xF3B08042
    // Test aarch32_DSB_T1_A field option = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: option=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08042;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_dsb_t1_a_field_option_3_poweroftwo_8040_f3b08043() {
    // Thumb encoding (32): 0xF3B08043
    // Test aarch32_DSB_T1_A field option = 3 (PowerOfTwo)
    // ISET: T32
    // Fields: option=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08043;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_dsb_t1_a_field_option_4_poweroftwo_8040_f3b08044() {
    // Thumb encoding (32): 0xF3B08044
    // Test aarch32_DSB_T1_A field option = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: option=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08044;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_dsb_t1_a_field_option_5_poweroftwo_8040_f3b08045() {
    // Thumb encoding (32): 0xF3B08045
    // Test aarch32_DSB_T1_A field option = 5 (PowerOfTwo)
    // ISET: T32
    // Fields: option=5
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08045;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_dsb_t1_a_field_option_6_poweroftwo_8040_f3b08046() {
    // Thumb encoding (32): 0xF3B08046
    // Test aarch32_DSB_T1_A field option = 6 (PowerOfTwo)
    // ISET: T32
    // Fields: option=6
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08046;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_dsb_t1_a_field_option_7_poweroftwo_8040_f3b08047() {
    // Thumb encoding (32): 0xF3B08047
    // Test aarch32_DSB_T1_A field option = 7 (PowerOfTwo)
    // ISET: T32
    // Fields: option=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08047;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_dsb_t1_a_field_option_8_poweroftwo_8040_f3b08048() {
    // Thumb encoding (32): 0xF3B08048
    // Test aarch32_DSB_T1_A field option = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: option=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08048;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_dsb_t1_a_field_option_9_poweroftwo_8040_f3b08049() {
    // Thumb encoding (32): 0xF3B08049
    // Test aarch32_DSB_T1_A field option = 9 (PowerOfTwo)
    // ISET: T32
    // Fields: option=9
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08049;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_dsb_t1_a_field_option_10_poweroftwo_8040_f3b0804a() {
    // Thumb encoding (32): 0xF3B0804A
    // Test aarch32_DSB_T1_A field option = 10 (PowerOfTwo)
    // ISET: T32
    // Fields: option=10
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0804A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_dsb_t1_a_field_option_11_poweroftwo_8040_f3b0804b() {
    // Thumb encoding (32): 0xF3B0804B
    // Test aarch32_DSB_T1_A field option = 11 (PowerOfTwo)
    // ISET: T32
    // Fields: option=11
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0804B;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_dsb_t1_a_field_option_12_poweroftwo_8040_f3b0804c() {
    // Thumb encoding (32): 0xF3B0804C
    // Test aarch32_DSB_T1_A field option = 12 (PowerOfTwo)
    // ISET: T32
    // Fields: option=12
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0804C;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_dsb_t1_a_field_option_13_poweroftwo_8040_f3b0804d() {
    // Thumb encoding (32): 0xF3B0804D
    // Test aarch32_DSB_T1_A field option = 13 (PowerOfTwo)
    // ISET: T32
    // Fields: option=13
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0804D;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_dsb_t1_a_field_option_14_poweroftwo_8040_f3b0804e() {
    // Thumb encoding (32): 0xF3B0804E
    // Test aarch32_DSB_T1_A field option = 14 (PowerOfTwo)
    // ISET: T32
    // Fields: option=14
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0804E;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_dsb_t1_a_field_option_15_max_8040_f3b0804f() {
    // Thumb encoding (32): 0xF3B0804F
    // Test aarch32_DSB_T1_A field option = 15 (Max)
    // ISET: T32
    // Fields: option=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0804F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DSB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_dsb_t1_a_combo_0_8040_f3b08040() {
    // Thumb encoding (32): 0xF3B08040
    // Test aarch32_DSB_T1_A field combination: option=0
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

// ============================================================================
// aarch32_MSR_i_AS Tests
// ============================================================================

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_0_min_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: mask=0, R=0, imm12=0, cond=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_1_poweroftwo_0_13200000() {
    // Encoding: 0x13200000
    // Test aarch32_MSR_i_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, mask=0, cond=1, imm12=0
    let encoding: u32 = 0x13200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_2_poweroftwo_0_23200000() {
    // Encoding: 0x23200000
    // Test aarch32_MSR_i_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm12=0, R=0, mask=0
    let encoding: u32 = 0x23200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_3_poweroftwo_0_33200000() {
    // Encoding: 0x33200000
    // Test aarch32_MSR_i_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, imm12=0, mask=0, cond=3
    let encoding: u32 = 0x33200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_4_poweroftwo_0_43200000() {
    // Encoding: 0x43200000
    // Test aarch32_MSR_i_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=4, mask=0, imm12=0
    let encoding: u32 = 0x43200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_5_poweroftwo_0_53200000() {
    // Encoding: 0x53200000
    // Test aarch32_MSR_i_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, mask=0, cond=5, R=0
    let encoding: u32 = 0x53200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_6_poweroftwo_0_63200000() {
    // Encoding: 0x63200000
    // Test aarch32_MSR_i_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: mask=0, cond=6, R=0, imm12=0
    let encoding: u32 = 0x63200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_7_poweroftwo_0_73200000() {
    // Encoding: 0x73200000
    // Test aarch32_MSR_i_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, R=0, imm12=0, mask=0
    let encoding: u32 = 0x73200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_8_poweroftwo_0_83200000() {
    // Encoding: 0x83200000
    // Test aarch32_MSR_i_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm12=0, R=0, mask=0
    let encoding: u32 = 0x83200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_9_poweroftwo_0_93200000() {
    // Encoding: 0x93200000
    // Test aarch32_MSR_i_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=9, mask=0, R=0
    let encoding: u32 = 0x93200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_10_poweroftwo_0_a3200000() {
    // Encoding: 0xA3200000
    // Test aarch32_MSR_i_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: mask=0, R=0, imm12=0, cond=10
    let encoding: u32 = 0xA3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_11_poweroftwo_0_b3200000() {
    // Encoding: 0xB3200000
    // Test aarch32_MSR_i_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: mask=0, cond=11, imm12=0, R=0
    let encoding: u32 = 0xB3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_12_poweroftwo_0_c3200000() {
    // Encoding: 0xC3200000
    // Test aarch32_MSR_i_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm12=0, R=0, mask=0
    let encoding: u32 = 0xC3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_13_poweroftwo_0_d3200000() {
    // Encoding: 0xD3200000
    // Test aarch32_MSR_i_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=13, imm12=0, mask=0
    let encoding: u32 = 0xD3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_14_poweroftwo_0_e3200000() {
    // Encoding: 0xE3200000
    // Test aarch32_MSR_i_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=14, imm12=0, mask=0
    let encoding: u32 = 0xE3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_msr_i_a1_as_field_cond_15_max_0_f3200000() {
    // Encoding: 0xF3200000
    // Test aarch32_MSR_i_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: mask=0, imm12=0, R=0, cond=15
    let encoding: u32 = 0xF3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_i_a1_as_field_r_0_min_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS field R = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, mask=0, R=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_i_a1_as_field_r_1_max_0_03600000() {
    // Encoding: 0x03600000
    // Test aarch32_MSR_i_A1_AS field R = 1 (Max)
    // ISET: A32
    // Fields: R=1, mask=0, imm12=0, cond=0
    let encoding: u32 = 0x03600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_i_a1_as_field_mask_0_min_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS field mask = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, mask=0, R=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_msr_i_a1_as_field_mask_1_poweroftwo_0_03210000() {
    // Encoding: 0x03210000
    // Test aarch32_MSR_i_A1_AS field mask = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, R=0, mask=1, cond=0
    let encoding: u32 = 0x03210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_msr_i_a1_as_field_mask_7_poweroftwominusone_0_03270000() {
    // Encoding: 0x03270000
    // Test aarch32_MSR_i_A1_AS field mask = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=0, R=0, mask=7
    let encoding: u32 = 0x03270000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field mask 16 +: 4`
/// Requirement: FieldBoundary { field: "mask", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_msr_i_a1_as_field_mask_15_max_0_032f0000() {
    // Encoding: 0x032F0000
    // Test aarch32_MSR_i_A1_AS field mask = 15 (Max)
    // ISET: A32
    // Fields: imm12=0, R=0, mask=15, cond=0
    let encoding: u32 = 0x032F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_0_zero_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, R=0, imm12=0, mask=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_1_poweroftwo_0_03200001() {
    // Encoding: 0x03200001
    // Test aarch32_MSR_i_A1_AS field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, R=0, mask=0, cond=0
    let encoding: u32 = 0x03200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_3_poweroftwominusone_0_03200003() {
    // Encoding: 0x03200003
    // Test aarch32_MSR_i_A1_AS field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, R=0, mask=0, imm12=3
    let encoding: u32 = 0x03200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_4_poweroftwo_0_03200004() {
    // Encoding: 0x03200004
    // Test aarch32_MSR_i_A1_AS field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, cond=0, mask=0, R=0
    let encoding: u32 = 0x03200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_7_poweroftwominusone_0_03200007() {
    // Encoding: 0x03200007
    // Test aarch32_MSR_i_A1_AS field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, mask=0, R=0, imm12=7
    let encoding: u32 = 0x03200007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_8_poweroftwo_0_03200008() {
    // Encoding: 0x03200008
    // Test aarch32_MSR_i_A1_AS field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, R=0, cond=0, mask=0
    let encoding: u32 = 0x03200008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_15_poweroftwominusone_0_0320000f() {
    // Encoding: 0x0320000F
    // Test aarch32_MSR_i_A1_AS field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, mask=0, R=0, imm12=15
    let encoding: u32 = 0x0320000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_16_poweroftwo_0_03200010() {
    // Encoding: 0x03200010
    // Test aarch32_MSR_i_A1_AS field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=16, mask=0, R=0, cond=0
    let encoding: u32 = 0x03200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_31_poweroftwominusone_0_0320001f() {
    // Encoding: 0x0320001F
    // Test aarch32_MSR_i_A1_AS field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: mask=0, R=0, imm12=31, cond=0
    let encoding: u32 = 0x0320001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_32_poweroftwo_0_03200020() {
    // Encoding: 0x03200020
    // Test aarch32_MSR_i_A1_AS field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, mask=0, imm12=32, cond=0
    let encoding: u32 = 0x03200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_63_poweroftwominusone_0_0320003f() {
    // Encoding: 0x0320003F
    // Test aarch32_MSR_i_A1_AS field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, mask=0, R=0, cond=0
    let encoding: u32 = 0x0320003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_64_poweroftwo_0_03200040() {
    // Encoding: 0x03200040
    // Test aarch32_MSR_i_A1_AS field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, imm12=64, cond=0, mask=0
    let encoding: u32 = 0x03200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_127_poweroftwominusone_0_0320007f() {
    // Encoding: 0x0320007F
    // Test aarch32_MSR_i_A1_AS field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, mask=0, cond=0, R=0
    let encoding: u32 = 0x0320007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_128_poweroftwo_0_03200080() {
    // Encoding: 0x03200080
    // Test aarch32_MSR_i_A1_AS field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=128, mask=0, cond=0, R=0
    let encoding: u32 = 0x03200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_255_poweroftwominusone_0_032000ff() {
    // Encoding: 0x032000FF
    // Test aarch32_MSR_i_A1_AS field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, mask=0, R=0, imm12=255
    let encoding: u32 = 0x032000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_256_poweroftwo_0_03200100() {
    // Encoding: 0x03200100
    // Test aarch32_MSR_i_A1_AS field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: mask=0, cond=0, R=0, imm12=256
    let encoding: u32 = 0x03200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_511_poweroftwominusone_0_032001ff() {
    // Encoding: 0x032001FF
    // Test aarch32_MSR_i_A1_AS field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, mask=0, R=0, imm12=511
    let encoding: u32 = 0x032001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_512_poweroftwo_0_03200200() {
    // Encoding: 0x03200200
    // Test aarch32_MSR_i_A1_AS field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, cond=0, R=0, mask=0
    let encoding: u32 = 0x03200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_1023_poweroftwominusone_0_032003ff() {
    // Encoding: 0x032003FF
    // Test aarch32_MSR_i_A1_AS field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=1023, mask=0, cond=0, R=0
    let encoding: u32 = 0x032003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_1024_poweroftwo_0_03200400() {
    // Encoding: 0x03200400
    // Test aarch32_MSR_i_A1_AS field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, imm12=1024, cond=0, mask=0
    let encoding: u32 = 0x03200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_2047_poweroftwominusone_0_032007ff() {
    // Encoding: 0x032007FF
    // Test aarch32_MSR_i_A1_AS field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, R=0, mask=0, imm12=2047
    let encoding: u32 = 0x032007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_2048_poweroftwo_0_03200800() {
    // Encoding: 0x03200800
    // Test aarch32_MSR_i_A1_AS field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, mask=0, R=0, imm12=2048
    let encoding: u32 = 0x03200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_msr_i_a1_as_field_imm12_4095_max_0_03200fff() {
    // Encoding: 0x03200FFF
    // Test aarch32_MSR_i_A1_AS field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: R=0, cond=0, mask=0, imm12=4095
    let encoding: u32 = 0x03200FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_msr_i_a1_as_combo_0_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS field combination: cond=0, R=0, mask=0, imm12=0
    // ISET: A32
    // Fields: R=0, mask=0, cond=0, imm12=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_0_condition_eq_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, mask=0, R=0, imm12=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_1_condition_ne_0_13200000() {
    // Encoding: 0x13200000
    // Test aarch32_MSR_i_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, R=0, mask=0, cond=1
    let encoding: u32 = 0x13200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_2_condition_cs_hs_0_23200000() {
    // Encoding: 0x23200000
    // Test aarch32_MSR_i_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, R=0, cond=2, mask=0
    let encoding: u32 = 0x23200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_3_condition_cc_lo_0_33200000() {
    // Encoding: 0x33200000
    // Test aarch32_MSR_i_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, R=0, mask=0, imm12=0
    let encoding: u32 = 0x33200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_4_condition_mi_0_43200000() {
    // Encoding: 0x43200000
    // Test aarch32_MSR_i_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: R=0, cond=4, imm12=0, mask=0
    let encoding: u32 = 0x43200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_5_condition_pl_0_53200000() {
    // Encoding: 0x53200000
    // Test aarch32_MSR_i_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm12=0, R=0, mask=0
    let encoding: u32 = 0x53200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_6_condition_vs_0_63200000() {
    // Encoding: 0x63200000
    // Test aarch32_MSR_i_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, mask=0, R=0, imm12=0
    let encoding: u32 = 0x63200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_7_condition_vc_0_73200000() {
    // Encoding: 0x73200000
    // Test aarch32_MSR_i_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, R=0, mask=0, imm12=0
    let encoding: u32 = 0x73200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_8_condition_hi_0_83200000() {
    // Encoding: 0x83200000
    // Test aarch32_MSR_i_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm12=0, R=0, cond=8, mask=0
    let encoding: u32 = 0x83200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_9_condition_ls_0_93200000() {
    // Encoding: 0x93200000
    // Test aarch32_MSR_i_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, cond=9, mask=0, R=0
    let encoding: u32 = 0x93200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_10_condition_ge_0_a3200000() {
    // Encoding: 0xA3200000
    // Test aarch32_MSR_i_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: mask=0, R=0, cond=10, imm12=0
    let encoding: u32 = 0xA3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_11_condition_lt_0_b3200000() {
    // Encoding: 0xB3200000
    // Test aarch32_MSR_i_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: mask=0, cond=11, imm12=0, R=0
    let encoding: u32 = 0xB3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_12_condition_gt_0_c3200000() {
    // Encoding: 0xC3200000
    // Test aarch32_MSR_i_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: mask=0, imm12=0, R=0, cond=12
    let encoding: u32 = 0xC3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_13_condition_le_0_d3200000() {
    // Encoding: 0xD3200000
    // Test aarch32_MSR_i_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: R=0, imm12=0, mask=0, cond=13
    let encoding: u32 = 0xD3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_14_condition_al_0_e3200000() {
    // Encoding: 0xE3200000
    // Test aarch32_MSR_i_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: R=0, cond=14, mask=0, imm12=0
    let encoding: u32 = 0xE3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_msr_i_a1_as_special_cond_15_condition_nv_0_f3200000() {
    // Encoding: 0xF3200000
    // Test aarch32_MSR_i_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm12=0, cond=15, mask=0, R=0
    let encoding: u32 = 0xF3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mask" }), rhs: LitBits([false, false, false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"mask\" }), rhs: LitBits([false, false, false, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_i_a1_as_invalid_0_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "mask" }), rhs: LitBits([false, false, false, false]) }
    // ISET: A32
    // Fields: cond=0, mask=0, imm12=0, R=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_i_a1_as_invalid_1_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_MSR_i_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm12=0, cond=0, R=0, mask=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_msr_i_a1_as_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_MSR_i_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_i_a1_as_exception_0_03200000() {
    // Test aarch32_MSR_i_A1_AS exception: Unpredictable
    // Encoding: 0x03200000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x03200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_WFI_A Tests
// ============================================================================

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_0_min_3_03200003() {
    // Encoding: 0x03200003
    // Test aarch32_WFI_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_1_poweroftwo_3_13200003() {
    // Encoding: 0x13200003
    // Test aarch32_WFI_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_2_poweroftwo_3_23200003() {
    // Encoding: 0x23200003
    // Test aarch32_WFI_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_3_poweroftwo_3_33200003() {
    // Encoding: 0x33200003
    // Test aarch32_WFI_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_4_poweroftwo_3_43200003() {
    // Encoding: 0x43200003
    // Test aarch32_WFI_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_5_poweroftwo_3_53200003() {
    // Encoding: 0x53200003
    // Test aarch32_WFI_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_6_poweroftwo_3_63200003() {
    // Encoding: 0x63200003
    // Test aarch32_WFI_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_7_poweroftwo_3_73200003() {
    // Encoding: 0x73200003
    // Test aarch32_WFI_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_8_poweroftwo_3_83200003() {
    // Encoding: 0x83200003
    // Test aarch32_WFI_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_9_poweroftwo_3_93200003() {
    // Encoding: 0x93200003
    // Test aarch32_WFI_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_10_poweroftwo_3_a3200003() {
    // Encoding: 0xA3200003
    // Test aarch32_WFI_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_11_poweroftwo_3_b3200003() {
    // Encoding: 0xB3200003
    // Test aarch32_WFI_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_12_poweroftwo_3_c3200003() {
    // Encoding: 0xC3200003
    // Test aarch32_WFI_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_13_poweroftwo_3_d3200003() {
    // Encoding: 0xD3200003
    // Test aarch32_WFI_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_14_poweroftwo_3_e3200003() {
    // Encoding: 0xE3200003
    // Test aarch32_WFI_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_wfi_a1_a_field_cond_15_max_3_f3200003() {
    // Encoding: 0xF3200003
    // Test aarch32_WFI_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_wfi_a1_a_combo_0_3_03200003() {
    // Encoding: 0x03200003
    // Test aarch32_WFI_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_wfi_a1_a_special_cond_0_condition_eq_3_03200003() {
    // Encoding: 0x03200003
    // Test aarch32_WFI_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_wfi_a1_a_special_cond_1_condition_ne_3_13200003() {
    // Encoding: 0x13200003
    // Test aarch32_WFI_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_wfi_a1_a_special_cond_2_condition_cs_hs_3_23200003() {
    // Encoding: 0x23200003
    // Test aarch32_WFI_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_wfi_a1_a_special_cond_3_condition_cc_lo_3_33200003() {
    // Encoding: 0x33200003
    // Test aarch32_WFI_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_wfi_a1_a_special_cond_4_condition_mi_3_43200003() {
    // Encoding: 0x43200003
    // Test aarch32_WFI_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_wfi_a1_a_special_cond_5_condition_pl_3_53200003() {
    // Encoding: 0x53200003
    // Test aarch32_WFI_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_wfi_a1_a_special_cond_6_condition_vs_3_63200003() {
    // Encoding: 0x63200003
    // Test aarch32_WFI_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_wfi_a1_a_special_cond_7_condition_vc_3_73200003() {
    // Encoding: 0x73200003
    // Test aarch32_WFI_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_wfi_a1_a_special_cond_8_condition_hi_3_83200003() {
    // Encoding: 0x83200003
    // Test aarch32_WFI_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_wfi_a1_a_special_cond_9_condition_ls_3_93200003() {
    // Encoding: 0x93200003
    // Test aarch32_WFI_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_wfi_a1_a_special_cond_10_condition_ge_3_a3200003() {
    // Encoding: 0xA3200003
    // Test aarch32_WFI_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_wfi_a1_a_special_cond_11_condition_lt_3_b3200003() {
    // Encoding: 0xB3200003
    // Test aarch32_WFI_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_wfi_a1_a_special_cond_12_condition_gt_3_c3200003() {
    // Encoding: 0xC3200003
    // Test aarch32_WFI_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_wfi_a1_a_special_cond_13_condition_le_3_d3200003() {
    // Encoding: 0xD3200003
    // Test aarch32_WFI_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_wfi_a1_a_special_cond_14_condition_al_3_e3200003() {
    // Encoding: 0xE3200003
    // Test aarch32_WFI_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_wfi_a1_a_special_cond_15_condition_nv_3_f3200003() {
    // Encoding: 0xF3200003
    // Test aarch32_WFI_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_wfi_t1_a_basic_encoding_bf300000() {
    // Thumb encoding (32): 0xBF300000
    // Test aarch32_WFI_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBF300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_WFI_T2_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_wfi_t2_a_basic_encoding_f3a08003() {
    // Thumb encoding (32): 0xF3A08003
    // Test aarch32_WFI_T2_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_wfi_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_32_0_bf320020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_64_0_bf320020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_32_1_bf320020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_64_1_bf320020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_32_2_bf320020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_64_2_bf320020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_32_3_bf320020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_64_3_bf320020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_32_4_bf320020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_64_4_bf320020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_32_5_bf320020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_wfi_t1_a_lslv_oracle_64_5_bf320020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_wfi_t1_a_t16_oracle_0_bf300000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_wfi_t1_a_t16_oracle_1_bf300000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_wfi_t1_a_t16_oracle_2_bf300000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_WFI_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_wfi_t1_a_t16_oracle_3_bf300000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_SEV_A Tests
// ============================================================================

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sev_a1_a_field_cond_0_min_4_03200004() {
    // Encoding: 0x03200004
    // Test aarch32_SEV_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sev_a1_a_field_cond_1_poweroftwo_4_13200004() {
    // Encoding: 0x13200004
    // Test aarch32_SEV_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sev_a1_a_field_cond_2_poweroftwo_4_23200004() {
    // Encoding: 0x23200004
    // Test aarch32_SEV_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sev_a1_a_field_cond_3_poweroftwo_4_33200004() {
    // Encoding: 0x33200004
    // Test aarch32_SEV_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sev_a1_a_field_cond_4_poweroftwo_4_43200004() {
    // Encoding: 0x43200004
    // Test aarch32_SEV_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sev_a1_a_field_cond_5_poweroftwo_4_53200004() {
    // Encoding: 0x53200004
    // Test aarch32_SEV_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sev_a1_a_field_cond_6_poweroftwo_4_63200004() {
    // Encoding: 0x63200004
    // Test aarch32_SEV_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sev_a1_a_field_cond_7_poweroftwo_4_73200004() {
    // Encoding: 0x73200004
    // Test aarch32_SEV_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sev_a1_a_field_cond_8_poweroftwo_4_83200004() {
    // Encoding: 0x83200004
    // Test aarch32_SEV_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sev_a1_a_field_cond_9_poweroftwo_4_93200004() {
    // Encoding: 0x93200004
    // Test aarch32_SEV_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sev_a1_a_field_cond_10_poweroftwo_4_a3200004() {
    // Encoding: 0xA3200004
    // Test aarch32_SEV_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sev_a1_a_field_cond_11_poweroftwo_4_b3200004() {
    // Encoding: 0xB3200004
    // Test aarch32_SEV_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sev_a1_a_field_cond_12_poweroftwo_4_c3200004() {
    // Encoding: 0xC3200004
    // Test aarch32_SEV_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sev_a1_a_field_cond_13_poweroftwo_4_d3200004() {
    // Encoding: 0xD3200004
    // Test aarch32_SEV_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sev_a1_a_field_cond_14_poweroftwo_4_e3200004() {
    // Encoding: 0xE3200004
    // Test aarch32_SEV_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sev_a1_a_field_cond_15_max_4_f3200004() {
    // Encoding: 0xF3200004
    // Test aarch32_SEV_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sev_a1_a_combo_0_4_03200004() {
    // Encoding: 0x03200004
    // Test aarch32_SEV_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sev_a1_a_special_cond_0_condition_eq_4_03200004() {
    // Encoding: 0x03200004
    // Test aarch32_SEV_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sev_a1_a_special_cond_1_condition_ne_4_13200004() {
    // Encoding: 0x13200004
    // Test aarch32_SEV_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sev_a1_a_special_cond_2_condition_cs_hs_4_23200004() {
    // Encoding: 0x23200004
    // Test aarch32_SEV_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sev_a1_a_special_cond_3_condition_cc_lo_4_33200004() {
    // Encoding: 0x33200004
    // Test aarch32_SEV_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sev_a1_a_special_cond_4_condition_mi_4_43200004() {
    // Encoding: 0x43200004
    // Test aarch32_SEV_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sev_a1_a_special_cond_5_condition_pl_4_53200004() {
    // Encoding: 0x53200004
    // Test aarch32_SEV_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sev_a1_a_special_cond_6_condition_vs_4_63200004() {
    // Encoding: 0x63200004
    // Test aarch32_SEV_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sev_a1_a_special_cond_7_condition_vc_4_73200004() {
    // Encoding: 0x73200004
    // Test aarch32_SEV_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sev_a1_a_special_cond_8_condition_hi_4_83200004() {
    // Encoding: 0x83200004
    // Test aarch32_SEV_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sev_a1_a_special_cond_9_condition_ls_4_93200004() {
    // Encoding: 0x93200004
    // Test aarch32_SEV_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sev_a1_a_special_cond_10_condition_ge_4_a3200004() {
    // Encoding: 0xA3200004
    // Test aarch32_SEV_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sev_a1_a_special_cond_11_condition_lt_4_b3200004() {
    // Encoding: 0xB3200004
    // Test aarch32_SEV_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sev_a1_a_special_cond_12_condition_gt_4_c3200004() {
    // Encoding: 0xC3200004
    // Test aarch32_SEV_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sev_a1_a_special_cond_13_condition_le_4_d3200004() {
    // Encoding: 0xD3200004
    // Test aarch32_SEV_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sev_a1_a_special_cond_14_condition_al_4_e3200004() {
    // Encoding: 0xE3200004
    // Test aarch32_SEV_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sev_a1_a_special_cond_15_condition_nv_4_f3200004() {
    // Encoding: 0xF3200004
    // Test aarch32_SEV_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_sev_t1_a_basic_encoding_bf400000() {
    // Thumb encoding (32): 0xBF400000
    // Test aarch32_SEV_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBF400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEV_T2_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_sev_t2_a_basic_encoding_f3a08004() {
    // Thumb encoding (32): 0xF3A08004
    // Test aarch32_SEV_T2_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_sev_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_32_0_bf420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_64_0_bf420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_32_1_bf420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_64_1_bf420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_32_2_bf420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_64_2_bf420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_32_3_bf420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_64_3_bf420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_32_4_bf420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_64_4_bf420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_32_5_bf420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sev_t1_a_lslv_oracle_64_5_bf420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sev_t1_a_t16_oracle_0_bf400000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sev_t1_a_t16_oracle_1_bf400000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sev_t1_a_t16_oracle_2_bf400000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SEV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sev_t1_a_t16_oracle_3_bf400000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_BKPT_A Tests
// ============================================================================

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_0_min_70_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, imm4=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_1_poweroftwo_70_11200070() {
    // Encoding: 0x11200070
    // Test aarch32_BKPT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=1
    let encoding: u32 = 0x11200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_2_poweroftwo_70_21200070() {
    // Encoding: 0x21200070
    // Test aarch32_BKPT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm4=0, imm12=0
    let encoding: u32 = 0x21200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_3_poweroftwo_70_31200070() {
    // Encoding: 0x31200070
    // Test aarch32_BKPT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=3
    let encoding: u32 = 0x31200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_4_poweroftwo_70_41200070() {
    // Encoding: 0x41200070
    // Test aarch32_BKPT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, imm12=0, imm4=0
    let encoding: u32 = 0x41200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_5_poweroftwo_70_51200070() {
    // Encoding: 0x51200070
    // Test aarch32_BKPT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=5, imm4=0
    let encoding: u32 = 0x51200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_6_poweroftwo_70_61200070() {
    // Encoding: 0x61200070
    // Test aarch32_BKPT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=6
    let encoding: u32 = 0x61200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_7_poweroftwo_70_71200070() {
    // Encoding: 0x71200070
    // Test aarch32_BKPT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=7, imm4=0
    let encoding: u32 = 0x71200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_8_poweroftwo_70_81200070() {
    // Encoding: 0x81200070
    // Test aarch32_BKPT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm12=0, imm4=0
    let encoding: u32 = 0x81200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_9_poweroftwo_70_91200070() {
    // Encoding: 0x91200070
    // Test aarch32_BKPT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=9, imm12=0
    let encoding: u32 = 0x91200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_10_poweroftwo_70_a1200070() {
    // Encoding: 0xA1200070
    // Test aarch32_BKPT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=10, imm12=0
    let encoding: u32 = 0xA1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_11_poweroftwo_70_b1200070() {
    // Encoding: 0xB1200070
    // Test aarch32_BKPT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm4=0, imm12=0
    let encoding: u32 = 0xB1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_12_poweroftwo_70_c1200070() {
    // Encoding: 0xC1200070
    // Test aarch32_BKPT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm4=0, imm12=0
    let encoding: u32 = 0xC1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_13_poweroftwo_70_d1200070() {
    // Encoding: 0xD1200070
    // Test aarch32_BKPT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, imm4=0, imm12=0
    let encoding: u32 = 0xD1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_14_poweroftwo_70_e1200070() {
    // Encoding: 0xE1200070
    // Test aarch32_BKPT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=14, imm12=0
    let encoding: u32 = 0xE1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_bkpt_a1_a_field_cond_15_max_70_f1200070() {
    // Encoding: 0xF1200070
    // Test aarch32_BKPT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm4=0, cond=15, imm12=0
    let encoding: u32 = 0xF1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_0_zero_70_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_1_poweroftwo_70_01200170() {
    // Encoding: 0x01200170
    // Test aarch32_BKPT_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, imm4=0, cond=0
    let encoding: u32 = 0x01200170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_3_poweroftwominusone_70_01200370() {
    // Encoding: 0x01200370
    // Test aarch32_BKPT_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=3, imm4=0
    let encoding: u32 = 0x01200370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_4_poweroftwo_70_01200470() {
    // Encoding: 0x01200470
    // Test aarch32_BKPT_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=4, imm4=0
    let encoding: u32 = 0x01200470;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_7_poweroftwominusone_70_01200770() {
    // Encoding: 0x01200770
    // Test aarch32_BKPT_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=7, cond=0
    let encoding: u32 = 0x01200770;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_8_poweroftwo_70_01200870() {
    // Encoding: 0x01200870
    // Test aarch32_BKPT_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=8, imm4=0
    let encoding: u32 = 0x01200870;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_15_poweroftwominusone_70_01200f70() {
    // Encoding: 0x01200F70
    // Test aarch32_BKPT_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=15, cond=0
    let encoding: u32 = 0x01200F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_16_poweroftwo_70_01201070() {
    // Encoding: 0x01201070
    // Test aarch32_BKPT_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=16
    let encoding: u32 = 0x01201070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_31_poweroftwominusone_70_01201f70() {
    // Encoding: 0x01201F70
    // Test aarch32_BKPT_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=31
    let encoding: u32 = 0x01201F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_32_poweroftwo_70_01202070() {
    // Encoding: 0x01202070
    // Test aarch32_BKPT_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=32
    let encoding: u32 = 0x01202070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_63_poweroftwominusone_70_01203f70() {
    // Encoding: 0x01203F70
    // Test aarch32_BKPT_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=63, imm4=0
    let encoding: u32 = 0x01203F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_64_poweroftwo_70_01204070() {
    // Encoding: 0x01204070
    // Test aarch32_BKPT_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=64, imm4=0
    let encoding: u32 = 0x01204070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_127_poweroftwominusone_70_01207f70() {
    // Encoding: 0x01207F70
    // Test aarch32_BKPT_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=127
    let encoding: u32 = 0x01207F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_128_poweroftwo_70_01208070() {
    // Encoding: 0x01208070
    // Test aarch32_BKPT_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=128
    let encoding: u32 = 0x01208070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_255_poweroftwominusone_70_0120ff70() {
    // Encoding: 0x0120FF70
    // Test aarch32_BKPT_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=255, cond=0
    let encoding: u32 = 0x0120FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_256_poweroftwo_70_01210070() {
    // Encoding: 0x01210070
    // Test aarch32_BKPT_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=256
    let encoding: u32 = 0x01210070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_511_poweroftwominusone_70_0121ff70() {
    // Encoding: 0x0121FF70
    // Test aarch32_BKPT_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=511
    let encoding: u32 = 0x0121FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_512_poweroftwo_70_01220070() {
    // Encoding: 0x01220070
    // Test aarch32_BKPT_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=512, imm4=0
    let encoding: u32 = 0x01220070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_1023_poweroftwominusone_70_0123ff70() {
    // Encoding: 0x0123FF70
    // Test aarch32_BKPT_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=1023, cond=0
    let encoding: u32 = 0x0123FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_1024_poweroftwo_70_01240070() {
    // Encoding: 0x01240070
    // Test aarch32_BKPT_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=1024
    let encoding: u32 = 0x01240070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_2047_poweroftwominusone_70_0127ff70() {
    // Encoding: 0x0127FF70
    // Test aarch32_BKPT_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=2047, cond=0
    let encoding: u32 = 0x0127FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_2048_poweroftwo_70_01280070() {
    // Encoding: 0x01280070
    // Test aarch32_BKPT_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=2048, cond=0
    let encoding: u32 = 0x01280070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm12_4095_max_70_012fff70() {
    // Encoding: 0x012FFF70
    // Test aarch32_BKPT_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, cond=0, imm4=0
    let encoding: u32 = 0x012FFF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_0_zero_70_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_1_poweroftwo_70_01200071() {
    // Encoding: 0x01200071
    // Test aarch32_BKPT_A1_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=1, cond=0
    let encoding: u32 = 0x01200071;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_3_poweroftwominusone_70_01200073() {
    // Encoding: 0x01200073
    // Test aarch32_BKPT_A1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=0, imm4=3, cond=0
    let encoding: u32 = 0x01200073;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_4_poweroftwo_70_01200074() {
    // Encoding: 0x01200074
    // Test aarch32_BKPT_A1_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=4, cond=0
    let encoding: u32 = 0x01200074;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_7_poweroftwominusone_70_01200077() {
    // Encoding: 0x01200077
    // Test aarch32_BKPT_A1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=7, cond=0, imm12=0
    let encoding: u32 = 0x01200077;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_8_poweroftwo_70_01200078() {
    // Encoding: 0x01200078
    // Test aarch32_BKPT_A1_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=8
    let encoding: u32 = 0x01200078;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_bkpt_a1_a_field_imm4_15_max_70_0120007f() {
    // Encoding: 0x0120007F
    // Test aarch32_BKPT_A1_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: imm12=0, imm4=15, cond=0
    let encoding: u32 = 0x0120007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_bkpt_a1_a_combo_0_70_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A field combination: cond=0, imm12=0, imm4=0
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_0_condition_eq_112_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_1_condition_ne_112_11200070() {
    // Encoding: 0x11200070
    // Test aarch32_BKPT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=1
    let encoding: u32 = 0x11200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_2_condition_cs_hs_112_21200070() {
    // Encoding: 0x21200070
    // Test aarch32_BKPT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, cond=2, imm4=0
    let encoding: u32 = 0x21200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_3_condition_cc_lo_112_31200070() {
    // Encoding: 0x31200070
    // Test aarch32_BKPT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm12=0, imm4=0
    let encoding: u32 = 0x31200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_4_condition_mi_112_41200070() {
    // Encoding: 0x41200070
    // Test aarch32_BKPT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4=0, cond=4, imm12=0
    let encoding: u32 = 0x41200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_5_condition_pl_112_51200070() {
    // Encoding: 0x51200070
    // Test aarch32_BKPT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm4=0, cond=5, imm12=0
    let encoding: u32 = 0x51200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_6_condition_vs_112_61200070() {
    // Encoding: 0x61200070
    // Test aarch32_BKPT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, cond=6, imm4=0
    let encoding: u32 = 0x61200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_7_condition_vc_112_71200070() {
    // Encoding: 0x71200070
    // Test aarch32_BKPT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=7
    let encoding: u32 = 0x71200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_8_condition_hi_112_81200070() {
    // Encoding: 0x81200070
    // Test aarch32_BKPT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm4=0, cond=8, imm12=0
    let encoding: u32 = 0x81200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_9_condition_ls_112_91200070() {
    // Encoding: 0x91200070
    // Test aarch32_BKPT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, cond=9, imm4=0
    let encoding: u32 = 0x91200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_10_condition_ge_112_a1200070() {
    // Encoding: 0xA1200070
    // Test aarch32_BKPT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=10
    let encoding: u32 = 0xA1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_11_condition_lt_112_b1200070() {
    // Encoding: 0xB1200070
    // Test aarch32_BKPT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, imm12=0, imm4=0
    let encoding: u32 = 0xB1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_12_condition_gt_112_c1200070() {
    // Encoding: 0xC1200070
    // Test aarch32_BKPT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm4=0, cond=12, imm12=0
    let encoding: u32 = 0xC1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_13_condition_le_112_d1200070() {
    // Encoding: 0xD1200070
    // Test aarch32_BKPT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm12=0, cond=13, imm4=0
    let encoding: u32 = 0xD1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_14_condition_al_112_e1200070() {
    // Encoding: 0xE1200070
    // Test aarch32_BKPT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=14
    let encoding: u32 = 0xE1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_bkpt_a1_a_special_cond_15_condition_nv_112_f1200070() {
    // Encoding: 0xF1200070
    // Test aarch32_BKPT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=15
    let encoding: u32 = 0xF1200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bkpt_a1_a_invalid_0_70_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BKPT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bkpt_a1_a_invalid_1_70_01200070() {
    // Encoding: 0x01200070
    // Test aarch32_BKPT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=0
    let encoding: u32 = 0x01200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_0_zero_0_be000000() {
    // Thumb encoding (32): 0xBE000000
    // Test aarch32_BKPT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_1_poweroftwo_0_be010000() {
    // Thumb encoding (32): 0xBE010000
    // Test aarch32_BKPT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_3_poweroftwominusone_0_be030000() {
    // Thumb encoding (32): 0xBE030000
    // Test aarch32_BKPT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_4_poweroftwo_0_be040000() {
    // Thumb encoding (32): 0xBE040000
    // Test aarch32_BKPT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_7_poweroftwominusone_0_be070000() {
    // Thumb encoding (32): 0xBE070000
    // Test aarch32_BKPT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_8_poweroftwo_0_be080000() {
    // Thumb encoding (32): 0xBE080000
    // Test aarch32_BKPT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_15_poweroftwominusone_0_be0f0000() {
    // Thumb encoding (32): 0xBE0F0000
    // Test aarch32_BKPT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE0F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_16_poweroftwo_0_be100000() {
    // Thumb encoding (32): 0xBE100000
    // Test aarch32_BKPT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_31_poweroftwominusone_0_be1f0000() {
    // Thumb encoding (32): 0xBE1F0000
    // Test aarch32_BKPT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE1F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_32_poweroftwo_0_be200000() {
    // Thumb encoding (32): 0xBE200000
    // Test aarch32_BKPT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_63_poweroftwominusone_0_be3f0000() {
    // Thumb encoding (32): 0xBE3F0000
    // Test aarch32_BKPT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE3F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_64_poweroftwo_0_be400000() {
    // Thumb encoding (32): 0xBE400000
    // Test aarch32_BKPT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_127_poweroftwominusone_0_be7f0000() {
    // Thumb encoding (32): 0xBE7F0000
    // Test aarch32_BKPT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE7F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_128_poweroftwo_0_be800000() {
    // Thumb encoding (32): 0xBE800000
    // Test aarch32_BKPT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_bkpt_t1_a_field_imm8_255_max_0_beff0000() {
    // Thumb encoding (32): 0xBEFF0000
    // Test aarch32_BKPT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBEFF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_bkpt_t1_a_combo_0_0_be000000() {
    // Thumb encoding (32): 0xBE000000
    // Test aarch32_BKPT_T1_A field combination: imm8=0
    // ISET: T32
    // Fields: imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBE000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_32_0_be020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_64_0_be020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_32_1_be020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_64_1_be020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_32_2_be020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_64_2_be020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_32_3_be020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_64_3_be020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_32_4_be020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_64_4_be020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_32_5_be020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_bkpt_t1_a_lslv_oracle_64_5_be020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_bkpt_t1_a_t16_oracle_0_be000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_bkpt_t1_a_t16_oracle_1_be000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_bkpt_t1_a_t16_oracle_2_be000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BKPT_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_bkpt_t1_a_t16_oracle_3_be000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_MSR_br_AS Tests
// ============================================================================

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_0_min_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, R=0, cond=0, M1=0, M=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_1_poweroftwo_200_11200200() {
    // Encoding: 0x11200200
    // Test aarch32_MSR_br_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M1=0, Rn=0, cond=1, R=0, M=0
    let encoding: u32 = 0x11200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_2_poweroftwo_200_21200200() {
    // Encoding: 0x21200200
    // Test aarch32_MSR_br_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, R=0, M1=0, Rn=0, M=0
    let encoding: u32 = 0x21200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_3_poweroftwo_200_31200200() {
    // Encoding: 0x31200200
    // Test aarch32_MSR_br_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, R=0, cond=3, M1=0, M=0
    let encoding: u32 = 0x31200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_4_poweroftwo_200_41200200() {
    // Encoding: 0x41200200
    // Test aarch32_MSR_br_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=0, cond=4, M1=0, M=0
    let encoding: u32 = 0x41200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_5_poweroftwo_200_51200200() {
    // Encoding: 0x51200200
    // Test aarch32_MSR_br_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rn=0, M1=0, M=0, R=0
    let encoding: u32 = 0x51200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_6_poweroftwo_200_61200200() {
    // Encoding: 0x61200200
    // Test aarch32_MSR_br_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, M1=0, M=0, cond=6, R=0
    let encoding: u32 = 0x61200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_7_poweroftwo_200_71200200() {
    // Encoding: 0x71200200
    // Test aarch32_MSR_br_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=0, cond=7, M1=0, M=0
    let encoding: u32 = 0x71200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_8_poweroftwo_200_81200200() {
    // Encoding: 0x81200200
    // Test aarch32_MSR_br_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=8, R=0, M1=0
    let encoding: u32 = 0x81200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_9_poweroftwo_200_91200200() {
    // Encoding: 0x91200200
    // Test aarch32_MSR_br_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, R=0, M=0, M1=0, cond=9
    let encoding: u32 = 0x91200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_10_poweroftwo_200_a1200200() {
    // Encoding: 0xA1200200
    // Test aarch32_MSR_br_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, R=0, cond=10, M1=0
    let encoding: u32 = 0xA1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_11_poweroftwo_200_b1200200() {
    // Encoding: 0xB1200200
    // Test aarch32_MSR_br_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=11, Rn=0, M=0, M1=0
    let encoding: u32 = 0xB1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_12_poweroftwo_200_c1200200() {
    // Encoding: 0xC1200200
    // Test aarch32_MSR_br_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, R=0, M=0, Rn=0, M1=0
    let encoding: u32 = 0xC1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_13_poweroftwo_200_d1200200() {
    // Encoding: 0xD1200200
    // Test aarch32_MSR_br_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, R=0, M=0, M1=0, Rn=0
    let encoding: u32 = 0xD1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_14_poweroftwo_200_e1200200() {
    // Encoding: 0xE1200200
    // Test aarch32_MSR_br_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, R=0, M=0, M1=0, Rn=0
    let encoding: u32 = 0xE1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_msr_br_a1_as_field_cond_15_max_200_f1200200() {
    // Encoding: 0xF1200200
    // Test aarch32_MSR_br_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: R=0, M=0, Rn=0, cond=15, M1=0
    let encoding: u32 = 0xF1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_br_a1_as_field_r_0_min_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS field R = 0 (Min)
    // ISET: A32
    // Fields: cond=0, M1=0, M=0, R=0, Rn=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_br_a1_as_field_r_1_max_200_01600200() {
    // Encoding: 0x01600200
    // Test aarch32_MSR_br_A1_AS field R = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, M=0, M1=0, cond=0, R=1
    let encoding: u32 = 0x01600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_br_a1_as_field_m1_0_min_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS field M1 = 0 (Min)
    // ISET: A32
    // Fields: R=0, M1=0, M=0, Rn=0, cond=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_msr_br_a1_as_field_m1_1_poweroftwo_200_01210200() {
    // Encoding: 0x01210200
    // Test aarch32_MSR_br_A1_AS field M1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, M=0, R=0, M1=1, cond=0
    let encoding: u32 = 0x01210200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_msr_br_a1_as_field_m1_7_poweroftwominusone_200_01270200() {
    // Encoding: 0x01270200
    // Test aarch32_MSR_br_A1_AS field M1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, R=0, M1=7, M=0, Rn=0
    let encoding: u32 = 0x01270200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field M1 16 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_msr_br_a1_as_field_m1_15_max_200_012f0200() {
    // Encoding: 0x012F0200
    // Test aarch32_MSR_br_A1_AS field M1 = 15 (Max)
    // ISET: A32
    // Fields: cond=0, R=0, M1=15, M=0, Rn=0
    let encoding: u32 = 0x012F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field M 8 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_br_a1_as_field_m_0_min_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS field M = 0 (Min)
    // ISET: A32
    // Fields: R=0, cond=0, M=0, M1=0, Rn=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field M 8 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_br_a1_as_field_m_1_max_200_01200300() {
    // Encoding: 0x01200300
    // Test aarch32_MSR_br_A1_AS field M = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, R=0, M=1, M1=0
    let encoding: u32 = 0x01200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_msr_br_a1_as_field_rn_0_min_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS field Rn = 0 (Min)
    // ISET: A32
    // Fields: R=0, cond=0, M=0, Rn=0, M1=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_msr_br_a1_as_field_rn_1_poweroftwo_200_01200201() {
    // Encoding: 0x01200201
    // Test aarch32_MSR_br_A1_AS field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, M=0, cond=0, M1=0, Rn=1
    let encoding: u32 = 0x01200201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_msr_br_a1_as_combo_0_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS field combination: cond=0, R=0, M1=0, M=0, Rn=0
    // ISET: A32
    // Fields: R=0, M1=0, M=0, cond=0, Rn=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_0_condition_eq_512_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, R=0, cond=0, M=0, M1=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_1_condition_ne_512_11200200() {
    // Encoding: 0x11200200
    // Test aarch32_MSR_br_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: R=0, M1=0, cond=1, M=0, Rn=0
    let encoding: u32 = 0x11200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_2_condition_cs_hs_512_21200200() {
    // Encoding: 0x21200200
    // Test aarch32_MSR_br_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: M1=0, R=0, cond=2, M=0, Rn=0
    let encoding: u32 = 0x21200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_3_condition_cc_lo_512_31200200() {
    // Encoding: 0x31200200
    // Test aarch32_MSR_br_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: R=0, M1=0, cond=3, M=0, Rn=0
    let encoding: u32 = 0x31200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_4_condition_mi_512_41200200() {
    // Encoding: 0x41200200
    // Test aarch32_MSR_br_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, M1=0, cond=4, R=0, M=0
    let encoding: u32 = 0x41200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_5_condition_pl_512_51200200() {
    // Encoding: 0x51200200
    // Test aarch32_MSR_br_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: R=0, M=0, cond=5, M1=0, Rn=0
    let encoding: u32 = 0x51200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_6_condition_vs_512_61200200() {
    // Encoding: 0x61200200
    // Test aarch32_MSR_br_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: R=0, cond=6, M=0, Rn=0, M1=0
    let encoding: u32 = 0x61200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_7_condition_vc_512_71200200() {
    // Encoding: 0x71200200
    // Test aarch32_MSR_br_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: R=0, M1=0, cond=7, M=0, Rn=0
    let encoding: u32 = 0x71200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_8_condition_hi_512_81200200() {
    // Encoding: 0x81200200
    // Test aarch32_MSR_br_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, M1=0, M=0, Rn=0, R=0
    let encoding: u32 = 0x81200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_9_condition_ls_512_91200200() {
    // Encoding: 0x91200200
    // Test aarch32_MSR_br_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: R=0, M1=0, M=0, cond=9, Rn=0
    let encoding: u32 = 0x91200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_10_condition_ge_512_a1200200() {
    // Encoding: 0xA1200200
    // Test aarch32_MSR_br_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: M=0, cond=10, Rn=0, R=0, M1=0
    let encoding: u32 = 0xA1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_11_condition_lt_512_b1200200() {
    // Encoding: 0xB1200200
    // Test aarch32_MSR_br_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, R=0, M1=0, Rn=0, M=0
    let encoding: u32 = 0xB1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_12_condition_gt_512_c1200200() {
    // Encoding: 0xC1200200
    // Test aarch32_MSR_br_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: M=0, R=0, cond=12, M1=0, Rn=0
    let encoding: u32 = 0xC1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_13_condition_le_512_d1200200() {
    // Encoding: 0xD1200200
    // Test aarch32_MSR_br_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: R=0, cond=13, M=0, Rn=0, M1=0
    let encoding: u32 = 0xD1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_14_condition_al_512_e1200200() {
    // Encoding: 0xE1200200
    // Test aarch32_MSR_br_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, R=0, M=0, M1=0
    let encoding: u32 = 0xE1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_msr_br_a1_as_special_cond_15_condition_nv_512_f1200200() {
    // Encoding: 0xF1200200
    // Test aarch32_MSR_br_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: R=0, cond=15, Rn=0, M1=0, M=0
    let encoding: u32 = 0xF1200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_br_a1_as_invalid_0_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, M1=0, R=0, M=0, Rn=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_br_a1_as_invalid_1_200_01200200() {
    // Encoding: 0x01200200
    // Test aarch32_MSR_br_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: M=0, cond=0, M1=0, R=0, Rn=0
    let encoding: u32 = 0x01200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_br_t1_as_field_r_0_min_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS field R = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rn=0, M1=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field R 20 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_br_t1_as_field_r_1_max_8020_f3908020() {
    // Thumb encoding (32): 0xF3908020
    // Test aarch32_MSR_br_T1_AS field R = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, M=0, R=1, M1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3908020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_msr_br_t1_as_field_rn_0_min_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS field Rn = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rn=0, M=0, M1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_msr_br_t1_as_field_rn_1_poweroftwo_8020_f3818020() {
    // Thumb encoding (32): 0xF3818020
    // Test aarch32_MSR_br_T1_AS field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, R=0, M=0, M1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3818020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field M1 8 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_br_t1_as_field_m1_0_min_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS field M1 = 0 (Min)
    // ISET: T32
    // Fields: M=0, R=0, M1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field M1 8 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_msr_br_t1_as_field_m1_1_poweroftwo_8020_f3808120() {
    // Thumb encoding (32): 0xF3808120
    // Test aarch32_MSR_br_T1_AS field M1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, M1=1, R=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808120;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field M1 8 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_msr_br_t1_as_field_m1_7_poweroftwominusone_8020_f3808720() {
    // Thumb encoding (32): 0xF3808720
    // Test aarch32_MSR_br_T1_AS field M1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M1=7, M=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808720;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field M1 8 +: 4`
/// Requirement: FieldBoundary { field: "M1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_msr_br_t1_as_field_m1_15_max_8020_f3808f20() {
    // Thumb encoding (32): 0xF3808F20
    // Test aarch32_MSR_br_T1_AS field M1 = 15 (Max)
    // ISET: T32
    // Fields: M=0, M1=15, R=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808F20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_msr_br_t1_as_field_m_0_min_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS field M = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, R=0, M1=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_msr_br_t1_as_field_m_1_max_8020_f3808030() {
    // Thumb encoding (32): 0xF3808030
    // Test aarch32_MSR_br_T1_AS field M = 1 (Max)
    // ISET: T32
    // Fields: M=1, M1=0, R=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=0 (minimum value)
#[test]
fn test_aarch32_msr_br_t1_as_combo_0_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS field combination: R=0, Rn=0, M1=0, M=0
    // ISET: T32
    // Fields: R=0, M1=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_br_t1_as_invalid_0_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, R=0, M1=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_br_t1_as_invalid_1_8020_f3808020() {
    // Thumb encoding (32): 0xF3808020
    // Test aarch32_MSR_br_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M1=0, Rn=0, M=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MSR_br_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_br_a1_as_exception_0_01200200() {
    // Test aarch32_MSR_br_A1_AS exception: Unpredictable
    // Encoding: 0x01200200
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_MSR_br_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_msr_br_t1_as_exception_0_f3808020() {
    // Test aarch32_MSR_br_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SETEND_A Tests
// ============================================================================

/// Provenance: aarch32_SETEND_A1_A
/// ASL: `field E 9 +: 1`
/// Requirement: FieldBoundary { field: "E", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_setend_a1_a_field_e_0_min_0_f1010000() {
    // Encoding: 0xF1010000
    // Test aarch32_SETEND_A1_A field E = 0 (Min)
    // ISET: A32
    // Fields: E=0
    let encoding: u32 = 0xF1010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SETEND_A1_A
/// ASL: `field E 9 +: 1`
/// Requirement: FieldBoundary { field: "E", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_setend_a1_a_field_e_1_max_0_f1010200() {
    // Encoding: 0xF1010200
    // Test aarch32_SETEND_A1_A field E = 1 (Max)
    // ISET: A32
    // Fields: E=1
    let encoding: u32 = 0xF1010200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SETEND_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// E=0 (minimum value)
#[test]
fn test_aarch32_setend_a1_a_combo_0_0_f1010000() {
    // Encoding: 0xF1010000
    // Test aarch32_SETEND_A1_A field combination: E=0
    // ISET: A32
    // Fields: E=0
    let encoding: u32 = 0xF1010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `field E 19 +: 1`
/// Requirement: FieldBoundary { field: "E", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_setend_t1_a_field_e_0_min_0_b6400000() {
    // Thumb encoding (32): 0xB6400000
    // Test aarch32_SETEND_T1_A field E = 0 (Min)
    // ISET: T32
    // Fields: E=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `field E 19 +: 1`
/// Requirement: FieldBoundary { field: "E", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_setend_t1_a_field_e_1_max_0_b6480000() {
    // Thumb encoding (32): 0xB6480000
    // Test aarch32_SETEND_T1_A field E = 1 (Max)
    // ISET: T32
    // Fields: E=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// E=0 (minimum value)
#[test]
fn test_aarch32_setend_t1_a_combo_0_0_b6400000() {
    // Thumb encoding (32): 0xB6400000
    // Test aarch32_SETEND_T1_A field combination: E=0
    // ISET: T32
    // Fields: E=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_setend_t1_a_invalid_0_0_b6400000() {
    // Thumb encoding (32): 0xB6400000
    // Test aarch32_SETEND_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: E=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_setend_t1_a_invalid_1_0_b6400000() {
    // Thumb encoding (32): 0xB6400000
    // Test aarch32_SETEND_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: E=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_32_0_b6420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_64_0_b6420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_32_1_b6420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_64_1_b6420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_32_2_b6420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_64_2_b6420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_32_3_b6420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_64_3_b6420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_32_4_b6420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_64_4_b6420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_32_5_b6420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_setend_t1_a_lslv_oracle_64_5_b6420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_setend_t1_a_t16_oracle_0_b6400000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_setend_t1_a_t16_oracle_1_b6400000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_setend_t1_a_t16_oracle_2_b6400000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SETEND_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_setend_t1_a_t16_oracle_3_b6400000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_PLD_i_A Tests
// ============================================================================

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_i_a1_a_field_u_0_min_0_f5100000() {
    // Encoding: 0xF5100000
    // Test aarch32_PLD_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, R=0, Rn=0, U=0
    let encoding: u32 = 0xF5100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_i_a1_a_field_u_1_max_0_f5900000() {
    // Encoding: 0xF5900000
    // Test aarch32_PLD_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: R=0, Rn=0, imm12=0, U=1
    let encoding: u32 = 0xF5900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_i_a1_a_field_r_0_min_0_f5100000() {
    // Encoding: 0xF5100000
    // Test aarch32_PLD_i_A1_A field R = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, R=0
    let encoding: u32 = 0xF5100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field R 22 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_i_a1_a_field_r_1_max_0_f5500000() {
    // Encoding: 0xF5500000
    // Test aarch32_PLD_i_A1_A field R = 1 (Max)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, R=1
    let encoding: u32 = 0xF5500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_i_a1_a_field_rn_0_min_0_f5100000() {
    // Encoding: 0xF5100000
    // Test aarch32_PLD_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, R=0, imm12=0, Rn=0
    let encoding: u32 = 0xF5100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_i_a1_a_field_rn_1_poweroftwo_0_f5110000() {
    // Encoding: 0xF5110000
    // Test aarch32_PLD_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, imm12=0, U=0, R=0
    let encoding: u32 = 0xF5110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_0_zero_0_f5100000() {
    // Encoding: 0xF5100000
    // Test aarch32_PLD_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=0, R=0
    let encoding: u32 = 0xF5100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_1_poweroftwo_0_f5100001() {
    // Encoding: 0xF5100001
    // Test aarch32_PLD_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, R=0, U=0, imm12=1
    let encoding: u32 = 0xF5100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_3_poweroftwominusone_0_f5100003() {
    // Encoding: 0xF5100003
    // Test aarch32_PLD_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, R=0, imm12=3, Rn=0
    let encoding: u32 = 0xF5100003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_4_poweroftwo_0_f5100004() {
    // Encoding: 0xF5100004
    // Test aarch32_PLD_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, R=0, imm12=4
    let encoding: u32 = 0xF5100004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_7_poweroftwominusone_0_f5100007() {
    // Encoding: 0xF5100007
    // Test aarch32_PLD_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, U=0, R=0, imm12=7
    let encoding: u32 = 0xF5100007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_8_poweroftwo_0_f5100008() {
    // Encoding: 0xF5100008
    // Test aarch32_PLD_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=8, R=0, Rn=0
    let encoding: u32 = 0xF5100008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_15_poweroftwominusone_0_f510000f() {
    // Encoding: 0xF510000F
    // Test aarch32_PLD_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, R=0, U=0, imm12=15
    let encoding: u32 = 0xF510000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_16_poweroftwo_0_f5100010() {
    // Encoding: 0xF5100010
    // Test aarch32_PLD_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, R=0, imm12=16
    let encoding: u32 = 0xF5100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_31_poweroftwominusone_0_f510001f() {
    // Encoding: 0xF510001F
    // Test aarch32_PLD_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, U=0, R=0, imm12=31
    let encoding: u32 = 0xF510001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_32_poweroftwo_0_f5100020() {
    // Encoding: 0xF5100020
    // Test aarch32_PLD_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, R=0, imm12=32
    let encoding: u32 = 0xF5100020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_63_poweroftwominusone_0_f510003f() {
    // Encoding: 0xF510003F
    // Test aarch32_PLD_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, U=0, R=0, Rn=0
    let encoding: u32 = 0xF510003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_64_poweroftwo_0_f5100040() {
    // Encoding: 0xF5100040
    // Test aarch32_PLD_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, R=0, imm12=64
    let encoding: u32 = 0xF5100040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_127_poweroftwominusone_0_f510007f() {
    // Encoding: 0xF510007F
    // Test aarch32_PLD_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, R=0, U=0, Rn=0
    let encoding: u32 = 0xF510007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_128_poweroftwo_0_f5100080() {
    // Encoding: 0xF5100080
    // Test aarch32_PLD_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, R=0, imm12=128, Rn=0
    let encoding: u32 = 0xF5100080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_255_poweroftwominusone_0_f51000ff() {
    // Encoding: 0xF51000FF
    // Test aarch32_PLD_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: R=0, U=0, Rn=0, imm12=255
    let encoding: u32 = 0xF51000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_256_poweroftwo_0_f5100100() {
    // Encoding: 0xF5100100
    // Test aarch32_PLD_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, R=0, imm12=256, Rn=0
    let encoding: u32 = 0xF5100100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_511_poweroftwominusone_0_f51001ff() {
    // Encoding: 0xF51001FF
    // Test aarch32_PLD_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: R=0, imm12=511, Rn=0, U=0
    let encoding: u32 = 0xF51001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_512_poweroftwo_0_f5100200() {
    // Encoding: 0xF5100200
    // Test aarch32_PLD_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=0, imm12=512, U=0
    let encoding: u32 = 0xF5100200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_1023_poweroftwominusone_0_f51003ff() {
    // Encoding: 0xF51003FF
    // Test aarch32_PLD_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, U=0, R=0, imm12=1023
    let encoding: u32 = 0xF51003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_1024_poweroftwo_0_f5100400() {
    // Encoding: 0xF5100400
    // Test aarch32_PLD_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, U=0, Rn=0, imm12=1024
    let encoding: u32 = 0xF5100400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_2047_poweroftwominusone_0_f51007ff() {
    // Encoding: 0xF51007FF
    // Test aarch32_PLD_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, R=0, imm12=2047, U=0
    let encoding: u32 = 0xF51007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_2048_poweroftwo_0_f5100800() {
    // Encoding: 0xF5100800
    // Test aarch32_PLD_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, Rn=0, U=0, R=0
    let encoding: u32 = 0xF5100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pld_i_a1_a_field_imm12_4095_max_0_f5100fff() {
    // Encoding: 0xF5100FFF
    // Test aarch32_PLD_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, R=0, imm12=4095, U=0
    let encoding: u32 = 0xF5100FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pld_i_a1_a_combo_0_0_f5100000() {
    // Encoding: 0xF5100000
    // Test aarch32_PLD_i_A1_A field combination: U=0, R=0, Rn=0, imm12=0
    // ISET: A32
    // Fields: R=0, U=0, imm12=0, Rn=0
    let encoding: u32 = 0xF5100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_i_t1_a_field_w_0_min_f000_f890f000() {
    // Thumb encoding (32): 0xF890F000
    // Test aarch32_PLD_i_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm12=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_i_t1_a_field_w_1_max_f000_f8b0f000() {
    // Thumb encoding (32): 0xF8B0F000
    // Test aarch32_PLD_i_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: imm12=0, W=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_i_t1_a_field_rn_0_min_f000_f890f000() {
    // Thumb encoding (32): 0xF890F000
    // Test aarch32_PLD_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, W=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_i_t1_a_field_rn_1_poweroftwo_f000_f891f000() {
    // Thumb encoding (32): 0xF891F000
    // Test aarch32_PLD_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm12=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF891F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_0_zero_f000_f890f000() {
    // Thumb encoding (32): 0xF890F000
    // Test aarch32_PLD_i_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: W=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_1_poweroftwo_f000_f890f001() {
    // Thumb encoding (32): 0xF890F001
    // Test aarch32_PLD_i_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_3_poweroftwominusone_f000_f890f003() {
    // Thumb encoding (32): 0xF890F003
    // Test aarch32_PLD_i_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, imm12=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_4_poweroftwo_f000_f890f004() {
    // Thumb encoding (32): 0xF890F004
    // Test aarch32_PLD_i_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=4, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_7_poweroftwominusone_f000_f890f007() {
    // Thumb encoding (32): 0xF890F007
    // Test aarch32_PLD_i_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_8_poweroftwo_f000_f890f008() {
    // Thumb encoding (32): 0xF890F008
    // Test aarch32_PLD_i_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_15_poweroftwominusone_f000_f890f00f() {
    // Thumb encoding (32): 0xF890F00F
    // Test aarch32_PLD_i_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, imm12=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_16_poweroftwo_f000_f890f010() {
    // Thumb encoding (32): 0xF890F010
    // Test aarch32_PLD_i_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=16, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_31_poweroftwominusone_f000_f890f01f() {
    // Thumb encoding (32): 0xF890F01F
    // Test aarch32_PLD_i_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_32_poweroftwo_f000_f890f020() {
    // Thumb encoding (32): 0xF890F020
    // Test aarch32_PLD_i_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_63_poweroftwominusone_f000_f890f03f() {
    // Thumb encoding (32): 0xF890F03F
    // Test aarch32_PLD_i_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F03F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_64_poweroftwo_f000_f890f040() {
    // Thumb encoding (32): 0xF890F040
    // Test aarch32_PLD_i_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=64, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_127_poweroftwominusone_f000_f890f07f() {
    // Thumb encoding (32): 0xF890F07F
    // Test aarch32_PLD_i_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F07F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_128_poweroftwo_f000_f890f080() {
    // Thumb encoding (32): 0xF890F080
    // Test aarch32_PLD_i_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=128, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_255_poweroftwominusone_f000_f890f0ff() {
    // Thumb encoding (32): 0xF890F0FF
    // Test aarch32_PLD_i_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=255, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F0FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_256_poweroftwo_f000_f890f100() {
    // Thumb encoding (32): 0xF890F100
    // Test aarch32_PLD_i_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm12=256, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_511_poweroftwominusone_f000_f890f1ff() {
    // Thumb encoding (32): 0xF890F1FF
    // Test aarch32_PLD_i_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=511, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F1FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_512_poweroftwo_f000_f890f200() {
    // Thumb encoding (32): 0xF890F200
    // Test aarch32_PLD_i_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_1023_poweroftwominusone_f000_f890f3ff() {
    // Thumb encoding (32): 0xF890F3FF
    // Test aarch32_PLD_i_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, imm12=1023, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F3FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_1024_poweroftwo_f000_f890f400() {
    // Thumb encoding (32): 0xF890F400
    // Test aarch32_PLD_i_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, W=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_2047_poweroftwominusone_f000_f890f7ff() {
    // Thumb encoding (32): 0xF890F7FF
    // Test aarch32_PLD_i_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=2047, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F7FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_2048_poweroftwo_f000_f890f800() {
    // Thumb encoding (32): 0xF890F800
    // Test aarch32_PLD_i_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pld_i_t1_a_field_imm12_4095_max_f000_f890ffff() {
    // Thumb encoding (32): 0xF890FFFF
    // Test aarch32_PLD_i_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: W=0, Rn=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890FFFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_pld_i_t1_a_combo_0_f000_f890f000() {
    // Thumb encoding (32): 0xF890F000
    // Test aarch32_PLD_i_T1_A field combination: W=0, Rn=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_i_t2_a_field_w_0_min_fc00_f810fc00() {
    // Thumb encoding (32): 0xF810FC00
    // Test aarch32_PLD_i_T2_A field W = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_i_t2_a_field_w_1_max_fc00_f830fc00() {
    // Thumb encoding (32): 0xF830FC00
    // Test aarch32_PLD_i_T2_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, W=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF830FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pld_i_t2_a_field_rn_0_min_fc00_f810fc00() {
    // Thumb encoding (32): 0xF810FC00
    // Test aarch32_PLD_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pld_i_t2_a_field_rn_1_poweroftwo_fc00_f811fc00() {
    // Thumb encoding (32): 0xF811FC00
    // Test aarch32_PLD_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF811FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_0_zero_fc00_f810fc00() {
    // Thumb encoding (32): 0xF810FC00
    // Test aarch32_PLD_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_1_poweroftwo_fc00_f810fc01() {
    // Thumb encoding (32): 0xF810FC01
    // Test aarch32_PLD_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_3_poweroftwominusone_fc00_f810fc03() {
    // Thumb encoding (32): 0xF810FC03
    // Test aarch32_PLD_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_4_poweroftwo_fc00_f810fc04() {
    // Thumb encoding (32): 0xF810FC04
    // Test aarch32_PLD_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=4, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_7_poweroftwominusone_fc00_f810fc07() {
    // Thumb encoding (32): 0xF810FC07
    // Test aarch32_PLD_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=7, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_8_poweroftwo_fc00_f810fc08() {
    // Thumb encoding (32): 0xF810FC08
    // Test aarch32_PLD_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_15_poweroftwominusone_fc00_f810fc0f() {
    // Thumb encoding (32): 0xF810FC0F
    // Test aarch32_PLD_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, imm8=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_16_poweroftwo_fc00_f810fc10() {
    // Thumb encoding (32): 0xF810FC10
    // Test aarch32_PLD_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_31_poweroftwominusone_fc00_f810fc1f() {
    // Thumb encoding (32): 0xF810FC1F
    // Test aarch32_PLD_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_32_poweroftwo_fc00_f810fc20() {
    // Thumb encoding (32): 0xF810FC20
    // Test aarch32_PLD_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_63_poweroftwominusone_fc00_f810fc3f() {
    // Thumb encoding (32): 0xF810FC3F
    // Test aarch32_PLD_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_64_poweroftwo_fc00_f810fc40() {
    // Thumb encoding (32): 0xF810FC40
    // Test aarch32_PLD_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_127_poweroftwominusone_fc00_f810fc7f() {
    // Thumb encoding (32): 0xF810FC7F
    // Test aarch32_PLD_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_128_poweroftwo_fc00_f810fc80() {
    // Thumb encoding (32): 0xF810FC80
    // Test aarch32_PLD_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_pld_i_t2_a_field_imm8_255_max_fc00_f810fcff() {
    // Thumb encoding (32): 0xF810FCFF
    // Test aarch32_PLD_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FCFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_pld_i_t2_a_combo_0_fc00_f810fc00() {
    // Thumb encoding (32): 0xF810FC00
    // Test aarch32_PLD_i_T2_A field combination: W=0, Rn=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_pld_i_t2_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_pld_i_t2_a_t32_oracle_0_f811fc00() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF811FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_pld_i_t2_a_t32_oracle_1_f811fc00() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF811FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_pld_i_t2_a_t32_oracle_2_f811fc00() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF811FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_pld_i_t2_a_t32_oracle_3_f811fc00() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF811FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_NOP_A Tests
// ============================================================================

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_nop_a1_a_field_cond_0_min_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_NOP_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_nop_a1_a_field_cond_1_poweroftwo_0_13200000() {
    // Encoding: 0x13200000
    // Test aarch32_NOP_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_nop_a1_a_field_cond_2_poweroftwo_0_23200000() {
    // Encoding: 0x23200000
    // Test aarch32_NOP_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_nop_a1_a_field_cond_3_poweroftwo_0_33200000() {
    // Encoding: 0x33200000
    // Test aarch32_NOP_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_nop_a1_a_field_cond_4_poweroftwo_0_43200000() {
    // Encoding: 0x43200000
    // Test aarch32_NOP_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_nop_a1_a_field_cond_5_poweroftwo_0_53200000() {
    // Encoding: 0x53200000
    // Test aarch32_NOP_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_nop_a1_a_field_cond_6_poweroftwo_0_63200000() {
    // Encoding: 0x63200000
    // Test aarch32_NOP_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_nop_a1_a_field_cond_7_poweroftwo_0_73200000() {
    // Encoding: 0x73200000
    // Test aarch32_NOP_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_nop_a1_a_field_cond_8_poweroftwo_0_83200000() {
    // Encoding: 0x83200000
    // Test aarch32_NOP_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_nop_a1_a_field_cond_9_poweroftwo_0_93200000() {
    // Encoding: 0x93200000
    // Test aarch32_NOP_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_nop_a1_a_field_cond_10_poweroftwo_0_a3200000() {
    // Encoding: 0xA3200000
    // Test aarch32_NOP_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_nop_a1_a_field_cond_11_poweroftwo_0_b3200000() {
    // Encoding: 0xB3200000
    // Test aarch32_NOP_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_nop_a1_a_field_cond_12_poweroftwo_0_c3200000() {
    // Encoding: 0xC3200000
    // Test aarch32_NOP_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_nop_a1_a_field_cond_13_poweroftwo_0_d3200000() {
    // Encoding: 0xD3200000
    // Test aarch32_NOP_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_nop_a1_a_field_cond_14_poweroftwo_0_e3200000() {
    // Encoding: 0xE3200000
    // Test aarch32_NOP_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_nop_a1_a_field_cond_15_max_0_f3200000() {
    // Encoding: 0xF3200000
    // Test aarch32_NOP_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_nop_a1_a_combo_0_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_NOP_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_nop_a1_a_special_cond_0_condition_eq_0_03200000() {
    // Encoding: 0x03200000
    // Test aarch32_NOP_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_nop_a1_a_special_cond_1_condition_ne_0_13200000() {
    // Encoding: 0x13200000
    // Test aarch32_NOP_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_nop_a1_a_special_cond_2_condition_cs_hs_0_23200000() {
    // Encoding: 0x23200000
    // Test aarch32_NOP_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_nop_a1_a_special_cond_3_condition_cc_lo_0_33200000() {
    // Encoding: 0x33200000
    // Test aarch32_NOP_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_nop_a1_a_special_cond_4_condition_mi_0_43200000() {
    // Encoding: 0x43200000
    // Test aarch32_NOP_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_nop_a1_a_special_cond_5_condition_pl_0_53200000() {
    // Encoding: 0x53200000
    // Test aarch32_NOP_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_nop_a1_a_special_cond_6_condition_vs_0_63200000() {
    // Encoding: 0x63200000
    // Test aarch32_NOP_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_nop_a1_a_special_cond_7_condition_vc_0_73200000() {
    // Encoding: 0x73200000
    // Test aarch32_NOP_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_nop_a1_a_special_cond_8_condition_hi_0_83200000() {
    // Encoding: 0x83200000
    // Test aarch32_NOP_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_nop_a1_a_special_cond_9_condition_ls_0_93200000() {
    // Encoding: 0x93200000
    // Test aarch32_NOP_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_nop_a1_a_special_cond_10_condition_ge_0_a3200000() {
    // Encoding: 0xA3200000
    // Test aarch32_NOP_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_nop_a1_a_special_cond_11_condition_lt_0_b3200000() {
    // Encoding: 0xB3200000
    // Test aarch32_NOP_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_nop_a1_a_special_cond_12_condition_gt_0_c3200000() {
    // Encoding: 0xC3200000
    // Test aarch32_NOP_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_nop_a1_a_special_cond_13_condition_le_0_d3200000() {
    // Encoding: 0xD3200000
    // Test aarch32_NOP_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_nop_a1_a_special_cond_14_condition_al_0_e3200000() {
    // Encoding: 0xE3200000
    // Test aarch32_NOP_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_nop_a1_a_special_cond_15_condition_nv_0_f3200000() {
    // Encoding: 0xF3200000
    // Test aarch32_NOP_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_nop_t1_a_basic_encoding_bf000000() {
    // Thumb encoding (32): 0xBF000000
    // Test aarch32_NOP_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBF000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_NOP_T2_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_nop_t2_a_basic_encoding_f3a08000() {
    // Thumb encoding (32): 0xF3A08000
    // Test aarch32_NOP_T2_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_nop_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_32_0_bf020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_64_0_bf020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_32_1_bf020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_64_1_bf020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_32_2_bf020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_64_2_bf020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_32_3_bf020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_64_3_bf020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_32_4_bf020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_64_4_bf020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_32_5_bf020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_nop_t1_a_lslv_oracle_64_5_bf020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_nop_t1_a_t16_oracle_0_bf000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_nop_t1_a_t16_oracle_1_bf000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_nop_t1_a_t16_oracle_2_bf000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_NOP_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_nop_t1_a_t16_oracle_3_bf000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_HVC_AS Tests
// ============================================================================

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_0_min_70_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, imm4=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_1_poweroftwo_70_11400070() {
    // Encoding: 0x11400070
    // Test aarch32_HVC_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, imm4=0, imm12=0
    let encoding: u32 = 0x11400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_2_poweroftwo_70_21400070() {
    // Encoding: 0x21400070
    // Test aarch32_HVC_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=2, imm12=0
    let encoding: u32 = 0x21400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_3_poweroftwo_70_31400070() {
    // Encoding: 0x31400070
    // Test aarch32_HVC_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm12=0, imm4=0
    let encoding: u32 = 0x31400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_4_poweroftwo_70_41400070() {
    // Encoding: 0x41400070
    // Test aarch32_HVC_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=4, imm12=0
    let encoding: u32 = 0x41400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_5_poweroftwo_70_51400070() {
    // Encoding: 0x51400070
    // Test aarch32_HVC_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=5, imm12=0
    let encoding: u32 = 0x51400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_6_poweroftwo_70_61400070() {
    // Encoding: 0x61400070
    // Test aarch32_HVC_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, imm12=0, imm4=0
    let encoding: u32 = 0x61400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_7_poweroftwo_70_71400070() {
    // Encoding: 0x71400070
    // Test aarch32_HVC_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=7, imm4=0
    let encoding: u32 = 0x71400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_8_poweroftwo_70_81400070() {
    // Encoding: 0x81400070
    // Test aarch32_HVC_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm12=0, imm4=0
    let encoding: u32 = 0x81400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_9_poweroftwo_70_91400070() {
    // Encoding: 0x91400070
    // Test aarch32_HVC_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=9
    let encoding: u32 = 0x91400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_10_poweroftwo_70_a1400070() {
    // Encoding: 0xA1400070
    // Test aarch32_HVC_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=10, imm12=0
    let encoding: u32 = 0xA1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_11_poweroftwo_70_b1400070() {
    // Encoding: 0xB1400070
    // Test aarch32_HVC_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=11
    let encoding: u32 = 0xB1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_12_poweroftwo_70_c1400070() {
    // Encoding: 0xC1400070
    // Test aarch32_HVC_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm12=0, imm4=0
    let encoding: u32 = 0xC1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_13_poweroftwo_70_d1400070() {
    // Encoding: 0xD1400070
    // Test aarch32_HVC_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, imm4=0, imm12=0
    let encoding: u32 = 0xD1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_14_poweroftwo_70_e1400070() {
    // Encoding: 0xE1400070
    // Test aarch32_HVC_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=14, imm12=0
    let encoding: u32 = 0xE1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_hvc_a1_a_field_cond_15_max_70_f1400070() {
    // Encoding: 0xF1400070
    // Test aarch32_HVC_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm4=0, imm12=0
    let encoding: u32 = 0xF1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_0_zero_70_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_1_poweroftwo_70_01400170() {
    // Encoding: 0x01400170
    // Test aarch32_HVC_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, imm4=0, cond=0
    let encoding: u32 = 0x01400170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_3_poweroftwominusone_70_01400370() {
    // Encoding: 0x01400370
    // Test aarch32_HVC_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=3, imm4=0
    let encoding: u32 = 0x01400370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_4_poweroftwo_70_01400470() {
    // Encoding: 0x01400470
    // Test aarch32_HVC_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, imm4=0, cond=0
    let encoding: u32 = 0x01400470;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_7_poweroftwominusone_70_01400770() {
    // Encoding: 0x01400770
    // Test aarch32_HVC_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=7
    let encoding: u32 = 0x01400770;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_8_poweroftwo_70_01400870() {
    // Encoding: 0x01400870
    // Test aarch32_HVC_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, imm4=0, cond=0
    let encoding: u32 = 0x01400870;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_15_poweroftwominusone_70_01400f70() {
    // Encoding: 0x01400F70
    // Test aarch32_HVC_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=15
    let encoding: u32 = 0x01400F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_16_poweroftwo_70_01401070() {
    // Encoding: 0x01401070
    // Test aarch32_HVC_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=16, imm4=0
    let encoding: u32 = 0x01401070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_31_poweroftwominusone_70_01401f70() {
    // Encoding: 0x01401F70
    // Test aarch32_HVC_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=31, imm4=0
    let encoding: u32 = 0x01401F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_32_poweroftwo_70_01402070() {
    // Encoding: 0x01402070
    // Test aarch32_HVC_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=32, imm4=0
    let encoding: u32 = 0x01402070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_63_poweroftwominusone_70_01403f70() {
    // Encoding: 0x01403F70
    // Test aarch32_HVC_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, cond=0, imm4=0
    let encoding: u32 = 0x01403F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_64_poweroftwo_70_01404070() {
    // Encoding: 0x01404070
    // Test aarch32_HVC_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=64
    let encoding: u32 = 0x01404070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_127_poweroftwominusone_70_01407f70() {
    // Encoding: 0x01407F70
    // Test aarch32_HVC_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=127
    let encoding: u32 = 0x01407F70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_128_poweroftwo_70_01408070() {
    // Encoding: 0x01408070
    // Test aarch32_HVC_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=128, imm4=0
    let encoding: u32 = 0x01408070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_255_poweroftwominusone_70_0140ff70() {
    // Encoding: 0x0140FF70
    // Test aarch32_HVC_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=255
    let encoding: u32 = 0x0140FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_256_poweroftwo_70_01410070() {
    // Encoding: 0x01410070
    // Test aarch32_HVC_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=256, cond=0, imm4=0
    let encoding: u32 = 0x01410070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_511_poweroftwominusone_70_0141ff70() {
    // Encoding: 0x0141FF70
    // Test aarch32_HVC_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, imm4=0, cond=0
    let encoding: u32 = 0x0141FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_512_poweroftwo_70_01420070() {
    // Encoding: 0x01420070
    // Test aarch32_HVC_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, imm4=0, cond=0
    let encoding: u32 = 0x01420070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_1023_poweroftwominusone_70_0143ff70() {
    // Encoding: 0x0143FF70
    // Test aarch32_HVC_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=1023
    let encoding: u32 = 0x0143FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_1024_poweroftwo_70_01440070() {
    // Encoding: 0x01440070
    // Test aarch32_HVC_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=1024, imm4=0
    let encoding: u32 = 0x01440070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_2047_poweroftwominusone_70_0147ff70() {
    // Encoding: 0x0147FF70
    // Test aarch32_HVC_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=2047
    let encoding: u32 = 0x0147FF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_2048_poweroftwo_70_01480070() {
    // Encoding: 0x01480070
    // Test aarch32_HVC_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, imm4=0, cond=0
    let encoding: u32 = 0x01480070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_hvc_a1_a_field_imm12_4095_max_70_014fff70() {
    // Encoding: 0x014FFF70
    // Test aarch32_HVC_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm4=0, imm12=4095, cond=0
    let encoding: u32 = 0x014FFF70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_0_zero_70_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_1_poweroftwo_70_01400071() {
    // Encoding: 0x01400071
    // Test aarch32_HVC_A1_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=1
    let encoding: u32 = 0x01400071;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_3_poweroftwominusone_70_01400073() {
    // Encoding: 0x01400073
    // Test aarch32_HVC_A1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=3, cond=0, imm12=0
    let encoding: u32 = 0x01400073;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_4_poweroftwo_70_01400074() {
    // Encoding: 0x01400074
    // Test aarch32_HVC_A1_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=4, imm12=0, cond=0
    let encoding: u32 = 0x01400074;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_7_poweroftwominusone_70_01400077() {
    // Encoding: 0x01400077
    // Test aarch32_HVC_A1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=7, cond=0, imm12=0
    let encoding: u32 = 0x01400077;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_8_poweroftwo_70_01400078() {
    // Encoding: 0x01400078
    // Test aarch32_HVC_A1_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=8, cond=0, imm12=0
    let encoding: u32 = 0x01400078;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_hvc_a1_a_field_imm4_15_max_70_0140007f() {
    // Encoding: 0x0140007F
    // Test aarch32_HVC_A1_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=15
    let encoding: u32 = 0x0140007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_hvc_a1_a_combo_0_70_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A field combination: cond=0, imm12=0, imm4=0
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_hvc_a1_a_special_cond_0_condition_eq_112_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_hvc_a1_a_special_cond_1_condition_ne_112_11400070() {
    // Encoding: 0x11400070
    // Test aarch32_HVC_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=1
    let encoding: u32 = 0x11400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_hvc_a1_a_special_cond_2_condition_cs_hs_112_21400070() {
    // Encoding: 0x21400070
    // Test aarch32_HVC_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, imm12=0, imm4=0
    let encoding: u32 = 0x21400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_hvc_a1_a_special_cond_3_condition_cc_lo_112_31400070() {
    // Encoding: 0x31400070
    // Test aarch32_HVC_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=3
    let encoding: u32 = 0x31400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_hvc_a1_a_special_cond_4_condition_mi_112_41400070() {
    // Encoding: 0x41400070
    // Test aarch32_HVC_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm12=0, imm4=0
    let encoding: u32 = 0x41400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_hvc_a1_a_special_cond_5_condition_pl_112_51400070() {
    // Encoding: 0x51400070
    // Test aarch32_HVC_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm12=0, cond=5, imm4=0
    let encoding: u32 = 0x51400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_hvc_a1_a_special_cond_6_condition_vs_112_61400070() {
    // Encoding: 0x61400070
    // Test aarch32_HVC_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm12=0, imm4=0
    let encoding: u32 = 0x61400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_hvc_a1_a_special_cond_7_condition_vc_112_71400070() {
    // Encoding: 0x71400070
    // Test aarch32_HVC_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, imm4=0, imm12=0
    let encoding: u32 = 0x71400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_hvc_a1_a_special_cond_8_condition_hi_112_81400070() {
    // Encoding: 0x81400070
    // Test aarch32_HVC_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm4=0, cond=8, imm12=0
    let encoding: u32 = 0x81400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_hvc_a1_a_special_cond_9_condition_ls_112_91400070() {
    // Encoding: 0x91400070
    // Test aarch32_HVC_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=9
    let encoding: u32 = 0x91400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_hvc_a1_a_special_cond_10_condition_ge_112_a1400070() {
    // Encoding: 0xA1400070
    // Test aarch32_HVC_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4=0, cond=10, imm12=0
    let encoding: u32 = 0xA1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_hvc_a1_a_special_cond_11_condition_lt_112_b1400070() {
    // Encoding: 0xB1400070
    // Test aarch32_HVC_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, imm12=0, imm4=0
    let encoding: u32 = 0xB1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_hvc_a1_a_special_cond_12_condition_gt_112_c1400070() {
    // Encoding: 0xC1400070
    // Test aarch32_HVC_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=12
    let encoding: u32 = 0xC1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_hvc_a1_a_special_cond_13_condition_le_112_d1400070() {
    // Encoding: 0xD1400070
    // Test aarch32_HVC_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm4=0, imm12=0
    let encoding: u32 = 0xD1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_hvc_a1_a_special_cond_14_condition_al_112_e1400070() {
    // Encoding: 0xE1400070
    // Test aarch32_HVC_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, cond=14, imm4=0
    let encoding: u32 = 0xE1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_hvc_a1_a_special_cond_15_condition_nv_112_f1400070() {
    // Encoding: 0xF1400070
    // Test aarch32_HVC_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, imm12=0, imm4=0
    let encoding: u32 = 0xF1400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hvc_a1_a_invalid_0_70_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hvc_a1_a_invalid_1_70_01400070() {
    // Encoding: 0x01400070
    // Test aarch32_HVC_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x01400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_0_zero_8000_f7e08000() {
    // Thumb encoding (32): 0xF7E08000
    // Test aarch32_HVC_T1_A field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: imm4=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_1_poweroftwo_8000_f7e18000() {
    // Thumb encoding (32): 0xF7E18000
    // Test aarch32_HVC_T1_A field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_3_poweroftwominusone_8000_f7e38000() {
    // Thumb encoding (32): 0xF7E38000
    // Test aarch32_HVC_T1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=0, imm4=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E38000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_4_poweroftwo_8000_f7e48000() {
    // Thumb encoding (32): 0xF7E48000
    // Test aarch32_HVC_T1_A field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=4, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E48000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_7_poweroftwominusone_8000_f7e78000() {
    // Thumb encoding (32): 0xF7E78000
    // Test aarch32_HVC_T1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=7, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E78000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_8_poweroftwo_8000_f7e88000() {
    // Thumb encoding (32): 0xF7E88000
    // Test aarch32_HVC_T1_A field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, imm4=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E88000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_hvc_t1_a_field_imm4_15_max_8000_f7ef8000() {
    // Thumb encoding (32): 0xF7EF8000
    // Test aarch32_HVC_T1_A field imm4 = 15 (Max)
    // ISET: T32
    // Fields: imm12=0, imm4=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7EF8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_0_zero_8000_f7e08000() {
    // Thumb encoding (32): 0xF7E08000
    // Test aarch32_HVC_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: imm4=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_1_poweroftwo_8000_f7e08001() {
    // Thumb encoding (32): 0xF7E08001
    // Test aarch32_HVC_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_3_poweroftwominusone_8000_f7e08003() {
    // Thumb encoding (32): 0xF7E08003
    // Test aarch32_HVC_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_4_poweroftwo_8000_f7e08004() {
    // Thumb encoding (32): 0xF7E08004
    // Test aarch32_HVC_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_7_poweroftwominusone_8000_f7e08007() {
    // Thumb encoding (32): 0xF7E08007
    // Test aarch32_HVC_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=7, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_8_poweroftwo_8000_f7e08008() {
    // Thumb encoding (32): 0xF7E08008
    // Test aarch32_HVC_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_15_poweroftwominusone_8000_f7e0800f() {
    // Thumb encoding (32): 0xF7E0800F
    // Test aarch32_HVC_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E0800F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_16_poweroftwo_8000_f7e08010() {
    // Thumb encoding (32): 0xF7E08010
    // Test aarch32_HVC_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_31_poweroftwominusone_8000_f7e0801f() {
    // Thumb encoding (32): 0xF7E0801F
    // Test aarch32_HVC_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=31, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E0801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_32_poweroftwo_8000_f7e08020() {
    // Thumb encoding (32): 0xF7E08020
    // Test aarch32_HVC_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_63_poweroftwominusone_8000_f7e0803f() {
    // Thumb encoding (32): 0xF7E0803F
    // Test aarch32_HVC_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E0803F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_64_poweroftwo_8000_f7e08040() {
    // Thumb encoding (32): 0xF7E08040
    // Test aarch32_HVC_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_127_poweroftwominusone_8000_f7e0807f() {
    // Thumb encoding (32): 0xF7E0807F
    // Test aarch32_HVC_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E0807F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_128_poweroftwo_8000_f7e08080() {
    // Thumb encoding (32): 0xF7E08080
    // Test aarch32_HVC_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_255_poweroftwominusone_8000_f7e080ff() {
    // Thumb encoding (32): 0xF7E080FF
    // Test aarch32_HVC_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E080FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_256_poweroftwo_8000_f7e08100() {
    // Thumb encoding (32): 0xF7E08100
    // Test aarch32_HVC_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_511_poweroftwominusone_8000_f7e081ff() {
    // Thumb encoding (32): 0xF7E081FF
    // Test aarch32_HVC_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E081FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_512_poweroftwo_8000_f7e08200() {
    // Thumb encoding (32): 0xF7E08200
    // Test aarch32_HVC_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_1023_poweroftwominusone_8000_f7e083ff() {
    // Thumb encoding (32): 0xF7E083FF
    // Test aarch32_HVC_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E083FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_1024_poweroftwo_8000_f7e08400() {
    // Thumb encoding (32): 0xF7E08400
    // Test aarch32_HVC_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_2047_poweroftwominusone_8000_f7e087ff() {
    // Thumb encoding (32): 0xF7E087FF
    // Test aarch32_HVC_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E087FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_2048_poweroftwo_8000_f7e08800() {
    // Thumb encoding (32): 0xF7E08800
    // Test aarch32_HVC_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_hvc_t1_a_field_imm12_4095_max_8000_f7e08fff() {
    // Thumb encoding (32): 0xF7E08FFF
    // Test aarch32_HVC_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: imm4=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_hvc_t1_a_combo_0_8000_f7e08000() {
    // Thumb encoding (32): 0xF7E08000
    // Test aarch32_HVC_T1_A field combination: imm4=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hvc_t1_a_invalid_0_8000_f7e08000() {
    // Thumb encoding (32): 0xF7E08000
    // Test aarch32_HVC_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: imm12=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hvc_t1_a_invalid_1_8000_f7e08000() {
    // Thumb encoding (32): 0xF7E08000
    // Test aarch32_HVC_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm12=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_hvc_a1_a_exception_0_01400070() {
    // Test aarch32_HVC_A1_A exception: Undefined
    // Encoding: 0x01400070
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01400070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hvc_a1_a_exception_1_01400070() {
    // Test aarch32_HVC_A1_A exception: Unpredictable
    // Encoding: 0x01400070
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01400070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_HVC_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_hvc_a1_a_exception_2_01400070() {
    // Test aarch32_HVC_A1_A exception: Undefined
    // Encoding: 0x01400070
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01400070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_hvc_t1_a_exception_0_f7e08000() {
    // Test aarch32_HVC_T1_A exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_hvc_t1_a_exception_1_f7e08000() {
    // Test aarch32_HVC_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_HVC_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_hvc_t1_a_exception_2_f7e08000() {
    // Test aarch32_HVC_T1_A exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF7E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SVC_A Tests
// ============================================================================

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_svc_a1_a_field_cond_0_min_0_0f000000() {
    // Encoding: 0x0F000000
    // Test aarch32_SVC_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm24=0, cond=0
    let encoding: u32 = 0x0F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_svc_a1_a_field_cond_1_poweroftwo_0_1f000000() {
    // Encoding: 0x1F000000
    // Test aarch32_SVC_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=1
    let encoding: u32 = 0x1F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_svc_a1_a_field_cond_2_poweroftwo_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch32_SVC_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=2
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_svc_a1_a_field_cond_3_poweroftwo_0_3f000000() {
    // Encoding: 0x3F000000
    // Test aarch32_SVC_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm24=0
    let encoding: u32 = 0x3F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_svc_a1_a_field_cond_4_poweroftwo_0_4f000000() {
    // Encoding: 0x4F000000
    // Test aarch32_SVC_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=4
    let encoding: u32 = 0x4F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_svc_a1_a_field_cond_5_poweroftwo_0_5f000000() {
    // Encoding: 0x5F000000
    // Test aarch32_SVC_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, imm24=0
    let encoding: u32 = 0x5F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_svc_a1_a_field_cond_6_poweroftwo_0_6f000000() {
    // Encoding: 0x6F000000
    // Test aarch32_SVC_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=6
    let encoding: u32 = 0x6F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_svc_a1_a_field_cond_7_poweroftwo_0_7f000000() {
    // Encoding: 0x7F000000
    // Test aarch32_SVC_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, imm24=0
    let encoding: u32 = 0x7F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_svc_a1_a_field_cond_8_poweroftwo_0_8f000000() {
    // Encoding: 0x8F000000
    // Test aarch32_SVC_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm24=0
    let encoding: u32 = 0x8F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_svc_a1_a_field_cond_9_poweroftwo_0_9f000000() {
    // Encoding: 0x9F000000
    // Test aarch32_SVC_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=9
    let encoding: u32 = 0x9F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_svc_a1_a_field_cond_10_poweroftwo_0_af000000() {
    // Encoding: 0xAF000000
    // Test aarch32_SVC_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=10
    let encoding: u32 = 0xAF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_svc_a1_a_field_cond_11_poweroftwo_0_bf000000() {
    // Encoding: 0xBF000000
    // Test aarch32_SVC_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm24=0
    let encoding: u32 = 0xBF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_svc_a1_a_field_cond_12_poweroftwo_0_cf000000() {
    // Encoding: 0xCF000000
    // Test aarch32_SVC_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm24=0
    let encoding: u32 = 0xCF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_svc_a1_a_field_cond_13_poweroftwo_0_df000000() {
    // Encoding: 0xDF000000
    // Test aarch32_SVC_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=0, cond=13
    let encoding: u32 = 0xDF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_svc_a1_a_field_cond_14_poweroftwo_0_ef000000() {
    // Encoding: 0xEF000000
    // Test aarch32_SVC_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, imm24=0
    let encoding: u32 = 0xEF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_svc_a1_a_field_cond_15_max_0_ff000000() {
    // Encoding: 0xFF000000
    // Test aarch32_SVC_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm24=0, cond=15
    let encoding: u32 = 0xFF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_svc_a1_a_field_imm24_0_zero_0_0f000000() {
    // Encoding: 0x0F000000
    // Test aarch32_SVC_A1_A field imm24 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm24=0
    let encoding: u32 = 0x0F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_svc_a1_a_field_imm24_1_poweroftwo_0_0f000001() {
    // Encoding: 0x0F000001
    // Test aarch32_SVC_A1_A field imm24 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=1
    let encoding: u32 = 0x0F000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_svc_a1_a_field_imm24_3_poweroftwominusone_0_0f000003() {
    // Encoding: 0x0F000003
    // Test aarch32_SVC_A1_A field imm24 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=3
    let encoding: u32 = 0x0F000003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_4_poweroftwo_0_0f000004() {
    // Encoding: 0x0F000004
    // Test aarch32_SVC_A1_A field imm24 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=4, cond=0
    let encoding: u32 = 0x0F000004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_svc_a1_a_field_imm24_7_poweroftwominusone_0_0f000007() {
    // Encoding: 0x0F000007
    // Test aarch32_SVC_A1_A field imm24 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=7
    let encoding: u32 = 0x0F000007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_8_poweroftwo_0_0f000008() {
    // Encoding: 0x0F000008
    // Test aarch32_SVC_A1_A field imm24 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=8, cond=0
    let encoding: u32 = 0x0F000008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_svc_a1_a_field_imm24_15_poweroftwominusone_0_0f00000f() {
    // Encoding: 0x0F00000F
    // Test aarch32_SVC_A1_A field imm24 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=15
    let encoding: u32 = 0x0F00000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_16_poweroftwo_0_0f000010() {
    // Encoding: 0x0F000010
    // Test aarch32_SVC_A1_A field imm24 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=16, cond=0
    let encoding: u32 = 0x0F000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_svc_a1_a_field_imm24_31_poweroftwominusone_0_0f00001f() {
    // Encoding: 0x0F00001F
    // Test aarch32_SVC_A1_A field imm24 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=31
    let encoding: u32 = 0x0F00001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_32_poweroftwo_0_0f000020() {
    // Encoding: 0x0F000020
    // Test aarch32_SVC_A1_A field imm24 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=32, cond=0
    let encoding: u32 = 0x0F000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_svc_a1_a_field_imm24_63_poweroftwominusone_0_0f00003f() {
    // Encoding: 0x0F00003F
    // Test aarch32_SVC_A1_A field imm24 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=63, cond=0
    let encoding: u32 = 0x0F00003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_64_poweroftwo_0_0f000040() {
    // Encoding: 0x0F000040
    // Test aarch32_SVC_A1_A field imm24 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=64, cond=0
    let encoding: u32 = 0x0F000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_svc_a1_a_field_imm24_127_poweroftwominusone_0_0f00007f() {
    // Encoding: 0x0F00007F
    // Test aarch32_SVC_A1_A field imm24 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=127, cond=0
    let encoding: u32 = 0x0F00007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_128_poweroftwo_0_0f000080() {
    // Encoding: 0x0F000080
    // Test aarch32_SVC_A1_A field imm24 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=128, cond=0
    let encoding: u32 = 0x0F000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_svc_a1_a_field_imm24_255_poweroftwominusone_0_0f0000ff() {
    // Encoding: 0x0F0000FF
    // Test aarch32_SVC_A1_A field imm24 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=255, cond=0
    let encoding: u32 = 0x0F0000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_256_poweroftwo_0_0f000100() {
    // Encoding: 0x0F000100
    // Test aarch32_SVC_A1_A field imm24 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=256
    let encoding: u32 = 0x0F000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_svc_a1_a_field_imm24_511_poweroftwominusone_0_0f0001ff() {
    // Encoding: 0x0F0001FF
    // Test aarch32_SVC_A1_A field imm24 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=511, cond=0
    let encoding: u32 = 0x0F0001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_512_poweroftwo_0_0f000200() {
    // Encoding: 0x0F000200
    // Test aarch32_SVC_A1_A field imm24 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=512, cond=0
    let encoding: u32 = 0x0F000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_svc_a1_a_field_imm24_1023_poweroftwominusone_0_0f0003ff() {
    // Encoding: 0x0F0003FF
    // Test aarch32_SVC_A1_A field imm24 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=1023, cond=0
    let encoding: u32 = 0x0F0003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_1024_poweroftwo_0_0f000400() {
    // Encoding: 0x0F000400
    // Test aarch32_SVC_A1_A field imm24 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=1024, cond=0
    let encoding: u32 = 0x0F000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 2047, boundary: PowerOfTwoMinusOne }
/// 2^11 - 1 = 2047
#[test]
fn test_aarch32_svc_a1_a_field_imm24_2047_poweroftwominusone_0_0f0007ff() {
    // Encoding: 0x0F0007FF
    // Test aarch32_SVC_A1_A field imm24 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=2047
    let encoding: u32 = 0x0F0007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_2048_poweroftwo_0_0f000800() {
    // Encoding: 0x0F000800
    // Test aarch32_SVC_A1_A field imm24 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=2048
    let encoding: u32 = 0x0F000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 4095, boundary: PowerOfTwoMinusOne }
/// 2^12 - 1 = 4095
#[test]
fn test_aarch32_svc_a1_a_field_imm24_4095_poweroftwominusone_0_0f000fff() {
    // Encoding: 0x0F000FFF
    // Test aarch32_SVC_A1_A field imm24 = 4095 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=4095
    let encoding: u32 = 0x0F000FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 4096, boundary: PowerOfTwo }
/// power of 2 (2^12 = 4096)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_4096_poweroftwo_0_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch32_SVC_A1_A field imm24 = 4096 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=4096
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 8191, boundary: PowerOfTwoMinusOne }
/// 2^13 - 1 = 8191
#[test]
fn test_aarch32_svc_a1_a_field_imm24_8191_poweroftwominusone_0_0f001fff() {
    // Encoding: 0x0F001FFF
    // Test aarch32_SVC_A1_A field imm24 = 8191 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=8191
    let encoding: u32 = 0x0F001FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 8192, boundary: PowerOfTwo }
/// power of 2 (2^13 = 8192)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_8192_poweroftwo_0_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch32_SVC_A1_A field imm24 = 8192 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=8192, cond=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 16383, boundary: PowerOfTwoMinusOne }
/// 2^14 - 1 = 16383
#[test]
fn test_aarch32_svc_a1_a_field_imm24_16383_poweroftwominusone_0_0f003fff() {
    // Encoding: 0x0F003FFF
    // Test aarch32_SVC_A1_A field imm24 = 16383 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=16383
    let encoding: u32 = 0x0F003FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 16384, boundary: PowerOfTwo }
/// power of 2 (2^14 = 16384)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_16384_poweroftwo_0_0f004000() {
    // Encoding: 0x0F004000
    // Test aarch32_SVC_A1_A field imm24 = 16384 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=16384
    let encoding: u32 = 0x0F004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 32767, boundary: PowerOfTwoMinusOne }
/// 2^15 - 1 = 32767
#[test]
fn test_aarch32_svc_a1_a_field_imm24_32767_poweroftwominusone_0_0f007fff() {
    // Encoding: 0x0F007FFF
    // Test aarch32_SVC_A1_A field imm24 = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=32767, cond=0
    let encoding: u32 = 0x0F007FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 32768, boundary: PowerOfTwo }
/// power of 2 (2^15 = 32768)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_32768_poweroftwo_0_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch32_SVC_A1_A field imm24 = 32768 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=32768
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 65535, boundary: PowerOfTwoMinusOne }
/// 2^16 - 1 = 65535
#[test]
fn test_aarch32_svc_a1_a_field_imm24_65535_poweroftwominusone_0_0f00ffff() {
    // Encoding: 0x0F00FFFF
    // Test aarch32_SVC_A1_A field imm24 = 65535 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=65535
    let encoding: u32 = 0x0F00FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 65536, boundary: PowerOfTwo }
/// power of 2 (2^16 = 65536)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_65536_poweroftwo_0_0f010000() {
    // Encoding: 0x0F010000
    // Test aarch32_SVC_A1_A field imm24 = 65536 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=65536
    let encoding: u32 = 0x0F010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 131071, boundary: PowerOfTwoMinusOne }
/// 2^17 - 1 = 131071
#[test]
fn test_aarch32_svc_a1_a_field_imm24_131071_poweroftwominusone_0_0f01ffff() {
    // Encoding: 0x0F01FFFF
    // Test aarch32_SVC_A1_A field imm24 = 131071 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=131071, cond=0
    let encoding: u32 = 0x0F01FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 131072, boundary: PowerOfTwo }
/// power of 2 (2^17 = 131072)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_131072_poweroftwo_0_0f020000() {
    // Encoding: 0x0F020000
    // Test aarch32_SVC_A1_A field imm24 = 131072 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=131072
    let encoding: u32 = 0x0F020000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 262143, boundary: PowerOfTwoMinusOne }
/// 2^18 - 1 = 262143
#[test]
fn test_aarch32_svc_a1_a_field_imm24_262143_poweroftwominusone_0_0f03ffff() {
    // Encoding: 0x0F03FFFF
    // Test aarch32_SVC_A1_A field imm24 = 262143 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=262143
    let encoding: u32 = 0x0F03FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 262144, boundary: PowerOfTwo }
/// power of 2 (2^18 = 262144)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_262144_poweroftwo_0_0f040000() {
    // Encoding: 0x0F040000
    // Test aarch32_SVC_A1_A field imm24 = 262144 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=262144, cond=0
    let encoding: u32 = 0x0F040000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 524287, boundary: PowerOfTwoMinusOne }
/// 2^19 - 1 = 524287
#[test]
fn test_aarch32_svc_a1_a_field_imm24_524287_poweroftwominusone_0_0f07ffff() {
    // Encoding: 0x0F07FFFF
    // Test aarch32_SVC_A1_A field imm24 = 524287 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=524287
    let encoding: u32 = 0x0F07FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 524288, boundary: PowerOfTwo }
/// power of 2 (2^19 = 524288)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_524288_poweroftwo_0_0f080000() {
    // Encoding: 0x0F080000
    // Test aarch32_SVC_A1_A field imm24 = 524288 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=524288, cond=0
    let encoding: u32 = 0x0F080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 1048575, boundary: PowerOfTwoMinusOne }
/// 2^20 - 1 = 1048575
#[test]
fn test_aarch32_svc_a1_a_field_imm24_1048575_poweroftwominusone_0_0f0fffff() {
    // Encoding: 0x0F0FFFFF
    // Test aarch32_SVC_A1_A field imm24 = 1048575 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=1048575
    let encoding: u32 = 0x0F0FFFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 1048576, boundary: PowerOfTwo }
/// power of 2 (2^20 = 1048576)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_1048576_poweroftwo_0_0f100000() {
    // Encoding: 0x0F100000
    // Test aarch32_SVC_A1_A field imm24 = 1048576 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=1048576
    let encoding: u32 = 0x0F100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 2097151, boundary: PowerOfTwoMinusOne }
/// 2^21 - 1 = 2097151
#[test]
fn test_aarch32_svc_a1_a_field_imm24_2097151_poweroftwominusone_0_0f1fffff() {
    // Encoding: 0x0F1FFFFF
    // Test aarch32_SVC_A1_A field imm24 = 2097151 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=2097151
    let encoding: u32 = 0x0F1FFFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 2097152, boundary: PowerOfTwo }
/// power of 2 (2^21 = 2097152)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_2097152_poweroftwo_0_0f200000() {
    // Encoding: 0x0F200000
    // Test aarch32_SVC_A1_A field imm24 = 2097152 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=2097152, cond=0
    let encoding: u32 = 0x0F200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 4194303, boundary: PowerOfTwoMinusOne }
/// 2^22 - 1 = 4194303
#[test]
fn test_aarch32_svc_a1_a_field_imm24_4194303_poweroftwominusone_0_0f3fffff() {
    // Encoding: 0x0F3FFFFF
    // Test aarch32_SVC_A1_A field imm24 = 4194303 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm24=4194303, cond=0
    let encoding: u32 = 0x0F3FFFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 4194304, boundary: PowerOfTwo }
/// power of 2 (2^22 = 4194304)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_4194304_poweroftwo_0_0f400000() {
    // Encoding: 0x0F400000
    // Test aarch32_SVC_A1_A field imm24 = 4194304 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm24=4194304
    let encoding: u32 = 0x0F400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 8388607, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (8388607)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_8388607_poweroftwominusone_0_0f7fffff() {
    // Encoding: 0x0F7FFFFF
    // Test aarch32_SVC_A1_A field imm24 = 8388607 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm24=8388607
    let encoding: u32 = 0x0F7FFFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 8388608, boundary: PowerOfTwo }
/// power of 2 (2^23 = 8388608)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_8388608_poweroftwo_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch32_SVC_A1_A field imm24 = 8388608 (PowerOfTwo)
    // ISET: A32
    // Fields: imm24=8388608, cond=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field imm24 0 +: 24`
/// Requirement: FieldBoundary { field: "imm24", value: 16777215, boundary: Max }
/// maximum immediate (16777215)
#[test]
fn test_aarch32_svc_a1_a_field_imm24_16777215_max_0_0fffffff() {
    // Encoding: 0x0FFFFFFF
    // Test aarch32_SVC_A1_A field imm24 = 16777215 (Max)
    // ISET: A32
    // Fields: cond=0, imm24=16777215
    let encoding: u32 = 0x0FFFFFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_svc_a1_a_combo_0_0_0f000000() {
    // Encoding: 0x0F000000
    // Test aarch32_SVC_A1_A field combination: cond=0, imm24=0
    // ISET: A32
    // Fields: imm24=0, cond=0
    let encoding: u32 = 0x0F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_svc_a1_a_special_cond_0_condition_eq_0_0f000000() {
    // Encoding: 0x0F000000
    // Test aarch32_SVC_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm24=0
    let encoding: u32 = 0x0F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_svc_a1_a_special_cond_1_condition_ne_0_1f000000() {
    // Encoding: 0x1F000000
    // Test aarch32_SVC_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, imm24=0
    let encoding: u32 = 0x1F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_svc_a1_a_special_cond_2_condition_cs_hs_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch32_SVC_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm24=0, cond=2
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_svc_a1_a_special_cond_3_condition_cc_lo_0_3f000000() {
    // Encoding: 0x3F000000
    // Test aarch32_SVC_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm24=0, cond=3
    let encoding: u32 = 0x3F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_svc_a1_a_special_cond_4_condition_mi_0_4f000000() {
    // Encoding: 0x4F000000
    // Test aarch32_SVC_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm24=0
    let encoding: u32 = 0x4F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_svc_a1_a_special_cond_5_condition_pl_0_5f000000() {
    // Encoding: 0x5F000000
    // Test aarch32_SVC_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm24=0, cond=5
    let encoding: u32 = 0x5F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_svc_a1_a_special_cond_6_condition_vs_0_6f000000() {
    // Encoding: 0x6F000000
    // Test aarch32_SVC_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm24=0
    let encoding: u32 = 0x6F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_svc_a1_a_special_cond_7_condition_vc_0_7f000000() {
    // Encoding: 0x7F000000
    // Test aarch32_SVC_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, imm24=0
    let encoding: u32 = 0x7F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_svc_a1_a_special_cond_8_condition_hi_0_8f000000() {
    // Encoding: 0x8F000000
    // Test aarch32_SVC_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm24=0
    let encoding: u32 = 0x8F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_svc_a1_a_special_cond_9_condition_ls_0_9f000000() {
    // Encoding: 0x9F000000
    // Test aarch32_SVC_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm24=0, cond=9
    let encoding: u32 = 0x9F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_svc_a1_a_special_cond_10_condition_ge_0_af000000() {
    // Encoding: 0xAF000000
    // Test aarch32_SVC_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm24=0, cond=10
    let encoding: u32 = 0xAF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_svc_a1_a_special_cond_11_condition_lt_0_bf000000() {
    // Encoding: 0xBF000000
    // Test aarch32_SVC_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm24=0, cond=11
    let encoding: u32 = 0xBF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_svc_a1_a_special_cond_12_condition_gt_0_cf000000() {
    // Encoding: 0xCF000000
    // Test aarch32_SVC_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm24=0, cond=12
    let encoding: u32 = 0xCF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_svc_a1_a_special_cond_13_condition_le_0_df000000() {
    // Encoding: 0xDF000000
    // Test aarch32_SVC_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm24=0, cond=13
    let encoding: u32 = 0xDF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_svc_a1_a_special_cond_14_condition_al_0_ef000000() {
    // Encoding: 0xEF000000
    // Test aarch32_SVC_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm24=0, cond=14
    let encoding: u32 = 0xEF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_svc_a1_a_special_cond_15_condition_nv_0_ff000000() {
    // Encoding: 0xFF000000
    // Test aarch32_SVC_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm24=0, cond=15
    let encoding: u32 = 0xFF000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_svc_t1_a_field_imm8_0_zero_0_df000000() {
    // Thumb encoding (32): 0xDF000000
    // Test aarch32_SVC_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_svc_t1_a_field_imm8_1_poweroftwo_0_df010000() {
    // Thumb encoding (32): 0xDF010000
    // Test aarch32_SVC_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_svc_t1_a_field_imm8_3_poweroftwominusone_0_df030000() {
    // Thumb encoding (32): 0xDF030000
    // Test aarch32_SVC_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_4_poweroftwo_0_df040000() {
    // Thumb encoding (32): 0xDF040000
    // Test aarch32_SVC_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_svc_t1_a_field_imm8_7_poweroftwominusone_0_df070000() {
    // Thumb encoding (32): 0xDF070000
    // Test aarch32_SVC_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_8_poweroftwo_0_df080000() {
    // Thumb encoding (32): 0xDF080000
    // Test aarch32_SVC_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_svc_t1_a_field_imm8_15_poweroftwominusone_0_df0f0000() {
    // Thumb encoding (32): 0xDF0F0000
    // Test aarch32_SVC_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF0F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_16_poweroftwo_0_df100000() {
    // Thumb encoding (32): 0xDF100000
    // Test aarch32_SVC_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_svc_t1_a_field_imm8_31_poweroftwominusone_0_df1f0000() {
    // Thumb encoding (32): 0xDF1F0000
    // Test aarch32_SVC_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF1F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_32_poweroftwo_0_df200000() {
    // Thumb encoding (32): 0xDF200000
    // Test aarch32_SVC_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_svc_t1_a_field_imm8_63_poweroftwominusone_0_df3f0000() {
    // Thumb encoding (32): 0xDF3F0000
    // Test aarch32_SVC_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF3F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_64_poweroftwo_0_df400000() {
    // Thumb encoding (32): 0xDF400000
    // Test aarch32_SVC_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_127_poweroftwominusone_0_df7f0000() {
    // Thumb encoding (32): 0xDF7F0000
    // Test aarch32_SVC_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF7F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_128_poweroftwo_0_df800000() {
    // Thumb encoding (32): 0xDF800000
    // Test aarch32_SVC_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_svc_t1_a_field_imm8_255_max_0_dfff0000() {
    // Thumb encoding (32): 0xDFFF0000
    // Test aarch32_SVC_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDFFF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_svc_t1_a_combo_0_0_df000000() {
    // Thumb encoding (32): 0xDF000000
    // Test aarch32_SVC_T1_A field combination: imm8=0
    // ISET: T32
    // Fields: imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDF000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_32_0_df020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_64_0_df020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_32_1_df020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_64_1_df020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_32_2_df020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_64_2_df020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_32_3_df020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_64_3_df020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_32_4_df020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_64_4_df020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_32_5_df020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_svc_t1_a_lslv_oracle_64_5_df020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_svc_t1_a_t16_oracle_0_df000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_svc_t1_a_t16_oracle_1_df000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_svc_t1_a_t16_oracle_2_df000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SVC_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_svc_t1_a_t16_oracle_3_df000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_PLD_l_A Tests
// ============================================================================

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_l_a1_a_field_u_0_min_0_f51f0000() {
    // Encoding: 0xF51F0000
    // Test aarch32_PLD_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm12=0
    let encoding: u32 = 0xF51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_l_a1_a_field_u_1_max_0_f59f0000() {
    // Encoding: 0xF59F0000
    // Test aarch32_PLD_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, imm12=0
    let encoding: u32 = 0xF59F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_0_zero_0_f51f0000() {
    // Encoding: 0xF51F0000
    // Test aarch32_PLD_l_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: U=0, imm12=0
    let encoding: u32 = 0xF51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_1_poweroftwo_0_f51f0001() {
    // Encoding: 0xF51F0001
    // Test aarch32_PLD_l_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, U=0
    let encoding: u32 = 0xF51F0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_3_poweroftwominusone_0_f51f0003() {
    // Encoding: 0xF51F0003
    // Test aarch32_PLD_l_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=3
    let encoding: u32 = 0xF51F0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_4_poweroftwo_0_f51f0004() {
    // Encoding: 0xF51F0004
    // Test aarch32_PLD_l_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=4
    let encoding: u32 = 0xF51F0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_7_poweroftwominusone_0_f51f0007() {
    // Encoding: 0xF51F0007
    // Test aarch32_PLD_l_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=7
    let encoding: u32 = 0xF51F0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_8_poweroftwo_0_f51f0008() {
    // Encoding: 0xF51F0008
    // Test aarch32_PLD_l_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=8
    let encoding: u32 = 0xF51F0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_15_poweroftwominusone_0_f51f000f() {
    // Encoding: 0xF51F000F
    // Test aarch32_PLD_l_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=15
    let encoding: u32 = 0xF51F000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_16_poweroftwo_0_f51f0010() {
    // Encoding: 0xF51F0010
    // Test aarch32_PLD_l_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=16, U=0
    let encoding: u32 = 0xF51F0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_31_poweroftwominusone_0_f51f001f() {
    // Encoding: 0xF51F001F
    // Test aarch32_PLD_l_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, U=0
    let encoding: u32 = 0xF51F001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_32_poweroftwo_0_f51f0020() {
    // Encoding: 0xF51F0020
    // Test aarch32_PLD_l_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=32, U=0
    let encoding: u32 = 0xF51F0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_63_poweroftwominusone_0_f51f003f() {
    // Encoding: 0xF51F003F
    // Test aarch32_PLD_l_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=63
    let encoding: u32 = 0xF51F003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_64_poweroftwo_0_f51f0040() {
    // Encoding: 0xF51F0040
    // Test aarch32_PLD_l_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=64, U=0
    let encoding: u32 = 0xF51F0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_127_poweroftwominusone_0_f51f007f() {
    // Encoding: 0xF51F007F
    // Test aarch32_PLD_l_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=127
    let encoding: u32 = 0xF51F007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_128_poweroftwo_0_f51f0080() {
    // Encoding: 0xF51F0080
    // Test aarch32_PLD_l_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=128, U=0
    let encoding: u32 = 0xF51F0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_255_poweroftwominusone_0_f51f00ff() {
    // Encoding: 0xF51F00FF
    // Test aarch32_PLD_l_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=255
    let encoding: u32 = 0xF51F00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_256_poweroftwo_0_f51f0100() {
    // Encoding: 0xF51F0100
    // Test aarch32_PLD_l_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=256
    let encoding: u32 = 0xF51F0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_511_poweroftwominusone_0_f51f01ff() {
    // Encoding: 0xF51F01FF
    // Test aarch32_PLD_l_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=511
    let encoding: u32 = 0xF51F01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_512_poweroftwo_0_f51f0200() {
    // Encoding: 0xF51F0200
    // Test aarch32_PLD_l_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, U=0
    let encoding: u32 = 0xF51F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_1023_poweroftwominusone_0_f51f03ff() {
    // Encoding: 0xF51F03FF
    // Test aarch32_PLD_l_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=1023
    let encoding: u32 = 0xF51F03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_1024_poweroftwo_0_f51f0400() {
    // Encoding: 0xF51F0400
    // Test aarch32_PLD_l_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, U=0
    let encoding: u32 = 0xF51F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_2047_poweroftwominusone_0_f51f07ff() {
    // Encoding: 0xF51F07FF
    // Test aarch32_PLD_l_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=2047, U=0
    let encoding: u32 = 0xF51F07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_2048_poweroftwo_0_f51f0800() {
    // Encoding: 0xF51F0800
    // Test aarch32_PLD_l_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=2048
    let encoding: u32 = 0xF51F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pld_l_a1_a_field_imm12_4095_max_0_f51f0fff() {
    // Encoding: 0xF51F0FFF
    // Test aarch32_PLD_l_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: U=0, imm12=4095
    let encoding: u32 = 0xF51F0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pld_l_a1_a_combo_0_0_f51f0000() {
    // Encoding: 0xF51F0000
    // Test aarch32_PLD_l_A1_A field combination: U=0, imm12=0
    // ISET: A32
    // Fields: U=0, imm12=0
    let encoding: u32 = 0xF51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pld_l_t1_a_field_u_0_min_f000_f81ff000() {
    // Thumb encoding (32): 0xF81FF000
    // Test aarch32_PLD_l_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pld_l_t1_a_field_u_1_max_f000_f89ff000() {
    // Thumb encoding (32): 0xF89FF000
    // Test aarch32_PLD_l_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF89FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_0_zero_f000_f81ff000() {
    // Thumb encoding (32): 0xF81FF000
    // Test aarch32_PLD_l_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_1_poweroftwo_f000_f81ff001() {
    // Thumb encoding (32): 0xF81FF001
    // Test aarch32_PLD_l_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_3_poweroftwominusone_f000_f81ff003() {
    // Thumb encoding (32): 0xF81FF003
    // Test aarch32_PLD_l_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=3, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_4_poweroftwo_f000_f81ff004() {
    // Thumb encoding (32): 0xF81FF004
    // Test aarch32_PLD_l_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=4, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_7_poweroftwominusone_f000_f81ff007() {
    // Thumb encoding (32): 0xF81FF007
    // Test aarch32_PLD_l_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_8_poweroftwo_f000_f81ff008() {
    // Thumb encoding (32): 0xF81FF008
    // Test aarch32_PLD_l_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_15_poweroftwominusone_f000_f81ff00f() {
    // Thumb encoding (32): 0xF81FF00F
    // Test aarch32_PLD_l_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_16_poweroftwo_f000_f81ff010() {
    // Thumb encoding (32): 0xF81FF010
    // Test aarch32_PLD_l_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_31_poweroftwominusone_f000_f81ff01f() {
    // Thumb encoding (32): 0xF81FF01F
    // Test aarch32_PLD_l_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=31, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_32_poweroftwo_f000_f81ff020() {
    // Thumb encoding (32): 0xF81FF020
    // Test aarch32_PLD_l_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_63_poweroftwominusone_f000_f81ff03f() {
    // Thumb encoding (32): 0xF81FF03F
    // Test aarch32_PLD_l_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=63, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF03F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_64_poweroftwo_f000_f81ff040() {
    // Thumb encoding (32): 0xF81FF040
    // Test aarch32_PLD_l_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_127_poweroftwominusone_f000_f81ff07f() {
    // Thumb encoding (32): 0xF81FF07F
    // Test aarch32_PLD_l_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF07F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_128_poweroftwo_f000_f81ff080() {
    // Thumb encoding (32): 0xF81FF080
    // Test aarch32_PLD_l_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_255_poweroftwominusone_f000_f81ff0ff() {
    // Thumb encoding (32): 0xF81FF0FF
    // Test aarch32_PLD_l_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF0FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_256_poweroftwo_f000_f81ff100() {
    // Thumb encoding (32): 0xF81FF100
    // Test aarch32_PLD_l_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_511_poweroftwominusone_f000_f81ff1ff() {
    // Thumb encoding (32): 0xF81FF1FF
    // Test aarch32_PLD_l_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=511, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF1FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_512_poweroftwo_f000_f81ff200() {
    // Thumb encoding (32): 0xF81FF200
    // Test aarch32_PLD_l_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_1023_poweroftwominusone_f000_f81ff3ff() {
    // Thumb encoding (32): 0xF81FF3FF
    // Test aarch32_PLD_l_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF3FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_1024_poweroftwo_f000_f81ff400() {
    // Thumb encoding (32): 0xF81FF400
    // Test aarch32_PLD_l_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1024, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_2047_poweroftwominusone_f000_f81ff7ff() {
    // Thumb encoding (32): 0xF81FF7FF
    // Test aarch32_PLD_l_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=2047, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF7FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_2048_poweroftwo_f000_f81ff800() {
    // Thumb encoding (32): 0xF81FF800
    // Test aarch32_PLD_l_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_pld_l_t1_a_field_imm12_4095_max_f000_f81fffff() {
    // Thumb encoding (32): 0xF81FFFFF
    // Test aarch32_PLD_l_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: U=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FFFFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_pld_l_t1_a_combo_0_f000_f81ff000() {
    // Thumb encoding (32): 0xF81FF000
    // Test aarch32_PLD_l_T1_A field combination: U=0, imm12=0
    // ISET: T32
    // Fields: U=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_pld_l_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_pld_l_t1_a_t32_oracle_0_f81ff000() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_pld_l_t1_a_t32_oracle_1_f81ff000() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_pld_l_t1_a_t32_oracle_2_f81ff000() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_PLD_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_pld_l_t1_a_t32_oracle_3_f81ff000() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0xF81FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_CLREX_A Tests
// ============================================================================

/// Provenance: aarch32_CLREX_A1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_clrex_a1_a_basic_encoding_f5700010() {
    // Encoding: 0xF5700010
    // Test aarch32_CLREX_A1_A basic encoding
    // ISET: A32
    let encoding: u32 = 0xF5700010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CLREX_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_clrex_t1_a_basic_encoding_f3b08020() {
    // Thumb encoding (32): 0xF3B08020
    // Test aarch32_CLREX_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

// ============================================================================
// aarch32_DMB_A Tests
// ============================================================================

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_dmb_a1_a_field_option_0_min_50_f5700050() {
    // Encoding: 0xF5700050
    // Test aarch32_DMB_A1_A field option = 0 (Min)
    // ISET: A32
    // Fields: option=0
    let encoding: u32 = 0xF5700050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_dmb_a1_a_field_option_1_poweroftwo_50_f5700051() {
    // Encoding: 0xF5700051
    // Test aarch32_DMB_A1_A field option = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: option=1
    let encoding: u32 = 0xF5700051;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_dmb_a1_a_field_option_2_poweroftwo_50_f5700052() {
    // Encoding: 0xF5700052
    // Test aarch32_DMB_A1_A field option = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: option=2
    let encoding: u32 = 0xF5700052;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_dmb_a1_a_field_option_3_poweroftwo_50_f5700053() {
    // Encoding: 0xF5700053
    // Test aarch32_DMB_A1_A field option = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: option=3
    let encoding: u32 = 0xF5700053;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_dmb_a1_a_field_option_4_poweroftwo_50_f5700054() {
    // Encoding: 0xF5700054
    // Test aarch32_DMB_A1_A field option = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: option=4
    let encoding: u32 = 0xF5700054;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_dmb_a1_a_field_option_5_poweroftwo_50_f5700055() {
    // Encoding: 0xF5700055
    // Test aarch32_DMB_A1_A field option = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: option=5
    let encoding: u32 = 0xF5700055;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_dmb_a1_a_field_option_6_poweroftwo_50_f5700056() {
    // Encoding: 0xF5700056
    // Test aarch32_DMB_A1_A field option = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: option=6
    let encoding: u32 = 0xF5700056;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_dmb_a1_a_field_option_7_poweroftwo_50_f5700057() {
    // Encoding: 0xF5700057
    // Test aarch32_DMB_A1_A field option = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: option=7
    let encoding: u32 = 0xF5700057;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_dmb_a1_a_field_option_8_poweroftwo_50_f5700058() {
    // Encoding: 0xF5700058
    // Test aarch32_DMB_A1_A field option = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: option=8
    let encoding: u32 = 0xF5700058;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_dmb_a1_a_field_option_9_poweroftwo_50_f5700059() {
    // Encoding: 0xF5700059
    // Test aarch32_DMB_A1_A field option = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: option=9
    let encoding: u32 = 0xF5700059;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_dmb_a1_a_field_option_10_poweroftwo_50_f570005a() {
    // Encoding: 0xF570005A
    // Test aarch32_DMB_A1_A field option = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: option=10
    let encoding: u32 = 0xF570005A;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_dmb_a1_a_field_option_11_poweroftwo_50_f570005b() {
    // Encoding: 0xF570005B
    // Test aarch32_DMB_A1_A field option = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: option=11
    let encoding: u32 = 0xF570005B;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_dmb_a1_a_field_option_12_poweroftwo_50_f570005c() {
    // Encoding: 0xF570005C
    // Test aarch32_DMB_A1_A field option = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: option=12
    let encoding: u32 = 0xF570005C;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_dmb_a1_a_field_option_13_poweroftwo_50_f570005d() {
    // Encoding: 0xF570005D
    // Test aarch32_DMB_A1_A field option = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: option=13
    let encoding: u32 = 0xF570005D;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_dmb_a1_a_field_option_14_poweroftwo_50_f570005e() {
    // Encoding: 0xF570005E
    // Test aarch32_DMB_A1_A field option = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: option=14
    let encoding: u32 = 0xF570005E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_dmb_a1_a_field_option_15_max_50_f570005f() {
    // Encoding: 0xF570005F
    // Test aarch32_DMB_A1_A field option = 15 (Max)
    // ISET: A32
    // Fields: option=15
    let encoding: u32 = 0xF570005F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_dmb_a1_a_combo_0_50_f5700050() {
    // Encoding: 0xF5700050
    // Test aarch32_DMB_A1_A field combination: option=0
    // ISET: A32
    // Fields: option=0
    let encoding: u32 = 0xF5700050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 0, boundary: Min }
/// option 0
#[test]
fn test_aarch32_dmb_t1_a_field_option_0_min_8050_f3b08050() {
    // Thumb encoding (32): 0xF3B08050
    // Test aarch32_DMB_T1_A field option = 0 (Min)
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 1, boundary: PowerOfTwo }
/// option 1
#[test]
fn test_aarch32_dmb_t1_a_field_option_1_poweroftwo_8050_f3b08051() {
    // Thumb encoding (32): 0xF3B08051
    // Test aarch32_DMB_T1_A field option = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: option=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08051;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 2, boundary: PowerOfTwo }
/// option 2
#[test]
fn test_aarch32_dmb_t1_a_field_option_2_poweroftwo_8050_f3b08052() {
    // Thumb encoding (32): 0xF3B08052
    // Test aarch32_DMB_T1_A field option = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: option=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08052;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 3, boundary: PowerOfTwo }
/// option 3
#[test]
fn test_aarch32_dmb_t1_a_field_option_3_poweroftwo_8050_f3b08053() {
    // Thumb encoding (32): 0xF3B08053
    // Test aarch32_DMB_T1_A field option = 3 (PowerOfTwo)
    // ISET: T32
    // Fields: option=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08053;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 4, boundary: PowerOfTwo }
/// option 4
#[test]
fn test_aarch32_dmb_t1_a_field_option_4_poweroftwo_8050_f3b08054() {
    // Thumb encoding (32): 0xF3B08054
    // Test aarch32_DMB_T1_A field option = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: option=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08054;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 5, boundary: PowerOfTwo }
/// option 5
#[test]
fn test_aarch32_dmb_t1_a_field_option_5_poweroftwo_8050_f3b08055() {
    // Thumb encoding (32): 0xF3B08055
    // Test aarch32_DMB_T1_A field option = 5 (PowerOfTwo)
    // ISET: T32
    // Fields: option=5
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08055;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 6, boundary: PowerOfTwo }
/// option 6
#[test]
fn test_aarch32_dmb_t1_a_field_option_6_poweroftwo_8050_f3b08056() {
    // Thumb encoding (32): 0xF3B08056
    // Test aarch32_DMB_T1_A field option = 6 (PowerOfTwo)
    // ISET: T32
    // Fields: option=6
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08056;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 7, boundary: PowerOfTwo }
/// option 7
#[test]
fn test_aarch32_dmb_t1_a_field_option_7_poweroftwo_8050_f3b08057() {
    // Thumb encoding (32): 0xF3B08057
    // Test aarch32_DMB_T1_A field option = 7 (PowerOfTwo)
    // ISET: T32
    // Fields: option=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08057;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 8, boundary: PowerOfTwo }
/// option 8
#[test]
fn test_aarch32_dmb_t1_a_field_option_8_poweroftwo_8050_f3b08058() {
    // Thumb encoding (32): 0xF3B08058
    // Test aarch32_DMB_T1_A field option = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: option=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08058;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 9, boundary: PowerOfTwo }
/// option 9
#[test]
fn test_aarch32_dmb_t1_a_field_option_9_poweroftwo_8050_f3b08059() {
    // Thumb encoding (32): 0xF3B08059
    // Test aarch32_DMB_T1_A field option = 9 (PowerOfTwo)
    // ISET: T32
    // Fields: option=9
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08059;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 10, boundary: PowerOfTwo }
/// option 10
#[test]
fn test_aarch32_dmb_t1_a_field_option_10_poweroftwo_8050_f3b0805a() {
    // Thumb encoding (32): 0xF3B0805A
    // Test aarch32_DMB_T1_A field option = 10 (PowerOfTwo)
    // ISET: T32
    // Fields: option=10
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0805A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 11, boundary: PowerOfTwo }
/// option 11
#[test]
fn test_aarch32_dmb_t1_a_field_option_11_poweroftwo_8050_f3b0805b() {
    // Thumb encoding (32): 0xF3B0805B
    // Test aarch32_DMB_T1_A field option = 11 (PowerOfTwo)
    // ISET: T32
    // Fields: option=11
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0805B;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 12, boundary: PowerOfTwo }
/// option 12
#[test]
fn test_aarch32_dmb_t1_a_field_option_12_poweroftwo_8050_f3b0805c() {
    // Thumb encoding (32): 0xF3B0805C
    // Test aarch32_DMB_T1_A field option = 12 (PowerOfTwo)
    // ISET: T32
    // Fields: option=12
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0805C;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 13, boundary: PowerOfTwo }
/// option 13
#[test]
fn test_aarch32_dmb_t1_a_field_option_13_poweroftwo_8050_f3b0805d() {
    // Thumb encoding (32): 0xF3B0805D
    // Test aarch32_DMB_T1_A field option = 13 (PowerOfTwo)
    // ISET: T32
    // Fields: option=13
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0805D;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 14, boundary: PowerOfTwo }
/// option 14
#[test]
fn test_aarch32_dmb_t1_a_field_option_14_poweroftwo_8050_f3b0805e() {
    // Thumb encoding (32): 0xF3B0805E
    // Test aarch32_DMB_T1_A field option = 14 (PowerOfTwo)
    // ISET: T32
    // Fields: option=14
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0805E;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field option 0 +: 4`
/// Requirement: FieldBoundary { field: "option", value: 15, boundary: Max }
/// option 15
#[test]
fn test_aarch32_dmb_t1_a_field_option_15_max_8050_f3b0805f() {
    // Thumb encoding (32): 0xF3B0805F
    // Test aarch32_DMB_T1_A field option = 15 (Max)
    // ISET: T32
    // Fields: option=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B0805F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_DMB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// option=0 (option 0)
#[test]
fn test_aarch32_dmb_t1_a_combo_0_8050_f3b08050() {
    // Thumb encoding (32): 0xF3B08050
    // Test aarch32_DMB_T1_A field combination: option=0
    // ISET: T32
    // Fields: option=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}
