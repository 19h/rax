//! A32 simd load tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_VLDM_A Tests
// ============================================================================

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, Vd=0, D=0, P=0, Rn=0, U=0, imm8=0, cond=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_1_poweroftwo_b00_1c100b00() {
    // Encoding: 0x1C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, imm8=0, D=0, Vd=0, cond=1, P=0, Rn=0
    let encoding: u32 = 0x1C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_2_poweroftwo_b00_2c100b00() {
    // Encoding: 0x2C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, W=0, P=0, Vd=0, Rn=0, U=0, cond=2, imm8=0
    let encoding: u32 = 0x2C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_3_poweroftwo_b00_3c100b00() {
    // Encoding: 0x3C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, cond=3, W=0, U=0, imm8=0, P=0, D=0, Rn=0
    let encoding: u32 = 0x3C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_4_poweroftwo_b00_4c100b00() {
    // Encoding: 0x4C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Vd=0, W=0, imm8=0, cond=4, D=0, Rn=0
    let encoding: u32 = 0x4C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_5_poweroftwo_b00_5c100b00() {
    // Encoding: 0x5C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=5, D=0, U=0, Rn=0, W=0, Vd=0, imm8=0
    let encoding: u32 = 0x5C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_6_poweroftwo_b00_6c100b00() {
    // Encoding: 0x6C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, imm8=0, W=0, cond=6, U=0, D=0, Vd=0
    let encoding: u32 = 0x6C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_7_poweroftwo_b00_7c100b00() {
    // Encoding: 0x7C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=7, D=0, Vd=0, imm8=0, P=0, U=0
    let encoding: u32 = 0x7C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_8_poweroftwo_b00_8c100b00() {
    // Encoding: 0x8C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=8, W=0, imm8=0, U=0, D=0, Vd=0, Rn=0
    let encoding: u32 = 0x8C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_9_poweroftwo_b00_9c100b00() {
    // Encoding: 0x9C100B00
    // Test aarch32_VLDM_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm8=0, U=0, P=0, cond=9, W=0, Vd=0, Rn=0
    let encoding: u32 = 0x9C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_10_poweroftwo_b00_ac100b00() {
    // Encoding: 0xAC100B00
    // Test aarch32_VLDM_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=10, Vd=0, D=0, imm8=0, W=0, P=0, Rn=0
    let encoding: u32 = 0xAC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_11_poweroftwo_b00_bc100b00() {
    // Encoding: 0xBC100B00
    // Test aarch32_VLDM_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, W=0, U=0, Rn=0, imm8=0, P=0, cond=11, Vd=0
    let encoding: u32 = 0xBC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_12_poweroftwo_b00_cc100b00() {
    // Encoding: 0xCC100B00
    // Test aarch32_VLDM_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=12, D=0, Rn=0, Vd=0, W=0, P=0, imm8=0
    let encoding: u32 = 0xCC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_13_poweroftwo_b00_dc100b00() {
    // Encoding: 0xDC100B00
    // Test aarch32_VLDM_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Vd=0, W=0, Rn=0, U=0, P=0, imm8=0, D=0
    let encoding: u32 = 0xDC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_14_poweroftwo_b00_ec100b00() {
    // Encoding: 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vd=0, imm8=0, Rn=0, W=0, cond=14, P=0, D=0
    let encoding: u32 = 0xEC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_15_max_b00_fc100b00() {
    // Encoding: 0xFC100B00
    // Test aarch32_VLDM_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, U=0, Vd=0, W=0, P=0, imm8=0, D=0, cond=15
    let encoding: u32 = 0xFC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: imm8=0, cond=0, D=0, P=0, W=0, U=0, Rn=0, Vd=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_1_max_b00_0d100b00() {
    // Encoding: 0x0D100B00
    // Test aarch32_VLDM_T1A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: cond=0, P=1, Rn=0, imm8=0, W=0, U=0, D=0, Vd=0
    let encoding: u32 = 0x0D100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, W=0, Vd=0, D=0, imm8=0, Rn=0, cond=0, P=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_1_max_b00_0c900b00() {
    // Encoding: 0x0C900B00
    // Test aarch32_VLDM_T1A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, U=1, W=0, Rn=0, P=0, D=0, imm8=0, cond=0
    let encoding: u32 = 0x0C900B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, cond=0, P=0, W=0, imm8=0, U=0, D=0, Rn=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_1_max_b00_0c500b00() {
    // Encoding: 0x0C500B00
    // Test aarch32_VLDM_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: imm8=0, U=0, W=0, Vd=0, cond=0, P=0, D=1, Rn=0
    let encoding: u32 = 0x0C500B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, W=0, P=0, D=0, Rn=0, cond=0, imm8=0, U=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_1_max_b00_0c300b00() {
    // Encoding: 0x0C300B00
    // Test aarch32_VLDM_T1A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: P=0, imm8=0, cond=0, Vd=0, D=0, W=1, Rn=0, U=0
    let encoding: u32 = 0x0C300B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, cond=0, U=0, Vd=0, P=0, D=0, Rn=0, imm8=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_1_poweroftwo_b00_0c110b00() {
    // Encoding: 0x0C110B00
    // Test aarch32_VLDM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, P=0, D=0, U=0, W=0, Vd=0, imm8=0, cond=0
    let encoding: u32 = 0x0C110B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_0_min_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, Vd=0, P=0, D=0, imm8=0, cond=0, U=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_1_poweroftwo_b00_0c101b00() {
    // Encoding: 0x0C101B00
    // Test aarch32_VLDM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm8=0, D=0, U=0, Vd=1, cond=0, P=0, Rn=0
    let encoding: u32 = 0x0C101B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_0_zero_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, W=0, D=0, imm8=0, Vd=0, P=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_1_poweroftwo_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, cond=0, Vd=0, W=0, imm8=1, U=0, P=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_0_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, imm8=0, cond=0, Vd=0, W=0, D=0, U=0, Rn=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_1_b00_1c100b00() {
    // Encoding: 0x1C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=1, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, Vd=0, U=0, imm8=0, D=0, cond=1, W=0, Rn=0
    let encoding: u32 = 0x1C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_2_b00_2c100b00() {
    // Encoding: 0x2C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=2, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=2, Vd=0, U=0, W=0, imm8=0, P=0, D=0, Rn=0
    let encoding: u32 = 0x2C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_3_b00_3c100b00() {
    // Encoding: 0x3C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=3, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=3, U=0, D=0, Rn=0, P=0, Vd=0, imm8=0, W=0
    let encoding: u32 = 0x3C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_4_b00_4c100b00() {
    // Encoding: 0x4C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=4, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, P=0, W=0, U=0, imm8=0, cond=4, D=0, Rn=0
    let encoding: u32 = 0x4C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_5_b00_5c100b00() {
    // Encoding: 0x5C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=5, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, P=0, imm8=0, Rn=0, cond=5, U=0, Vd=0, D=0
    let encoding: u32 = 0x5C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_6_b00_6c100b00() {
    // Encoding: 0x6C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=6, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, P=0, U=0, W=0, Vd=0, cond=6, D=0, Rn=0
    let encoding: u32 = 0x6C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_7_b00_7c100b00() {
    // Encoding: 0x7C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=7, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=0, P=0, Vd=0, cond=7, W=0, U=0
    let encoding: u32 = 0x7C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_8_b00_8c100b00() {
    // Encoding: 0x8C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=8, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, Vd=0, cond=8, Rn=0, U=0, D=0, W=0, P=0
    let encoding: u32 = 0x8C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_9_b00_9c100b00() {
    // Encoding: 0x9C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=9, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, P=0, U=0, Rn=0, W=0, Vd=0, cond=9, D=0
    let encoding: u32 = 0x9C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_10_b00_ac100b00() {
    // Encoding: 0xAC100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=10, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, cond=10, imm8=0, P=0, Rn=0, U=0, D=0, Vd=0
    let encoding: u32 = 0xAC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_11_b00_bc100b00() {
    // Encoding: 0xBC100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=11, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, Vd=0, P=0, D=0, Rn=0, W=0, cond=11, imm8=0
    let encoding: u32 = 0xBC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_12_b00_cc100b00() {
    // Encoding: 0xCC100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=12, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, Rn=0, D=0, P=0, U=0, cond=12, Vd=0, imm8=0
    let encoding: u32 = 0xCC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_13_b00_dc100b00() {
    // Encoding: 0xDC100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=13, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, imm8=0, cond=13, U=0, W=0, Rn=0, P=0, Vd=0
    let encoding: u32 = 0xDC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_14_b00_ec100b00() {
    // Encoding: 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=14, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=14, D=0, Rn=0, imm8=0, P=0, U=0, W=0, Vd=0
    let encoding: u32 = 0xEC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_15_b00_fc100b00() {
    // Encoding: 0xFC100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=15, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, imm8=0, P=0, Rn=0, cond=15, U=0, W=0, Vd=0
    let encoding: u32 = 0xFC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_16_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, Vd=0, P=0, D=0, W=0, Rn=0, imm8=0, cond=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_17_b00_0d100b00() {
    // Encoding: 0x0D100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=1, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Rn=0, U=0, P=1, D=0, Vd=0, W=0, imm8=0, cond=0
    let encoding: u32 = 0x0D100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_18_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, cond=0, D=0, P=0, W=0, imm8=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_19_b00_0c900b00() {
    // Encoding: 0x0C900B00
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=1, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, imm8=0, D=0, cond=0, Rn=0, W=0, U=1, Vd=0
    let encoding: u32 = 0x0C900B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_0_condition_eq_2816_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: W=0, imm8=0, Rn=0, Vd=0, D=0, P=0, cond=0, U=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_1_condition_ne_2816_1c100b00() {
    // Encoding: 0x1C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, imm8=0, U=0, D=0, P=0, W=0, Vd=0, Rn=0
    let encoding: u32 = 0x1C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_2_condition_cs_hs_2816_2c100b00() {
    // Encoding: 0x2C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, W=0, cond=2, P=0, imm8=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0x2C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_3_condition_cc_lo_2816_3c100b00() {
    // Encoding: 0x3C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, cond=3, Rn=0, U=0, Vd=0, imm8=0, P=0, D=0
    let encoding: u32 = 0x3C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_4_condition_mi_2816_4c100b00() {
    // Encoding: 0x4C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: P=0, cond=4, Rn=0, Vd=0, U=0, D=0, W=0, imm8=0
    let encoding: u32 = 0x4C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_5_condition_pl_2816_5c100b00() {
    // Encoding: 0x5C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, W=0, Vd=0, imm8=0, P=0, Rn=0, cond=5, D=0
    let encoding: u32 = 0x5C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_6_condition_vs_2816_6c100b00() {
    // Encoding: 0x6C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: P=0, imm8=0, Vd=0, cond=6, D=0, U=0, Rn=0, W=0
    let encoding: u32 = 0x6C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_7_condition_vc_2816_7c100b00() {
    // Encoding: 0x7C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, W=0, P=0, cond=7, imm8=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0x7C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_8_condition_hi_2816_8c100b00() {
    // Encoding: 0x8C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: P=0, D=0, Vd=0, imm8=0, U=0, cond=8, W=0, Rn=0
    let encoding: u32 = 0x8C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_9_condition_ls_2816_9c100b00() {
    // Encoding: 0x9C100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: W=0, Rn=0, Vd=0, imm8=0, D=0, U=0, P=0, cond=9
    let encoding: u32 = 0x9C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_10_condition_ge_2816_ac100b00() {
    // Encoding: 0xAC100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, P=0, U=0, Vd=0, D=0, imm8=0, Rn=0, W=0
    let encoding: u32 = 0xAC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_11_condition_lt_2816_bc100b00() {
    // Encoding: 0xBC100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Vd=0, D=0, W=0, U=0, P=0, Rn=0, imm8=0, cond=11
    let encoding: u32 = 0xBC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_12_condition_gt_2816_cc100b00() {
    // Encoding: 0xCC100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, cond=12, imm8=0, W=0, Vd=0, D=0
    let encoding: u32 = 0xCC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_13_condition_le_2816_dc100b00() {
    // Encoding: 0xDC100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, P=0, U=0, W=0, Rn=0, Vd=0, D=0, imm8=0
    let encoding: u32 = 0xDC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_14_condition_al_2816_ec100b00() {
    // Encoding: 0xEC100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=14, P=0, D=0, U=0, Vd=0, imm8=0
    let encoding: u32 = 0xEC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_15_condition_nv_2816_fc100b00() {
    // Encoding: 0xFC100B00
    // Test aarch32_VLDM_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm8=0, D=0, P=0, cond=15, W=0, Vd=0, Rn=0, U=0
    let encoding: u32 = 0xFC100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_0_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rn=0, D=0, cond=0, W=0, P=0, Vd=0, U=0, imm8=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_1_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, Vd=0, U=0, imm8=0, cond=0, P=0, W=0, D=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_2_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: A32
    // Fields: imm8=0, U=0, D=0, W=0, P=0, cond=0, Rn=0, Vd=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_3_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, cond=0, Vd=0, imm8=0, U=0, Rn=0, P=0, D=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_4_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: A32
    // Fields: P=0, imm8=0, D=0, W=0, Vd=0, cond=0, Rn=0, U=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_5_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, imm8=0, W=0, P=0, Vd=0, U=0, cond=0, Rn=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_6_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: A32
    // Fields: W=0, U=0, cond=0, D=0, imm8=0, Vd=0, Rn=0, P=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_7_b00_0c100b00() {
    // Encoding: 0x0C100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, W=0, Vd=0, imm8=0, U=0, P=0, Rn=0, cond=0
    let encoding: u32 = 0x0C100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, Vd=0, D=0, imm8=0, Rn=0, W=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_1_poweroftwo_a00_1c100a00() {
    // Encoding: 0x1C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, cond=1, U=0, P=0, W=0, D=0, imm8=0
    let encoding: u32 = 0x1C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_2_poweroftwo_a00_2c100a00() {
    // Encoding: 0x2C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, P=0, Rn=0, cond=2, U=0, W=0, Vd=0, imm8=0
    let encoding: u32 = 0x2C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_3_poweroftwo_a00_3c100a00() {
    // Encoding: 0x3C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, D=0, cond=3, W=0, P=0, U=0, Rn=0, Vd=0
    let encoding: u32 = 0x3C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_4_poweroftwo_a00_4c100a00() {
    // Encoding: 0x4C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, W=0, D=0, U=0, Rn=0, cond=4, Vd=0, P=0
    let encoding: u32 = 0x4C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_5_poweroftwo_a00_5c100a00() {
    // Encoding: 0x5C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Vd=0, Rn=0, imm8=0, cond=5, W=0, U=0, D=0
    let encoding: u32 = 0x5C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_6_poweroftwo_a00_6c100a00() {
    // Encoding: 0x6C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, cond=6, D=0, U=0, P=0, Rn=0, W=0, Vd=0
    let encoding: u32 = 0x6C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_7_poweroftwo_a00_7c100a00() {
    // Encoding: 0x7C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, U=0, W=0, P=0, cond=7, imm8=0, Vd=0, Rn=0
    let encoding: u32 = 0x7C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_8_poweroftwo_a00_8c100a00() {
    // Encoding: 0x8C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, P=0, U=0, cond=8, imm8=0, W=0, Rn=0, D=0
    let encoding: u32 = 0x8C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_9_poweroftwo_a00_9c100a00() {
    // Encoding: 0x9C100A00
    // Test aarch32_VLDM_T2A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, P=0, U=0, W=0, Rn=0, cond=9, D=0, Vd=0
    let encoding: u32 = 0x9C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_10_poweroftwo_a00_ac100a00() {
    // Encoding: 0xAC100A00
    // Test aarch32_VLDM_T2A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, U=0, P=0, cond=10, W=0, Vd=0, imm8=0, Rn=0
    let encoding: u32 = 0xAC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_11_poweroftwo_a00_bc100a00() {
    // Encoding: 0xBC100A00
    // Test aarch32_VLDM_T2A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, D=0, cond=11, P=0, Vd=0, imm8=0, U=0
    let encoding: u32 = 0xBC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_12_poweroftwo_a00_cc100a00() {
    // Encoding: 0xCC100A00
    // Test aarch32_VLDM_T2A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm8=0, Vd=0, D=0, cond=12, P=0, U=0, W=0
    let encoding: u32 = 0xCC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_13_poweroftwo_a00_dc100a00() {
    // Encoding: 0xDC100A00
    // Test aarch32_VLDM_T2A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=13, U=0, Vd=0, P=0, imm8=0, D=0
    let encoding: u32 = 0xDC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_14_poweroftwo_a00_ec100a00() {
    // Encoding: 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, U=0, W=0, P=0, D=0, cond=14, imm8=0
    let encoding: u32 = 0xEC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vldm_t2a2_a_field_cond_15_max_a00_fc100a00() {
    // Encoding: 0xFC100A00
    // Test aarch32_VLDM_T2A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: P=0, U=0, Vd=0, imm8=0, D=0, cond=15, W=0, Rn=0
    let encoding: u32 = 0xFC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_p_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, U=0, cond=0, Rn=0, imm8=0, D=0, Vd=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_p_1_max_a00_0d100a00() {
    // Encoding: 0x0D100A00
    // Test aarch32_VLDM_T2A2_A field P = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, cond=0, W=0, imm8=0, U=0, P=1, Rn=0
    let encoding: u32 = 0x0D100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_u_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, Vd=0, cond=0, W=0, imm8=0, P=0, D=0, Rn=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_u_1_max_a00_0c900a00() {
    // Encoding: 0x0C900A00
    // Test aarch32_VLDM_T2A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Rn=0, cond=0, Vd=0, W=0, P=0, D=0, imm8=0
    let encoding: u32 = 0x0C900A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_d_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, imm8=0, D=0, Vd=0, Rn=0, W=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_d_1_max_a00_0c500a00() {
    // Encoding: 0x0C500A00
    // Test aarch32_VLDM_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: P=0, W=0, Rn=0, Vd=0, imm8=0, D=1, U=0, cond=0
    let encoding: u32 = 0x0C500A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_w_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field W = 0 (Min)
    // ISET: A32
    // Fields: P=0, imm8=0, D=0, cond=0, Rn=0, W=0, Vd=0, U=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_w_1_max_a00_0c300a00() {
    // Encoding: 0x0C300A00
    // Test aarch32_VLDM_T2A2_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, W=1, Vd=0, P=0, imm8=0, D=0
    let encoding: u32 = 0x0C300A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldm_t2a2_a_field_rn_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, P=0, cond=0, U=0, D=0, W=0, imm8=0, Vd=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldm_t2a2_a_field_rn_1_poweroftwo_a00_0c110a00() {
    // Encoding: 0x0C110A00
    // Test aarch32_VLDM_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, D=0, Rn=1, W=0, cond=0, U=0, imm8=0, Vd=0
    let encoding: u32 = 0x0C110A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldm_t2a2_a_field_vd_0_min_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm8=0, Vd=0, cond=0, Rn=0, P=0, W=0, D=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldm_t2a2_a_field_vd_1_poweroftwo_a00_0c101a00() {
    // Encoding: 0x0C101A00
    // Test aarch32_VLDM_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm8=0, U=0, cond=0, Vd=1, Rn=0, P=0, W=0
    let encoding: u32 = 0x0C101A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_0_zero_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: P=0, U=0, Vd=0, imm8=0, W=0, D=0, Rn=0, cond=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_1_poweroftwo_a00_0c100a01() {
    // Encoding: 0x0C100A01
    // Test aarch32_VLDM_T2A2_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, P=0, Vd=0, cond=0, imm8=1, D=0
    let encoding: u32 = 0x0C100A01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_3_poweroftwominusone_a00_0c100a03() {
    // Encoding: 0x0C100A03
    // Test aarch32_VLDM_T2A2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, P=0, D=0, U=0, imm8=3, cond=0, Vd=0, W=0
    let encoding: u32 = 0x0C100A03;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_4_poweroftwo_a00_0c100a04() {
    // Encoding: 0x0C100A04
    // Test aarch32_VLDM_T2A2_A field imm8 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Vd=0, W=0, imm8=4, U=0, D=0, P=0
    let encoding: u32 = 0x0C100A04;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_7_poweroftwominusone_a00_0c100a07() {
    // Encoding: 0x0C100A07
    // Test aarch32_VLDM_T2A2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm8=7, Vd=0, P=0, U=0, W=0, D=0, Rn=0
    let encoding: u32 = 0x0C100A07;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_8_poweroftwo_a00_0c100a08() {
    // Encoding: 0x0C100A08
    // Test aarch32_VLDM_T2A2_A field imm8 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, D=0, cond=0, U=0, Vd=0, P=0, imm8=8, Rn=0
    let encoding: u32 = 0x0C100A08;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_15_poweroftwominusone_a00_0c100a0f() {
    // Encoding: 0x0C100A0F
    // Test aarch32_VLDM_T2A2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, Vd=0, Rn=0, U=0, W=0, D=0, cond=0, imm8=15
    let encoding: u32 = 0x0C100A0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_16_poweroftwo_a00_0c100a10() {
    // Encoding: 0x0C100A10
    // Test aarch32_VLDM_T2A2_A field imm8 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=16, W=0, cond=0, Rn=0, P=0, U=0, Vd=0, D=0
    let encoding: u32 = 0x0C100A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_31_poweroftwominusone_a00_0c100a1f() {
    // Encoding: 0x0C100A1F
    // Test aarch32_VLDM_T2A2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Rn=0, U=0, imm8=31, Vd=0, cond=0, W=0, P=0
    let encoding: u32 = 0x0C100A1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_32_poweroftwo_a00_0c100a20() {
    // Encoding: 0x0C100A20
    // Test aarch32_VLDM_T2A2_A field imm8 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, Vd=0, Rn=0, U=0, P=0, imm8=32, D=0
    let encoding: u32 = 0x0C100A20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_63_poweroftwominusone_a00_0c100a3f() {
    // Encoding: 0x0C100A3F
    // Test aarch32_VLDM_T2A2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Vd=0, U=0, P=0, imm8=63, cond=0, W=0, Rn=0
    let encoding: u32 = 0x0C100A3F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_64_poweroftwo_a00_0c100a40() {
    // Encoding: 0x0C100A40
    // Test aarch32_VLDM_T2A2_A field imm8 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, W=0, P=0, U=0, Rn=0, imm8=64, cond=0, D=0
    let encoding: u32 = 0x0C100A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_127_poweroftwominusone_a00_0c100a7f() {
    // Encoding: 0x0C100A7F
    // Test aarch32_VLDM_T2A2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Vd=0, W=0, P=0, cond=0, U=0, D=0, imm8=127
    let encoding: u32 = 0x0C100A7F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_128_poweroftwo_a00_0c100a80() {
    // Encoding: 0x0C100A80
    // Test aarch32_VLDM_T2A2_A field imm8 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, U=0, cond=0, W=0, Rn=0, Vd=0, imm8=128, P=0
    let encoding: u32 = 0x0C100A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_255_max_a00_0c100aff() {
    // Encoding: 0x0C100AFF
    // Test aarch32_VLDM_T2A2_A field imm8 = 255 (Max)
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=255, P=0, U=0, cond=0, W=0, Vd=0
    let encoding: u32 = 0x0C100AFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_0_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Rn=0, imm8=0, W=0, U=0, cond=0, P=0, D=0, Vd=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_1_a00_1c100a00() {
    // Encoding: 0x1C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=1, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, D=0, cond=1, P=0, W=0, U=0, Vd=0, Rn=0
    let encoding: u32 = 0x1C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_2_a00_2c100a00() {
    // Encoding: 0x2C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=2, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, cond=2, D=0, imm8=0, Rn=0, W=0, P=0, U=0
    let encoding: u32 = 0x2C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_3_a00_3c100a00() {
    // Encoding: 0x3C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=3, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, W=0, P=0, Rn=0, Vd=0, imm8=0, cond=3, D=0
    let encoding: u32 = 0x3C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_4_a00_4c100a00() {
    // Encoding: 0x4C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=4, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, Vd=0, D=0, U=0, cond=4, imm8=0, W=0, Rn=0
    let encoding: u32 = 0x4C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_5_a00_5c100a00() {
    // Encoding: 0x5C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=5, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Rn=0, U=0, Vd=0, D=0, imm8=0, P=0, cond=5, W=0
    let encoding: u32 = 0x5C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_6_a00_6c100a00() {
    // Encoding: 0x6C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=6, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, Vd=0, cond=6, W=0, Rn=0, P=0, D=0, imm8=0
    let encoding: u32 = 0x6C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_7_a00_7c100a00() {
    // Encoding: 0x7C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=7, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, cond=7, Rn=0, imm8=0, P=0, W=0, Vd=0, D=0
    let encoding: u32 = 0x7C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_8_a00_8c100a00() {
    // Encoding: 0x8C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=8, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, Vd=0, imm8=0, cond=8, Rn=0, P=0, D=0, U=0
    let encoding: u32 = 0x8C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_9_a00_9c100a00() {
    // Encoding: 0x9C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=9, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, W=0, cond=9, imm8=0, P=0, U=0, D=0, Rn=0
    let encoding: u32 = 0x9C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_10_a00_ac100a00() {
    // Encoding: 0xAC100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=10, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, Vd=0, imm8=0, P=0, Rn=0, D=0, W=0, cond=10
    let encoding: u32 = 0xAC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_11_a00_bc100a00() {
    // Encoding: 0xBC100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=11, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, D=0, cond=11, Rn=0, Vd=0, imm8=0, U=0, W=0
    let encoding: u32 = 0xBC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_12_a00_cc100a00() {
    // Encoding: 0xCC100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=12, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, Rn=0, D=0, cond=12, imm8=0, Vd=0, U=0, W=0
    let encoding: u32 = 0xCC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_13_a00_dc100a00() {
    // Encoding: 0xDC100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=13, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, P=0, imm8=0, D=0, cond=13, W=0, U=0, Rn=0
    let encoding: u32 = 0xDC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_14_a00_ec100a00() {
    // Encoding: 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=14, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=14, D=0, W=0, U=0, imm8=0, Rn=0, Vd=0, P=0
    let encoding: u32 = 0xEC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_15_a00_fc100a00() {
    // Encoding: 0xFC100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=15, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, P=0, W=0, Vd=0, cond=15, Rn=0, D=0, U=0
    let encoding: u32 = 0xFC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_16_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, U=0, Vd=0, P=0, cond=0, Rn=0, imm8=0, W=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_17_a00_0d100a00() {
    // Encoding: 0x0D100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=0, P=1, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=0, U=0, D=0, imm8=0, P=1, Vd=0, Rn=0, W=0
    let encoding: u32 = 0x0D100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_18_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, W=0, U=0, Vd=0, imm8=0, D=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_19_a00_0c900a00() {
    // Encoding: 0x0C900A00
    // Test aarch32_VLDM_T2A2_A field combination: cond=0, P=0, U=1, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=0, imm8=0, U=1, Rn=0, P=0, W=0, Vd=0, D=0
    let encoding: u32 = 0x0C900A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_0_condition_eq_2560_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Vd=0, D=0, U=0, cond=0, P=0, imm8=0, W=0, Rn=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_1_condition_ne_2560_1c100a00() {
    // Encoding: 0x1C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, imm8=0, D=0, cond=1, W=0, Vd=0
    let encoding: u32 = 0x1C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_2_condition_cs_hs_2560_2c100a00() {
    // Encoding: 0x2C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, Vd=0, P=0, Rn=0, D=0, cond=2, imm8=0, U=0
    let encoding: u32 = 0x2C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_3_condition_cc_lo_2560_3c100a00() {
    // Encoding: 0x3C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, U=0, Vd=0, Rn=0, cond=3, P=0, imm8=0, D=0
    let encoding: u32 = 0x3C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_4_condition_mi_2560_4c100a00() {
    // Encoding: 0x4C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: P=0, U=0, W=0, D=0, Rn=0, imm8=0, cond=4, Vd=0
    let encoding: u32 = 0x4C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_5_condition_pl_2560_5c100a00() {
    // Encoding: 0x5C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: P=0, W=0, cond=5, D=0, Rn=0, Vd=0, U=0, imm8=0
    let encoding: u32 = 0x5C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_6_condition_vs_2560_6c100a00() {
    // Encoding: 0x6C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Vd=0, P=0, cond=6, W=0, U=0, D=0, imm8=0, Rn=0
    let encoding: u32 = 0x6C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_7_condition_vc_2560_7c100a00() {
    // Encoding: 0x7C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, imm8=0, Vd=0, P=0, cond=7, D=0
    let encoding: u32 = 0x7C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_8_condition_hi_2560_8c100a00() {
    // Encoding: 0x8C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: D=0, U=0, Rn=0, cond=8, Vd=0, imm8=0, P=0, W=0
    let encoding: u32 = 0x8C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_9_condition_ls_2560_9c100a00() {
    // Encoding: 0x9C100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: D=0, cond=9, P=0, Rn=0, U=0, imm8=0, W=0, Vd=0
    let encoding: u32 = 0x9C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_10_condition_ge_2560_ac100a00() {
    // Encoding: 0xAC100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, U=0, D=0, imm8=0, Rn=0, Vd=0, W=0, P=0
    let encoding: u32 = 0xAC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_11_condition_lt_2560_bc100a00() {
    // Encoding: 0xBC100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, cond=11, D=0, imm8=0, W=0, Vd=0, P=0, Rn=0
    let encoding: u32 = 0xBC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_12_condition_gt_2560_cc100a00() {
    // Encoding: 0xCC100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, cond=12, D=0, P=0, Vd=0, imm8=0
    let encoding: u32 = 0xCC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_13_condition_le_2560_dc100a00() {
    // Encoding: 0xDC100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, U=0, D=0, W=0, Rn=0, imm8=0, P=0, Vd=0
    let encoding: u32 = 0xDC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_14_condition_al_2560_ec100a00() {
    // Encoding: 0xEC100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: D=0, U=0, imm8=0, P=0, W=0, cond=14, Vd=0, Rn=0
    let encoding: u32 = 0xEC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vldm_t2a2_a_special_cond_15_condition_nv_2560_fc100a00() {
    // Encoding: 0xFC100A00
    // Test aarch32_VLDM_T2A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm8=0, P=0, U=0, D=0, W=0, Vd=0, Rn=0, cond=15
    let encoding: u32 = 0xFC100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_0_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: imm8=0, W=0, P=0, D=0, Rn=0, U=0, cond=0, Vd=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_1_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: cond=0, U=0, W=0, D=0, P=0, imm8=0, Rn=0, Vd=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_2_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: A32
    // Fields: Rn=0, imm8=0, W=0, Vd=0, cond=0, U=0, P=0, D=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_3_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, P=0, Vd=0, Rn=0, cond=0, W=0, U=0, imm8=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_4_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: A32
    // Fields: Rn=0, U=0, P=0, D=0, cond=0, Vd=0, imm8=0, W=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_5_a00_0c100a00() {
    // Encoding: 0x0C100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Vd=0, W=0, imm8=0, D=0, U=0, P=0, Rn=0
    let encoding: u32 = 0x0C100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_0_min_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field P = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, Rn=0, D=0, Vd=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_1_max_b00_ed100b00() {
    // Thumb encoding (32): 0xED100B00
    // Test aarch32_VLDM_T1A1_A field P = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, W=0, D=0, Vd=0, imm8=0, U=0, P=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_0_min_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field U = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, Vd=0, imm8=0, Rn=0, U=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_1_max_b00_ec900b00() {
    // Thumb encoding (32): 0xEC900B00
    // Test aarch32_VLDM_T1A1_A field U = 1 (Max)
    // ISET: T32
    // Fields: W=0, Vd=0, imm8=0, U=1, D=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC900B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_0_min_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, U=0, D=0, Vd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_1_max_b00_ec500b00() {
    // Thumb encoding (32): 0xEC500B00
    // Test aarch32_VLDM_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, P=0, W=0, Rn=0, Vd=0, D=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_0_min_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field W = 0 (Min)
    // ISET: T32
    // Fields: P=0, U=0, D=0, W=0, Vd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_1_max_b00_ec300b00() {
    // Thumb encoding (32): 0xEC300B00
    // Test aarch32_VLDM_T1A1_A field W = 1 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, U=0, P=0, W=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC300B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_0_min_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: W=0, U=0, Rn=0, imm8=0, P=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_1_poweroftwo_b00_ec110b00() {
    // Thumb encoding (32): 0xEC110B00
    // Test aarch32_VLDM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, W=0, Rn=1, imm8=0, U=0, Vd=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC110B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_0_min_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: W=0, Vd=0, imm8=0, D=0, P=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_1_poweroftwo_b00_ec101b00() {
    // Thumb encoding (32): 0xEC101B00
    // Test aarch32_VLDM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, Vd=1, D=0, P=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC101B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_0_zero_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Vd=0, Rn=0, P=0, U=0, D=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_1_poweroftwo_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rn=0, Vd=0, W=0, D=0, imm8=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_0_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: P=0, U=0, Rn=0, Vd=0, D=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_1_b00_ed100b00() {
    // Thumb encoding (32): 0xED100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=1, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, P=1, Rn=0, D=0, U=0, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_2_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, U=0, Vd=0, imm8=0, D=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_3_b00_ec900b00() {
    // Thumb encoding (32): 0xEC900B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=1, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, imm8=0, U=1, D=0, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC900B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_4_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, W=0, U=0, D=0, Rn=0, P=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_5_b00_ec500b00() {
    // Thumb encoding (32): 0xEC500B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=1, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, P=0, imm8=0, Rn=0, D=1, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_6_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: P=0, Rn=0, Vd=0, D=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_7_b00_ec300b00() {
    // Thumb encoding (32): 0xEC300B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=1, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, U=0, D=0, W=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC300B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_8_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, D=0, W=0, P=0, U=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_9_b00_ec110b00() {
    // Thumb encoding (32): 0xEC110B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=1, Vd=0, imm8=0
    // ISET: T32
    // Fields: W=0, Rn=1, U=0, Vd=0, D=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC110B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_10_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: D=0, P=0, U=0, imm8=0, Rn=0, Vd=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_11_b00_ec101b00() {
    // Thumb encoding (32): 0xEC101B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=1, imm8=0
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, P=0, Rn=0, Vd=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC101B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_12_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, D=0, W=0, imm8=0, Vd=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_13_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=1
    // ISET: T32
    // Fields: U=0, W=0, D=0, P=0, Rn=0, Vd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_0_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, P=0, W=0, Rn=0, Vd=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_1_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, W=0, P=0, U=0, imm8=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_2_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=0, U=0, Vd=0, D=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_3_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, D=0, Vd=0, P=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_4_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, Vd=0, P=0, D=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_5_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, U=0, Rn=0, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_6_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: T32
    // Fields: P=0, D=0, imm8=0, W=0, U=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_7_b00_ec100b00() {
    // Thumb encoding (32): 0xEC100B00
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, Rn=0, D=0, P=0, U=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_p_0_min_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field P = 0 (Min)
    // ISET: T32
    // Fields: U=0, Vd=0, P=0, Rn=0, W=0, D=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_p_1_max_a00_ed100a00() {
    // Thumb encoding (32): 0xED100A00
    // Test aarch32_VLDM_T2A2_A field P = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, U=0, imm8=0, D=0, P=1, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_u_0_min_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field U = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, P=0, U=0, W=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_u_1_max_a00_ec900a00() {
    // Thumb encoding (32): 0xEC900A00
    // Test aarch32_VLDM_T2A2_A field U = 1 (Max)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=0, Vd=0, D=0, P=0, U=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC900A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_d_0_min_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, imm8=0, P=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_d_1_max_a00_ec500a00() {
    // Thumb encoding (32): 0xEC500A00
    // Test aarch32_VLDM_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: P=0, D=1, Vd=0, W=0, imm8=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t2a2_a_field_w_0_min_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field W = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, D=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t2a2_a_field_w_1_max_a00_ec300a00() {
    // Thumb encoding (32): 0xEC300A00
    // Test aarch32_VLDM_T2A2_A field W = 1 (Max)
    // ISET: T32
    // Fields: W=1, P=0, U=0, Rn=0, D=0, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC300A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldm_t2a2_a_field_rn_0_min_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: U=0, P=0, Rn=0, imm8=0, W=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldm_t2a2_a_field_rn_1_poweroftwo_a00_ec110a00() {
    // Thumb encoding (32): 0xEC110A00
    // Test aarch32_VLDM_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=1, Vd=0, imm8=0, D=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC110A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldm_t2a2_a_field_vd_0_min_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, P=0, W=0, imm8=0, D=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldm_t2a2_a_field_vd_1_poweroftwo_a00_ec101a00() {
    // Thumb encoding (32): 0xEC101A00
    // Test aarch32_VLDM_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, imm8=0, Vd=1, U=0, D=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC101A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_0_zero_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, D=0, Rn=0, W=0, P=0, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_1_poweroftwo_a00_ec100a01() {
    // Thumb encoding (32): 0xEC100A01
    // Test aarch32_VLDM_T2A2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, W=0, imm8=1, Rn=0, D=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_3_poweroftwominusone_a00_ec100a03() {
    // Thumb encoding (32): 0xEC100A03
    // Test aarch32_VLDM_T2A2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, U=0, W=0, P=0, Rn=0, imm8=3, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_4_poweroftwo_a00_ec100a04() {
    // Thumb encoding (32): 0xEC100A04
    // Test aarch32_VLDM_T2A2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, W=0, Rn=0, P=0, D=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_7_poweroftwominusone_a00_ec100a07() {
    // Thumb encoding (32): 0xEC100A07
    // Test aarch32_VLDM_T2A2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, U=0, W=0, Vd=0, P=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_8_poweroftwo_a00_ec100a08() {
    // Thumb encoding (32): 0xEC100A08
    // Test aarch32_VLDM_T2A2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, imm8=8, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_15_poweroftwominusone_a00_ec100a0f() {
    // Thumb encoding (32): 0xEC100A0F
    // Test aarch32_VLDM_T2A2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, U=0, Vd=0, W=0, P=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_16_poweroftwo_a00_ec100a10() {
    // Thumb encoding (32): 0xEC100A10
    // Test aarch32_VLDM_T2A2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, Rn=0, Vd=0, W=0, imm8=16, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_31_poweroftwominusone_a00_ec100a1f() {
    // Thumb encoding (32): 0xEC100A1F
    // Test aarch32_VLDM_T2A2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, imm8=31, D=0, P=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_32_poweroftwo_a00_ec100a20() {
    // Thumb encoding (32): 0xEC100A20
    // Test aarch32_VLDM_T2A2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, U=0, P=0, Vd=0, imm8=32, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_63_poweroftwominusone_a00_ec100a3f() {
    // Thumb encoding (32): 0xEC100A3F
    // Test aarch32_VLDM_T2A2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rn=0, W=0, P=0, Vd=0, imm8=63, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_64_poweroftwo_a00_ec100a40() {
    // Thumb encoding (32): 0xEC100A40
    // Test aarch32_VLDM_T2A2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, imm8=64, D=0, P=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_127_poweroftwominusone_a00_ec100a7f() {
    // Thumb encoding (32): 0xEC100A7F
    // Test aarch32_VLDM_T2A2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, D=0, U=0, P=0, Rn=0, Vd=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_128_poweroftwo_a00_ec100a80() {
    // Thumb encoding (32): 0xEC100A80
    // Test aarch32_VLDM_T2A2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, U=0, D=0, Rn=0, W=0, P=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vldm_t2a2_a_field_imm8_255_max_a00_ec100aff() {
    // Thumb encoding (32): 0xEC100AFF
    // Test aarch32_VLDM_T2A2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, Vd=0, D=0, imm8=255, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100AFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_0_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, U=0, D=0, Rn=0, P=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_1_a00_ed100a00() {
    // Thumb encoding (32): 0xED100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=1, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, U=0, W=0, Vd=0, D=0, P=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_2_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, W=0, D=0, U=0, Rn=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_3_a00_ec900a00() {
    // Thumb encoding (32): 0xEC900A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=1, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, D=0, U=1, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC900A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_4_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, W=0, U=0, P=0, D=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_5_a00_ec500a00() {
    // Thumb encoding (32): 0xEC500A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=1, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, imm8=0, D=1, P=0, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_6_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, W=0, D=0, U=0, P=0, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_7_a00_ec300a00() {
    // Thumb encoding (32): 0xEC300A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=1, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: P=0, U=0, D=0, W=1, Rn=0, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC300A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_8_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Vd=0, W=0, P=0, Rn=0, U=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_9_a00_ec110a00() {
    // Thumb encoding (32): 0xEC110A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=1, Vd=0, imm8=0
    // ISET: T32
    // Fields: D=0, P=0, imm8=0, U=0, Rn=1, Vd=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC110A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_10_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, D=0, Rn=0, P=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_11_a00_ec101a00() {
    // Thumb encoding (32): 0xEC101A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=1, imm8=0
    // ISET: T32
    // Fields: Rn=0, Vd=1, imm8=0, W=0, U=0, P=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC101A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_12_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: P=0, imm8=0, W=0, U=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_13_a00_ec100a01() {
    // Thumb encoding (32): 0xEC100A01
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=1
    // ISET: T32
    // Fields: W=0, Rn=0, U=0, Vd=0, D=0, imm8=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_14_a00_ec100a03() {
    // Thumb encoding (32): 0xEC100A03
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=3
    // ISET: T32
    // Fields: P=0, Rn=0, imm8=3, U=0, D=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_15_a00_ec100a04() {
    // Thumb encoding (32): 0xEC100A04
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=4
    // ISET: T32
    // Fields: P=0, W=0, Vd=0, U=0, D=0, imm8=4, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_16_a00_ec100a07() {
    // Thumb encoding (32): 0xEC100A07
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=7
    // ISET: T32
    // Fields: U=0, P=0, D=0, imm8=7, W=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_17_a00_ec100a08() {
    // Thumb encoding (32): 0xEC100A08
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=8
    // ISET: T32
    // Fields: U=0, Rn=0, Vd=0, D=0, P=0, W=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_vldm_t2a2_a_combo_18_a00_ec100a0f() {
    // Thumb encoding (32): 0xEC100A0F
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=15
    // ISET: T32
    // Fields: D=0, W=0, U=0, Vd=0, P=0, Rn=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_vldm_t2a2_a_combo_19_a00_ec100a10() {
    // Thumb encoding (32): 0xEC100A10
    // Test aarch32_VLDM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=16
    // ISET: T32
    // Fields: D=0, P=0, W=0, Rn=0, U=0, Vd=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_0_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: U=0, Rn=0, D=0, P=0, W=0, imm8=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_1_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: P=0, Vd=0, imm8=0, U=0, D=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_2_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: T32
    // Fields: W=0, D=0, Rn=0, P=0, Vd=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_3_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, P=0, imm8=0, U=0, Rn=0, W=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_4_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: T32
    // Fields: P=0, U=0, W=0, Rn=0, imm8=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t2a2_a_invalid_5_a00_ec100a00() {
    // Thumb encoding (32): 0xEC100A00
    // Test aarch32_VLDM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, imm8=0, W=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD2_m_A Tests
// ============================================================================

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_d_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, align=0, Vd=0, type1=0, size=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_d_1_max_800_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_VLD2_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, Rm=0, D=1, type1=0, size=0, align=0, Rn=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rn_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rm=0, type1=0, size=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rn_1_poweroftwo_800_f4210000() {
    // Encoding: 0xF4210000
    // Test aarch32_VLD2_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rn=1, type1=0, size=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_vd_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: type1=0, align=0, size=0, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_vd_1_poweroftwo_800_f4201000() {
    // Encoding: 0xF4201000
    // Test aarch32_VLD2_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, size=0, type1=0, Rm=0, D=0, Rn=0, Vd=1
    let encoding: u32 = 0xF4201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, align=0, Rn=0, Vd=0, D=0, type1=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_1_poweroftwo_800_f4200100() {
    // Encoding: 0xF4200100
    // Test aarch32_VLD2_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, size=0, Rm=0, Rn=0, Vd=0, D=0, type1=1
    let encoding: u32 = 0xF4200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_7_poweroftwominusone_800_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD2_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Vd=0, type1=7, Rn=0, D=0, size=0, align=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_15_max_800_f4200f00() {
    // Encoding: 0xF4200F00
    // Test aarch32_VLD2_m_T1A1_A field type1 = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, D=0, type1=15, align=0, Rn=0
    let encoding: u32 = 0xF4200F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, type1=0, Rn=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_1_poweroftwo_800_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD2_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, D=0, Vd=0, type1=0, Rm=0, size=1, Rn=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_2_poweroftwo_800_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD2_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, size=2, D=0, Vd=0, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_3_max_800_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD2_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vd=0, Rm=0, Rn=0, type1=0, size=3, D=0, align=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_align_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, type1=0, size=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_align_1_poweroftwo_800_f4200010() {
    // Encoding: 0xF4200010
    // Test aarch32_VLD2_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, align=1, Rn=0, D=0, type1=0
    let encoding: u32 = 0xF4200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_align_3_max_800_f4200030() {
    // Encoding: 0xF4200030
    // Test aarch32_VLD2_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: align=3, Vd=0, Rn=0, Rm=0, D=0, type1=0, size=0
    let encoding: u32 = 0xF4200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rm_0_min_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: align=0, type1=0, size=0, Vd=0, Rn=0, D=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rm_1_poweroftwo_800_f4200001() {
    // Encoding: 0xF4200001
    // Test aarch32_VLD2_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rn=0, type1=0, size=0, D=0, Rm=1, Vd=0
    let encoding: u32 = 0xF4200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_0_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, type1=0, align=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_1_800_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=1, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, align=0, Vd=0, type1=0, Rn=0, Rm=0, D=1
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_2_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, align=0, Rn=0, Vd=0, type1=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_3_800_f4210000() {
    // Encoding: 0xF4210000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Rm=0, type1=0, D=0, Vd=0, Rn=1, size=0
    let encoding: u32 = 0xF4210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_4_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, type1=0, Vd=0, Rn=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_5_800_f4201000() {
    // Encoding: 0xF4201000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=1, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=1, size=0, Rn=0, D=0, align=0, type1=0
    let encoding: u32 = 0xF4201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_6_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, size=0, align=0, Rn=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=1 (value 1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_7_800_f4200100() {
    // Encoding: 0xF4200100
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, type1=1, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_8_800_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=7, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, type1=7, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_9_800_f4200f00() {
    // Encoding: 0xF4200F00
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=15, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, align=0, size=0, Rm=0, Vd=0, type1=15, Rn=0
    let encoding: u32 = 0xF4200F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_10_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, align=0, size=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_11_800_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, align=0, size=1, type1=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_12_800_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, type1=0, size=2, D=0, Rm=0, align=0, Rn=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_13_800_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, type1=0, align=0, Rm=0, D=0, size=3
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_14_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, align=0, type1=0, Vd=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_15_800_f4200010() {
    // Encoding: 0xF4200010
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, type1=0, align=1, size=0, Vd=0
    let encoding: u32 = 0xF4200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_16_800_f4200030() {
    // Encoding: 0xF4200030
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: D=0, align=3, size=0, Vd=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0xF4200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_17_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, type1=0, size=0, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_18_800_f4200001() {
    // Encoding: 0xF4200001
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: size=0, align=0, D=0, Rm=1, Rn=0, Vd=0, type1=0
    let encoding: u32 = 0xF4200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_19_800_f4210001() {
    // Encoding: 0xF4210001
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: D=0, size=0, Rm=1, Rn=1, Vd=0, align=0, type1=0
    let encoding: u32 = 0xF4210001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_0_size_variant_0_2048_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: type1=0, D=0, Rn=0, size=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_1_size_variant_1_2048_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD2_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, D=0, Vd=0, size=1, align=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_2_size_variant_2_2048_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD2_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, type1=0, size=2, align=0, Rm=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_3_size_variant_3_2048_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD2_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, D=0, align=0, size=3, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_0_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, Vd=0, type1=0, D=0, size=0, align=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_1_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, align=0, Vd=0, type1=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_2_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: type1=0, Vd=0, D=0, size=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_3_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, Vd=0, Rn=0, type1=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_4_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, type1=0, size=0, Rm=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_5_800_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Vd=0, type1=0, size=0, align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_d_0_min_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, align=0, Rm=0, Vd=0, size=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_d_1_max_300_f4600300() {
    // Encoding: 0xF4600300
    // Test aarch32_VLD2_m_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=1, align=0, Rm=0
    let encoding: u32 = 0xF4600300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rn_0_min_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rn=0, size=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rn_1_poweroftwo_300_f4210300() {
    // Encoding: 0xF4210300
    // Test aarch32_VLD2_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, align=0, Rn=1, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4210300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_vd_0_min_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, D=0, align=0, Rm=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_vd_1_poweroftwo_300_f4201300() {
    // Encoding: 0xF4201300
    // Test aarch32_VLD2_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=1, D=0, size=0, align=0
    let encoding: u32 = 0xF4201300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_0_min_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rm=0, D=0, Vd=0, size=0, Rn=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_1_poweroftwo_300_f4200340() {
    // Encoding: 0xF4200340
    // Test aarch32_VLD2_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=0, size=1, Rn=0, align=0, Vd=0
    let encoding: u32 = 0xF4200340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_2_poweroftwo_300_f4200380() {
    // Encoding: 0xF4200380
    // Test aarch32_VLD2_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=2, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4200380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_3_max_300_f42003c0() {
    // Encoding: 0xF42003C0
    // Test aarch32_VLD2_m_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, align=0, size=3, D=0
    let encoding: u32 = 0xF42003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_align_0_min_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_align_1_poweroftwo_300_f4200310() {
    // Encoding: 0xF4200310
    // Test aarch32_VLD2_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, size=0, Rn=0, align=1
    let encoding: u32 = 0xF4200310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_align_3_max_300_f4200330() {
    // Encoding: 0xF4200330
    // Test aarch32_VLD2_m_T2A2_A field align = 3 (Max)
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, Rm=0, Rn=0, align=3
    let encoding: u32 = 0xF4200330;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rm_0_min_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, D=0, size=0, Vd=0, Rn=0, align=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rm_1_poweroftwo_300_f4200301() {
    // Encoding: 0xF4200301
    // Test aarch32_VLD2_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=1, Vd=0, size=0, D=0, align=0
    let encoding: u32 = 0xF4200301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_0_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rm=0, Vd=0, Rn=0, align=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_1_300_f4600300() {
    // Encoding: 0xF4600300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, align=0, Vd=0, size=0, Rn=0, D=1
    let encoding: u32 = 0xF4600300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_2_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, size=0, align=0, Vd=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_3_300_f4210300() {
    // Encoding: 0xF4210300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, align=0, D=0, Vd=0, Rn=1
    let encoding: u32 = 0xF4210300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_4_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, size=0, Rn=0, Vd=0, align=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_5_300_f4201300() {
    // Encoding: 0xF4201300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, Rm=0, align=0, Vd=1
    let encoding: u32 = 0xF4201300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_6_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_7_300_f4200340() {
    // Encoding: 0xF4200340
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=0, D=0, size=1, Rn=0
    let encoding: u32 = 0xF4200340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_8_300_f4200380() {
    // Encoding: 0xF4200380
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=2, Rm=0, Rn=0, align=0, Vd=0
    let encoding: u32 = 0xF4200380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_9_300_f42003c0() {
    // Encoding: 0xF42003C0
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: size=3, align=0, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF42003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_10_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_11_300_f4200310() {
    // Encoding: 0xF4200310
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, size=0, align=1
    let encoding: u32 = 0xF4200310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_12_300_f4200330() {
    // Encoding: 0xF4200330
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: Rn=0, align=3, D=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4200330;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_13_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Vd=0, Rn=0, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_14_300_f4200301() {
    // Encoding: 0xF4200301
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: align=0, D=0, Vd=0, Rm=1, size=0, Rn=0
    let encoding: u32 = 0xF4200301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_15_300_f4210301() {
    // Encoding: 0xF4210301
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: Rn=1, D=0, size=0, Rm=1, align=0, Vd=0
    let encoding: u32 = 0xF4210301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_16_300_f42f030f() {
    // Encoding: 0xF42F030F
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: A32
    // Fields: size=0, align=0, Rm=31, D=0, Vd=0, Rn=31
    let encoding: u32 = 0xF42F030F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_0_size_variant_0_768_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, Vd=0, D=0, align=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_1_size_variant_1_768_f4200340() {
    // Encoding: 0xF4200340
    // Test aarch32_VLD2_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, Rn=0, align=0, size=1, Vd=0, Rm=0
    let encoding: u32 = 0xF4200340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_2_size_variant_2_768_f4200380() {
    // Encoding: 0xF4200380
    // Test aarch32_VLD2_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, size=2, align=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4200380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_3_size_variant_3_768_f42003c0() {
    // Encoding: 0xF42003C0
    // Test aarch32_VLD2_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, align=0, size=3, Rn=0
    let encoding: u32 = 0xF42003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_0_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_1_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Rn=0, align=0, Rm=0, Vd=0, size=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_2_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: align=0, Rm=0, size=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_3_300_f4200300() {
    // Encoding: 0xF4200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, align=0, Vd=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4200300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_d_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=0, type1=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_d_1_max_800_f9600000() {
    // Thumb encoding (32): 0xF9600000
    // Test aarch32_VLD2_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, D=1, type1=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rn_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: align=0, D=0, size=0, type1=0, Vd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rn_1_poweroftwo_800_f9210000() {
    // Thumb encoding (32): 0xF9210000
    // Test aarch32_VLD2_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, D=0, size=0, Rm=0, type1=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_vd_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, align=0, Vd=0, D=0, Rn=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_vd_1_poweroftwo_800_f9201000() {
    // Thumb encoding (32): 0xF9201000
    // Test aarch32_VLD2_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, size=0, align=0, Rm=0, D=0, Vd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, Rm=0, Rn=0, size=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_1_poweroftwo_800_f9200100() {
    // Thumb encoding (32): 0xF9200100
    // Test aarch32_VLD2_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, type1=1, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_7_poweroftwominusone_800_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD2_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, type1=7, align=0, Rm=0, size=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_type1_15_max_800_f9200f00() {
    // Thumb encoding (32): 0xF9200F00
    // Test aarch32_VLD2_m_T1A1_A field type1 = 15 (Max)
    // ISET: T32
    // Fields: type1=15, D=0, Vd=0, size=0, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, align=0, Rn=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_1_poweroftwo_800_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD2_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, type1=0, size=1, Rm=0, Rn=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_2_poweroftwo_800_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD2_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=2, type1=0, align=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_size_3_max_800_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD2_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: align=0, size=3, Rn=0, type1=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_align_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, size=0, align=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_align_1_poweroftwo_800_f9200010() {
    // Thumb encoding (32): 0xF9200010
    // Test aarch32_VLD2_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, size=0, align=1, D=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_align_3_max_800_f9200030() {
    // Thumb encoding (32): 0xF9200030
    // Test aarch32_VLD2_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: size=0, type1=0, D=0, Rm=0, Vd=0, align=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rm_0_min_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, type1=0, D=0, Rn=0, Vd=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t1a1_a_field_rm_1_poweroftwo_800_f9200001() {
    // Thumb encoding (32): 0xF9200001
    // Test aarch32_VLD2_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, align=0, Rm=1, type1=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_0_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, Rn=0, size=0, align=0, D=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_1_800_f9600000() {
    // Thumb encoding (32): 0xF9600000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=1, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=1, align=0, size=0, Vd=0, Rm=0, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_2_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Vd=0, Rn=0, type1=0, size=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_3_800_f9210000() {
    // Thumb encoding (32): 0xF9210000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, align=0, Rm=0, Rn=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_4_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, type1=0, Vd=0, align=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_5_800_f9201000() {
    // Thumb encoding (32): 0xF9201000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=1, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, size=0, align=0, Vd=1, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_6_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=1 (value 1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_7_800_f9200100() {
    // Thumb encoding (32): 0xF9200100
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Vd=0, align=0, type1=1, D=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_8_800_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=7, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, align=0, type1=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_9_800_f9200f00() {
    // Thumb encoding (32): 0xF9200F00
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=15, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, D=0, Vd=0, type1=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_10_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, size=0, Vd=0, align=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_11_800_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, D=0, size=1, align=0, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_12_800_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, type1=0, Rm=0, Vd=0, align=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_13_800_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, Rm=0, size=3, Rn=0, Vd=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_14_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, Rm=0, Vd=0, align=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_15_800_f9200010() {
    // Thumb encoding (32): 0xF9200010
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: size=0, Rn=0, D=0, align=1, Rm=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_16_800_f9200030() {
    // Thumb encoding (32): 0xF9200030
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: type1=0, D=0, Rn=0, align=3, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_17_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, align=0, type1=0, size=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_18_800_f9200001() {
    // Thumb encoding (32): 0xF9200001
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: D=0, size=0, align=0, Vd=0, type1=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_m_t1a1_a_combo_19_800_f9210001() {
    // Thumb encoding (32): 0xF9210001
    // Test aarch32_VLD2_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: align=0, Rm=1, Rn=1, D=0, Vd=0, type1=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_0_size_variant_0_2048_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: type1=0, D=0, size=0, Rn=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_1_size_variant_1_2048_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD2_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: type1=0, D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_2_size_variant_2_2048_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD2_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, type1=0, size=2, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_m_t1a1_a_special_size_3_size_variant_3_2048_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD2_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Vd=0, type1=0, align=0, size=3, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_0_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Rn=0, type1=0, Vd=0, size=0, Rm=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_1_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, Rm=0, type1=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_2_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, Rn=0, Vd=0, type1=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_3_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, align=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_4_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: type1=0, size=0, Rm=0, align=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t1a1_a_invalid_5_800_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD2_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: type1=0, size=0, Rn=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_d_0_min_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, align=0, D=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_d_1_max_300_f9600300() {
    // Thumb encoding (32): 0xF9600300
    // Test aarch32_VLD2_m_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: align=0, Vd=0, D=1, size=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rn_0_min_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rn_1_poweroftwo_300_f9210300() {
    // Thumb encoding (32): 0xF9210300
    // Test aarch32_VLD2_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, size=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_vd_0_min_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_vd_1_poweroftwo_300_f9201300() {
    // Thumb encoding (32): 0xF9201300
    // Test aarch32_VLD2_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=1, size=0, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_0_min_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, D=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_1_poweroftwo_300_f9200340() {
    // Thumb encoding (32): 0xF9200340
    // Test aarch32_VLD2_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, Vd=0, Rn=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_2_poweroftwo_300_f9200380() {
    // Thumb encoding (32): 0xF9200380
    // Test aarch32_VLD2_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, size=2, align=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_size_3_max_300_f92003c0() {
    // Thumb encoding (32): 0xF92003C0
    // Test aarch32_VLD2_m_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=3, align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_align_0_min_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_align_1_poweroftwo_300_f9200310() {
    // Thumb encoding (32): 0xF9200310
    // Test aarch32_VLD2_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=0, D=0, Rn=0, align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_align_3_max_300_f9200330() {
    // Thumb encoding (32): 0xF9200330
    // Test aarch32_VLD2_m_T2A2_A field align = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, align=3, D=0, Rm=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200330;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rm_0_min_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_m_t2a2_a_field_rm_1_poweroftwo_300_f9200301() {
    // Thumb encoding (32): 0xF9200301
    // Test aarch32_VLD2_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, Vd=0, size=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_0_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, align=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_1_300_f9600300() {
    // Thumb encoding (32): 0xF9600300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rn=0, Vd=0, size=0, Rm=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_2_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, align=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_3_300_f9210300() {
    // Thumb encoding (32): 0xF9210300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Rn=1, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_4_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, Vd=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_5_300_f9201300() {
    // Thumb encoding (32): 0xF9201300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, Vd=1, D=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_6_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, align=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_7_300_f9200340() {
    // Thumb encoding (32): 0xF9200340
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, align=0, Rm=0, size=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_8_300_f9200380() {
    // Thumb encoding (32): 0xF9200380
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, align=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_9_300_f92003c0() {
    // Thumb encoding (32): 0xF92003C0
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, size=3, D=0, Vd=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_10_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_11_300_f9200310() {
    // Thumb encoding (32): 0xF9200310
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: size=0, Rn=0, Rm=0, D=0, Vd=0, align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_12_300_f9200330() {
    // Thumb encoding (32): 0xF9200330
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, size=0, align=3, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200330;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_13_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_14_300_f9200301() {
    // Thumb encoding (32): 0xF9200301
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, align=0, Vd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_15_300_f9210301() {
    // Thumb encoding (32): 0xF9210301
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: D=0, Rn=1, align=0, size=0, Vd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_m_t2a2_a_combo_16_300_f92f030f() {
    // Thumb encoding (32): 0xF92F030F
    // Test aarch32_VLD2_m_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, size=0, Vd=0, align=0, D=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92F030F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_0_size_variant_0_768_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, align=0, D=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_1_size_variant_1_768_f9200340() {
    // Thumb encoding (32): 0xF9200340
    // Test aarch32_VLD2_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, align=0, Rm=0, D=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_2_size_variant_2_768_f9200380() {
    // Thumb encoding (32): 0xF9200380
    // Test aarch32_VLD2_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, Vd=0, Rm=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_m_t2a2_a_special_size_3_size_variant_3_768_f92003c0() {
    // Thumb encoding (32): 0xF92003C0
    // Test aarch32_VLD2_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: align=0, Vd=0, Rn=0, D=0, size=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_0_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, Rn=0, align=0, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_1_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_2_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, D=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_m_t2a2_a_invalid_3_300_f9200300() {
    // Thumb encoding (32): 0xF9200300
    // Test aarch32_VLD2_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLDR_A Tests
// ============================================================================

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_0_min_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: D=0, U=0, Vd=0, imm8=0, size=0, cond=0, Rn=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_1_poweroftwo_800_1d100800() {
    // Encoding: 0x1D100800
    // Test aarch32_VLDR_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, cond=1, imm8=0, U=0, D=0
    let encoding: u32 = 0x1D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_2_poweroftwo_800_2d100800() {
    // Encoding: 0x2D100800
    // Test aarch32_VLDR_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, U=0, cond=2, D=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0x2D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_3_poweroftwo_800_3d100800() {
    // Encoding: 0x3D100800
    // Test aarch32_VLDR_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Vd=0, D=0, size=0, imm8=0, U=0, Rn=0
    let encoding: u32 = 0x3D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_4_poweroftwo_800_4d100800() {
    // Encoding: 0x4D100800
    // Test aarch32_VLDR_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, imm8=0, Rn=0, D=0, size=0, U=0, Vd=0
    let encoding: u32 = 0x4D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_5_poweroftwo_800_5d100800() {
    // Encoding: 0x5D100800
    // Test aarch32_VLDR_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, D=0, Vd=0, imm8=0, size=0, cond=5
    let encoding: u32 = 0x5D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_6_poweroftwo_800_6d100800() {
    // Encoding: 0x6D100800
    // Test aarch32_VLDR_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, cond=6, U=0, D=0, Rn=0, Vd=0, imm8=0
    let encoding: u32 = 0x6D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_7_poweroftwo_800_7d100800() {
    // Encoding: 0x7D100800
    // Test aarch32_VLDR_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, U=0, size=0, cond=7, imm8=0, Rn=0
    let encoding: u32 = 0x7D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_8_poweroftwo_800_8d100800() {
    // Encoding: 0x8D100800
    // Test aarch32_VLDR_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, D=0, imm8=0, cond=8, U=0
    let encoding: u32 = 0x8D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_9_poweroftwo_800_9d100800() {
    // Encoding: 0x9D100800
    // Test aarch32_VLDR_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rn=0, U=0, cond=9, Vd=0, imm8=0, D=0
    let encoding: u32 = 0x9D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_10_poweroftwo_800_ad100800() {
    // Encoding: 0xAD100800
    // Test aarch32_VLDR_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vd=0, size=0, Rn=0, cond=10, imm8=0, D=0
    let encoding: u32 = 0xAD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_11_poweroftwo_800_bd100800() {
    // Encoding: 0xBD100800
    // Test aarch32_VLDR_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, imm8=0, D=0, U=0, cond=11, Rn=0, Vd=0
    let encoding: u32 = 0xBD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_12_poweroftwo_800_cd100800() {
    // Encoding: 0xCD100800
    // Test aarch32_VLDR_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, cond=12, U=0, Vd=0, imm8=0
    let encoding: u32 = 0xCD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_13_poweroftwo_800_dd100800() {
    // Encoding: 0xDD100800
    // Test aarch32_VLDR_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm8=0, cond=13, size=0, D=0, U=0, Vd=0
    let encoding: u32 = 0xDD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_14_poweroftwo_800_ed100800() {
    // Encoding: 0xED100800
    // Test aarch32_VLDR_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, imm8=0, cond=14, D=0, U=0
    let encoding: u32 = 0xED100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vldr_a1_a_field_cond_15_max_800_fd100800() {
    // Encoding: 0xFD100800
    // Test aarch32_VLDR_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, imm8=0, D=0, U=0, size=0, cond=15, Rn=0
    let encoding: u32 = 0xFD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldr_a1_a_field_u_0_min_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: D=0, imm8=0, cond=0, Rn=0, U=0, size=0, Vd=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldr_a1_a_field_u_1_max_800_0d900800() {
    // Encoding: 0x0D900800
    // Test aarch32_VLDR_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, D=0, Vd=0, U=1, size=0, imm8=0
    let encoding: u32 = 0x0D900800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldr_a1_a_field_d_0_min_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: imm8=0, D=0, Rn=0, U=0, cond=0, Vd=0, size=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldr_a1_a_field_d_1_max_800_0d500800() {
    // Encoding: 0x0D500800
    // Test aarch32_VLDR_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, U=0, Vd=0, imm8=0, cond=0, size=0, D=1
    let encoding: u32 = 0x0D500800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldr_a1_a_field_rn_0_min_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm8=0, Rn=0, Vd=0, U=0, D=0, cond=0, size=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldr_a1_a_field_rn_1_poweroftwo_800_0d110800() {
    // Encoding: 0x0D110800
    // Test aarch32_VLDR_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, U=0, D=0, Vd=0, size=0, imm8=0
    let encoding: u32 = 0x0D110800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldr_a1_a_field_vd_0_min_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, imm8=0, D=0, cond=0, Vd=0, U=0, Rn=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldr_a1_a_field_vd_1_poweroftwo_800_0d101800() {
    // Encoding: 0x0D101800
    // Test aarch32_VLDR_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, U=0, Vd=1, imm8=0, size=0, cond=0
    let encoding: u32 = 0x0D101800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vldr_a1_a_field_size_0_min_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: cond=0, D=0, Rn=0, Vd=0, size=0, imm8=0, U=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vldr_a1_a_field_size_1_poweroftwo_800_0d100900() {
    // Encoding: 0x0D100900
    // Test aarch32_VLDR_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=1, imm8=0, D=0, U=0, Rn=0, cond=0
    let encoding: u32 = 0x0D100900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vldr_a1_a_field_size_2_poweroftwo_800_0d100a00() {
    // Encoding: 0x0D100A00
    // Test aarch32_VLDR_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, cond=0, imm8=0, U=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0x0D100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vldr_a1_a_field_size_3_max_800_0d100b00() {
    // Encoding: 0x0D100B00
    // Test aarch32_VLDR_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Vd=0, D=0, imm8=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x0D100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_0_zero_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, D=0, imm8=0, Vd=0, size=0, U=0, Rn=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_1_poweroftwo_800_0d100801() {
    // Encoding: 0x0D100801
    // Test aarch32_VLDR_A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, U=0, cond=0, imm8=1, Rn=0
    let encoding: u32 = 0x0D100801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_3_poweroftwominusone_800_0d100803() {
    // Encoding: 0x0D100803
    // Test aarch32_VLDR_A1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Vd=0, imm8=3, Rn=0, cond=0, size=0, D=0
    let encoding: u32 = 0x0D100803;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_4_poweroftwo_800_0d100804() {
    // Encoding: 0x0D100804
    // Test aarch32_VLDR_A1_A field imm8 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, D=0, imm8=4, Rn=0, Vd=0, size=0
    let encoding: u32 = 0x0D100804;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_7_poweroftwominusone_800_0d100807() {
    // Encoding: 0x0D100807
    // Test aarch32_VLDR_A1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, Rn=0, U=0, cond=0, D=0, Vd=0, imm8=7
    let encoding: u32 = 0x0D100807;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_8_poweroftwo_800_0d100808() {
    // Encoding: 0x0D100808
    // Test aarch32_VLDR_A1_A field imm8 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm8=8, Vd=0, cond=0, Rn=0, size=0, D=0
    let encoding: u32 = 0x0D100808;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_15_poweroftwominusone_800_0d10080f() {
    // Encoding: 0x0D10080F
    // Test aarch32_VLDR_A1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Vd=0, U=0, size=0, imm8=15, cond=0, Rn=0
    let encoding: u32 = 0x0D10080F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_16_poweroftwo_800_0d100810() {
    // Encoding: 0x0D100810
    // Test aarch32_VLDR_A1_A field imm8 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=16, cond=0, U=0, Rn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0x0D100810;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_31_poweroftwominusone_800_0d10081f() {
    // Encoding: 0x0D10081F
    // Test aarch32_VLDR_A1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, Vd=0, Rn=0, U=0, cond=0, imm8=31, D=0
    let encoding: u32 = 0x0D10081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_32_poweroftwo_800_0d100820() {
    // Encoding: 0x0D100820
    // Test aarch32_VLDR_A1_A field imm8 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, size=0, imm8=32, Vd=0, cond=0, D=0
    let encoding: u32 = 0x0D100820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_63_poweroftwominusone_800_0d10083f() {
    // Encoding: 0x0D10083F
    // Test aarch32_VLDR_A1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, U=0, imm8=63, D=0, Vd=0, size=0, Rn=0
    let encoding: u32 = 0x0D10083F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_64_poweroftwo_800_0d100840() {
    // Encoding: 0x0D100840
    // Test aarch32_VLDR_A1_A field imm8 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=64, Rn=0, U=0, Vd=0, D=0, cond=0, size=0
    let encoding: u32 = 0x0D100840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_127_poweroftwominusone_800_0d10087f() {
    // Encoding: 0x0D10087F
    // Test aarch32_VLDR_A1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, imm8=127, Rn=0, cond=0, U=0, D=0, Vd=0
    let encoding: u32 = 0x0D10087F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_128_poweroftwo_800_0d100880() {
    // Encoding: 0x0D100880
    // Test aarch32_VLDR_A1_A field imm8 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=128, size=0, U=0, cond=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0x0D100880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vldr_a1_a_field_imm8_255_max_800_0d1008ff() {
    // Encoding: 0x0D1008FF
    // Test aarch32_VLDR_A1_A field imm8 = 255 (Max)
    // ISET: A32
    // Fields: size=0, cond=0, Vd=0, imm8=255, U=0, D=0, Rn=0
    let encoding: u32 = 0x0D1008FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vldr_a1_a_combo_0_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field combination: cond=0, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: Rn=0, size=0, imm8=0, cond=0, U=0, D=0, Vd=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vldr_a1_a_combo_1_800_1d100800() {
    // Encoding: 0x1D100800
    // Test aarch32_VLDR_A1_A field combination: cond=1, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: D=0, cond=1, Rn=0, Vd=0, size=0, U=0, imm8=0
    let encoding: u32 = 0x1D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vldr_a1_a_combo_2_800_2d100800() {
    // Encoding: 0x2D100800
    // Test aarch32_VLDR_A1_A field combination: cond=2, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: size=0, cond=2, Vd=0, imm8=0, U=0, D=0, Rn=0
    let encoding: u32 = 0x2D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vldr_a1_a_combo_3_800_3d100800() {
    // Encoding: 0x3D100800
    // Test aarch32_VLDR_A1_A field combination: cond=3, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, Rn=0, cond=3, Vd=0, size=0, D=0, U=0
    let encoding: u32 = 0x3D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vldr_a1_a_combo_4_800_4d100800() {
    // Encoding: 0x4D100800
    // Test aarch32_VLDR_A1_A field combination: cond=4, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: cond=4, Rn=0, imm8=0, Vd=0, size=0, D=0, U=0
    let encoding: u32 = 0x4D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vldr_a1_a_combo_5_800_5d100800() {
    // Encoding: 0x5D100800
    // Test aarch32_VLDR_A1_A field combination: cond=5, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, cond=5, imm8=0, Rn=0, U=0, size=0, D=0
    let encoding: u32 = 0x5D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vldr_a1_a_combo_6_800_6d100800() {
    // Encoding: 0x6D100800
    // Test aarch32_VLDR_A1_A field combination: cond=6, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: U=0, D=0, size=0, imm8=0, Vd=0, Rn=0, cond=6
    let encoding: u32 = 0x6D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vldr_a1_a_combo_7_800_7d100800() {
    // Encoding: 0x7D100800
    // Test aarch32_VLDR_A1_A field combination: cond=7, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, cond=7, Vd=0, size=0, imm8=0
    let encoding: u32 = 0x7D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vldr_a1_a_combo_8_800_8d100800() {
    // Encoding: 0x8D100800
    // Test aarch32_VLDR_A1_A field combination: cond=8, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, cond=8, Vd=0, size=0, imm8=0
    let encoding: u32 = 0x8D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vldr_a1_a_combo_9_800_9d100800() {
    // Encoding: 0x9D100800
    // Test aarch32_VLDR_A1_A field combination: cond=9, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, Vd=0, imm8=0, cond=9, U=0
    let encoding: u32 = 0x9D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vldr_a1_a_combo_10_800_ad100800() {
    // Encoding: 0xAD100800
    // Test aarch32_VLDR_A1_A field combination: cond=10, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: cond=10, U=0, D=0, Vd=0, size=0, Rn=0, imm8=0
    let encoding: u32 = 0xAD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vldr_a1_a_combo_11_800_bd100800() {
    // Encoding: 0xBD100800
    // Test aarch32_VLDR_A1_A field combination: cond=11, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: U=0, Rn=0, size=0, D=0, cond=11, imm8=0, Vd=0
    let encoding: u32 = 0xBD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vldr_a1_a_combo_12_800_cd100800() {
    // Encoding: 0xCD100800
    // Test aarch32_VLDR_A1_A field combination: cond=12, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, D=0, U=0, Rn=0, cond=12, Vd=0, size=0
    let encoding: u32 = 0xCD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vldr_a1_a_combo_13_800_dd100800() {
    // Encoding: 0xDD100800
    // Test aarch32_VLDR_A1_A field combination: cond=13, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: cond=13, U=0, imm8=0, Rn=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xDD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vldr_a1_a_combo_14_800_ed100800() {
    // Encoding: 0xED100800
    // Test aarch32_VLDR_A1_A field combination: cond=14, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, cond=14, D=0, size=0, imm8=0
    let encoding: u32 = 0xED100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vldr_a1_a_combo_15_800_fd100800() {
    // Encoding: 0xFD100800
    // Test aarch32_VLDR_A1_A field combination: cond=15, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: cond=15, Vd=0, size=0, imm8=0, D=0, U=0, Rn=0
    let encoding: u32 = 0xFD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldr_a1_a_combo_16_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field combination: cond=0, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: D=0, size=0, U=0, Rn=0, imm8=0, cond=0, Vd=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldr_a1_a_combo_17_800_0d900800() {
    // Encoding: 0x0D900800
    // Test aarch32_VLDR_A1_A field combination: cond=0, U=1, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: cond=0, U=1, Rn=0, D=0, Vd=0, imm8=0, size=0
    let encoding: u32 = 0x0D900800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vldr_a1_a_combo_18_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A field combination: cond=0, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, Rn=0, cond=0, Vd=0, U=0, size=0, D=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vldr_a1_a_combo_19_800_0d500800() {
    // Encoding: 0x0D500800
    // Test aarch32_VLDR_A1_A field combination: cond=0, U=0, D=1, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, U=0, cond=0, size=0, D=1, Rn=0, Vd=0
    let encoding: u32 = 0x0D500800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vldr_a1_a_special_cond_0_condition_eq_2048_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, D=0, Vd=0, size=0, Rn=0, U=0, imm8=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vldr_a1_a_special_cond_1_condition_ne_2048_1d100800() {
    // Encoding: 0x1D100800
    // Test aarch32_VLDR_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Vd=0, imm8=0, cond=1, U=0, D=0, size=0, Rn=0
    let encoding: u32 = 0x1D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vldr_a1_a_special_cond_2_condition_cs_hs_2048_2d100800() {
    // Encoding: 0x2D100800
    // Test aarch32_VLDR_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, imm8=0, cond=2, Vd=0, size=0
    let encoding: u32 = 0x2D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vldr_a1_a_special_cond_3_condition_cc_lo_2048_3d100800() {
    // Encoding: 0x3D100800
    // Test aarch32_VLDR_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, Vd=0, cond=3, size=0, imm8=0
    let encoding: u32 = 0x3D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vldr_a1_a_special_cond_4_condition_mi_2048_4d100800() {
    // Encoding: 0x4D100800
    // Test aarch32_VLDR_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, U=0, D=0, size=0, Rn=0, imm8=0, Vd=0
    let encoding: u32 = 0x4D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vldr_a1_a_special_cond_5_condition_pl_2048_5d100800() {
    // Encoding: 0x5D100800
    // Test aarch32_VLDR_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm8=0, D=0, Rn=0, Vd=0, U=0, size=0, cond=5
    let encoding: u32 = 0x5D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vldr_a1_a_special_cond_6_condition_vs_2048_6d100800() {
    // Encoding: 0x6D100800
    // Test aarch32_VLDR_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Vd=0, U=0, size=0, cond=6, imm8=0, D=0, Rn=0
    let encoding: u32 = 0x6D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vldr_a1_a_special_cond_7_condition_vc_2048_7d100800() {
    // Encoding: 0x7D100800
    // Test aarch32_VLDR_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: size=0, cond=7, U=0, imm8=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0x7D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vldr_a1_a_special_cond_8_condition_hi_2048_8d100800() {
    // Encoding: 0x8D100800
    // Test aarch32_VLDR_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, imm8=0, cond=8, U=0, Vd=0
    let encoding: u32 = 0x8D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vldr_a1_a_special_cond_9_condition_ls_2048_9d100800() {
    // Encoding: 0x9D100800
    // Test aarch32_VLDR_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: D=0, imm8=0, U=0, Rn=0, cond=9, size=0, Vd=0
    let encoding: u32 = 0x9D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vldr_a1_a_special_cond_10_condition_ge_2048_ad100800() {
    // Encoding: 0xAD100800
    // Test aarch32_VLDR_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Vd=0, D=0, imm8=0, Rn=0, cond=10, size=0, U=0
    let encoding: u32 = 0xAD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vldr_a1_a_special_cond_11_condition_lt_2048_bd100800() {
    // Encoding: 0xBD100800
    // Test aarch32_VLDR_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Vd=0, imm8=0, cond=11, size=0, D=0, U=0
    let encoding: u32 = 0xBD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vldr_a1_a_special_cond_12_condition_gt_2048_cd100800() {
    // Encoding: 0xCD100800
    // Test aarch32_VLDR_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, Vd=0, imm8=0, size=0, cond=12
    let encoding: u32 = 0xCD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vldr_a1_a_special_cond_13_condition_le_2048_dd100800() {
    // Encoding: 0xDD100800
    // Test aarch32_VLDR_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, D=0, cond=13, Rn=0, Vd=0, size=0, imm8=0
    let encoding: u32 = 0xDD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vldr_a1_a_special_cond_14_condition_al_2048_ed100800() {
    // Encoding: 0xED100800
    // Test aarch32_VLDR_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: D=0, cond=14, U=0, Rn=0, Vd=0, size=0, imm8=0
    let encoding: u32 = 0xED100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vldr_a1_a_special_cond_15_condition_nv_2048_fd100800() {
    // Encoding: 0xFD100800
    // Test aarch32_VLDR_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, size=0, imm8=0, cond=15, D=0
    let encoding: u32 = 0xFD100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vldr_a1_a_special_size_0_size_variant_0_2048_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm8=0, U=0, D=0, Vd=0, cond=0, size=0, Rn=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vldr_a1_a_special_size_1_size_variant_1_2048_0d100900() {
    // Encoding: 0x0D100900
    // Test aarch32_VLDR_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: imm8=0, Rn=0, D=0, size=1, cond=0, U=0, Vd=0
    let encoding: u32 = 0x0D100900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vldr_a1_a_special_size_2_size_variant_2_2048_0d100a00() {
    // Encoding: 0x0D100A00
    // Test aarch32_VLDR_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, size=2, imm8=0, U=0, cond=0
    let encoding: u32 = 0x0D100A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vldr_a1_a_special_size_3_size_variant_3_2048_0d100b00() {
    // Encoding: 0x0D100B00
    // Test aarch32_VLDR_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=0, cond=0, Vd=0, size=3, U=0
    let encoding: u32 = 0x0D100B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldr_a1_a_invalid_0_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: imm8=0, size=0, D=0, U=0, cond=0, Rn=0, Vd=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldr_a1_a_invalid_1_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, U=0, imm8=0, Rn=0, Vd=0, size=0, cond=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }) } }, rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldr_a1_a_invalid_2_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0, imm8=0, U=0, Rn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDR_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldr_a1_a_invalid_3_800_0d100800() {
    // Encoding: 0x0D100800
    // Test aarch32_VLDR_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, size=0, U=0, D=0, imm8=0, Rn=0, cond=0
    let encoding: u32 = 0x0D100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldr_t1_a_field_u_0_min_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, Vd=0, U=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldr_t1_a_field_u_1_max_800_ed900800() {
    // Thumb encoding (32): 0xED900800
    // Test aarch32_VLDR_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, U=1, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED900800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldr_t1_a_field_d_0_min_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, U=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldr_t1_a_field_d_1_max_800_ed500800() {
    // Thumb encoding (32): 0xED500800
    // Test aarch32_VLDR_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, U=0, size=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldr_t1_a_field_rn_0_min_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: U=0, D=0, Vd=0, Rn=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldr_t1_a_field_rn_1_poweroftwo_800_ed110800() {
    // Thumb encoding (32): 0xED110800
    // Test aarch32_VLDR_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=1, Vd=0, U=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldr_t1_a_field_vd_0_min_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, U=0, imm8=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldr_t1_a_field_vd_1_poweroftwo_800_ed101800() {
    // Thumb encoding (32): 0xED101800
    // Test aarch32_VLDR_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, U=0, size=0, D=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED101800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vldr_t1_a_field_size_0_min_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vldr_t1_a_field_size_1_poweroftwo_800_ed100900() {
    // Thumb encoding (32): 0xED100900
    // Test aarch32_VLDR_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, imm8=0, D=0, U=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vldr_t1_a_field_size_2_poweroftwo_800_ed100a00() {
    // Thumb encoding (32): 0xED100A00
    // Test aarch32_VLDR_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, size=2, imm8=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vldr_t1_a_field_size_3_max_800_ed100b00() {
    // Thumb encoding (32): 0xED100B00
    // Test aarch32_VLDR_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, U=0, imm8=0, Vd=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_0_zero_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_1_poweroftwo_800_ed100801() {
    // Thumb encoding (32): 0xED100801
    // Test aarch32_VLDR_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, imm8=1, Rn=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_3_poweroftwominusone_800_ed100803() {
    // Thumb encoding (32): 0xED100803
    // Test aarch32_VLDR_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, D=0, Rn=0, Vd=0, size=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_4_poweroftwo_800_ed100804() {
    // Thumb encoding (32): 0xED100804
    // Test aarch32_VLDR_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, U=0, imm8=4, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_7_poweroftwominusone_800_ed100807() {
    // Thumb encoding (32): 0xED100807
    // Test aarch32_VLDR_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Vd=0, size=0, imm8=7, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_8_poweroftwo_800_ed100808() {
    // Thumb encoding (32): 0xED100808
    // Test aarch32_VLDR_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Vd=0, size=0, imm8=8, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_15_poweroftwominusone_800_ed10080f() {
    // Thumb encoding (32): 0xED10080F
    // Test aarch32_VLDR_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, imm8=15, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED10080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_16_poweroftwo_800_ed100810() {
    // Thumb encoding (32): 0xED100810
    // Test aarch32_VLDR_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Vd=0, Rn=0, D=0, size=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_31_poweroftwominusone_800_ed10081f() {
    // Thumb encoding (32): 0xED10081F
    // Test aarch32_VLDR_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, size=0, U=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED10081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_32_poweroftwo_800_ed100820() {
    // Thumb encoding (32): 0xED100820
    // Test aarch32_VLDR_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, U=0, Vd=0, imm8=32, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_63_poweroftwominusone_800_ed10083f() {
    // Thumb encoding (32): 0xED10083F
    // Test aarch32_VLDR_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, U=0, imm8=63, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED10083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_64_poweroftwo_800_ed100840() {
    // Thumb encoding (32): 0xED100840
    // Test aarch32_VLDR_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, U=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_127_poweroftwominusone_800_ed10087f() {
    // Thumb encoding (32): 0xED10087F
    // Test aarch32_VLDR_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, U=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED10087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_128_poweroftwo_800_ed100880() {
    // Thumb encoding (32): 0xED100880
    // Test aarch32_VLDR_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, imm8=128, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vldr_t1_a_field_imm8_255_max_800_ed1008ff() {
    // Thumb encoding (32): 0xED1008FF
    // Test aarch32_VLDR_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: size=0, U=0, Rn=0, Vd=0, imm8=255, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED1008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldr_t1_a_combo_0_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: size=0, U=0, Vd=0, Rn=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldr_t1_a_combo_1_800_ed900800() {
    // Thumb encoding (32): 0xED900800
    // Test aarch32_VLDR_T1_A field combination: U=1, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, imm8=0, D=0, size=0, U=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED900800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vldr_t1_a_combo_2_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: size=0, imm8=0, U=0, Vd=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vldr_t1_a_combo_3_800_ed500800() {
    // Thumb encoding (32): 0xED500800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=1, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, D=1, Vd=0, U=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vldr_t1_a_combo_4_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: U=0, D=0, Vd=0, imm8=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vldr_t1_a_combo_5_800_ed110800() {
    // Thumb encoding (32): 0xED110800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=1, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: Rn=1, Vd=0, size=0, D=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vldr_t1_a_combo_6_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: size=0, Rn=0, imm8=0, Vd=0, U=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vldr_t1_a_combo_7_800_ed101800() {
    // Thumb encoding (32): 0xED101800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=1, size=0, imm8=0
    // ISET: T32
    // Fields: U=0, imm8=0, Rn=0, size=0, D=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED101800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vldr_t1_a_combo_8_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, U=0, size=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vldr_t1_a_combo_9_800_ed100900() {
    // Thumb encoding (32): 0xED100900
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=1, imm8=0
    // ISET: T32
    // Fields: size=1, imm8=0, U=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vldr_t1_a_combo_10_800_ed100a00() {
    // Thumb encoding (32): 0xED100A00
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=2, imm8=0
    // ISET: T32
    // Fields: size=2, imm8=0, U=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vldr_t1_a_combo_11_800_ed100b00() {
    // Thumb encoding (32): 0xED100B00
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=3, imm8=0
    // ISET: T32
    // Fields: D=0, Vd=0, U=0, Rn=0, size=3, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_vldr_t1_a_combo_12_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: D=0, U=0, Rn=0, Vd=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_vldr_t1_a_combo_13_800_ed100801() {
    // Thumb encoding (32): 0xED100801
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=1
    // ISET: T32
    // Fields: Rn=0, U=0, Vd=0, size=0, D=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_vldr_t1_a_combo_14_800_ed100803() {
    // Thumb encoding (32): 0xED100803
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=3
    // ISET: T32
    // Fields: Rn=0, D=0, U=0, size=0, Vd=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_vldr_t1_a_combo_15_800_ed100804() {
    // Thumb encoding (32): 0xED100804
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=4
    // ISET: T32
    // Fields: imm8=4, size=0, Rn=0, D=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_vldr_t1_a_combo_16_800_ed100807() {
    // Thumb encoding (32): 0xED100807
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=7
    // ISET: T32
    // Fields: imm8=7, Rn=0, D=0, Vd=0, size=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_vldr_t1_a_combo_17_800_ed100808() {
    // Thumb encoding (32): 0xED100808
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=8
    // ISET: T32
    // Fields: size=0, imm8=8, U=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_vldr_t1_a_combo_18_800_ed10080f() {
    // Thumb encoding (32): 0xED10080F
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=15
    // ISET: T32
    // Fields: imm8=15, Rn=0, U=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED10080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_vldr_t1_a_combo_19_800_ed100810() {
    // Thumb encoding (32): 0xED100810
    // Test aarch32_VLDR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=16
    // ISET: T32
    // Fields: U=0, size=0, imm8=16, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vldr_t1_a_special_size_0_size_variant_0_2048_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, imm8=0, U=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vldr_t1_a_special_size_1_size_variant_1_2048_ed100900() {
    // Thumb encoding (32): 0xED100900
    // Test aarch32_VLDR_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm8=0, D=0, Rn=0, U=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vldr_t1_a_special_size_2_size_variant_2_2048_ed100a00() {
    // Thumb encoding (32): 0xED100A00
    // Test aarch32_VLDR_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, U=0, imm8=0, Vd=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vldr_t1_a_special_size_3_size_variant_3_2048_ed100b00() {
    // Thumb encoding (32): 0xED100B00
    // Test aarch32_VLDR_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Vd=0, U=0, D=0, size=3, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldr_t1_a_invalid_0_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: size=0, Rn=0, imm8=0, U=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldr_t1_a_invalid_1_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, D=0, size=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldr_t1_a_invalid_2_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: Rn=0, D=0, U=0, size=0, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDR_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldr_t1_a_invalid_3_800_ed100800() {
    // Thumb encoding (32): 0xED100800
    // Test aarch32_VLDR_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, U=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLDM_A Tests
// ============================================================================

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, P=0, Vd=0, cond=0, U=0, imm8=0, Rn=0, D=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_1_poweroftwo_b01_1c100b01() {
    // Encoding: 0x1C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm8=0, cond=1, D=0, Rn=0, Vd=0, P=0, U=0
    let encoding: u32 = 0x1C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_2_poweroftwo_b01_2c100b01() {
    // Encoding: 0x2C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm8=0, W=0, D=0, P=0, U=0, Vd=0, Rn=0
    let encoding: u32 = 0x2C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_3_poweroftwo_b01_3c100b01() {
    // Encoding: 0x3C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, D=0, Vd=0, P=0, U=0, Rn=0, cond=3, imm8=0
    let encoding: u32 = 0x3C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_4_poweroftwo_b01_4c100b01() {
    // Encoding: 0x4C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, D=0, W=0, U=0, Vd=0, P=0, Rn=0, cond=4
    let encoding: u32 = 0x4C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_5_poweroftwo_b01_5c100b01() {
    // Encoding: 0x5C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, imm8=0, D=0, P=0, cond=5, Rn=0, Vd=0
    let encoding: u32 = 0x5C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_6_poweroftwo_b01_6c100b01() {
    // Encoding: 0x6C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, U=0, imm8=0, D=0, P=0, W=0, cond=6
    let encoding: u32 = 0x6C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_7_poweroftwo_b01_7c100b01() {
    // Encoding: 0x7C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, D=0, U=0, cond=7, Vd=0, W=0, imm8=0, Rn=0
    let encoding: u32 = 0x7C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_8_poweroftwo_b01_8c100b01() {
    // Encoding: 0x8C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, imm8=0, cond=8, D=0, Rn=0, W=0, Vd=0
    let encoding: u32 = 0x8C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_9_poweroftwo_b01_9c100b01() {
    // Encoding: 0x9C100B01
    // Test aarch32_VLDM_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, cond=9, Rn=0, Vd=0, D=0, U=0, imm8=0
    let encoding: u32 = 0x9C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_10_poweroftwo_b01_ac100b01() {
    // Encoding: 0xAC100B01
    // Test aarch32_VLDM_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, Vd=0, W=0, P=0, U=0, cond=10, D=0, Rn=0
    let encoding: u32 = 0xAC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_11_poweroftwo_b01_bc100b01() {
    // Encoding: 0xBC100B01
    // Test aarch32_VLDM_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, U=0, Rn=0, P=0, W=0, D=0, imm8=0, cond=11
    let encoding: u32 = 0xBC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_12_poweroftwo_b01_cc100b01() {
    // Encoding: 0xCC100B01
    // Test aarch32_VLDM_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, P=0, Vd=0, W=0, imm8=0, U=0, Rn=0, D=0
    let encoding: u32 = 0xCC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_13_poweroftwo_b01_dc100b01() {
    // Encoding: 0xDC100B01
    // Test aarch32_VLDM_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, Vd=0, P=0, U=0, D=0, W=0, Rn=0, cond=13
    let encoding: u32 = 0xDC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_14_poweroftwo_b01_ec100b01() {
    // Encoding: 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, W=0, D=0, cond=14, U=0, P=0, imm8=0
    let encoding: u32 = 0xEC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vldm_t1a1_a_field_cond_15_max_b01_fc100b01() {
    // Encoding: 0xFC100B01
    // Test aarch32_VLDM_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, Vd=0, W=0, P=0, cond=15, imm8=0
    let encoding: u32 = 0xFC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, U=0, D=0, imm8=0, Vd=0, cond=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_1_max_b01_0d100b01() {
    // Encoding: 0x0D100B01
    // Test aarch32_VLDM_T1A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, imm8=0, Rn=0, W=0, P=1, D=0, U=0, cond=0
    let encoding: u32 = 0x0D100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: D=0, imm8=0, Rn=0, P=0, U=0, W=0, Vd=0, cond=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_1_max_b01_0c900b01() {
    // Encoding: 0x0C900B01
    // Test aarch32_VLDM_T1A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, W=0, Vd=0, Rn=0, imm8=0, D=0, cond=0, P=0
    let encoding: u32 = 0x0C900B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, U=0, W=0, P=0, cond=0, imm8=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_1_max_b01_0c500b01() {
    // Encoding: 0x0C500B01
    // Test aarch32_VLDM_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: U=0, imm8=0, Vd=0, cond=0, D=1, P=0, W=0, Rn=0
    let encoding: u32 = 0x0C500B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: imm8=0, D=0, cond=0, Vd=0, P=0, W=0, Rn=0, U=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_1_max_b01_0c300b01() {
    // Encoding: 0x0C300B01
    // Test aarch32_VLDM_T1A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: P=0, D=0, cond=0, Vd=0, U=0, W=1, Rn=0, imm8=0
    let encoding: u32 = 0x0C300B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, U=0, W=0, cond=0, imm8=0, P=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_1_poweroftwo_b01_0c110b01() {
    // Encoding: 0x0C110B01
    // Test aarch32_VLDM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Vd=0, D=0, U=0, W=0, cond=0, imm8=0, Rn=1
    let encoding: u32 = 0x0C110B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_0_min_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rn=0, D=0, U=0, Vd=0, imm8=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_1_poweroftwo_b01_0c101b01() {
    // Encoding: 0x0C101B01
    // Test aarch32_VLDM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, imm8=0, D=0, P=0, Rn=0, Vd=1, U=0
    let encoding: u32 = 0x0C101B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_0_zero_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, Vd=0, U=0, P=0, imm8=0, D=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_1_poweroftwo_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, W=0, P=0, imm8=1, D=0, cond=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_0_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, D=0, U=0, W=0, Rn=0, P=0, cond=0, imm8=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_1_b01_1c100b01() {
    // Encoding: 0x1C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=1, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, cond=1, W=0, P=0, U=0, D=0, imm8=0
    let encoding: u32 = 0x1C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_2_b01_2c100b01() {
    // Encoding: 0x2C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=2, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, W=0, Vd=0, cond=2, imm8=0, Rn=0, U=0, P=0
    let encoding: u32 = 0x2C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_3_b01_3c100b01() {
    // Encoding: 0x3C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=3, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, U=0, Vd=0, W=0, imm8=0, D=0, Rn=0, cond=3
    let encoding: u32 = 0x3C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_4_b01_4c100b01() {
    // Encoding: 0x4C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=4, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, D=0, U=0, W=0, cond=4, imm8=0, Rn=0, Vd=0
    let encoding: u32 = 0x4C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_5_b01_5c100b01() {
    // Encoding: 0x5C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=5, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, U=0, P=0, D=0, imm8=0, Vd=0, cond=5, Rn=0
    let encoding: u32 = 0x5C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_6_b01_6c100b01() {
    // Encoding: 0x6C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=6, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=6, Vd=0, imm8=0, Rn=0, U=0, P=0, D=0, W=0
    let encoding: u32 = 0x6C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_7_b01_7c100b01() {
    // Encoding: 0x7C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=7, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, Vd=0, U=0, D=0, cond=7, P=0, Rn=0, imm8=0
    let encoding: u32 = 0x7C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_8_b01_8c100b01() {
    // Encoding: 0x8C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=8, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, Rn=0, D=0, Vd=0, cond=8, P=0, W=0, U=0
    let encoding: u32 = 0x8C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_9_b01_9c100b01() {
    // Encoding: 0x9C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=9, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, Vd=0, U=0, cond=9, P=0, Rn=0, imm8=0, W=0
    let encoding: u32 = 0x9C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_10_b01_ac100b01() {
    // Encoding: 0xAC100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=10, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, cond=10, U=0, imm8=0, Rn=0, W=0, Vd=0, P=0
    let encoding: u32 = 0xAC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_11_b01_bc100b01() {
    // Encoding: 0xBC100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=11, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, imm8=0, Vd=0, D=0, W=0, cond=11, Rn=0, P=0
    let encoding: u32 = 0xBC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_12_b01_cc100b01() {
    // Encoding: 0xCC100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=12, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, Vd=0, imm8=0, P=0, U=0, D=0, Rn=0, cond=12
    let encoding: u32 = 0xCC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_13_b01_dc100b01() {
    // Encoding: 0xDC100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=13, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, U=0, W=0, Rn=0, P=0, cond=13, Vd=0, imm8=0
    let encoding: u32 = 0xDC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_14_b01_ec100b01() {
    // Encoding: 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=14, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: D=0, P=0, cond=14, Vd=0, imm8=0, Rn=0, U=0, W=0
    let encoding: u32 = 0xEC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_15_b01_fc100b01() {
    // Encoding: 0xFC100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=15, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: cond=15, U=0, Rn=0, D=0, W=0, Vd=0, P=0, imm8=0
    let encoding: u32 = 0xFC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_16_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, D=0, Vd=0, P=0, imm8=0, cond=0, Rn=0, W=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_17_b01_0d100b01() {
    // Encoding: 0x0D100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=1, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, Rn=0, imm8=0, P=1, Vd=0, D=0, cond=0, W=0
    let encoding: u32 = 0x0D100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_18_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: Vd=0, U=0, P=0, D=0, Rn=0, cond=0, imm8=0, W=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_19_b01_0c900b01() {
    // Encoding: 0x0C900B01
    // Test aarch32_VLDM_T1A1_A field combination: cond=0, P=0, U=1, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, Vd=0, Rn=0, imm8=0, W=0, cond=0, D=0, U=1
    let encoding: u32 = 0x0C900B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_0_condition_eq_2817_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, W=0, P=0, D=0, imm8=0, cond=0, Vd=0, Rn=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_1_condition_ne_2817_1c100b01() {
    // Encoding: 0x1C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, imm8=0, W=0, D=0, P=0, Vd=0, U=0
    let encoding: u32 = 0x1C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_2_condition_cs_hs_2817_2c100b01() {
    // Encoding: 0x2C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm8=0, D=0, U=0, P=0, Vd=0, cond=2, Rn=0, W=0
    let encoding: u32 = 0x2C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_3_condition_cc_lo_2817_3c100b01() {
    // Encoding: 0x3C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, W=0, Rn=0, imm8=0, U=0, P=0, Vd=0, D=0
    let encoding: u32 = 0x3C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_4_condition_mi_2817_4c100b01() {
    // Encoding: 0x4C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, cond=4, W=0, Vd=0, P=0, Rn=0, imm8=0, D=0
    let encoding: u32 = 0x4C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_5_condition_pl_2817_5c100b01() {
    // Encoding: 0x5C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, imm8=0, Vd=0, Rn=0, D=0, P=0, cond=5, W=0
    let encoding: u32 = 0x5C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_6_condition_vs_2817_6c100b01() {
    // Encoding: 0x6C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Vd=0, D=0, U=0, Rn=0, P=0, W=0, cond=6, imm8=0
    let encoding: u32 = 0x6C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_7_condition_vc_2817_7c100b01() {
    // Encoding: 0x7C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, P=0, W=0, cond=7, Vd=0, D=0, Rn=0, imm8=0
    let encoding: u32 = 0x7C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_8_condition_hi_2817_8c100b01() {
    // Encoding: 0x8C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm8=0, Rn=0, W=0, U=0, cond=8, D=0, Vd=0, P=0
    let encoding: u32 = 0x8C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_9_condition_ls_2817_9c100b01() {
    // Encoding: 0x9C100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, imm8=0, U=0, Rn=0, cond=9, W=0, D=0, Vd=0
    let encoding: u32 = 0x9C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_10_condition_ge_2817_ac100b01() {
    // Encoding: 0xAC100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, cond=10, D=0, P=0, W=0, imm8=0
    let encoding: u32 = 0xAC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_11_condition_lt_2817_bc100b01() {
    // Encoding: 0xBC100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, P=0, D=0, Vd=0, W=0, cond=11, Rn=0, imm8=0
    let encoding: u32 = 0xBC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_12_condition_gt_2817_cc100b01() {
    // Encoding: 0xCC100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=12, P=0, D=0, Vd=0, W=0, imm8=0
    let encoding: u32 = 0xCC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_13_condition_le_2817_dc100b01() {
    // Encoding: 0xDC100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, D=0, Rn=0, W=0, P=0, imm8=0, U=0, Vd=0
    let encoding: u32 = 0xDC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_14_condition_al_2817_ec100b01() {
    // Encoding: 0xEC100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, U=0, Vd=0, P=0, D=0, imm8=0, Rn=0, cond=14
    let encoding: u32 = 0xEC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vldm_t1a1_a_special_cond_15_condition_nv_2817_fc100b01() {
    // Encoding: 0xFC100B01
    // Test aarch32_VLDM_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: D=0, P=0, imm8=0, cond=15, Rn=0, W=0, U=0, Vd=0
    let encoding: u32 = 0xFC100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_0_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: U=0, cond=0, D=0, W=0, P=0, Rn=0, Vd=0, imm8=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_1_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, U=0, W=0, P=0, cond=0, D=0, imm8=0, Rn=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_2_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: A32
    // Fields: D=0, imm8=0, cond=0, Rn=0, Vd=0, U=0, P=0, W=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_3_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, D=0, P=0, U=0, imm8=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_4_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: A32
    // Fields: P=0, cond=0, U=0, Vd=0, imm8=0, D=0, W=0, Rn=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_5_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, imm8=0, D=0, U=0, P=0, W=0, Vd=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_6_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: A32
    // Fields: W=0, U=0, P=0, cond=0, Vd=0, D=0, Rn=0, imm8=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_7_b01_0c100b01() {
    // Encoding: 0x0C100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm8=0, U=0, cond=0, W=0, Rn=0, P=0, D=0, Vd=0
    let encoding: u32 = 0x0C100B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_0_min_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field P = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, U=0, P=0, W=0, Rn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_p_1_max_b01_ed100b01() {
    // Thumb encoding (32): 0xED100B01
    // Test aarch32_VLDM_T1A1_A field P = 1 (Max)
    // ISET: T32
    // Fields: D=0, U=0, Vd=0, imm8=0, W=0, Rn=0, P=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_0_min_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field U = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, Vd=0, imm8=0, U=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_u_1_max_b01_ec900b01() {
    // Thumb encoding (32): 0xEC900B01
    // Test aarch32_VLDM_T1A1_A field U = 1 (Max)
    // ISET: T32
    // Fields: D=0, W=0, Vd=0, Rn=0, U=1, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC900B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_0_min_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, D=0, W=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_d_1_max_b01_ec500b01() {
    // Thumb encoding (32): 0xEC500B01
    // Test aarch32_VLDM_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, P=0, W=0, imm8=0, Vd=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_0_min_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field W = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, W=0, P=0, Rn=0, D=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vldm_t1a1_a_field_w_1_max_b01_ec300b01() {
    // Thumb encoding (32): 0xEC300B01
    // Test aarch32_VLDM_T1A1_A field W = 1 (Max)
    // ISET: T32
    // Fields: D=0, imm8=0, Vd=0, U=0, Rn=0, W=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC300B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_0_min_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: P=0, D=0, Vd=0, U=0, Rn=0, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vldm_t1a1_a_field_rn_1_poweroftwo_b01_ec110b01() {
    // Thumb encoding (32): 0xEC110B01
    // Test aarch32_VLDM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, W=0, D=0, Rn=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC110B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_0_min_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: P=0, U=0, D=0, Rn=0, imm8=0, Vd=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vldm_t1a1_a_field_vd_1_poweroftwo_b01_ec101b01() {
    // Thumb encoding (32): 0xEC101B01
    // Test aarch32_VLDM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, D=0, P=0, Rn=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC101B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_0_zero_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, D=0, imm8=0, Vd=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vldm_t1a1_a_field_imm8_1_poweroftwo_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, U=0, W=0, imm8=1, Vd=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_0_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, D=0, U=0, P=0, W=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_1_b01_ed100b01() {
    // Thumb encoding (32): 0xED100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=1, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: U=0, Rn=0, Vd=0, imm8=0, P=1, W=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_2_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: W=0, P=0, U=0, D=0, Vd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_3_b01_ec900b01() {
    // Thumb encoding (32): 0xEC900B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=1, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: U=1, D=0, W=0, Vd=0, imm8=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC900B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_4_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: W=0, D=0, Rn=0, P=0, U=0, imm8=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_5_b01_ec500b01() {
    // Thumb encoding (32): 0xEC500B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=1, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: U=0, P=0, D=1, W=0, imm8=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_6_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, P=0, W=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_7_b01_ec300b01() {
    // Thumb encoding (32): 0xEC300B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=1, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, P=0, D=0, imm8=0, W=1, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC300B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_8_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, U=0, W=0, D=0, P=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vldm_t1a1_a_combo_9_b01_ec110b01() {
    // Thumb encoding (32): 0xEC110B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=1, Vd=0, imm8=0
    // ISET: T32
    // Fields: D=0, Vd=0, imm8=0, P=0, Rn=1, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC110B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_10_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, U=0, imm8=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_11_b01_ec101b01() {
    // Thumb encoding (32): 0xEC101B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=1, imm8=0
    // ISET: T32
    // Fields: P=0, imm8=0, D=0, W=0, Rn=0, U=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC101B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_12_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: D=0, W=0, Vd=0, Rn=0, imm8=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_vldm_t1a1_a_combo_13_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=1
    // ISET: T32
    // Fields: Vd=0, P=0, D=0, W=0, imm8=1, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_0_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: P=0, imm8=0, Rn=0, D=0, U=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_1_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, Rn=0, U=0, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_2_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: T32
    // Fields: U=0, P=0, Rn=0, W=0, imm8=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_3_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, U=0, P=0, D=0, Vd=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_4_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: T32
    // Fields: W=0, U=0, D=0, P=0, imm8=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_5_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, U=0, imm8=0, D=0, P=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_6_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: T32
    // Fields: imm8=0, P=0, U=0, W=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLDM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vldm_t1a1_a_invalid_7_b01_ec100b01() {
    // Thumb encoding (32): 0xEC100B01
    // Test aarch32_VLDM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, W=0, P=0, Vd=0, Rn=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC100B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD4_m_A Tests
// ============================================================================

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_d_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, align=0, Rm=0, type1=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_d_1_max_0_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_VLD4_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: type1=0, Vd=0, D=1, align=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rn_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, align=0, Rm=0, Rn=0, type1=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rn_1_poweroftwo_0_f4210000() {
    // Encoding: 0xF4210000
    // Test aarch32_VLD4_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=1, Vd=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_vd_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, type1=0, size=0, align=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_vd_1_poweroftwo_0_f4201000() {
    // Encoding: 0xF4201000
    // Test aarch32_VLD4_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, Vd=1, size=0, align=0, type1=0
    let encoding: u32 = 0xF4201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, D=0, size=0, Vd=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_1_poweroftwo_0_f4200100() {
    // Encoding: 0xF4200100
    // Test aarch32_VLD4_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, D=0, size=0, Vd=0, type1=1, Rm=0, Rn=0
    let encoding: u32 = 0xF4200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_7_poweroftwominusone_0_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD4_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, type1=7, D=0, size=0, align=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_15_max_0_f4200f00() {
    // Encoding: 0xF4200F00
    // Test aarch32_VLD4_m_T1A1_A field type1 = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, type1=15, size=0, align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4200F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, Vd=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_1_poweroftwo_0_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD4_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, align=0, Vd=0, Rm=0, type1=0, size=1
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_2_poweroftwo_0_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD4_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, size=2, align=0, Rn=0, Vd=0, D=0, Rm=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_3_max_0_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD4_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: align=0, Rm=0, type1=0, Rn=0, Vd=0, D=0, size=3
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_align_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, type1=0, size=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_align_1_poweroftwo_0_f4200010() {
    // Encoding: 0xF4200010
    // Test aarch32_VLD4_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, type1=0, size=0, Vd=0, align=1
    let encoding: u32 = 0xF4200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_align_3_max_0_f4200030() {
    // Encoding: 0xF4200030
    // Test aarch32_VLD4_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: size=0, Rn=0, align=3, Rm=0, Vd=0, type1=0, D=0
    let encoding: u32 = 0xF4200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rm_0_min_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, Rm=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rm_1_poweroftwo_0_f4200001() {
    // Encoding: 0xF4200001
    // Test aarch32_VLD4_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=1, type1=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_0_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, type1=0, align=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_1_0_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=1, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, type1=0, Rm=0, align=0, D=1
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_2_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, D=0, align=0, Vd=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_3_0_f4210000() {
    // Encoding: 0xF4210000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, align=0, type1=0, Rn=1, size=0, Vd=0
    let encoding: u32 = 0xF4210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_4_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, type1=0, size=0, D=0, align=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_5_0_f4201000() {
    // Encoding: 0xF4201000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=1, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=1, size=0, align=0, Rn=0, D=0, Rm=0, type1=0
    let encoding: u32 = 0xF4201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=0 (minimum value)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_6_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, align=0, Rm=0, size=0, type1=0, Vd=0, D=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=1 (value 1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_7_0_f4200100() {
    // Encoding: 0xF4200100
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, type1=1, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF4200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_8_0_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=7, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, Rn=0, type1=7, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_9_0_f4200f00() {
    // Encoding: 0xF4200F00
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=15, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Vd=0, D=0, Rn=0, type1=15
    let encoding: u32 = 0xF4200F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_10_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Vd=0, type1=0, D=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_11_0_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, align=0, Vd=0, size=1, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_12_0_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, type1=0, size=2, align=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_13_0_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Vd=0, size=3, D=0, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_14_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, D=0, size=0, Vd=0, align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_15_0_f4200010() {
    // Encoding: 0xF4200010
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, Vd=0, align=1, size=0, D=0
    let encoding: u32 = 0xF4200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_16_0_f4200030() {
    // Encoding: 0xF4200030
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: type1=0, Vd=0, D=0, Rn=0, Rm=0, size=0, align=3
    let encoding: u32 = 0xF4200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_17_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, align=0, size=0, D=0, Rn=0, type1=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_18_0_f4200001() {
    // Encoding: 0xF4200001
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, Rn=0, size=0, D=0, Vd=0, type1=0, align=0
    let encoding: u32 = 0xF4200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_19_0_f4210001() {
    // Encoding: 0xF4210001
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=1, D=0, Rn=1, type1=0, size=0
    let encoding: u32 = 0xF4210001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_0_size_variant_0_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: type1=0, Vd=0, size=0, align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_1_size_variant_1_0_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD4_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: type1=0, D=0, size=1, align=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_2_size_variant_2_0_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD4_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, size=2, D=0, Rn=0, Rm=0, type1=0, align=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_3_size_variant_3_0_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD4_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, size=3, D=0, type1=0, align=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_0_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: size=0, D=0, type1=0, Vd=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_1_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, Vd=0, D=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_2_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Vd=0, type1=0, size=0, D=0, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_3_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: size=0, type1=0, align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_d_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, type1=0, size=0, Rm=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_d_1_max_0_f9600000() {
    // Thumb encoding (32): 0xF9600000
    // Test aarch32_VLD4_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, Vd=0, type1=0, Rn=0, D=1, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rn_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, size=0, type1=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rn_1_poweroftwo_0_f9210000() {
    // Thumb encoding (32): 0xF9210000
    // Test aarch32_VLD4_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, D=0, Vd=0, size=0, align=0, Rm=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_vd_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rm=0, Vd=0, size=0, D=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_vd_1_poweroftwo_0_f9201000() {
    // Thumb encoding (32): 0xF9201000
    // Test aarch32_VLD4_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Vd=1, align=0, Rm=0, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, type1=0, Rm=0, align=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_1_poweroftwo_0_f9200100() {
    // Thumb encoding (32): 0xF9200100
    // Test aarch32_VLD4_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, align=0, D=0, type1=1, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_7_poweroftwominusone_0_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD4_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: align=0, type1=7, Vd=0, D=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_type1_15_max_0_f9200f00() {
    // Thumb encoding (32): 0xF9200F00
    // Test aarch32_VLD4_m_T1A1_A field type1 = 15 (Max)
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, align=0, Vd=0, Rn=0, type1=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, type1=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_1_poweroftwo_0_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD4_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rn=0, size=1, align=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_2_poweroftwo_0_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD4_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, align=0, type1=0, Vd=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_size_3_max_0_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD4_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: align=0, Rm=0, type1=0, D=0, Rn=0, Vd=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_align_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_align_1_poweroftwo_0_f9200010() {
    // Thumb encoding (32): 0xF9200010
    // Test aarch32_VLD4_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, size=0, align=1, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_align_3_max_0_f9200030() {
    // Thumb encoding (32): 0xF9200030
    // Test aarch32_VLD4_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, align=3, Vd=0, Rm=0, D=0, size=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rm_0_min_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: align=0, D=0, Rm=0, Vd=0, size=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_m_t1a1_a_field_rm_1_poweroftwo_0_f9200001() {
    // Thumb encoding (32): 0xF9200001
    // Test aarch32_VLD4_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, Rm=1, align=0, type1=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_0_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, align=0, type1=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_1_0_f9600000() {
    // Thumb encoding (32): 0xF9600000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=1, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, size=0, align=0, Rm=0, D=1, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_2_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, type1=0, align=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_3_0_f9210000() {
    // Thumb encoding (32): 0xF9210000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Vd=0, Rm=0, Rn=1, align=0, type1=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_4_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, type1=0, Vd=0, size=0, D=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_5_0_f9201000() {
    // Thumb encoding (32): 0xF9201000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=1, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, type1=0, Vd=1, Rn=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=0 (minimum value)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_6_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, Vd=0, type1=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=1 (value 1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_7_0_f9200100() {
    // Thumb encoding (32): 0xF9200100
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, align=0, Rm=0, type1=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_8_0_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=7, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, Rn=0, Vd=0, type1=7, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_9_0_f9200f00() {
    // Thumb encoding (32): 0xF9200F00
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=15, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=15, align=0, Rm=0, Vd=0, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_10_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, D=0, Rm=0, align=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_11_0_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=1, Rn=0, align=0, D=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_12_0_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, size=2, Rn=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_13_0_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, type1=0, Rm=0, size=3, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_14_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, type1=0, Rn=0, size=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_15_0_f9200010() {
    // Thumb encoding (32): 0xF9200010
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, type1=0, align=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_16_0_f9200030() {
    // Thumb encoding (32): 0xF9200030
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, type1=0, align=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_17_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, align=0, Rm=0, Rn=0, type1=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_18_0_f9200001() {
    // Thumb encoding (32): 0xF9200001
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: align=0, size=0, Rn=0, Vd=0, D=0, type1=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_m_t1a1_a_combo_19_0_f9210001() {
    // Thumb encoding (32): 0xF9210001
    // Test aarch32_VLD4_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, align=0, D=0, type1=0, size=0, Vd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_0_size_variant_0_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, type1=0, align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_1_size_variant_1_0_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD4_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, Vd=0, align=0, Rn=0, D=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_2_size_variant_2_0_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD4_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rm=0, type1=0, align=0, D=0, Rn=0, Vd=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_m_t1a1_a_special_size_3_size_variant_3_0_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD4_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, size=3, align=0, type1=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_0_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: align=0, Rm=0, Vd=0, D=0, size=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_1_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, type1=0, D=0, Rn=0, Vd=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_2_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: type1=0, align=0, Rm=0, Vd=0, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_m_t1a1_a_invalid_3_0_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD4_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, type1=0, size=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD3_m_A Tests
// ============================================================================

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_d_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: align=0, type1=0, D=0, Rm=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_d_1_max_400_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_VLD3_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: align=0, Rn=0, D=1, Rm=0, Vd=0, type1=0, size=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rn_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rn_1_poweroftwo_400_f4210000() {
    // Encoding: 0xF4210000
    // Test aarch32_VLD3_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rm=0, type1=0, size=0, Vd=0, Rn=1, D=0
    let encoding: u32 = 0xF4210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_vd_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, align=0, Vd=0, type1=0, D=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_vd_1_poweroftwo_400_f4201000() {
    // Encoding: 0xF4201000
    // Test aarch32_VLD3_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=1, size=0, D=0, type1=0, Rn=0
    let encoding: u32 = 0xF4201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, align=0, Rm=0, type1=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_1_poweroftwo_400_f4200100() {
    // Encoding: 0xF4200100
    // Test aarch32_VLD3_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, type1=1, Vd=0, D=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_7_poweroftwominusone_400_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD3_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=7, align=0, Rm=0, D=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_15_max_400_f4200f00() {
    // Encoding: 0xF4200F00
    // Test aarch32_VLD3_m_T1A1_A field type1 = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, Rm=0, align=0, size=0, D=0, Rn=0, type1=15
    let encoding: u32 = 0xF4200F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_1_poweroftwo_400_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD3_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, align=0, Rm=0, Rn=0, size=1, D=0, Vd=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_2_poweroftwo_400_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD3_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, size=2, align=0, Rm=0, Vd=0, type1=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_3_max_400_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD3_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, type1=0, Vd=0, size=3, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_align_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Vd=0, type1=0, D=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_align_1_poweroftwo_400_f4200010() {
    // Encoding: 0xF4200010
    // Test aarch32_VLD3_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=0, align=1, Rm=0, D=0, type1=0, Vd=0
    let encoding: u32 = 0xF4200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_align_3_max_400_f4200030() {
    // Encoding: 0xF4200030
    // Test aarch32_VLD3_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, type1=0, D=0, Rn=0, align=3
    let encoding: u32 = 0xF4200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rm_0_min_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, align=0, type1=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rm_1_poweroftwo_400_f4200001() {
    // Encoding: 0xF4200001
    // Test aarch32_VLD3_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, align=0, D=0, Rm=1, Rn=0, type1=0, Vd=0
    let encoding: u32 = 0xF4200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_0_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, type1=0, size=0, align=0, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_1_400_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=1, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, align=0, type1=0, Rm=0, D=1, Vd=0, size=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_2_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, align=0, type1=0, size=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_3_400_f4210000() {
    // Encoding: 0xF4210000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=1, D=0, type1=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_4_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, type1=0, align=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_5_400_f4201000() {
    // Encoding: 0xF4201000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=1, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, D=0, Rm=0, align=0, type1=0, Rn=0, Vd=1
    let encoding: u32 = 0xF4201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=0 (minimum value)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_6_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, align=0, Rn=0, size=0, type1=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=1 (value 1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_7_400_f4200100() {
    // Encoding: 0xF4200100
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=1, D=0, Vd=0, Rn=0, align=0, Rm=0, size=0
    let encoding: u32 = 0xF4200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_8_400_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=7, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=7, align=0, size=0, D=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_9_400_f4200f00() {
    // Encoding: 0xF4200F00
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=15, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, type1=15, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF4200F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_10_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rn=0, type1=0, align=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_11_400_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: size=1, D=0, align=0, Rn=0, Rm=0, Vd=0, type1=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_12_400_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, Rm=0, type1=0, D=0, size=2
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_13_400_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=3, Rm=0, Vd=0, D=0, type1=0, align=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_14_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, Vd=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_15_400_f4200010() {
    // Encoding: 0xF4200010
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, align=1, Rn=0, type1=0, D=0
    let encoding: u32 = 0xF4200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_16_400_f4200030() {
    // Encoding: 0xF4200030
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: type1=0, align=3, Rm=0, Rn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_17_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, align=0, Rm=0, type1=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_18_400_f4200001() {
    // Encoding: 0xF4200001
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: align=0, Rn=0, Vd=0, D=0, type1=0, Rm=1, size=0
    let encoding: u32 = 0xF4200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_19_400_f4210001() {
    // Encoding: 0xF4210001
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, D=0, Rn=1, Vd=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4210001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_0_size_variant_0_1024_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=0, type1=0, align=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_1_size_variant_1_1024_f4200040() {
    // Encoding: 0xF4200040
    // Test aarch32_VLD3_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, Rm=0, Vd=0, Rn=0, type1=0, align=0, D=0
    let encoding: u32 = 0xF4200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_2_size_variant_2_1024_f4200080() {
    // Encoding: 0xF4200080
    // Test aarch32_VLD3_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: type1=0, Rn=0, align=0, D=0, size=2, Rm=0, Vd=0
    let encoding: u32 = 0xF4200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_3_size_variant_3_1024_f42000c0() {
    // Encoding: 0xF42000C0
    // Test aarch32_VLD3_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, Rm=0, Vd=0, Rn=0, align=0, D=0, type1=0
    let encoding: u32 = 0xF42000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_0_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vd=0, Rm=0, size=0, type1=0, Rn=0, D=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_1_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, align=0, Rm=0, D=0, size=0, type1=0, Vd=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_2_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, type1=0, align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_3_400_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, type1=0, size=0, align=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_d_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, type1=0, Rm=0, D=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_d_1_max_400_f9600000() {
    // Thumb encoding (32): 0xF9600000
    // Test aarch32_VLD3_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vd=0, align=0, Rn=0, Rm=0, D=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rn_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, D=0, type1=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rn_1_poweroftwo_400_f9210000() {
    // Thumb encoding (32): 0xF9210000
    // Test aarch32_VLD3_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, align=0, Rn=1, type1=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_vd_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, type1=0, align=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_vd_1_poweroftwo_400_f9201000() {
    // Thumb encoding (32): 0xF9201000
    // Test aarch32_VLD3_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, Rn=0, D=0, Vd=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, align=0, Rm=0, Rn=0, type1=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_1_poweroftwo_400_f9200100() {
    // Thumb encoding (32): 0xF9200100
    // Test aarch32_VLD3_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, align=0, type1=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_7_poweroftwominusone_400_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD3_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: type1=7, Rn=0, Vd=0, Rm=0, size=0, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_type1_15_max_400_f9200f00() {
    // Thumb encoding (32): 0xF9200F00
    // Test aarch32_VLD3_m_T1A1_A field type1 = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, align=0, Rm=0, Vd=0, type1=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, align=0, D=0, type1=0, size=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_1_poweroftwo_400_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD3_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, type1=0, size=1, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_2_poweroftwo_400_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD3_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, type1=0, align=0, D=0, Vd=0, size=2, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_size_3_max_400_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD3_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, align=0, size=3, type1=0, Rn=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_align_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, type1=0, size=0, align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_align_1_poweroftwo_400_f9200010() {
    // Thumb encoding (32): 0xF9200010
    // Test aarch32_VLD3_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rn=0, Vd=0, align=1, size=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_align_3_max_400_f9200030() {
    // Thumb encoding (32): 0xF9200030
    // Test aarch32_VLD3_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, align=3, Rm=0, type1=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rm_0_min_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, type1=0, align=0, Rm=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_m_t1a1_a_field_rm_1_poweroftwo_400_f9200001() {
    // Thumb encoding (32): 0xF9200001
    // Test aarch32_VLD3_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, size=0, Vd=0, type1=0, align=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_0_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, type1=0, Vd=0, D=0, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_1_400_f9600000() {
    // Thumb encoding (32): 0xF9600000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=1, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=1, Rn=0, Vd=0, size=0, type1=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_2_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, type1=0, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_3_400_f9210000() {
    // Thumb encoding (32): 0xF9210000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, type1=0, size=0, align=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_4_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, size=0, Vd=0, align=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_5_400_f9201000() {
    // Thumb encoding (32): 0xF9201000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=1, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, align=0, Vd=1, type1=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=0 (minimum value)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_6_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: type1=0, size=0, D=0, align=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=1 (value 1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_7_400_f9200100() {
    // Thumb encoding (32): 0xF9200100
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, type1=1, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_8_400_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=7, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, type1=7, D=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// type1=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_9_400_f9200f00() {
    // Thumb encoding (32): 0xF9200F00
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=15, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, align=0, type1=15, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_10_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, Rn=0, size=0, align=0, D=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_11_400_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, type1=0, align=0, Rm=0, Rn=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_12_400_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, size=2, D=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_13_400_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, align=0, type1=0, Vd=0, Rn=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_14_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, align=0, D=0, size=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_15_400_f9200010() {
    // Thumb encoding (32): 0xF9200010
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, align=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_16_400_f9200030() {
    // Thumb encoding (32): 0xF9200030
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: align=3, D=0, Rn=0, Vd=0, type1=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_17_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, type1=0, Rn=0, size=0, align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_18_400_f9200001() {
    // Thumb encoding (32): 0xF9200001
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, size=0, D=0, type1=0, Vd=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_m_t1a1_a_combo_19_400_f9210001() {
    // Thumb encoding (32): 0xF9210001
    // Test aarch32_VLD3_m_T1A1_A field combination: D=0, Rn=1, Vd=0, type1=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=1, Rm=1, type1=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_0_size_variant_0_1024_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, type1=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_1_size_variant_1_1024_f9200040() {
    // Thumb encoding (32): 0xF9200040
    // Test aarch32_VLD3_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: type1=0, Rn=0, align=0, Rm=0, D=0, size=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_2_size_variant_2_1024_f9200080() {
    // Thumb encoding (32): 0xF9200080
    // Test aarch32_VLD3_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Rn=0, type1=0, size=2, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_m_t1a1_a_special_size_3_size_variant_3_1024_f92000c0() {
    // Thumb encoding (32): 0xF92000C0
    // Test aarch32_VLD3_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=3, align=0, Rm=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_0_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, size=0, Rm=0, align=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_1_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, D=0, type1=0, align=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_2_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: align=0, Vd=0, Rm=0, Rn=0, size=0, type1=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_m_t1a1_a_invalid_3_400_f9200000() {
    // Thumb encoding (32): 0xF9200000
    // Test aarch32_VLD3_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, type1=0, align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD1_m_A Tests
// ============================================================================

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_d_0_min_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Rm=0, align=0, Vd=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_d_1_max_700_f4600700() {
    // Encoding: 0xF4600700
    // Test aarch32_VLD1_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Vd=0, Rn=0, Rm=0, align=0, size=0
    let encoding: u32 = 0xF4600700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rn_0_min_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rn=0, Vd=0, size=0, Rm=0, D=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rn_1_poweroftwo_700_f4210700() {
    // Encoding: 0xF4210700
    // Test aarch32_VLD1_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, size=0, D=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4210700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_vd_0_min_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, align=0, Rn=0, Rm=0, Vd=0, size=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_vd_1_poweroftwo_700_f4201700() {
    // Encoding: 0xF4201700
    // Test aarch32_VLD1_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, align=0, Vd=1, D=0, size=0
    let encoding: u32 = 0xF4201700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_0_min_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, D=0, Rn=0, align=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_1_poweroftwo_700_f4200740() {
    // Encoding: 0xF4200740
    // Test aarch32_VLD1_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, D=0, Rn=0, Rm=0, Vd=0, size=1
    let encoding: u32 = 0xF4200740;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_2_poweroftwo_700_f4200780() {
    // Encoding: 0xF4200780
    // Test aarch32_VLD1_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, align=0, Rn=0, size=2, Rm=0
    let encoding: u32 = 0xF4200780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_3_max_700_f42007c0() {
    // Encoding: 0xF42007C0
    // Test aarch32_VLD1_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=3, align=0, Rm=0
    let encoding: u32 = 0xF42007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_align_0_min_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: align=0, Vd=0, D=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_align_1_poweroftwo_700_f4200710() {
    // Encoding: 0xF4200710
    // Test aarch32_VLD1_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, size=0, Vd=0, align=1
    let encoding: u32 = 0xF4200710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_align_3_max_700_f4200730() {
    // Encoding: 0xF4200730
    // Test aarch32_VLD1_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, D=0, align=3, size=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4200730;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rm_0_min_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, align=0, D=0, Rn=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rm_1_poweroftwo_700_f4200701() {
    // Encoding: 0xF4200701
    // Test aarch32_VLD1_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, align=0, Vd=0, Rm=1
    let encoding: u32 = 0xF4200701;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_0_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_1_700_f4600700() {
    // Encoding: 0xF4600700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Rn=0, D=1, Vd=0
    let encoding: u32 = 0xF4600700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_2_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Rm=0, D=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_3_700_f4210700() {
    // Encoding: 0xF4210700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, D=0, align=0, Rm=0, Rn=1, Vd=0
    let encoding: u32 = 0xF4210700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_4_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rm=0, Vd=0, Rn=0, align=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_5_700_f4201700() {
    // Encoding: 0xF4201700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, align=0, Vd=1, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4201700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_6_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=0, align=0, Rm=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_7_700_f4200740() {
    // Encoding: 0xF4200740
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, align=0, size=1, Vd=0
    let encoding: u32 = 0xF4200740;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_8_700_f4200780() {
    // Encoding: 0xF4200780
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, Vd=0, size=2, align=0, D=0
    let encoding: u32 = 0xF4200780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_9_700_f42007c0() {
    // Encoding: 0xF42007C0
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=0, D=0, Rn=0, size=3
    let encoding: u32 = 0xF42007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_10_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, align=0, Vd=0, size=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_11_700_f4200710() {
    // Encoding: 0xF4200710
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: align=1, size=0, D=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_12_700_f4200730() {
    // Encoding: 0xF4200730
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, Rm=0, align=3, Vd=0
    let encoding: u32 = 0xF4200730;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_13_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_14_700_f4200701() {
    // Encoding: 0xF4200701
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=1, Vd=0, align=0, D=0
    let encoding: u32 = 0xF4200701;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_15_700_f4210701() {
    // Encoding: 0xF4210701
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: align=0, Rm=1, size=0, D=0, Rn=1, Vd=0
    let encoding: u32 = 0xF4210701;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_16_700_f42f070f() {
    // Encoding: 0xF42F070F
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=31, size=0, D=0, Rn=31
    let encoding: u32 = 0xF42F070F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_0_size_variant_0_1792_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Rn=0, align=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_1_size_variant_1_1792_f4200740() {
    // Encoding: 0xF4200740
    // Test aarch32_VLD1_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, align=0, Vd=0, Rn=0, size=1, Rm=0
    let encoding: u32 = 0xF4200740;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_2_size_variant_2_1792_f4200780() {
    // Encoding: 0xF4200780
    // Test aarch32_VLD1_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: align=0, size=2, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4200780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_3_size_variant_3_1792_f42007c0() {
    // Encoding: 0xF42007C0
    // Test aarch32_VLD1_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, Vd=0, D=0, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF42007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_0_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: align=0, Rn=0, Rm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_1_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: align=0, size=0, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_2_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_3_700_f4200700() {
    // Encoding: 0xF4200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: size=0, Vd=0, align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4200700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_d_0_min_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_d_1_max_a00_f4600a00() {
    // Encoding: 0xF4600A00
    // Test aarch32_VLD1_m_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Rm=0, Rn=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4600A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rn_0_min_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, align=0, D=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rn_1_poweroftwo_a00_f4210a00() {
    // Encoding: 0xF4210A00
    // Test aarch32_VLD1_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=1, D=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4210A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_vd_0_min_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: align=0, D=0, Vd=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_vd_1_poweroftwo_a00_f4201a00() {
    // Encoding: 0xF4201A00
    // Test aarch32_VLD1_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rm=0, align=0, Rn=0, D=0, Vd=1
    let encoding: u32 = 0xF4201A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_0_min_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, size=0, align=0, Vd=0, D=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_1_poweroftwo_a00_f4200a40() {
    // Encoding: 0xF4200A40
    // Test aarch32_VLD1_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, D=0, Rn=0, size=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4200A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_2_poweroftwo_a00_f4200a80() {
    // Encoding: 0xF4200A80
    // Test aarch32_VLD1_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rm=0, size=2, Rn=0, D=0, align=0
    let encoding: u32 = 0xF4200A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_3_max_a00_f4200ac0() {
    // Encoding: 0xF4200AC0
    // Test aarch32_VLD1_m_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200AC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_align_0_min_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, align=0, size=0, Rm=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_align_1_poweroftwo_a00_f4200a10() {
    // Encoding: 0xF4200A10
    // Test aarch32_VLD1_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, align=1
    let encoding: u32 = 0xF4200A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_align_3_max_a00_f4200a30() {
    // Encoding: 0xF4200A30
    // Test aarch32_VLD1_m_T2A2_A field align = 3 (Max)
    // ISET: A32
    // Fields: align=3, size=0, Vd=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4200A30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rm_0_min_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, align=0, D=0, size=0, Rn=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rm_1_poweroftwo_a00_f4200a01() {
    // Encoding: 0xF4200A01
    // Test aarch32_VLD1_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, D=0, Rn=0, size=0, align=0, Vd=0
    let encoding: u32 = 0xF4200A01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_0_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, align=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_1_a00_f4600a00() {
    // Encoding: 0xF4600A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=1, Rn=0, size=0, align=0
    let encoding: u32 = 0xF4600A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_2_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_3_a00_f4210a00() {
    // Encoding: 0xF4210A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=1, Vd=0, size=0, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4210A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_4_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, align=0, D=0, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_5_a00_f4201a00() {
    // Encoding: 0xF4201A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Vd=1, Rm=0, D=0, size=0, Rn=0
    let encoding: u32 = 0xF4201A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_6_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, align=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_7_a00_f4200a40() {
    // Encoding: 0xF4200A40
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, align=0, Vd=0, size=1
    let encoding: u32 = 0xF4200A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_8_a00_f4200a80() {
    // Encoding: 0xF4200A80
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Rm=0, size=2, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_9_a00_f4200ac0() {
    // Encoding: 0xF4200AC0
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, D=0, Rn=0, size=3, Rm=0, Vd=0
    let encoding: u32 = 0xF4200AC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_10_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, align=0, D=0, Vd=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_11_a00_f4200a10() {
    // Encoding: 0xF4200A10
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: Rn=0, align=1, Rm=0, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4200A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_12_a00_f4200a30() {
    // Encoding: 0xF4200A30
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: align=3, Vd=0, size=0, Rn=0, Rm=0, D=0
    let encoding: u32 = 0xF4200A30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_13_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_14_a00_f4200a01() {
    // Encoding: 0xF4200A01
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=1, D=0, align=0, Vd=0
    let encoding: u32 = 0xF4200A01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_15_a00_f4210a01() {
    // Encoding: 0xF4210A01
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: align=0, Rm=1, D=0, size=0, Rn=1, Vd=0
    let encoding: u32 = 0xF4210A01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_16_a00_f42f0a0f() {
    // Encoding: 0xF42F0A0F
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=31, size=0, align=0, Rm=31
    let encoding: u32 = 0xF42F0A0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_0_size_variant_0_2560_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, Rm=0, D=0, align=0, Rn=0, size=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_1_size_variant_1_2560_f4200a40() {
    // Encoding: 0xF4200A40
    // Test aarch32_VLD1_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, Vd=0, Rm=0, align=0, D=0, Rn=0
    let encoding: u32 = 0xF4200A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_2_size_variant_2_2560_f4200a80() {
    // Encoding: 0xF4200A80
    // Test aarch32_VLD1_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, align=0, D=0, Rm=0, Rn=0, size=2
    let encoding: u32 = 0xF4200A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_3_size_variant_3_2560_f4200ac0() {
    // Encoding: 0xF4200AC0
    // Test aarch32_VLD1_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, align=0, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4200AC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_0_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, size=0, Vd=0, align=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_1_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_2_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, D=0, align=0, Rn=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_3_a00_f4200a00() {
    // Encoding: 0xF4200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, size=0, align=0, Rn=0
    let encoding: u32 = 0xF4200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_d_0_min_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: align=0, Vd=0, Rn=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_d_1_max_600_f4600600() {
    // Encoding: 0xF4600600
    // Test aarch32_VLD1_m_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Vd=0, align=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0xF4600600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rn_0_min_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, align=0, Rn=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rn_1_poweroftwo_600_f4210600() {
    // Encoding: 0xF4210600
    // Test aarch32_VLD1_m_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=0, Rn=1, Rm=0, align=0, D=0
    let encoding: u32 = 0xF4210600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_vd_0_min_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, Vd=0, D=0, align=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_vd_1_poweroftwo_600_f4201600() {
    // Encoding: 0xF4201600
    // Test aarch32_VLD1_m_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rn=0, align=0, Rm=0, Vd=1, D=0
    let encoding: u32 = 0xF4201600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_0_min_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, align=0, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_1_poweroftwo_600_f4200640() {
    // Encoding: 0xF4200640
    // Test aarch32_VLD1_m_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Vd=0, size=1, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4200640;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_2_poweroftwo_600_f4200680() {
    // Encoding: 0xF4200680
    // Test aarch32_VLD1_m_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=2, align=0, Vd=0, D=0, Rm=0
    let encoding: u32 = 0xF4200680;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_3_max_600_f42006c0() {
    // Encoding: 0xF42006C0
    // Test aarch32_VLD1_m_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=3, Rm=0, align=0
    let encoding: u32 = 0xF42006C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_align_0_min_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field align = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, align=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_align_1_poweroftwo_600_f4200610() {
    // Encoding: 0xF4200610
    // Test aarch32_VLD1_m_T3A3_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, align=1, D=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200610;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_align_3_max_600_f4200630() {
    // Encoding: 0xF4200630
    // Test aarch32_VLD1_m_T3A3_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, align=3, D=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200630;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rm_0_min_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rm_1_poweroftwo_600_f4200601() {
    // Encoding: 0xF4200601
    // Test aarch32_VLD1_m_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rn=0, size=0, Rm=1, Vd=0, D=0
    let encoding: u32 = 0xF4200601;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_0_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, align=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_1_600_f4600600() {
    // Encoding: 0xF4600600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Rm=0, D=1, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4600600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_2_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, align=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_3_600_f4210600() {
    // Encoding: 0xF4210600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=1, D=0, size=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4210600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_4_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, D=0, align=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_5_600_f4201600() {
    // Encoding: 0xF4201600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=1, size=0, Rm=0, align=0, D=0, Rn=0
    let encoding: u32 = 0xF4201600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_6_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, align=0, size=0, Rm=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_7_600_f4200640() {
    // Encoding: 0xF4200640
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: size=1, align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200640;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_8_600_f4200680() {
    // Encoding: 0xF4200680
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, D=0, size=2, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4200680;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_9_600_f42006c0() {
    // Encoding: 0xF42006C0
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: size=3, Rm=0, align=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF42006C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_10_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_11_600_f4200610() {
    // Encoding: 0xF4200610
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, align=1, Vd=0, Rn=0
    let encoding: u32 = 0xF4200610;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_12_600_f4200630() {
    // Encoding: 0xF4200630
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, align=3, Rm=0, Vd=0
    let encoding: u32 = 0xF4200630;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_13_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, D=0, align=0, Vd=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_14_600_f4200601() {
    // Encoding: 0xF4200601
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=1, Vd=0, D=0, align=0
    let encoding: u32 = 0xF4200601;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_15_600_f4210601() {
    // Encoding: 0xF4210601
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: D=0, Rm=1, size=0, Vd=0, align=0, Rn=1
    let encoding: u32 = 0xF4210601;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_16_600_f42f060f() {
    // Encoding: 0xF42F060F
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: A32
    // Fields: align=0, D=0, Rm=31, Rn=31, Vd=0, size=0
    let encoding: u32 = 0xF42F060F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_0_size_variant_0_1536_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, align=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_1_size_variant_1_1536_f4200640() {
    // Encoding: 0xF4200640
    // Test aarch32_VLD1_m_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, align=0, D=0, Rm=0, size=1, Vd=0
    let encoding: u32 = 0xF4200640;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_2_size_variant_2_1536_f4200680() {
    // Encoding: 0xF4200680
    // Test aarch32_VLD1_m_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, D=0, Rn=0, Vd=0, align=0, Rm=0
    let encoding: u32 = 0xF4200680;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_3_size_variant_3_1536_f42006c0() {
    // Encoding: 0xF42006C0
    // Test aarch32_VLD1_m_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, Rm=0, D=0, Rn=0, Vd=0, align=0
    let encoding: u32 = 0xF42006C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_0_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, align=0, Vd=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_1_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, Rm=0, align=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_2_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, align=0, D=0, Rn=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_3_600_f4200600() {
    // Encoding: 0xF4200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, align=0, Rm=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4200600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_d_0_min_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, D=0, Rm=0, align=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_d_1_max_200_f4600200() {
    // Encoding: 0xF4600200
    // Test aarch32_VLD1_m_T4A4_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, size=0, align=0, Rm=0, Rn=0, D=1
    let encoding: u32 = 0xF4600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rn_0_min_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=0, D=0, size=0, Rn=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rn_1_poweroftwo_200_f4210200() {
    // Encoding: 0xF4210200
    // Test aarch32_VLD1_m_T4A4_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, align=0, Rn=1, Vd=0, Rm=0
    let encoding: u32 = 0xF4210200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_vd_0_min_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_vd_1_poweroftwo_200_f4201200() {
    // Encoding: 0xF4201200
    // Test aarch32_VLD1_m_T4A4_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, size=0, Vd=1, Rn=0, D=0, Rm=0
    let encoding: u32 = 0xF4201200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_0_min_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rn=0, Rm=0, align=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_1_poweroftwo_200_f4200240() {
    // Encoding: 0xF4200240
    // Test aarch32_VLD1_m_T4A4_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rn=0, Rm=0, D=0, Vd=0, size=1
    let encoding: u32 = 0xF4200240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_2_poweroftwo_200_f4200280() {
    // Encoding: 0xF4200280
    // Test aarch32_VLD1_m_T4A4_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200280;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_3_max_200_f42002c0() {
    // Encoding: 0xF42002C0
    // Test aarch32_VLD1_m_T4A4_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Rn=0, align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF42002C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_align_0_min_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_align_1_poweroftwo_200_f4200210() {
    // Encoding: 0xF4200210
    // Test aarch32_VLD1_m_T4A4_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, align=1, Rm=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4200210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_align_3_max_200_f4200230() {
    // Encoding: 0xF4200230
    // Test aarch32_VLD1_m_T4A4_A field align = 3 (Max)
    // ISET: A32
    // Fields: align=3, Rn=0, size=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4200230;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rm_0_min_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, Rm=0, D=0, align=0, Rn=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rm_1_poweroftwo_200_f4200201() {
    // Encoding: 0xF4200201
    // Test aarch32_VLD1_m_T4A4_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, D=0, Rn=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4200201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_0_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, size=0, align=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_1_200_f4600200() {
    // Encoding: 0xF4600200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, D=1, align=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_2_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_3_200_f4210200() {
    // Encoding: 0xF4210200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=1, Rm=0, D=0, Vd=0, align=0
    let encoding: u32 = 0xF4210200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_4_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, align=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_5_200_f4201200() {
    // Encoding: 0xF4201200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=1, D=0, Rn=0, Rm=0, align=0
    let encoding: u32 = 0xF4201200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_6_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, align=0, Rn=0, Vd=0, Rm=0, size=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_7_200_f4200240() {
    // Encoding: 0xF4200240
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=0, D=0, Rn=0, size=1
    let encoding: u32 = 0xF4200240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_8_200_f4200280() {
    // Encoding: 0xF4200280
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, align=0, D=0, size=2, Rn=0, Rm=0
    let encoding: u32 = 0xF4200280;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_9_200_f42002c0() {
    // Encoding: 0xF42002C0
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=3, D=0, align=0, Rm=0
    let encoding: u32 = 0xF42002C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_10_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, D=0, Vd=0, align=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_11_200_f4200210() {
    // Encoding: 0xF4200210
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rm=0, align=1, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4200210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_12_200_f4200230() {
    // Encoding: 0xF4200230
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, align=3, Vd=0, D=0, Rm=0
    let encoding: u32 = 0xF4200230;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_13_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, Rn=0, align=0, D=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_14_200_f4200201() {
    // Encoding: 0xF4200201
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: size=0, Rm=1, align=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4200201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_15_200_f4210201() {
    // Encoding: 0xF4210201
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: A32
    // Fields: align=0, D=0, size=0, Rn=1, Vd=0, Rm=1
    let encoding: u32 = 0xF4210201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_16_200_f42f020f() {
    // Encoding: 0xF42F020F
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: A32
    // Fields: size=0, align=0, Rn=31, D=0, Vd=0, Rm=31
    let encoding: u32 = 0xF42F020F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_0_size_variant_0_512_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=0, align=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_1_size_variant_1_512_f4200240() {
    // Encoding: 0xF4200240
    // Test aarch32_VLD1_m_T4A4_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, Rm=0, D=0, size=1
    let encoding: u32 = 0xF4200240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_2_size_variant_2_512_f4200280() {
    // Encoding: 0xF4200280
    // Test aarch32_VLD1_m_T4A4_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, size=2, align=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4200280;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_3_size_variant_3_512_f42002c0() {
    // Encoding: 0xF42002C0
    // Test aarch32_VLD1_m_T4A4_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, size=3, D=0, Rn=0, Rm=0, align=0
    let encoding: u32 = 0xF42002C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t4a4_a_invalid_0_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t4a4_a_invalid_1_200_f4200200() {
    // Encoding: 0xF4200200
    // Test aarch32_VLD1_m_T4A4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, align=0, size=0, Rm=0
    let encoding: u32 = 0xF4200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_d_0_min_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_d_1_max_700_f9600700() {
    // Thumb encoding (32): 0xF9600700
    // Test aarch32_VLD1_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rn_0_min_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, size=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rn_1_poweroftwo_700_f9210700() {
    // Thumb encoding (32): 0xF9210700
    // Test aarch32_VLD1_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, align=0, D=0, Rn=1, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_vd_0_min_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, align=0, D=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_vd_1_poweroftwo_700_f9201700() {
    // Thumb encoding (32): 0xF9201700
    // Test aarch32_VLD1_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, size=0, Rn=0, Vd=1, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_0_min_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_1_poweroftwo_700_f9200740() {
    // Thumb encoding (32): 0xF9200740
    // Test aarch32_VLD1_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=1, Rm=0, align=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200740;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_2_poweroftwo_700_f9200780() {
    // Thumb encoding (32): 0xF9200780
    // Test aarch32_VLD1_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=2, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_size_3_max_700_f92007c0() {
    // Thumb encoding (32): 0xF92007C0
    // Test aarch32_VLD1_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, size=3, Rm=0, align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_align_0_min_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, Vd=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_align_1_poweroftwo_700_f9200710() {
    // Thumb encoding (32): 0xF9200710
    // Test aarch32_VLD1_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=1, D=0, Rn=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_align_3_max_700_f9200730() {
    // Thumb encoding (32): 0xF9200730
    // Test aarch32_VLD1_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: size=0, Rn=0, align=3, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200730;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rm_0_min_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, Rm=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t1a1_a_field_rm_1_poweroftwo_700_f9200701() {
    // Thumb encoding (32): 0xF9200701
    // Test aarch32_VLD1_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Rn=0, Vd=0, size=0, D=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200701;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_0_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, Rn=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_1_700_f9600700() {
    // Thumb encoding (32): 0xF9600700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, D=1, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_2_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_3_700_f9210700() {
    // Thumb encoding (32): 0xF9210700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rn=1, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_4_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, align=0, Vd=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_5_700_f9201700() {
    // Thumb encoding (32): 0xF9201700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, D=0, Vd=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_6_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_7_700_f9200740() {
    // Thumb encoding (32): 0xF9200740
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, Vd=0, size=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200740;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_8_700_f9200780() {
    // Thumb encoding (32): 0xF9200780
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=2, Vd=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_9_700_f92007c0() {
    // Thumb encoding (32): 0xF92007C0
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=3, Rn=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_10_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_11_700_f9200710() {
    // Thumb encoding (32): 0xF9200710
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, size=0, align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_12_700_f9200730() {
    // Thumb encoding (32): 0xF9200730
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, align=3, Vd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200730;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_13_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, Rn=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_14_700_f9200701() {
    // Thumb encoding (32): 0xF9200701
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, Rn=0, Rm=1, size=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200701;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_15_700_f9210701() {
    // Thumb encoding (32): 0xF9210701
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: size=0, align=0, Vd=0, D=0, Rn=1, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210701;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t1a1_a_combo_16_700_f92f070f() {
    // Thumb encoding (32): 0xF92F070F
    // Test aarch32_VLD1_m_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Vd=0, Rm=31, align=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92F070F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_0_size_variant_0_1792_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, Rn=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_1_size_variant_1_1792_f9200740() {
    // Thumb encoding (32): 0xF9200740
    // Test aarch32_VLD1_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, align=0, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200740;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_2_size_variant_2_1792_f9200780() {
    // Thumb encoding (32): 0xF9200780
    // Test aarch32_VLD1_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t1a1_a_special_size_3_size_variant_3_1792_f92007c0() {
    // Thumb encoding (32): 0xF92007C0
    // Test aarch32_VLD1_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, D=0, Rn=0, align=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_0_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, Rn=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_1_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_2_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Rm=0, Vd=0, align=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t1a1_a_invalid_3_700_f9200700() {
    // Thumb encoding (32): 0xF9200700
    // Test aarch32_VLD1_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200700;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_d_0_min_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, align=0, Rm=0, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_d_1_max_a00_f9600a00() {
    // Thumb encoding (32): 0xF9600A00
    // Test aarch32_VLD1_m_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, align=0, Rm=0, Vd=0, D=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rn_0_min_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, Rm=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rn_1_poweroftwo_a00_f9210a00() {
    // Thumb encoding (32): 0xF9210A00
    // Test aarch32_VLD1_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, D=0, align=0, Rm=0, Rn=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_vd_0_min_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_vd_1_poweroftwo_a00_f9201a00() {
    // Thumb encoding (32): 0xF9201A00
    // Test aarch32_VLD1_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, size=0, Rn=0, D=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_0_min_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_1_poweroftwo_a00_f9200a40() {
    // Thumb encoding (32): 0xF9200A40
    // Test aarch32_VLD1_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_2_poweroftwo_a00_f9200a80() {
    // Thumb encoding (32): 0xF9200A80
    // Test aarch32_VLD1_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, align=0, size=2, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_size_3_max_a00_f9200ac0() {
    // Thumb encoding (32): 0xF9200AC0
    // Test aarch32_VLD1_m_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, D=0, align=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200AC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_align_0_min_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, Vd=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_align_1_poweroftwo_a00_f9200a10() {
    // Thumb encoding (32): 0xF9200A10
    // Test aarch32_VLD1_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, align=1, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_align_3_max_a00_f9200a30() {
    // Thumb encoding (32): 0xF9200A30
    // Test aarch32_VLD1_m_T2A2_A field align = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, align=3, Rn=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rm_0_min_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, size=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t2a2_a_field_rm_1_poweroftwo_a00_f9200a01() {
    // Thumb encoding (32): 0xF9200A01
    // Test aarch32_VLD1_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, size=0, Rn=0, D=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_0_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, Rn=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_1_a00_f9600a00() {
    // Thumb encoding (32): 0xF9600A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rn=0, Vd=0, D=1, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_2_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, align=0, Rn=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_3_a00_f9210a00() {
    // Thumb encoding (32): 0xF9210A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, D=0, Rn=1, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_4_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_5_a00_f9201a00() {
    // Thumb encoding (32): 0xF9201A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=1, align=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_6_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, align=0, Rn=0, Vd=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_7_a00_f9200a40() {
    // Thumb encoding (32): 0xF9200A40
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Vd=0, Rn=0, D=0, Rm=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_8_a00_f9200a80() {
    // Thumb encoding (32): 0xF9200A80
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, align=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_9_a00_f9200ac0() {
    // Thumb encoding (32): 0xF9200AC0
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, D=0, Vd=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200AC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_10_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_11_a00_f9200a10() {
    // Thumb encoding (32): 0xF9200A10
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, align=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_12_a00_f9200a30() {
    // Thumb encoding (32): 0xF9200A30
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, align=3, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_13_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, D=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_14_a00_f9200a01() {
    // Thumb encoding (32): 0xF9200A01
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, align=0, D=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_15_a00_f9210a01() {
    // Thumb encoding (32): 0xF9210A01
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, align=0, size=0, Rm=1, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t2a2_a_combo_16_a00_f92f0a0f() {
    // Thumb encoding (32): 0xF92F0A0F
    // Test aarch32_VLD1_m_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: T32
    // Fields: size=0, align=0, D=0, Rn=31, Rm=31, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92F0A0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_0_size_variant_0_2560_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_1_size_variant_1_2560_f9200a40() {
    // Thumb encoding (32): 0xF9200A40
    // Test aarch32_VLD1_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, Rm=0, size=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_2_size_variant_2_2560_f9200a80() {
    // Thumb encoding (32): 0xF9200A80
    // Test aarch32_VLD1_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, align=0, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t2a2_a_special_size_3_size_variant_3_2560_f9200ac0() {
    // Thumb encoding (32): 0xF9200AC0
    // Test aarch32_VLD1_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, Rn=0, Rm=0, size=3, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200AC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_0_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Rn=0, D=0, Rm=0, size=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_1_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, align=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_2_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, align=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t2a2_a_invalid_3_a00_f9200a00() {
    // Thumb encoding (32): 0xF9200A00
    // Test aarch32_VLD1_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_d_0_min_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, align=0, size=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_d_1_max_600_f9600600() {
    // Thumb encoding (32): 0xF9600600
    // Test aarch32_VLD1_m_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: align=0, Rm=0, size=0, Rn=0, D=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rn_0_min_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, align=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rn_1_poweroftwo_600_f9210600() {
    // Thumb encoding (32): 0xF9210600
    // Test aarch32_VLD1_m_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Vd=0, size=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_vd_0_min_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_vd_1_poweroftwo_600_f9201600() {
    // Thumb encoding (32): 0xF9201600
    // Test aarch32_VLD1_m_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, align=0, Vd=1, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_0_min_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_1_poweroftwo_600_f9200640() {
    // Thumb encoding (32): 0xF9200640
    // Test aarch32_VLD1_m_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=1, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200640;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_2_poweroftwo_600_f9200680() {
    // Thumb encoding (32): 0xF9200680
    // Test aarch32_VLD1_m_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, size=2, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_size_3_max_600_f92006c0() {
    // Thumb encoding (32): 0xF92006C0
    // Test aarch32_VLD1_m_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, size=3, D=0, Rn=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92006C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_align_0_min_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, align=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_align_1_poweroftwo_600_f9200610() {
    // Thumb encoding (32): 0xF9200610
    // Test aarch32_VLD1_m_T3A3_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, align=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200610;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_align_3_max_600_f9200630() {
    // Thumb encoding (32): 0xF9200630
    // Test aarch32_VLD1_m_T3A3_A field align = 3 (Max)
    // ISET: T32
    // Fields: align=3, size=0, D=0, Vd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200630;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rm_0_min_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t3a3_a_field_rm_1_poweroftwo_600_f9200601() {
    // Thumb encoding (32): 0xF9200601
    // Test aarch32_VLD1_m_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, align=0, Rn=0, D=0, size=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200601;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_0_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_1_600_f9600600() {
    // Thumb encoding (32): 0xF9600600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=1, Vd=0, size=0, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_2_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, D=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_3_600_f9210600() {
    // Thumb encoding (32): 0xF9210600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=1, align=0, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_4_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_5_600_f9201600() {
    // Thumb encoding (32): 0xF9201600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, align=0, Vd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_6_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_7_600_f9200640() {
    // Thumb encoding (32): 0xF9200640
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, align=0, Rn=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200640;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_8_600_f9200680() {
    // Thumb encoding (32): 0xF9200680
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rn=0, Rm=0, size=2, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_9_600_f92006c0() {
    // Thumb encoding (32): 0xF92006C0
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, size=3, Rn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92006C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_10_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Vd=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_11_600_f9200610() {
    // Thumb encoding (32): 0xF9200610
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Rn=0, Rm=0, align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200610;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_12_600_f9200630() {
    // Thumb encoding (32): 0xF9200630
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, Rm=0, align=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200630;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_13_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, align=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_14_600_f9200601() {
    // Thumb encoding (32): 0xF9200601
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: align=0, Vd=0, Rn=0, size=0, Rm=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200601;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_15_600_f9210601() {
    // Thumb encoding (32): 0xF9210601
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Vd=0, Rn=1, D=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210601;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t3a3_a_combo_16_600_f92f060f() {
    // Thumb encoding (32): 0xF92F060F
    // Test aarch32_VLD1_m_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Vd=0, Rm=31, size=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92F060F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_0_size_variant_0_1536_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_1_size_variant_1_1536_f9200640() {
    // Thumb encoding (32): 0xF9200640
    // Test aarch32_VLD1_m_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: align=0, Rm=0, size=1, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200640;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_2_size_variant_2_1536_f9200680() {
    // Thumb encoding (32): 0xF9200680
    // Test aarch32_VLD1_m_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Vd=0, size=2, Rn=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t3a3_a_special_size_3_size_variant_3_1536_f92006c0() {
    // Thumb encoding (32): 0xF92006C0
    // Test aarch32_VLD1_m_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, D=0, size=3, Vd=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92006C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_0_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_1_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_2_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rm=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t3a3_a_invalid_3_600_f9200600() {
    // Thumb encoding (32): 0xF9200600
    // Test aarch32_VLD1_m_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200600;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_d_0_min_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_d_1_max_200_f9600200() {
    // Thumb encoding (32): 0xF9600200
    // Test aarch32_VLD1_m_T4A4_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, align=0, size=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rn_0_min_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, align=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rn_1_poweroftwo_200_f9210200() {
    // Thumb encoding (32): 0xF9210200
    // Test aarch32_VLD1_m_T4A4_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=1, Vd=0, Rm=0, align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_vd_0_min_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, size=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_vd_1_poweroftwo_200_f9201200() {
    // Thumb encoding (32): 0xF9201200
    // Test aarch32_VLD1_m_T4A4_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Vd=1, Rn=0, size=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_0_min_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_1_poweroftwo_200_f9200240() {
    // Thumb encoding (32): 0xF9200240
    // Test aarch32_VLD1_m_T4A4_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, size=1, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_2_poweroftwo_200_f9200280() {
    // Thumb encoding (32): 0xF9200280
    // Test aarch32_VLD1_m_T4A4_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, D=0, Rm=0, Rn=0, Vd=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200280;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_size_3_max_200_f92002c0() {
    // Thumb encoding (32): 0xF92002C0
    // Test aarch32_VLD1_m_T4A4_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, size=3, Rm=0, D=0, Rn=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92002C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_align_0_min_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field align = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, align=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_align_1_poweroftwo_200_f9200210() {
    // Thumb encoding (32): 0xF9200210
    // Test aarch32_VLD1_m_T4A4_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, align=1, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_align_3_max_200_f9200230() {
    // Thumb encoding (32): 0xF9200230
    // Test aarch32_VLD1_m_T4A4_A field align = 3 (Max)
    // ISET: T32
    // Fields: align=3, Rm=0, Rn=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200230;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rm_0_min_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_m_t4a4_a_field_rm_1_poweroftwo_200_f9200201() {
    // Thumb encoding (32): 0xF9200201
    // Test aarch32_VLD1_m_T4A4_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, align=0, D=0, Vd=0, Rm=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_0_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Rm=0, Rn=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_1_200_f9600200() {
    // Thumb encoding (32): 0xF9600200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=1, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=1, Vd=0, align=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9600200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_2_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_3_200_f9210200() {
    // Thumb encoding (32): 0xF9210200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=1, Vd=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_4_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rn=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_5_200_f9201200() {
    // Thumb encoding (32): 0xF9201200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=1, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, align=0, Vd=1, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9201200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_6_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, align=0, Vd=0, Rm=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_7_200_f9200240() {
    // Thumb encoding (32): 0xF9200240
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=1, align=0, Rm=0
    // ISET: T32
    // Fields: size=1, Rn=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_8_200_f9200280() {
    // Thumb encoding (32): 0xF9200280
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=2, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200280;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_9_200_f92002c0() {
    // Thumb encoding (32): 0xF92002C0
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=3, align=0, Rm=0
    // ISET: T32
    // Fields: size=3, Rn=0, align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92002C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=0 (minimum value)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_10_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, align=0, size=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=1 (value 1)
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_11_200_f9200210() {
    // Thumb encoding (32): 0xF9200210
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=1, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, align=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// align=3 (maximum value (3))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_12_200_f9200230() {
    // Thumb encoding (32): 0xF9200230
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=3, Rm=0
    // ISET: T32
    // Fields: size=0, align=3, Rn=0, Vd=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200230;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_13_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rn=0, Rm=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_14_200_f9200201() {
    // Thumb encoding (32): 0xF9200201
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rn=0, size=0, D=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_15_200_f9210201() {
    // Thumb encoding (32): 0xF9210201
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=1, Vd=0, size=0, align=0, Rm=1
    // ISET: T32
    // Fields: D=0, align=0, Rm=1, Vd=0, Rn=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9210201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_m_t4a4_a_combo_16_200_f92f020f() {
    // Thumb encoding (32): 0xF92F020F
    // Test aarch32_VLD1_m_T4A4_A field combination: D=0, Rn=31, Vd=0, size=0, align=0, Rm=31
    // ISET: T32
    // Fields: D=0, Rn=31, Vd=0, Rm=31, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92F020F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_0_size_variant_0_512_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, Rn=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_1_size_variant_1_512_f9200240() {
    // Thumb encoding (32): 0xF9200240
    // Test aarch32_VLD1_m_T4A4_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, size=1, Rm=0, Vd=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_2_size_variant_2_512_f9200280() {
    // Thumb encoding (32): 0xF9200280
    // Test aarch32_VLD1_m_T4A4_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: align=0, Rn=0, Rm=0, Vd=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200280;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_m_t4a4_a_special_size_3_size_variant_3_512_f92002c0() {
    // Thumb encoding (32): 0xF92002C0
    // Test aarch32_VLD1_m_T4A4_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=3, Rn=0, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF92002C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t4a4_a_invalid_0_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_m_T4A4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_m_t4a4_a_invalid_1_200_f9200200() {
    // Thumb encoding (32): 0xF9200200
    // Test aarch32_VLD1_m_T4A4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9200200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD1_1_A Tests
// ============================================================================

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_d_0_min_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, D=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_d_1_max_0_f4e00000() {
    // Encoding: 0xF4E00000
    // Test aarch32_VLD1_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: index_align=0, Rn=0, size=0, Vd=0, D=1, Rm=0
    let encoding: u32 = 0xF4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rn_0_min_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, Rn=0, index_align=0, D=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rn_1_poweroftwo_0_f4a10000() {
    // Encoding: 0xF4A10000
    // Test aarch32_VLD1_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rm=0, index_align=0, Rn=1
    let encoding: u32 = 0xF4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_vd_0_min_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_vd_1_poweroftwo_0_f4a01000() {
    // Encoding: 0xF4A01000
    // Test aarch32_VLD1_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Vd=1, Rn=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_0_min_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, Rm=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_1_poweroftwo_0_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rn=0, Rm=0, Vd=0, D=0, size=1
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_2_poweroftwo_0_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=2, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_3_max_0_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Vd=0, Rn=0, Rm=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_0_min_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, D=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_1_poweroftwo_0_f4a00010() {
    // Encoding: 0xF4A00010
    // Test aarch32_VLD1_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, index_align=1, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_7_poweroftwominusone_0_f4a00070() {
    // Encoding: 0xF4A00070
    // Test aarch32_VLD1_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, index_align=7, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_15_max_0_f4a000f0() {
    // Encoding: 0xF4A000F0
    // Test aarch32_VLD1_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, index_align=15, Rm=0, D=0
    let encoding: u32 = 0xF4A000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rm_0_min_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rm_1_poweroftwo_0_f4a00001() {
    // Encoding: 0xF4A00001
    // Test aarch32_VLD1_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, Vd=0, size=0, Rm=1
    let encoding: u32 = 0xF4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_0_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, D=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_1_0_f4e00000() {
    // Encoding: 0xF4E00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, D=1, size=0
    let encoding: u32 = 0xF4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_2_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, Rn=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_3_0_f4a10000() {
    // Encoding: 0xF4A10000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=0, Rn=1, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_4_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, index_align=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_5_0_f4a01000() {
    // Encoding: 0xF4A01000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=1, D=0, size=0, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_6_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_7_0_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, size=1, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_8_0_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=2, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_9_0_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=3, Rn=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_10_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, Rn=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_11_0_f4a00010() {
    // Encoding: 0xF4A00010
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=1, Rm=0, size=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_12_0_f4a00070() {
    // Encoding: 0xF4A00070
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, Rn=0, index_align=7, Rm=0
    let encoding: u32 = 0xF4A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_13_0_f4a000f0() {
    // Encoding: 0xF4A000F0
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=15, D=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_14_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_15_0_f4a00001() {
    // Encoding: 0xF4A00001
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Rm=1, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_16_0_f4a10001() {
    // Encoding: 0xF4A10001
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: D=0, Rn=1, Vd=0, index_align=0, size=0, Rm=1
    let encoding: u32 = 0xF4A10001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_17_0_f4af000f() {
    // Encoding: 0xF4AF000F
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rm=31, index_align=0, Rn=31
    let encoding: u32 = 0xF4AF000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_0_size_variant_0_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_1_size_variant_1_0_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, index_align=0, D=0, size=1
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_2_size_variant_2_0_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, index_align=0, size=2, Rn=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_3_size_variant_3_0_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, index_align=0, size=3, Vd=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_0_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_1_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_2_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, index_align=0, Rn=0, D=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_3_0_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_d_0_min_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_d_1_max_400_f4e00000() {
    // Encoding: 0xF4E00000
    // Test aarch32_VLD1_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, D=1, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rn_0_min_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Vd=0, D=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rn_1_poweroftwo_400_f4a10000() {
    // Encoding: 0xF4A10000
    // Test aarch32_VLD1_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, Rn=1, D=0, index_align=0
    let encoding: u32 = 0xF4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_vd_0_min_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_vd_1_poweroftwo_400_f4a01000() {
    // Encoding: 0xF4A01000
    // Test aarch32_VLD1_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Vd=1, size=0, Rn=0, Rm=0, D=0
    let encoding: u32 = 0xF4A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_0_min_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_1_poweroftwo_400_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, Vd=0, size=1, Rm=0
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_2_poweroftwo_400_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, size=2, D=0, Vd=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_3_max_400_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, size=3, Rm=0, Vd=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_0_min_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_1_poweroftwo_400_f4a00010() {
    // Encoding: 0xF4A00010
    // Test aarch32_VLD1_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=1, Vd=0, Rm=0, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_7_poweroftwominusone_400_f4a00070() {
    // Encoding: 0xF4A00070
    // Test aarch32_VLD1_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, index_align=7, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_15_max_400_f4a000f0() {
    // Encoding: 0xF4A000F0
    // Test aarch32_VLD1_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, index_align=15, Rm=0, Vd=0
    let encoding: u32 = 0xF4A000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rm_0_min_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rm_1_poweroftwo_400_f4a00001() {
    // Encoding: 0xF4A00001
    // Test aarch32_VLD1_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, D=0, Vd=0, size=0, Rn=0, Rm=1
    let encoding: u32 = 0xF4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_0_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_1_400_f4e00000() {
    // Encoding: 0xF4E00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=1, size=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_2_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_3_400_f4a10000() {
    // Encoding: 0xF4A10000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, Rn=1, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_4_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_5_400_f4a01000() {
    // Encoding: 0xF4A01000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, size=0, Vd=1
    let encoding: u32 = 0xF4A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_6_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, Vd=0, index_align=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_7_400_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=1, index_align=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_8_400_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=2, index_align=0, D=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_9_400_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=3, Rn=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_10_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_11_400_f4a00010() {
    // Encoding: 0xF4A00010
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: index_align=1, Rm=0, Rn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_12_400_f4a00070() {
    // Encoding: 0xF4A00070
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: index_align=7, D=0, Rn=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_13_400_f4a000f0() {
    // Encoding: 0xF4A000F0
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: index_align=15, Rm=0, Rn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4A000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_14_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_15_400_f4a00001() {
    // Encoding: 0xF4A00001
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: size=0, index_align=0, D=0, Rm=1, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_16_400_f4a10001() {
    // Encoding: 0xF4A10001
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, Vd=0, D=0, Rn=1, size=0, index_align=0
    let encoding: u32 = 0xF4A10001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_17_400_f4af000f() {
    // Encoding: 0xF4AF000F
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Rn=31, size=0, index_align=0, Vd=0, Rm=31, D=0
    let encoding: u32 = 0xF4AF000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_0_size_variant_0_1024_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, Rm=0, Rn=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_1_size_variant_1_1024_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, Rm=0, D=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_2_size_variant_2_1024_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, Rn=0, Vd=0, index_align=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_3_size_variant_3_1024_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, D=0, Vd=0, size=3
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_0_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_1_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_2_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, index_align=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_3_400_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_d_0_min_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_d_1_max_800_f4e00000() {
    // Encoding: 0xF4E00000
    // Test aarch32_VLD1_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, D=1, Vd=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rn_0_min_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rn_1_poweroftwo_800_f4a10000() {
    // Encoding: 0xF4A10000
    // Test aarch32_VLD1_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Vd=0, size=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_vd_0_min_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, Rn=0, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_vd_1_poweroftwo_800_f4a01000() {
    // Encoding: 0xF4A01000
    // Test aarch32_VLD1_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, index_align=0, D=0, Vd=1, size=0, Rm=0
    let encoding: u32 = 0xF4A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_0_min_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rn=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_1_poweroftwo_800_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, size=1, Rn=0, index_align=0
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_2_poweroftwo_800_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, D=0, Rm=0, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_3_max_800_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, D=0, size=3, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_0_min_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, size=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_1_poweroftwo_800_f4a00010() {
    // Encoding: 0xF4A00010
    // Test aarch32_VLD1_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=1, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_7_poweroftwominusone_800_f4a00070() {
    // Encoding: 0xF4A00070
    // Test aarch32_VLD1_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, D=0, Rm=0, index_align=7
    let encoding: u32 = 0xF4A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_15_max_800_f4a000f0() {
    // Encoding: 0xF4A000F0
    // Test aarch32_VLD1_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: index_align=15, Rm=0, D=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4A000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rm_0_min_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rm_1_poweroftwo_800_f4a00001() {
    // Encoding: 0xF4A00001
    // Test aarch32_VLD1_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=1, size=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_0_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, index_align=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_1_800_f4e00000() {
    // Encoding: 0xF4E00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, Vd=0, size=0, D=1, Rm=0
    let encoding: u32 = 0xF4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_2_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, Rn=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_3_800_f4a10000() {
    // Encoding: 0xF4A10000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=0, size=0, Rn=1, Rm=0, D=0
    let encoding: u32 = 0xF4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_4_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, Rn=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_5_800_f4a01000() {
    // Encoding: 0xF4A01000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, D=0, size=0, Vd=1
    let encoding: u32 = 0xF4A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_6_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, size=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_7_800_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, index_align=0, Vd=0, Rn=0, size=1
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_8_800_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, size=2, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_9_800_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, Rn=0, D=0, size=3
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_10_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, Rn=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_11_800_f4a00010() {
    // Encoding: 0xF4A00010
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=1, size=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_12_800_f4a00070() {
    // Encoding: 0xF4A00070
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, Rm=0, index_align=7
    let encoding: u32 = 0xF4A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_13_800_f4a000f0() {
    // Encoding: 0xF4A000F0
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=15, Rn=0, Rm=0, size=0, D=0
    let encoding: u32 = 0xF4A000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_14_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rm=0, index_align=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_15_800_f4a00001() {
    // Encoding: 0xF4A00001
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Vd=0, D=0, Rm=1
    let encoding: u32 = 0xF4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_16_800_f4a10001() {
    // Encoding: 0xF4A10001
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, Rn=1, D=0, Vd=0, size=0, index_align=0
    let encoding: u32 = 0xF4A10001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_17_800_f4af000f() {
    // Encoding: 0xF4AF000F
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Rm=31, Vd=0, index_align=0, Rn=31, D=0, size=0
    let encoding: u32 = 0xF4AF000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_0_size_variant_0_2048_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, index_align=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_1_size_variant_1_2048_f4a00400() {
    // Encoding: 0xF4A00400
    // Test aarch32_VLD1_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, index_align=0, D=0, size=1, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_2_size_variant_2_2048_f4a00800() {
    // Encoding: 0xF4A00800
    // Test aarch32_VLD1_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, size=2, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_3_size_variant_3_2048_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=3, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_0_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Vd=0, index_align=0, D=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_1_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: index_align=0, D=0, Rm=0, size=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_2_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: index_align=0, D=0, Vd=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_3_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Vd=0, index_align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_4_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, size=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_5_800_f4a00000() {
    // Encoding: 0xF4A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, Rm=0, index_align=0, size=0
    let encoding: u32 = 0xF4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_d_0_min_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, Rn=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_d_1_max_0_f9e00000() {
    // Thumb encoding (32): 0xF9E00000
    // Test aarch32_VLD1_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: index_align=0, D=1, size=0, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rn_0_min_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rn_1_poweroftwo_0_f9a10000() {
    // Thumb encoding (32): 0xF9A10000
    // Test aarch32_VLD1_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=1, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_vd_0_min_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_vd_1_poweroftwo_0_f9a01000() {
    // Thumb encoding (32): 0xF9A01000
    // Test aarch32_VLD1_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=1, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_0_min_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, size=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_1_poweroftwo_0_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, index_align=0, size=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_2_poweroftwo_0_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, Rn=0, size=2, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_size_3_max_0_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=3, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_0_min_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Rm=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_1_poweroftwo_0_f9a00010() {
    // Thumb encoding (32): 0xF9A00010
    // Test aarch32_VLD1_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, index_align=1, size=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_7_poweroftwominusone_0_f9a00070() {
    // Thumb encoding (32): 0xF9A00070
    // Test aarch32_VLD1_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, index_align=7, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_index_align_15_max_0_f9a000f0() {
    // Thumb encoding (32): 0xF9A000F0
    // Test aarch32_VLD1_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, index_align=15, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rm_0_min_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, index_align=0, Rn=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t1a1_a_field_rm_1_poweroftwo_0_f9a00001() {
    // Thumb encoding (32): 0xF9A00001
    // Test aarch32_VLD1_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Vd=0, D=0, size=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_0_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, size=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_1_0_f9e00000() {
    // Thumb encoding (32): 0xF9E00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=1, index_align=0, Rn=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_2_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=0, Rm=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_3_0_f9a10000() {
    // Thumb encoding (32): 0xF9A10000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, index_align=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_4_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_5_0_f9a01000() {
    // Thumb encoding (32): 0xF9A01000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Rm=0, index_align=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_6_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, index_align=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_7_0_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=1, Rm=0, Rn=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_8_0_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=2, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_9_0_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_10_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Rm=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_11_0_f9a00010() {
    // Thumb encoding (32): 0xF9A00010
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, index_align=1, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_12_0_f9a00070() {
    // Thumb encoding (32): 0xF9A00070
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: index_align=7, D=0, Rn=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_13_0_f9a000f0() {
    // Thumb encoding (32): 0xF9A000F0
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, index_align=15, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_14_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, index_align=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_15_0_f9a00001() {
    // Thumb encoding (32): 0xF9A00001
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rm=1, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_16_0_f9a10001() {
    // Thumb encoding (32): 0xF9A10001
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: D=0, Rn=1, index_align=0, Vd=0, Rm=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_1_t1a1_a_combo_17_0_f9af000f() {
    // Thumb encoding (32): 0xF9AF000F
    // Test aarch32_VLD1_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, index_align=0, D=0, Rm=31, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_0_size_variant_0_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, size=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_1_size_variant_1_0_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Rn=0, size=1, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_2_size_variant_2_0_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, size=2, D=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_1_t1a1_a_special_size_3_size_variant_3_0_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Rn=0, Rm=0, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_0_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_1_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_2_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t1a1_a_invalid_3_0_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: index_align=0, Rn=0, D=0, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_d_0_min_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_d_1_max_400_f9e00000() {
    // Thumb encoding (32): 0xF9E00000
    // Test aarch32_VLD1_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: index_align=0, Rn=0, size=0, Vd=0, Rm=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rn_0_min_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rn_1_poweroftwo_400_f9a10000() {
    // Thumb encoding (32): 0xF9A10000
    // Test aarch32_VLD1_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rm=0, D=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_vd_0_min_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_vd_1_poweroftwo_400_f9a01000() {
    // Thumb encoding (32): 0xF9A01000
    // Test aarch32_VLD1_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, Vd=1, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_0_min_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_1_poweroftwo_400_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_2_poweroftwo_400_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rm=0, size=2, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_size_3_max_400_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Rn=0, D=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_0_min_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_1_poweroftwo_400_f9a00010() {
    // Thumb encoding (32): 0xF9A00010
    // Test aarch32_VLD1_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, index_align=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_7_poweroftwominusone_400_f9a00070() {
    // Thumb encoding (32): 0xF9A00070
    // Test aarch32_VLD1_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rn=0, Rm=0, index_align=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_index_align_15_max_400_f9a000f0() {
    // Thumb encoding (32): 0xF9A000F0
    // Test aarch32_VLD1_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, index_align=15, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rm_0_min_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t2a2_a_field_rm_1_poweroftwo_400_f9a00001() {
    // Thumb encoding (32): 0xF9A00001
    // Test aarch32_VLD1_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=1, size=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_0_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_1_400_f9e00000() {
    // Thumb encoding (32): 0xF9E00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, size=0, Rm=0, D=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_2_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, Rm=0, index_align=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_3_400_f9a10000() {
    // Thumb encoding (32): 0xF9A10000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=1, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_4_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rn=0, index_align=0, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_5_400_f9a01000() {
    // Thumb encoding (32): 0xF9A01000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, size=0, index_align=0, Rn=0, D=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_6_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_7_400_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=1, D=0, Rm=0, Rn=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_8_400_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, Rm=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_9_400_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, index_align=0, Vd=0, Rn=0, D=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_10_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, index_align=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_11_400_f9a00010() {
    // Thumb encoding (32): 0xF9A00010
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=1, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_12_400_f9a00070() {
    // Thumb encoding (32): 0xF9A00070
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=7, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_13_400_f9a000f0() {
    // Thumb encoding (32): 0xF9A000F0
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: index_align=15, size=0, Rn=0, Vd=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_14_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_15_400_f9a00001() {
    // Thumb encoding (32): 0xF9A00001
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: size=0, D=0, index_align=0, Vd=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_16_400_f9a10001() {
    // Thumb encoding (32): 0xF9A10001
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rm=1, Rn=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_1_t2a2_a_combo_17_400_f9af000f() {
    // Thumb encoding (32): 0xF9AF000F
    // Test aarch32_VLD1_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, size=0, Vd=0, Rm=31, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_0_size_variant_0_1024_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Rn=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_1_size_variant_1_1024_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, Rn=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_2_size_variant_2_1024_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: index_align=0, size=2, D=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_1_t2a2_a_special_size_3_size_variant_3_1024_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=3, Rm=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_0_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_1_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_2_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, index_align=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t2a2_a_invalid_3_400_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, D=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_d_0_min_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, index_align=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_d_1_max_800_f9e00000() {
    // Thumb encoding (32): 0xF9E00000
    // Test aarch32_VLD1_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, index_align=0, Rn=0, Rm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rn_0_min_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, index_align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rn_1_poweroftwo_800_f9a10000() {
    // Thumb encoding (32): 0xF9A10000
    // Test aarch32_VLD1_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, Rn=1, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_vd_0_min_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_vd_1_poweroftwo_800_f9a01000() {
    // Thumb encoding (32): 0xF9A01000
    // Test aarch32_VLD1_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, size=0, Vd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_0_min_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_1_poweroftwo_800_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=1, Rm=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_2_poweroftwo_800_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, index_align=0, D=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_size_3_max_800_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, size=3, D=0, Rn=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_0_min_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_1_poweroftwo_800_f9a00010() {
    // Thumb encoding (32): 0xF9A00010
    // Test aarch32_VLD1_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, Rn=0, Vd=0, index_align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_7_poweroftwominusone_800_f9a00070() {
    // Thumb encoding (32): 0xF9A00070
    // Test aarch32_VLD1_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, index_align=7, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_index_align_15_max_800_f9a000f0() {
    // Thumb encoding (32): 0xF9A000F0
    // Test aarch32_VLD1_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, D=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rm_0_min_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, Rn=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_1_t3a3_a_field_rm_1_poweroftwo_800_f9a00001() {
    // Thumb encoding (32): 0xF9A00001
    // Test aarch32_VLD1_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rm=1, Rn=0, D=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_0_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_1_800_f9e00000() {
    // Thumb encoding (32): 0xF9E00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, D=1, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_2_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_3_800_f9a10000() {
    // Thumb encoding (32): 0xF9A10000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rn=1, D=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_4_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_5_800_f9a01000() {
    // Thumb encoding (32): 0xF9A01000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, Vd=1, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_6_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=0, Rn=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_7_800_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, size=1, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_8_800_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=2, D=0, index_align=0, Vd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_9_800_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=3, D=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_10_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, Rn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_11_800_f9a00010() {
    // Thumb encoding (32): 0xF9A00010
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, D=0, index_align=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_12_800_f9a00070() {
    // Thumb encoding (32): 0xF9A00070
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=7, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_13_800_f9a000f0() {
    // Thumb encoding (32): 0xF9A000F0
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: Rm=0, index_align=15, Rn=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_14_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, Rn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_15_800_f9a00001() {
    // Thumb encoding (32): 0xF9A00001
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=1, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_16_800_f9a10001() {
    // Thumb encoding (32): 0xF9A10001
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, Rn=1, size=0, index_align=0, D=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_1_t3a3_a_combo_17_800_f9af000f() {
    // Thumb encoding (32): 0xF9AF000F
    // Test aarch32_VLD1_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Vd=0, Rn=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_0_size_variant_0_2048_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_1_size_variant_1_2048_f9a00400() {
    // Thumb encoding (32): 0xF9A00400
    // Test aarch32_VLD1_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, D=0, index_align=0, size=1, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_2_size_variant_2_2048_f9a00800() {
    // Thumb encoding (32): 0xF9A00800
    // Test aarch32_VLD1_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, D=0, Vd=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_1_t3a3_a_special_size_3_size_variant_3_2048_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, size=3, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_0_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_1_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, index_align=0, size=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_2_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_3_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, D=0, Rm=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_4_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_1_t3a3_a_invalid_5_800_f9a00000() {
    // Thumb encoding (32): 0xF9A00000
    // Test aarch32_VLD1_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD3_1_A Tests
// ============================================================================

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_d_0_min_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_d_1_max_200_f4e00200() {
    // Encoding: 0xF4E00200
    // Test aarch32_VLD3_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, D=1, index_align=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rn_0_min_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rn_1_poweroftwo_200_f4a10200() {
    // Encoding: 0xF4A10200
    // Test aarch32_VLD3_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Vd=0, Rn=1, size=0, D=0
    let encoding: u32 = 0xF4A10200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_vd_0_min_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, index_align=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_vd_1_poweroftwo_200_f4a01200() {
    // Encoding: 0xF4A01200
    // Test aarch32_VLD3_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=1, D=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4A01200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_0_min_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_1_poweroftwo_200_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, size=1, index_align=0, Vd=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_2_poweroftwo_200_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rn=0, size=2, Rm=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_3_max_200_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, Rm=0, size=3, index_align=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_0_min_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Rm=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_1_poweroftwo_200_f4a00210() {
    // Encoding: 0xF4A00210
    // Test aarch32_VLD3_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=1, Vd=0, D=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_7_poweroftwominusone_200_f4a00270() {
    // Encoding: 0xF4A00270
    // Test aarch32_VLD3_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    let encoding: u32 = 0xF4A00270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_15_max_200_f4a002f0() {
    // Encoding: 0xF4A002F0
    // Test aarch32_VLD3_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, index_align=15, Rm=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4A002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rm_0_min_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rm_1_poweroftwo_200_f4a00201() {
    // Encoding: 0xF4A00201
    // Test aarch32_VLD3_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, Rm=1, Vd=0, size=0
    let encoding: u32 = 0xF4A00201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_0_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_1_200_f4e00200() {
    // Encoding: 0xF4E00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=1, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_2_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rm=0, Rn=0, size=0, index_align=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_3_200_f4a10200() {
    // Encoding: 0xF4A10200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, D=0, Rn=1, Vd=0
    let encoding: u32 = 0xF4A10200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_4_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, Rn=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_5_200_f4a01200() {
    // Encoding: 0xF4A01200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, index_align=0, Vd=1, Rm=0
    let encoding: u32 = 0xF4A01200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_6_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_7_200_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=1, index_align=0, Rm=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_8_200_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, size=2, Vd=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_9_200_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=3, index_align=0, Rn=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_10_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rn=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_11_200_f4a00210() {
    // Encoding: 0xF4A00210
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, Rm=0, index_align=1
    let encoding: u32 = 0xF4A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_12_200_f4a00270() {
    // Encoding: 0xF4A00270
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: index_align=7, D=0, Rn=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_13_200_f4a002f0() {
    // Encoding: 0xF4A002F0
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=15, Rm=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4A002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_14_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_15_200_f4a00201() {
    // Encoding: 0xF4A00201
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, index_align=0, Rm=1, size=0
    let encoding: u32 = 0xF4A00201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_16_200_f4a10201() {
    // Encoding: 0xF4A10201
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rn=1, D=0, Vd=0, size=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4A10201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_17_200_f4af020f() {
    // Encoding: 0xF4AF020F
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: index_align=0, Rm=31, Vd=0, D=0, Rn=31, size=0
    let encoding: u32 = 0xF4AF020F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_0_size_variant_0_512_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, index_align=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_1_size_variant_1_512_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, Rn=0, size=1, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_2_size_variant_2_512_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, D=0, index_align=0, size=2, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_3_size_variant_3_512_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rm=0, size=3, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_0_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: size=0, Rn=0, index_align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_1_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_2_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_3_200_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_d_0_min_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_d_1_max_600_f4e00200() {
    // Encoding: 0xF4E00200
    // Test aarch32_VLD3_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, Rn=0, index_align=0, Vd=0, Rm=0, D=1
    let encoding: u32 = 0xF4E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rn_0_min_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rn_1_poweroftwo_600_f4a10200() {
    // Encoding: 0xF4A10200
    // Test aarch32_VLD3_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Rn=1, size=0, Vd=0
    let encoding: u32 = 0xF4A10200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_vd_0_min_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_vd_1_poweroftwo_600_f4a01200() {
    // Encoding: 0xF4A01200
    // Test aarch32_VLD3_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, Vd=1, size=0
    let encoding: u32 = 0xF4A01200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_0_min_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, index_align=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_1_poweroftwo_600_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, size=1, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_2_poweroftwo_600_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=2, Rn=0, D=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_3_max_600_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, size=3, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_0_min_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_1_poweroftwo_600_f4a00210() {
    // Encoding: 0xF4A00210
    // Test aarch32_VLD3_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=1, Vd=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_7_poweroftwominusone_600_f4a00270() {
    // Encoding: 0xF4A00270
    // Test aarch32_VLD3_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rn=0, index_align=7, Rm=0
    let encoding: u32 = 0xF4A00270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_15_max_600_f4a002f0() {
    // Encoding: 0xF4A002F0
    // Test aarch32_VLD3_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, Rm=0, Vd=0, index_align=15
    let encoding: u32 = 0xF4A002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rm_0_min_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, Rm=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rm_1_poweroftwo_600_f4a00201() {
    // Encoding: 0xF4A00201
    // Test aarch32_VLD3_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=0, index_align=0, Rm=1, D=0, Rn=0
    let encoding: u32 = 0xF4A00201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_0_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_1_600_f4e00200() {
    // Encoding: 0xF4E00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, index_align=0, Vd=0, D=1
    let encoding: u32 = 0xF4E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_2_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_3_600_f4a10200() {
    // Encoding: 0xF4A10200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, Rn=1, D=0, Rm=0
    let encoding: u32 = 0xF4A10200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_4_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rn=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_5_600_f4a01200() {
    // Encoding: 0xF4A01200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=1, index_align=0, D=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4A01200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_6_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_7_600_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, size=1, Vd=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_8_600_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, size=2, Rn=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_9_600_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, D=0, Vd=0, Rn=0, size=3, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_10_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_11_600_f4a00210() {
    // Encoding: 0xF4A00210
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, size=0, index_align=1, Vd=0
    let encoding: u32 = 0xF4A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_12_600_f4a00270() {
    // Encoding: 0xF4A00270
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, size=0, index_align=7, Rn=0
    let encoding: u32 = 0xF4A00270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_13_600_f4a002f0() {
    // Encoding: 0xF4A002F0
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, size=0, index_align=15, Vd=0
    let encoding: u32 = 0xF4A002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_14_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_15_600_f4a00201() {
    // Encoding: 0xF4A00201
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=1, Rn=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_16_600_f4a10201() {
    // Encoding: 0xF4A10201
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=1, size=0, D=0, Rn=1
    let encoding: u32 = 0xF4A10201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_17_600_f4af020f() {
    // Encoding: 0xF4AF020F
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Rn=31, size=0, Rm=31, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4AF020F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_0_size_variant_0_1536_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, size=0, D=0, index_align=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_1_size_variant_1_1536_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: index_align=0, size=1, Rm=0, D=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_2_size_variant_2_1536_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=2, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_3_size_variant_3_1536_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: index_align=0, D=0, size=3, Vd=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_0_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rm=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_1_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, index_align=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_2_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_3_600_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_d_0_min_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_d_1_max_a00_f4e00200() {
    // Encoding: 0xF4E00200
    // Test aarch32_VLD3_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, D=1, index_align=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rn_0_min_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rn_1_poweroftwo_a00_f4a10200() {
    // Encoding: 0xF4A10200
    // Test aarch32_VLD3_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=1, Vd=0, index_align=0, size=0, D=0
    let encoding: u32 = 0xF4A10200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_vd_0_min_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, size=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_vd_1_poweroftwo_a00_f4a01200() {
    // Encoding: 0xF4A01200
    // Test aarch32_VLD3_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=1, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A01200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_0_min_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_1_poweroftwo_a00_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=1, Rn=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_2_poweroftwo_a00_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, size=2, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_3_max_a00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Rn=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_0_min_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_1_poweroftwo_a00_f4a00210() {
    // Encoding: 0xF4A00210
    // Test aarch32_VLD3_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, D=0, index_align=1
    let encoding: u32 = 0xF4A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_7_poweroftwominusone_a00_f4a00270() {
    // Encoding: 0xF4A00270
    // Test aarch32_VLD3_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: index_align=7, Vd=0, Rn=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_15_max_a00_f4a002f0() {
    // Encoding: 0xF4A002F0
    // Test aarch32_VLD3_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=15, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4A002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rm_0_min_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rm_1_poweroftwo_a00_f4a00201() {
    // Encoding: 0xF4A00201
    // Test aarch32_VLD3_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4A00201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_0_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, size=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_1_a00_f4e00200() {
    // Encoding: 0xF4E00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=1, index_align=0, Vd=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xF4E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_2_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Vd=0, size=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_3_a00_f4a10200() {
    // Encoding: 0xF4A10200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=1, size=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A10200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_4_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, index_align=0, size=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_5_a00_f4a01200() {
    // Encoding: 0xF4A01200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=0, Rm=0, size=0, Vd=1
    let encoding: u32 = 0xF4A01200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_6_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_7_a00_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=1, Rm=0, D=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_8_a00_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, Vd=0, Rm=0, size=2, D=0
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_9_a00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rn=0, size=3, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_10_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, index_align=0, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_11_a00_f4a00210() {
    // Encoding: 0xF4A00210
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, Rn=0, index_align=1, D=0, Rm=0
    let encoding: u32 = 0xF4A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_12_a00_f4a00270() {
    // Encoding: 0xF4A00270
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, Rn=0, size=0, index_align=7
    let encoding: u32 = 0xF4A00270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_13_a00_f4a002f0() {
    // Encoding: 0xF4A002F0
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Vd=0, index_align=15, Rm=0
    let encoding: u32 = 0xF4A002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_14_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, D=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_15_a00_f4a00201() {
    // Encoding: 0xF4A00201
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, Rm=1, size=0, Rn=0, index_align=0, D=0
    let encoding: u32 = 0xF4A00201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_16_a00_f4a10201() {
    // Encoding: 0xF4A10201
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rn=1, D=0, size=0, index_align=0, Vd=0, Rm=1
    let encoding: u32 = 0xF4A10201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_17_a00_f4af020f() {
    // Encoding: 0xF4AF020F
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Rn=31, Rm=31, index_align=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF4AF020F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_0_size_variant_0_2560_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, index_align=0, Vd=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_1_size_variant_1_2560_f4a00600() {
    // Encoding: 0xF4A00600
    // Test aarch32_VLD3_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, Rm=0, size=1, D=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4A00600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_2_size_variant_2_2560_f4a00a00() {
    // Encoding: 0xF4A00A00
    // Test aarch32_VLD3_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Vd=0, index_align=0, Rn=0, D=0, size=2
    let encoding: u32 = 0xF4A00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_3_size_variant_3_2560_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, size=3, index_align=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_0_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, size=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_1_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rn=0, index_align=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_2_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_3_a00_f4a00200() {
    // Encoding: 0xF4A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: index_align=0, Rn=0, Rm=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF4A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_d_0_min_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_d_1_max_200_f9e00200() {
    // Thumb encoding (32): 0xF9E00200
    // Test aarch32_VLD3_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=1, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rn_0_min_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rn_1_poweroftwo_200_f9a10200() {
    // Thumb encoding (32): 0xF9A10200
    // Test aarch32_VLD3_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Vd=0, index_align=0, size=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_vd_0_min_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_vd_1_poweroftwo_200_f9a01200() {
    // Thumb encoding (32): 0xF9A01200
    // Test aarch32_VLD3_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=1, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_0_min_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, Rn=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_1_poweroftwo_200_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_2_poweroftwo_200_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, index_align=0, Rm=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_size_3_max_200_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, size=3, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_0_min_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rn=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_1_poweroftwo_200_f9a00210() {
    // Thumb encoding (32): 0xF9A00210
    // Test aarch32_VLD3_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, Vd=0, index_align=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_7_poweroftwominusone_200_f9a00270() {
    // Thumb encoding (32): 0xF9A00270
    // Test aarch32_VLD3_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, Rn=0, Vd=0, index_align=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_index_align_15_max_200_f9a002f0() {
    // Thumb encoding (32): 0xF9A002F0
    // Test aarch32_VLD3_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, size=0, index_align=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rm_0_min_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t1a1_a_field_rm_1_poweroftwo_200_f9a00201() {
    // Thumb encoding (32): 0xF9A00201
    // Test aarch32_VLD3_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, Rm=1, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_0_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_1_200_f9e00200() {
    // Thumb encoding (32): 0xF9E00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=1, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_2_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_3_200_f9a10200() {
    // Thumb encoding (32): 0xF9A10200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rm=0, index_align=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_4_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_5_200_f9a01200() {
    // Thumb encoding (32): 0xF9A01200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Rm=0, size=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_6_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_7_200_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=1, Rn=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_8_200_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=2, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_9_200_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=3, Vd=0, Rm=0, Rn=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_10_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_11_200_f9a00210() {
    // Thumb encoding (32): 0xF9A00210
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, index_align=1, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_12_200_f9a00270() {
    // Thumb encoding (32): 0xF9A00270
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, index_align=7, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_13_200_f9a002f0() {
    // Thumb encoding (32): 0xF9A002F0
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=15, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_14_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_15_200_f9a00201() {
    // Thumb encoding (32): 0xF9A00201
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_16_200_f9a10201() {
    // Thumb encoding (32): 0xF9A10201
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, D=0, Vd=0, index_align=0, size=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_1_t1a1_a_combo_17_200_f9af020f() {
    // Thumb encoding (32): 0xF9AF020F
    // Test aarch32_VLD3_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=31, Rn=31, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF020F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_0_size_variant_0_512_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_1_size_variant_1_512_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, Rn=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_2_size_variant_2_512_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, Rn=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_1_t1a1_a_special_size_3_size_variant_3_512_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, size=3, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_0_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rm=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_1_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_2_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t1a1_a_invalid_3_200_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_d_0_min_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_d_1_max_600_f9e00200() {
    // Thumb encoding (32): 0xF9E00200
    // Test aarch32_VLD3_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=1, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rn_0_min_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rn_1_poweroftwo_600_f9a10200() {
    // Thumb encoding (32): 0xF9A10200
    // Test aarch32_VLD3_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Vd=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_vd_0_min_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_vd_1_poweroftwo_600_f9a01200() {
    // Thumb encoding (32): 0xF9A01200
    // Test aarch32_VLD3_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, D=0, Rm=0, Rn=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_0_min_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, index_align=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_1_poweroftwo_600_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, Rm=0, size=1, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_2_poweroftwo_600_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_size_3_max_600_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Vd=0, D=0, Rn=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_0_min_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_1_poweroftwo_600_f9a00210() {
    // Thumb encoding (32): 0xF9A00210
    // Test aarch32_VLD3_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, index_align=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_7_poweroftwominusone_600_f9a00270() {
    // Thumb encoding (32): 0xF9A00270
    // Test aarch32_VLD3_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, index_align=7, Vd=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_index_align_15_max_600_f9a002f0() {
    // Thumb encoding (32): 0xF9A002F0
    // Test aarch32_VLD3_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, Rm=0, Rn=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rm_0_min_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t2a2_a_field_rm_1_poweroftwo_600_f9a00201() {
    // Thumb encoding (32): 0xF9A00201
    // Test aarch32_VLD3_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, D=0, Vd=0, Rn=0, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_0_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_1_600_f9e00200() {
    // Thumb encoding (32): 0xF9E00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, D=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_2_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=0, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_3_600_f9a10200() {
    // Thumb encoding (32): 0xF9A10200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, size=0, D=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_4_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_5_600_f9a01200() {
    // Thumb encoding (32): 0xF9A01200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=1, index_align=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_6_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, size=0, Rn=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_7_600_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, size=1, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_8_600_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, Vd=0, size=2, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_9_600_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=3, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_10_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, index_align=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_11_600_f9a00210() {
    // Thumb encoding (32): 0xF9A00210
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, index_align=1, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_12_600_f9a00270() {
    // Thumb encoding (32): 0xF9A00270
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: index_align=7, Rn=0, Vd=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_13_600_f9a002f0() {
    // Thumb encoding (32): 0xF9A002F0
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, index_align=15, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_14_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Vd=0, Rn=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_15_600_f9a00201() {
    // Thumb encoding (32): 0xF9A00201
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, Rn=0, index_align=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_16_600_f9a10201() {
    // Thumb encoding (32): 0xF9A10201
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, size=0, index_align=0, D=0, Rn=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_1_t2a2_a_combo_17_600_f9af020f() {
    // Thumb encoding (32): 0xF9AF020F
    // Test aarch32_VLD3_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Rm=31, Vd=0, Rn=31, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF020F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_0_size_variant_0_1536_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_1_size_variant_1_1536_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, Vd=0, index_align=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_2_size_variant_2_1536_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=2, D=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_1_t2a2_a_special_size_3_size_variant_3_1536_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rm=0, index_align=0, D=0, Vd=0, Rn=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_0_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_1_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Rn=0, D=0, Vd=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_2_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t2a2_a_invalid_3_600_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, size=0, Rn=0, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_d_0_min_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_d_1_max_a00_f9e00200() {
    // Thumb encoding (32): 0xF9E00200
    // Test aarch32_VLD3_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=0, Rn=0, Rm=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rn_0_min_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rn_1_poweroftwo_a00_f9a10200() {
    // Thumb encoding (32): 0xF9A10200
    // Test aarch32_VLD3_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, Rn=1, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_vd_0_min_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, Rm=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_vd_1_poweroftwo_a00_f9a01200() {
    // Thumb encoding (32): 0xF9A01200
    // Test aarch32_VLD3_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Vd=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_0_min_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_1_poweroftwo_a00_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=1, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_2_poweroftwo_a00_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=2, Vd=0, Rm=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_size_3_max_a00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, size=3, Rm=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_0_min_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_1_poweroftwo_a00_f9a00210() {
    // Thumb encoding (32): 0xF9A00210
    // Test aarch32_VLD3_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=1, Rm=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_7_poweroftwominusone_a00_f9a00270() {
    // Thumb encoding (32): 0xF9A00270
    // Test aarch32_VLD3_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, index_align=7, size=0, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_index_align_15_max_a00_f9a002f0() {
    // Thumb encoding (32): 0xF9A002F0
    // Test aarch32_VLD3_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=15, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rm_0_min_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_1_t3a3_a_field_rm_1_poweroftwo_a00_f9a00201() {
    // Thumb encoding (32): 0xF9A00201
    // Test aarch32_VLD3_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=0, D=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_0_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_1_a00_f9e00200() {
    // Thumb encoding (32): 0xF9E00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=1, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_2_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rn=0, Rm=0, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_3_a00_f9a10200() {
    // Thumb encoding (32): 0xF9A10200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rm=0, index_align=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_4_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_5_a00_f9a01200() {
    // Thumb encoding (32): 0xF9A01200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Vd=1, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_6_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_7_a00_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, Rn=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_8_a00_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Vd=0, D=0, size=2, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_9_a00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, size=3, Rn=0, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_10_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_11_a00_f9a00210() {
    // Thumb encoding (32): 0xF9A00210
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, index_align=1, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_12_a00_f9a00270() {
    // Thumb encoding (32): 0xF9A00270
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: index_align=7, size=0, Rm=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_13_a00_f9a002f0() {
    // Thumb encoding (32): 0xF9A002F0
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=15, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_14_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_15_a00_f9a00201() {
    // Thumb encoding (32): 0xF9A00201
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: index_align=0, size=0, D=0, Rm=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_16_a00_f9a10201() {
    // Thumb encoding (32): 0xF9A10201
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, Vd=0, index_align=0, Rm=1, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_1_t3a3_a_combo_17_a00_f9af020f() {
    // Thumb encoding (32): 0xF9AF020F
    // Test aarch32_VLD3_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: index_align=0, Vd=0, Rn=31, size=0, Rm=31, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF020F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_0_size_variant_0_2560_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, index_align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_1_size_variant_1_2560_f9a00600() {
    // Thumb encoding (32): 0xF9A00600
    // Test aarch32_VLD3_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Rm=0, size=1, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_2_size_variant_2_2560_f9a00a00() {
    // Thumb encoding (32): 0xF9A00A00
    // Test aarch32_VLD3_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=2, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_1_t3a3_a_special_size_3_size_variant_3_2560_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, size=3, index_align=0, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_0_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: Rn=0, index_align=0, size=0, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_1_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, index_align=0, Vd=0, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_2_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, D=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_1_t3a3_a_invalid_3_a00_f9a00200() {
    // Thumb encoding (32): 0xF9A00200
    // Test aarch32_VLD3_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, index_align=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD1_a_A Tests
// ============================================================================

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_d_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, T=0, a=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_d_1_max_c00_f4e00c00() {
    // Encoding: 0xF4E00C00
    // Test aarch32_VLD1_a_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, a=0, size=0, Vd=0, D=1, T=0, Rn=0
    let encoding: u32 = 0xF4E00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rn_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, T=0, Rn=0, size=0, a=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rn_1_poweroftwo_c00_f4a10c00() {
    // Encoding: 0xF4A10C00
    // Test aarch32_VLD1_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Vd=0, Rm=0, T=0, D=0, size=0, a=0
    let encoding: u32 = 0xF4A10C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_vd_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: a=0, T=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_vd_1_poweroftwo_c00_f4a01c00() {
    // Encoding: 0xF4A01C00
    // Test aarch32_VLD1_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: a=0, Vd=1, Rn=0, size=0, T=0, D=0, Rm=0
    let encoding: u32 = 0xF4A01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, a=0, T=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_1_poweroftwo_c00_f4a00c40() {
    // Encoding: 0xF4A00C40
    // Test aarch32_VLD1_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: a=0, T=0, Rn=0, D=0, size=1, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_2_poweroftwo_c00_f4a00c80() {
    // Encoding: 0xF4A00C80
    // Test aarch32_VLD1_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: T=0, size=2, Rn=0, Vd=0, a=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_3_max_c00_f4a00cc0() {
    // Encoding: 0xF4A00CC0
    // Test aarch32_VLD1_a_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, T=0, Rm=0, Vd=0, a=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00CC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_t_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field T = 0 (Min)
    // ISET: A32
    // Fields: a=0, D=0, Rm=0, Rn=0, Vd=0, size=0, T=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_t_1_max_c00_f4a00c20() {
    // Encoding: 0xF4A00C20
    // Test aarch32_VLD1_a_T1A1_A field T = 1 (Max)
    // ISET: A32
    // Fields: a=0, D=0, Vd=0, T=1, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_a_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field a = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, a=0, Rm=0, T=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_a_1_max_c00_f4a00c10() {
    // Encoding: 0xF4A00C10
    // Test aarch32_VLD1_a_T1A1_A field a = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, T=0, a=1, Vd=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00C10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rm_0_min_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, a=0, Vd=0, T=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rm_1_poweroftwo_c00_f4a00c01() {
    // Encoding: 0xF4A00C01
    // Test aarch32_VLD1_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, T=0, a=0, size=0, Rm=1
    let encoding: u32 = 0xF4A00C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_0_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, a=0, D=0, T=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_1_c00_f4e00c00() {
    // Encoding: 0xF4E00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=1, T=0, Rm=0, size=0, Vd=0, a=0, Rn=0
    let encoding: u32 = 0xF4E00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_2_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: a=0, Rm=0, Vd=0, D=0, T=0, size=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_3_c00_f4a10c00() {
    // Encoding: 0xF4A10C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: a=0, D=0, Rn=1, size=0, T=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A10C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_4_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, Rn=0, T=0, Rm=0, D=0, a=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_5_c00_f4a01c00() {
    // Encoding: 0xF4A01C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, T=0, size=0, a=0, Vd=1
    let encoding: u32 = 0xF4A01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_6_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: a=0, Rm=0, T=0, Vd=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_7_c00_f4a00c40() {
    // Encoding: 0xF4A00C40
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, T=0, size=1, Vd=0, a=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_8_c00_f4a00c80() {
    // Encoding: 0xF4A00C80
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, a=0, Rn=0, Vd=0, D=0, size=2, T=0
    let encoding: u32 = 0xF4A00C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_9_c00_f4a00cc0() {
    // Encoding: 0xF4A00CC0
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, T=0, Vd=0, a=0, size=3, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00CC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_10_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, a=0, T=0, D=0, size=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_11_c00_f4a00c20() {
    // Encoding: 0xF4A00C20
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, T=1, size=0, a=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_12_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, Vd=0, T=0, a=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_13_c00_f4a00c10() {
    // Encoding: 0xF4A00C10
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, size=0, T=0, Rm=0, a=1
    let encoding: u32 = 0xF4A00C10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_14_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, Vd=0, T=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_15_c00_f4a00c01() {
    // Encoding: 0xF4A00C01
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: T=0, a=0, Vd=0, size=0, Rm=1, D=0, Rn=0
    let encoding: u32 = 0xF4A00C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_16_c00_f4a10c01() {
    // Encoding: 0xF4A10C01
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: size=0, Rn=1, a=0, T=0, Rm=1, Vd=0, D=0
    let encoding: u32 = 0xF4A10C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_17_c00_f4af0c0f() {
    // Encoding: 0xF4AF0C0F
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: A32
    // Fields: size=0, a=0, T=0, Rm=31, Rn=31, D=0, Vd=0
    let encoding: u32 = 0xF4AF0C0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_0_size_variant_0_3072_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, a=0, size=0, T=0, Vd=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_1_size_variant_1_3072_f4a00c40() {
    // Encoding: 0xF4A00C40
    // Test aarch32_VLD1_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: a=0, Rm=0, Rn=0, size=1, T=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_2_size_variant_2_3072_f4a00c80() {
    // Encoding: 0xF4A00C80
    // Test aarch32_VLD1_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Vd=0, T=0, a=0, Rn=0, D=0, size=2
    let encoding: u32 = 0xF4A00C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_3_size_variant_3_3072_f4a00cc0() {
    // Encoding: 0xF4A00CC0
    // Test aarch32_VLD1_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, Vd=0, T=0, Rn=0, a=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00CC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_0_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: Rn=0, a=0, D=0, Vd=0, Rm=0, size=0, T=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_1_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, T=0, a=0, size=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_2_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: Rm=0, D=0, T=0, a=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_3_c00_f4a00c00() {
    // Encoding: 0xF4A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: T=0, Rm=0, D=0, size=0, a=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_d_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_d_1_max_c00_f9e00c00() {
    // Thumb encoding (32): 0xF9E00C00
    // Test aarch32_VLD1_a_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: a=0, Rm=0, Rn=0, size=0, T=0, D=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rn_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, a=0, T=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rn_1_poweroftwo_c00_f9a10c00() {
    // Thumb encoding (32): 0xF9A10C00
    // Test aarch32_VLD1_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rn=1, T=0, D=0, Vd=0, Rm=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_vd_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, T=0, D=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_vd_1_poweroftwo_c00_f9a01c00() {
    // Thumb encoding (32): 0xF9A01C00
    // Test aarch32_VLD1_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=0, T=0, a=0, Rm=0, Vd=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_1_poweroftwo_c00_f9a00c40() {
    // Thumb encoding (32): 0xF9A00C40
    // Test aarch32_VLD1_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, D=0, T=0, Vd=0, a=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_2_poweroftwo_c00_f9a00c80() {
    // Thumb encoding (32): 0xF9A00C80
    // Test aarch32_VLD1_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=2, T=0, a=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_size_3_max_c00_f9a00cc0() {
    // Thumb encoding (32): 0xF9A00CC0
    // Test aarch32_VLD1_a_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, D=0, size=3, Vd=0, a=0, Rn=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00CC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_t_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field T = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, D=0, Rn=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_t_1_max_c00_f9a00c20() {
    // Thumb encoding (32): 0xF9A00C20
    // Test aarch32_VLD1_a_T1A1_A field T = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vd=0, Rn=0, D=0, T=1, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_a_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field a = 0 (Min)
    // ISET: T32
    // Fields: size=0, a=0, T=0, D=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_a_1_max_c00_f9a00c10() {
    // Thumb encoding (32): 0xF9A00C10
    // Test aarch32_VLD1_a_T1A1_A field a = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, T=0, D=0, size=0, a=1, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rm_0_min_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: T=0, a=0, Rm=0, Rn=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld1_a_t1a1_a_field_rm_1_poweroftwo_c00_f9a00c01() {
    // Thumb encoding (32): 0xF9A00C01
    // Test aarch32_VLD1_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, T=0, a=0, D=0, Rn=0, Rm=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_0_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, T=0, size=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_1_c00_f9e00c00() {
    // Thumb encoding (32): 0xF9E00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=1, Vd=0, size=0, T=0, a=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_2_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, a=0, Rm=0, D=0, T=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_3_c00_f9a10c00() {
    // Thumb encoding (32): 0xF9A10C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, D=0, size=0, a=0, Rm=0, Vd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_4_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, T=0, a=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_5_c00_f9a01c00() {
    // Thumb encoding (32): 0xF9A01C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=1, size=0, T=0, a=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_6_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, a=0, Rm=0, T=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_7_c00_f9a00c40() {
    // Thumb encoding (32): 0xF9A00C40
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, Rm=0, Vd=0, Rn=0, a=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_8_c00_f9a00c80() {
    // Thumb encoding (32): 0xF9A00C80
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, T=0, Rm=0, D=0, Rn=0, size=2, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_9_c00_f9a00cc0() {
    // Thumb encoding (32): 0xF9A00CC0
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, Rn=0, D=0, size=3, T=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00CC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_10_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, size=0, D=0, Vd=0, Rn=0, Rm=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_11_c00_f9a00c20() {
    // Thumb encoding (32): 0xF9A00C20
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, size=0, T=1, Vd=0, D=0, Rn=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_12_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, Rm=0, D=0, size=0, T=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_13_c00_f9a00c10() {
    // Thumb encoding (32): 0xF9A00C10
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: T32
    // Fields: T=0, a=1, Vd=0, size=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_14_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, a=0, Rm=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_15_c00_f9a00c01() {
    // Thumb encoding (32): 0xF9A00C01
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: size=0, a=0, Rm=1, D=0, T=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_16_c00_f9a10c01() {
    // Thumb encoding (32): 0xF9A10C01
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: a=0, Rm=1, Rn=1, D=0, Vd=0, T=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld1_a_t1a1_a_combo_17_c00_f9af0c0f() {
    // Thumb encoding (32): 0xF9AF0C0F
    // Test aarch32_VLD1_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: T32
    // Fields: a=0, D=0, size=0, Rm=31, Rn=31, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF0C0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_0_size_variant_0_3072_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, Vd=0, a=0, Rm=0, D=0, T=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_1_size_variant_1_3072_f9a00c40() {
    // Thumb encoding (32): 0xF9A00C40
    // Test aarch32_VLD1_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, size=1, D=0, Rn=0, a=0, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_2_size_variant_2_3072_f9a00c80() {
    // Thumb encoding (32): 0xF9A00C80
    // Test aarch32_VLD1_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, a=0, Rn=0, size=2, Vd=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld1_a_t1a1_a_special_size_3_size_variant_3_3072_f9a00cc0() {
    // Thumb encoding (32): 0xF9A00CC0
    // Test aarch32_VLD1_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: a=0, Vd=0, size=3, Rn=0, D=0, Rm=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00CC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_0_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: size=0, a=0, D=0, Rn=0, Rm=0, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_1_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: T=0, a=0, size=0, Rm=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_2_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, T=0, Rm=0, Vd=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD1_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld1_a_t1a1_a_invalid_3_c00_f9a00c00() {
    // Thumb encoding (32): 0xF9A00C00
    // Test aarch32_VLD1_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, a=0, Rm=0, Rn=0, Vd=0, D=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD3_a_A Tests
// ============================================================================

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_d_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, T=0, size=0, a=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_d_1_max_e00_f4e00e00() {
    // Encoding: 0xF4E00E00
    // Test aarch32_VLD3_a_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    let encoding: u32 = 0xF4E00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rn_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: T=0, a=0, Vd=0, size=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rn_1_poweroftwo_e00_f4a10e00() {
    // Encoding: 0xF4A10E00
    // Test aarch32_VLD3_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, T=0, a=0, Rm=0, Rn=1, size=0
    let encoding: u32 = 0xF4A10E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_vd_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, Vd=0, a=0, Rm=0, T=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_vd_1_poweroftwo_e00_f4a01e00() {
    // Encoding: 0xF4A01E00
    // Test aarch32_VLD3_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: T=0, size=0, a=0, D=0, Rn=0, Vd=1, Rm=0
    let encoding: u32 = 0xF4A01E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, T=0, D=0, Rn=0, size=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_1_poweroftwo_e00_f4a00e40() {
    // Encoding: 0xF4A00E40
    // Test aarch32_VLD3_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=1, a=0, T=0, Rm=0
    let encoding: u32 = 0xF4A00E40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_2_poweroftwo_e00_f4a00e80() {
    // Encoding: 0xF4A00E80
    // Test aarch32_VLD3_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=2, T=0, Rm=0, a=0
    let encoding: u32 = 0xF4A00E80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_3_max_e00_f4a00ec0() {
    // Encoding: 0xF4A00EC0
    // Test aarch32_VLD3_a_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: T=0, D=0, Vd=0, a=0, Rm=0, Rn=0, size=3
    let encoding: u32 = 0xF4A00EC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_t_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field T = 0 (Min)
    // ISET: A32
    // Fields: T=0, a=0, Rm=0, size=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_t_1_max_e00_f4a00e20() {
    // Encoding: 0xF4A00E20
    // Test aarch32_VLD3_a_T1A1_A field T = 1 (Max)
    // ISET: A32
    // Fields: a=0, Rm=0, size=0, T=1, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00E20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_a_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field a = 0 (Min)
    // ISET: A32
    // Fields: size=0, T=0, Rn=0, a=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_a_1_max_e00_f4a00e10() {
    // Encoding: 0xF4A00E10
    // Test aarch32_VLD3_a_T1A1_A field a = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, a=1, T=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00E10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rm_0_min_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, Rn=0, size=0, T=0, a=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rm_1_poweroftwo_e00_f4a00e01() {
    // Encoding: 0xF4A00E01
    // Test aarch32_VLD3_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, T=0, a=0, Rm=1, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00E01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_0_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, D=0, T=0, a=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_1_e00_f4e00e00() {
    // Encoding: 0xF4E00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, a=0, Rm=0, T=0, D=1, Rn=0, Vd=0
    let encoding: u32 = 0xF4E00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_2_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, D=0, Rn=0, T=0, a=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_3_e00_f4a10e00() {
    // Encoding: 0xF4A10E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=1, T=0, D=0, a=0, size=0, Vd=0
    let encoding: u32 = 0xF4A10E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_4_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rn=0, T=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_5_e00_f4a01e00() {
    // Encoding: 0xF4A01E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, a=0, D=0, Rn=0, Rm=0, T=0, Vd=1
    let encoding: u32 = 0xF4A01E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_6_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, T=0, Rn=0, D=0, size=0, a=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_7_e00_f4a00e40() {
    // Encoding: 0xF4A00E40
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, T=0, Rn=0, a=0, size=1, Rm=0, D=0
    let encoding: u32 = 0xF4A00E40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_8_e00_f4a00e80() {
    // Encoding: 0xF4A00E80
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=2, T=0, a=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00E80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_9_e00_f4a00ec0() {
    // Encoding: 0xF4A00EC0
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, size=3, Rn=0, T=0, a=0
    let encoding: u32 = 0xF4A00EC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_10_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, T=0, Rn=0, a=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_11_e00_f4a00e20() {
    // Encoding: 0xF4A00E20
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, T=1, a=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00E20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_12_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: T=0, Rn=0, Vd=0, a=0, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_13_e00_f4a00e10() {
    // Encoding: 0xF4A00E10
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: A32
    // Fields: size=0, a=1, Rm=0, Rn=0, D=0, Vd=0, T=0
    let encoding: u32 = 0xF4A00E10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_14_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rm=0, Rn=0, T=0, D=0, size=0, a=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_15_e00_f4a00e01() {
    // Encoding: 0xF4A00E01
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: D=0, T=0, Rn=0, size=0, Rm=1, a=0, Vd=0
    let encoding: u32 = 0xF4A00E01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_16_e00_f4a10e01() {
    // Encoding: 0xF4A10E01
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: Rn=1, Rm=1, size=0, D=0, Vd=0, T=0, a=0
    let encoding: u32 = 0xF4A10E01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_17_e00_f4af0e0f() {
    // Encoding: 0xF4AF0E0F
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: A32
    // Fields: Rm=31, Rn=31, T=0, D=0, Vd=0, size=0, a=0
    let encoding: u32 = 0xF4AF0E0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_0_size_variant_0_3584_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, T=0, Rn=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_1_size_variant_1_3584_f4a00e40() {
    // Encoding: 0xF4A00E40
    // Test aarch32_VLD3_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, D=0, a=0, Vd=0, T=0, Rm=0, size=1
    let encoding: u32 = 0xF4A00E40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_2_size_variant_2_3584_f4a00e80() {
    // Encoding: 0xF4A00E80
    // Test aarch32_VLD3_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, size=2, a=0, T=0
    let encoding: u32 = 0xF4A00E80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_3_size_variant_3_3584_f4a00ec0() {
    // Encoding: 0xF4A00EC0
    // Test aarch32_VLD3_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=3, T=0, a=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00EC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_0_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, T=0, size=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_1_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: a=0, Rn=0, D=0, Vd=0, size=0, T=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_2_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Vd=0, T=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_3_e00_f4a00e00() {
    // Encoding: 0xF4A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: size=0, Rm=0, Rn=0, a=0, D=0, T=0, Vd=0
    let encoding: u32 = 0xF4A00E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_d_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: T=0, a=0, Rm=0, Rn=0, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_d_1_max_e00_f9e00e00() {
    // Thumb encoding (32): 0xF9E00E00
    // Test aarch32_VLD3_a_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, D=1, Rn=0, T=0, Rm=0, Vd=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rn_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, a=0, size=0, D=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rn_1_poweroftwo_e00_f9a10e00() {
    // Thumb encoding (32): 0xF9A10E00
    // Test aarch32_VLD3_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Vd=0, T=0, Rm=0, size=0, D=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_vd_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, a=0, Rm=0, size=0, T=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_vd_1_poweroftwo_e00_f9a01e00() {
    // Thumb encoding (32): 0xF9A01E00
    // Test aarch32_VLD3_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=1, T=0, a=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_1_poweroftwo_e00_f9a00e40() {
    // Thumb encoding (32): 0xF9A00E40
    // Test aarch32_VLD3_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, Rn=0, D=0, Vd=0, T=0, Rm=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_2_poweroftwo_e00_f9a00e80() {
    // Thumb encoding (32): 0xF9A00E80
    // Test aarch32_VLD3_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, size=2, T=0, D=0, Rn=0, Vd=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_size_3_max_e00_f9a00ec0() {
    // Thumb encoding (32): 0xF9A00EC0
    // Test aarch32_VLD3_a_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, size=3, a=0, Rm=0, D=0, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00EC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_t_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field T = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, D=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_t_1_max_e00_f9a00e20() {
    // Thumb encoding (32): 0xF9A00E20
    // Test aarch32_VLD3_a_T1A1_A field T = 1 (Max)
    // ISET: T32
    // Fields: size=0, a=0, T=1, D=0, Vd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_a_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field a = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, T=0, a=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_a_1_max_e00_f9a00e10() {
    // Thumb encoding (32): 0xF9A00E10
    // Test aarch32_VLD3_a_T1A1_A field a = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, a=1, T=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rm_0_min_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, D=0, Vd=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld3_a_t1a1_a_field_rm_1_poweroftwo_e00_f9a00e01() {
    // Thumb encoding (32): 0xF9A00E01
    // Test aarch32_VLD3_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: T=0, a=0, Rn=0, Rm=1, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_0_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, T=0, a=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_1_e00_f9e00e00() {
    // Thumb encoding (32): 0xF9E00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: size=0, T=0, Rm=0, D=1, Vd=0, a=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_2_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, Rm=0, Vd=0, D=0, Rn=0, size=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_3_e00_f9a10e00() {
    // Thumb encoding (32): 0xF9A10E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, T=0, Vd=0, Rn=1, size=0, D=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_4_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, size=0, T=0, a=0, Vd=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_5_e00_f9a01e00() {
    // Thumb encoding (32): 0xF9A01E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=1, Rm=0, size=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_6_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, a=0, Rm=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_7_e00_f9a00e40() {
    // Thumb encoding (32): 0xF9A00E40
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: size=1, Rm=0, D=0, T=0, a=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_8_e00_f9a00e80() {
    // Thumb encoding (32): 0xF9A00E80
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=2, T=0, a=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_9_e00_f9a00ec0() {
    // Thumb encoding (32): 0xF9A00EC0
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: size=3, Vd=0, Rn=0, T=0, Rm=0, D=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00EC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_10_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, Rn=0, a=0, Rm=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_11_e00_f9a00e20() {
    // Thumb encoding (32): 0xF9A00E20
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, T=1, Rn=0, Vd=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_12_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, a=0, Rn=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_13_e00_f9a00e10() {
    // Thumb encoding (32): 0xF9A00E10
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, a=1, size=0, Rn=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_14_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, Rn=0, a=0, size=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_15_e00_f9a00e01() {
    // Thumb encoding (32): 0xF9A00E01
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rm=1, T=0, Rn=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_16_e00_f9a10e01() {
    // Thumb encoding (32): 0xF9A10E01
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, Vd=0, size=0, D=0, a=0, Rm=1, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld3_a_t1a1_a_combo_17_e00_f9af0e0f() {
    // Thumb encoding (32): 0xF9AF0E0F
    // Test aarch32_VLD3_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: T32
    // Fields: a=0, D=0, Vd=0, T=0, size=0, Rm=31, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF0E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_0_size_variant_0_3584_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, a=0, Rm=0, T=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_1_size_variant_1_3584_f9a00e40() {
    // Thumb encoding (32): 0xF9A00E40
    // Test aarch32_VLD3_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=1, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_2_size_variant_2_3584_f9a00e80() {
    // Thumb encoding (32): 0xF9A00E80
    // Test aarch32_VLD3_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rm=0, size=2, Rn=0, Vd=0, T=0, D=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld3_a_t1a1_a_special_size_3_size_variant_3_3584_f9a00ec0() {
    // Thumb encoding (32): 0xF9A00EC0
    // Test aarch32_VLD3_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, size=3, T=0, D=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00EC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_0_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, T=0, Rn=0, size=0, Rm=0, Vd=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_1_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, T=0, a=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_2_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, T=0, size=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD3_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld3_a_t1a1_a_invalid_3_e00_f9a00e00() {
    // Thumb encoding (32): 0xF9A00E00
    // Test aarch32_VLD3_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: T=0, D=0, Rn=0, size=0, a=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD4_a_A Tests
// ============================================================================

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_d_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: a=0, Rm=0, Vd=0, T=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_d_1_max_f00_f4e00f00() {
    // Encoding: 0xF4E00F00
    // Test aarch32_VLD4_a_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, a=0, Rm=0, T=0, Rn=0, size=0, D=1
    let encoding: u32 = 0xF4E00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rn_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, T=0, Vd=0, a=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rn_1_poweroftwo_f00_f4a10f00() {
    // Encoding: 0xF4A10F00
    // Test aarch32_VLD4_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, T=0, a=0, Rm=0, Rn=1
    let encoding: u32 = 0xF4A10F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_vd_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, D=0, Rn=0, T=0, a=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_vd_1_poweroftwo_f00_f4a01f00() {
    // Encoding: 0xF4A01F00
    // Test aarch32_VLD4_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, size=0, Rn=0, a=0, Vd=1, T=0
    let encoding: u32 = 0xF4A01F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, T=0, a=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_1_poweroftwo_f00_f4a00f40() {
    // Encoding: 0xF4A00F40
    // Test aarch32_VLD4_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: T=0, Vd=0, size=1, D=0, Rn=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00F40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_2_poweroftwo_f00_f4a00f80() {
    // Encoding: 0xF4A00F80
    // Test aarch32_VLD4_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, a=0, Rm=0, size=2, T=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_3_max_f00_f4a00fc0() {
    // Encoding: 0xF4A00FC0
    // Test aarch32_VLD4_a_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: T=0, Rn=0, size=3, a=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_t_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field T = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, a=0, T=0, size=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_t_1_max_f00_f4a00f20() {
    // Encoding: 0xF4A00F20
    // Test aarch32_VLD4_a_T1A1_A field T = 1 (Max)
    // ISET: A32
    // Fields: D=0, T=1, a=0, size=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00F20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_a_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field a = 0 (Min)
    // ISET: A32
    // Fields: T=0, D=0, Rn=0, Vd=0, a=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_a_1_max_f00_f4a00f10() {
    // Encoding: 0xF4A00F10
    // Test aarch32_VLD4_a_T1A1_A field a = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, T=0, Rm=0, size=0, a=1, Rn=0
    let encoding: u32 = 0xF4A00F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rm_0_min_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, T=0, Vd=0, D=0, size=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rm_1_poweroftwo_f00_f4a00f01() {
    // Encoding: 0xF4A00F01
    // Test aarch32_VLD4_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, a=0, D=0, T=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00F01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_0_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: T=0, a=0, Rm=0, D=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_1_f00_f4e00f00() {
    // Encoding: 0xF4E00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, T=0, a=0, Rm=0, D=1, Rn=0, size=0
    let encoding: u32 = 0xF4E00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_2_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, Rn=0, D=0, T=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_3_f00_f4a10f00() {
    // Encoding: 0xF4A10F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, T=0, Rm=0, Vd=0, a=0, Rn=1
    let encoding: u32 = 0xF4A10F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_4_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: T=0, size=0, D=0, a=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_5_f00_f4a01f00() {
    // Encoding: 0xF4A01F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=1, T=0, Rm=0, D=0, Rn=0, size=0, a=0
    let encoding: u32 = 0xF4A01F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_6_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, T=0, Vd=0, a=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_7_f00_f4a00f40() {
    // Encoding: 0xF4A00F40
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: a=0, Rm=0, D=0, Vd=0, Rn=0, T=0, size=1
    let encoding: u32 = 0xF4A00F40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_8_f00_f4a00f80() {
    // Encoding: 0xF4A00F80
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, a=0, Rm=0, Vd=0, size=2, T=0, D=0
    let encoding: u32 = 0xF4A00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_9_f00_f4a00fc0() {
    // Encoding: 0xF4A00FC0
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rm=0, size=3, D=0, Rn=0, T=0, a=0
    let encoding: u32 = 0xF4A00FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_10_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, T=0, Rn=0, D=0, size=0, Vd=0, a=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_11_f00_f4a00f20() {
    // Encoding: 0xF4A00F20
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, a=0, Rn=0, D=0, size=0, T=1
    let encoding: u32 = 0xF4A00F20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_12_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=0, T=0, a=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_13_f00_f4a00f10() {
    // Encoding: 0xF4A00F10
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: A32
    // Fields: T=0, a=1, Rm=0, Vd=0, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4A00F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_14_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, T=0, a=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_15_f00_f4a00f01() {
    // Encoding: 0xF4A00F01
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, Rm=1, D=0, size=0, T=0, Rn=0, a=0
    let encoding: u32 = 0xF4A00F01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_16_f00_f4a10f01() {
    // Encoding: 0xF4A10F01
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, D=0, Rn=1, size=0, T=0, a=0, Vd=0
    let encoding: u32 = 0xF4A10F01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_17_f00_f4af0f0f() {
    // Encoding: 0xF4AF0F0F
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: A32
    // Fields: D=0, a=0, Rn=31, T=0, Vd=0, size=0, Rm=31
    let encoding: u32 = 0xF4AF0F0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_0_size_variant_0_3840_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Rn=0, T=0, size=0, a=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_1_size_variant_1_3840_f4a00f40() {
    // Encoding: 0xF4A00F40
    // Test aarch32_VLD4_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=1, D=0, T=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00F40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_2_size_variant_2_3840_f4a00f80() {
    // Encoding: 0xF4A00F80
    // Test aarch32_VLD4_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=2, Vd=0, D=0, a=0, T=0
    let encoding: u32 = 0xF4A00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_3_size_variant_3_3840_f4a00fc0() {
    // Encoding: 0xF4A00FC0
    // Test aarch32_VLD4_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, size=3, a=0, Rm=0, Vd=0, Rn=0, T=0
    let encoding: u32 = 0xF4A00FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_0_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Vd=0, T=0, a=0, D=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_1_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, T=0, Rm=0, Vd=0, D=0, size=0, a=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_2_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Vd=0, T=0, Rm=0, a=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_3_f00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, T=0, size=0, a=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_d_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, a=0, D=0, T=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_d_1_max_f00_f9e00f00() {
    // Thumb encoding (32): 0xF9E00F00
    // Test aarch32_VLD4_a_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, D=1, Vd=0, size=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rn_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: a=0, Rn=0, D=0, size=0, Vd=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rn_1_poweroftwo_f00_f9a10f00() {
    // Thumb encoding (32): 0xF9A10F00
    // Test aarch32_VLD4_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, D=0, Vd=0, T=0, size=0, Rm=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_vd_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, T=0, Vd=0, Rn=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_vd_1_poweroftwo_f00_f9a01f00() {
    // Thumb encoding (32): 0xF9A01F00
    // Test aarch32_VLD4_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, a=0, Rm=0, Rn=0, Vd=0, T=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_1_poweroftwo_f00_f9a00f40() {
    // Thumb encoding (32): 0xF9A00F40
    // Test aarch32_VLD4_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, a=0, D=0, size=1, T=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_2_poweroftwo_f00_f9a00f80() {
    // Thumb encoding (32): 0xF9A00F80
    // Test aarch32_VLD4_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rm=0, size=2, Vd=0, Rn=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_size_3_max_f00_f9a00fc0() {
    // Thumb encoding (32): 0xF9A00FC0
    // Test aarch32_VLD4_a_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, size=3, Rn=0, a=0, T=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00FC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_t_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field T = 0 (Min)
    // ISET: T32
    // Fields: T=0, D=0, a=0, Vd=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_t_1_max_f00_f9a00f20() {
    // Thumb encoding (32): 0xF9A00F20
    // Test aarch32_VLD4_a_T1A1_A field T = 1 (Max)
    // ISET: T32
    // Fields: a=0, Vd=0, Rn=0, size=0, Rm=0, D=0, T=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_a_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field a = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, D=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_a_1_max_f00_f9a00f10() {
    // Thumb encoding (32): 0xF9A00F10
    // Test aarch32_VLD4_a_T1A1_A field a = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, a=1, Rm=0, size=0, D=0, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rm_0_min_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rn=0, a=0, Rm=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_a_t1a1_a_field_rm_1_poweroftwo_f00_f9a00f01() {
    // Thumb encoding (32): 0xF9A00F01
    // Test aarch32_VLD4_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Vd=0, T=0, size=0, a=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_0_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_1_f00_f9e00f00() {
    // Thumb encoding (32): 0xF9E00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=1, Rn=0, Vd=0, size=0, a=0, Rm=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_2_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, T=0, Vd=0, size=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_3_f00_f9a10f00() {
    // Thumb encoding (32): 0xF9A10F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rm=0, Rn=1, Vd=0, D=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_4_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: size=0, T=0, Rm=0, a=0, Vd=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_5_f00_f9a01f00() {
    // Thumb encoding (32): 0xF9A01F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, T=0, Rm=0, a=0, Vd=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_6_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, a=0, Rm=0, size=0, Rn=0, D=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_7_f00_f9a00f40() {
    // Thumb encoding (32): 0xF9A00F40
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=1, D=0, Rn=0, Rm=0, a=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_8_f00_f9a00f80() {
    // Thumb encoding (32): 0xF9A00F80
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, T=0, a=0, Rm=0, size=2, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_9_f00_f9a00fc0() {
    // Thumb encoding (32): 0xF9A00FC0
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, Rm=0, size=3, Vd=0, T=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00FC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_10_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, Rm=0, T=0, D=0, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_11_f00_f9a00f20() {
    // Thumb encoding (32): 0xF9A00F20
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: T32
    // Fields: a=0, Rn=0, Rm=0, D=0, T=1, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_12_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=0, a=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_13_f00_f9a00f10() {
    // Thumb encoding (32): 0xF9A00F10
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_14_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, a=0, D=0, T=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_15_f00_f9a00f01() {
    // Thumb encoding (32): 0xF9A00F01
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: Rn=0, size=0, a=0, Rm=1, T=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_16_f00_f9a10f01() {
    // Thumb encoding (32): 0xF9A10F01
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: size=0, a=0, Vd=0, Rm=1, T=0, D=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10F01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_a_t1a1_a_combo_17_f00_f9af0f0f() {
    // Thumb encoding (32): 0xF9AF0F0F
    // Test aarch32_VLD4_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, D=0, size=0, Vd=0, a=0, T=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF0F0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_0_size_variant_0_3840_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, T=0, Rn=0, a=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_1_size_variant_1_3840_f9a00f40() {
    // Thumb encoding (32): 0xF9A00F40
    // Test aarch32_VLD4_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, T=0, a=0, size=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_2_size_variant_2_3840_f9a00f80() {
    // Thumb encoding (32): 0xF9A00F80
    // Test aarch32_VLD4_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, T=0, a=0, Vd=0, Rm=0, size=2, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_a_t1a1_a_special_size_3_size_variant_3_3840_f9a00fc0() {
    // Thumb encoding (32): 0xF9A00FC0
    // Test aarch32_VLD4_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, size=3, T=0, a=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00FC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_0_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rm=0, T=0, a=0, D=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_1_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: a=0, Rn=0, Rm=0, T=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_2_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: T=0, a=0, Rm=0, D=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_a_t1a1_a_invalid_3_f00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, T=0, Rn=0, a=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD2_1_A Tests
// ============================================================================

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_d_0_min_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rm=0, D=0, index_align=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_d_1_max_100_f4e00100() {
    // Encoding: 0xF4E00100
    // Test aarch32_VLD2_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=1, size=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rn_0_min_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, index_align=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rn_1_poweroftwo_100_f4a10100() {
    // Encoding: 0xF4A10100
    // Test aarch32_VLD2_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rm=0, size=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A10100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_vd_0_min_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_vd_1_poweroftwo_100_f4a01100() {
    // Encoding: 0xF4A01100
    // Test aarch32_VLD2_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, Rm=0, size=0, D=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4A01100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_0_min_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Vd=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_1_poweroftwo_100_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=1, Rm=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_2_poweroftwo_100_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, index_align=0, size=2, Rm=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_3_max_100_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, size=3, Rm=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_0_min_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_1_poweroftwo_100_f4a00110() {
    // Encoding: 0xF4A00110
    // Test aarch32_VLD2_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, Rn=0, Vd=0, index_align=1
    let encoding: u32 = 0xF4A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_7_poweroftwominusone_100_f4a00170() {
    // Encoding: 0xF4A00170
    // Test aarch32_VLD2_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, index_align=7, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_15_max_100_f4a001f0() {
    // Encoding: 0xF4A001F0
    // Test aarch32_VLD2_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: size=0, index_align=15, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4A001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rm_0_min_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, Vd=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rm_1_poweroftwo_100_f4a00101() {
    // Encoding: 0xF4A00101
    // Test aarch32_VLD2_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, Vd=0, size=0, Rm=1
    let encoding: u32 = 0xF4A00101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_0_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_1_100_f4e00100() {
    // Encoding: 0xF4E00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, size=0, D=1, index_align=0
    let encoding: u32 = 0xF4E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_2_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_3_100_f4a10100() {
    // Encoding: 0xF4A10100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Rn=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4A10100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_4_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_5_100_f4a01100() {
    // Encoding: 0xF4A01100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, D=0, Rn=0, Vd=1
    let encoding: u32 = 0xF4A01100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_6_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_7_100_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=1, Vd=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_8_100_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=2, index_align=0, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_9_100_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=3, Vd=0, Rn=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_10_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, Rm=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_11_100_f4a00110() {
    // Encoding: 0xF4A00110
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Rm=0, index_align=1, Vd=0
    let encoding: u32 = 0xF4A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_12_100_f4a00170() {
    // Encoding: 0xF4A00170
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=7, Vd=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_13_100_f4a001f0() {
    // Encoding: 0xF4A001F0
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: index_align=15, Rm=0, D=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4A001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_14_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_15_100_f4a00101() {
    // Encoding: 0xF4A00101
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4A00101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_16_100_f4a10101() {
    // Encoding: 0xF4A10101
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, index_align=0, Rn=1, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4A10101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_17_100_f4af010f() {
    // Encoding: 0xF4AF010F
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, Rm=31, D=0, Rn=31
    let encoding: u32 = 0xF4AF010F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_0_size_variant_0_256_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, D=0, index_align=0, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_1_size_variant_1_256_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, size=1, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_2_size_variant_2_256_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, size=2, D=0, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_3_size_variant_3_256_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Vd=0, size=3, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t1a1_a_invalid_0_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: size=0, index_align=0, Rn=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t1a1_a_invalid_1_100_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_d_0_min_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, size=0, Rn=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_d_1_max_500_f4e00100() {
    // Encoding: 0xF4E00100
    // Test aarch32_VLD2_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=1, size=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rn_0_min_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, Rm=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rn_1_poweroftwo_500_f4a10100() {
    // Encoding: 0xF4A10100
    // Test aarch32_VLD2_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, D=0, size=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A10100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_vd_0_min_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_vd_1_poweroftwo_500_f4a01100() {
    // Encoding: 0xF4A01100
    // Test aarch32_VLD2_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rn=0, Rm=0, size=0, Vd=1, D=0
    let encoding: u32 = 0xF4A01100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_0_min_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_1_poweroftwo_500_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, index_align=0, Vd=0, Rm=0, D=0, size=1
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_2_poweroftwo_500_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rn=0, D=0, size=2, Rm=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_3_max_500_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=3, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_0_min_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_1_poweroftwo_500_f4a00110() {
    // Encoding: 0xF4A00110
    // Test aarch32_VLD2_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, size=0, index_align=1
    let encoding: u32 = 0xF4A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_7_poweroftwominusone_500_f4a00170() {
    // Encoding: 0xF4A00170
    // Test aarch32_VLD2_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, Vd=0, Rm=0, index_align=7
    let encoding: u32 = 0xF4A00170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_15_max_500_f4a001f0() {
    // Encoding: 0xF4A001F0
    // Test aarch32_VLD2_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rm=0, Rn=0, index_align=15
    let encoding: u32 = 0xF4A001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rm_0_min_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, index_align=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rm_1_poweroftwo_500_f4a00101() {
    // Encoding: 0xF4A00101
    // Test aarch32_VLD2_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, index_align=0, Rm=1, Vd=0
    let encoding: u32 = 0xF4A00101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_0_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_1_500_f4e00100() {
    // Encoding: 0xF4E00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, D=1, index_align=0, Rm=0
    let encoding: u32 = 0xF4E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_2_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, index_align=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_3_500_f4a10100() {
    // Encoding: 0xF4A10100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, Rn=1, Vd=0, D=0
    let encoding: u32 = 0xF4A10100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_4_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, index_align=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_5_500_f4a01100() {
    // Encoding: 0xF4A01100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, Vd=1, size=0
    let encoding: u32 = 0xF4A01100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_6_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_7_500_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, size=1, Rm=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_8_500_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=2, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_9_500_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, size=3, D=0, Vd=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_10_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_11_500_f4a00110() {
    // Encoding: 0xF4A00110
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=1, Rm=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_12_500_f4a00170() {
    // Encoding: 0xF4A00170
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, size=0, index_align=7, Vd=0, D=0
    let encoding: u32 = 0xF4A00170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_13_500_f4a001f0() {
    // Encoding: 0xF4A001F0
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: index_align=15, Rn=0, Vd=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4A001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_14_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, D=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_15_500_f4a00101() {
    // Encoding: 0xF4A00101
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4A00101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_16_500_f4a10101() {
    // Encoding: 0xF4A10101
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: index_align=0, Rm=1, Rn=1, Vd=0, size=0, D=0
    let encoding: u32 = 0xF4A10101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_17_500_f4af010f() {
    // Encoding: 0xF4AF010F
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Rn=31, size=0, D=0, Vd=0, index_align=0, Rm=31
    let encoding: u32 = 0xF4AF010F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_0_size_variant_0_1280_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, index_align=0, Rn=0, Rm=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_1_size_variant_1_1280_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, Rm=0, index_align=0, size=1
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_2_size_variant_2_1280_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, index_align=0, size=2, D=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_3_size_variant_3_1280_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, index_align=0, Vd=0, size=3, Rn=0, D=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t2a2_a_invalid_0_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t2a2_a_invalid_1_500_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_d_0_min_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, index_align=0, D=0, Rn=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_d_1_max_900_f4e00100() {
    // Encoding: 0xF4E00100
    // Test aarch32_VLD2_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, D=1, size=0, index_align=0
    let encoding: u32 = 0xF4E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rn_0_min_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rn_1_poweroftwo_900_f4a10100() {
    // Encoding: 0xF4A10100
    // Test aarch32_VLD2_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Vd=0, D=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A10100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_vd_0_min_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, size=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_vd_1_poweroftwo_900_f4a01100() {
    // Encoding: 0xF4A01100
    // Test aarch32_VLD2_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Vd=1, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A01100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_0_min_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_1_poweroftwo_900_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=1, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_2_poweroftwo_900_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, Rm=0, D=0, size=2
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_3_max_900_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, index_align=0, D=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_0_min_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, Rn=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_1_poweroftwo_900_f4a00110() {
    // Encoding: 0xF4A00110
    // Test aarch32_VLD2_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, size=0, index_align=1, Vd=0
    let encoding: u32 = 0xF4A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_7_poweroftwominusone_900_f4a00170() {
    // Encoding: 0xF4A00170
    // Test aarch32_VLD2_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, index_align=7, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_15_max_900_f4a001f0() {
    // Encoding: 0xF4A001F0
    // Test aarch32_VLD2_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, size=0, Rn=0, index_align=15
    let encoding: u32 = 0xF4A001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rm_0_min_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, size=0, Rn=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rm_1_poweroftwo_900_f4a00101() {
    // Encoding: 0xF4A00101
    // Test aarch32_VLD2_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=1, Vd=0, index_align=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_0_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_1_900_f4e00100() {
    // Encoding: 0xF4E00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, index_align=0, Rm=0, D=1
    let encoding: u32 = 0xF4E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_2_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, index_align=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_3_900_f4a10100() {
    // Encoding: 0xF4A10100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=1, size=0, index_align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A10100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_4_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, index_align=0, size=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_5_900_f4a01100() {
    // Encoding: 0xF4A01100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, Vd=1, D=0, Rn=0
    let encoding: u32 = 0xF4A01100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_6_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_7_900_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=1, index_align=0, Vd=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_8_900_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, D=0, size=2, Rm=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_9_900_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, size=3, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_10_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, index_align=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_11_900_f4a00110() {
    // Encoding: 0xF4A00110
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=1, size=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_12_900_f4a00170() {
    // Encoding: 0xF4A00170
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rn=0, Rm=0, index_align=7
    let encoding: u32 = 0xF4A00170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_13_900_f4a001f0() {
    // Encoding: 0xF4A001F0
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=15, Vd=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_14_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_15_900_f4a00101() {
    // Encoding: 0xF4A00101
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, index_align=0, Vd=0, Rm=1
    let encoding: u32 = 0xF4A00101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_16_900_f4a10101() {
    // Encoding: 0xF4A10101
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: size=0, D=0, Rn=1, Vd=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4A10101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_17_900_f4af010f() {
    // Encoding: 0xF4AF010F
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: Rm=31, D=0, size=0, index_align=0, Rn=31, Vd=0
    let encoding: u32 = 0xF4AF010F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_0_size_variant_0_2304_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_1_size_variant_1_2304_f4a00500() {
    // Encoding: 0xF4A00500
    // Test aarch32_VLD2_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rm=0, D=0, index_align=0, size=1, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_2_size_variant_2_2304_f4a00900() {
    // Encoding: 0xF4A00900
    // Test aarch32_VLD2_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Vd=0, index_align=0, size=2, D=0, Rn=0
    let encoding: u32 = 0xF4A00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_3_size_variant_3_2304_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: index_align=0, D=0, size=3, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_0_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_1_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_2_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_3_900_f4a00100() {
    // Encoding: 0xF4A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_d_0_min_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_d_1_max_100_f9e00100() {
    // Thumb encoding (32): 0xF9E00100
    // Test aarch32_VLD2_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, D=1, Rm=0, index_align=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rn_0_min_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, index_align=0, Rn=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rn_1_poweroftwo_100_f9a10100() {
    // Thumb encoding (32): 0xF9A10100
    // Test aarch32_VLD2_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, Rn=1, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_vd_0_min_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_vd_1_poweroftwo_100_f9a01100() {
    // Thumb encoding (32): 0xF9A01100
    // Test aarch32_VLD2_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=1, size=0, index_align=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_0_min_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_1_poweroftwo_100_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, index_align=0, Rm=0, size=1, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_2_poweroftwo_100_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=2, Rn=0, Vd=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_size_3_max_100_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Rm=0, index_align=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_0_min_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_1_poweroftwo_100_f9a00110() {
    // Thumb encoding (32): 0xF9A00110
    // Test aarch32_VLD2_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rm=0, size=0, index_align=1, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_7_poweroftwominusone_100_f9a00170() {
    // Thumb encoding (32): 0xF9A00170
    // Test aarch32_VLD2_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, D=0, size=0, index_align=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_index_align_15_max_100_f9a001f0() {
    // Thumb encoding (32): 0xF9A001F0
    // Test aarch32_VLD2_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Vd=0, index_align=15, D=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rm_0_min_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, index_align=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t1a1_a_field_rm_1_poweroftwo_100_f9a00101() {
    // Thumb encoding (32): 0xF9A00101
    // Test aarch32_VLD2_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Rn=0, Vd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_0_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, Rn=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_1_100_f9e00100() {
    // Thumb encoding (32): 0xF9E00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, size=0, D=1, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_2_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_3_100_f9a10100() {
    // Thumb encoding (32): 0xF9A10100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=1, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_4_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_5_100_f9a01100() {
    // Thumb encoding (32): 0xF9A01100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=1, D=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_6_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, index_align=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_7_100_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=0, size=1, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_8_100_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=0, size=2, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_9_100_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, size=3, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_10_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, size=0, D=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_11_100_f9a00110() {
    // Thumb encoding (32): 0xF9A00110
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=0, D=0, index_align=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_12_100_f9a00170() {
    // Thumb encoding (32): 0xF9A00170
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: index_align=7, Vd=0, D=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_13_100_f9a001f0() {
    // Thumb encoding (32): 0xF9A001F0
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=15, Rn=0, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_14_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_15_100_f9a00101() {
    // Thumb encoding (32): 0xF9A00101
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=1, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_16_100_f9a10101() {
    // Thumb encoding (32): 0xF9A10101
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=1, Rn=1, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_1_t1a1_a_combo_17_100_f9af010f() {
    // Thumb encoding (32): 0xF9AF010F
    // Test aarch32_VLD2_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: D=0, size=0, Rm=31, index_align=0, Rn=31, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF010F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_0_size_variant_0_256_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_1_size_variant_1_256_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, index_align=0, Rm=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_2_size_variant_2_256_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Rm=0, size=2, Rn=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_1_t1a1_a_special_size_3_size_variant_3_256_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: index_align=0, Rn=0, size=3, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t1a1_a_invalid_0_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, index_align=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t1a1_a_invalid_1_100_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_d_0_min_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_d_1_max_500_f9e00100() {
    // Thumb encoding (32): 0xF9E00100
    // Test aarch32_VLD2_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, size=0, Rn=0, D=1, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rn_0_min_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, index_align=0, Rn=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rn_1_poweroftwo_500_f9a10100() {
    // Thumb encoding (32): 0xF9A10100
    // Test aarch32_VLD2_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, index_align=0, D=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_vd_0_min_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, Rm=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_vd_1_poweroftwo_500_f9a01100() {
    // Thumb encoding (32): 0xF9A01100
    // Test aarch32_VLD2_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rn=0, D=0, index_align=0, Vd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_0_min_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_1_poweroftwo_500_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, index_align=0, size=1, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_2_poweroftwo_500_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, index_align=0, D=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_size_3_max_500_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: index_align=0, Vd=0, D=0, Rn=0, Rm=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_0_min_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, Rn=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_1_poweroftwo_500_f9a00110() {
    // Thumb encoding (32): 0xF9A00110
    // Test aarch32_VLD2_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, Vd=0, index_align=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_7_poweroftwominusone_500_f9a00170() {
    // Thumb encoding (32): 0xF9A00170
    // Test aarch32_VLD2_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, index_align=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_index_align_15_max_500_f9a001f0() {
    // Thumb encoding (32): 0xF9A001F0
    // Test aarch32_VLD2_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=15, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rm_0_min_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, Vd=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t2a2_a_field_rm_1_poweroftwo_500_f9a00101() {
    // Thumb encoding (32): 0xF9A00101
    // Test aarch32_VLD2_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=1, D=0, size=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_0_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_1_500_f9e00100() {
    // Thumb encoding (32): 0xF9E00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, Vd=0, Rn=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_2_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Vd=0, index_align=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_3_500_f9a10100() {
    // Thumb encoding (32): 0xF9A10100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, size=0, Vd=0, Rn=1, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_4_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=0, Rm=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_5_500_f9a01100() {
    // Thumb encoding (32): 0xF9A01100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=1, size=0, index_align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_6_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, D=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_7_500_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, index_align=0, D=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_8_500_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=2, Vd=0, index_align=0, Rn=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_9_500_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=3, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_10_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, index_align=0, size=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_11_500_f9a00110() {
    // Thumb encoding (32): 0xF9A00110
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: index_align=1, Vd=0, Rn=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_12_500_f9a00170() {
    // Thumb encoding (32): 0xF9A00170
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=7, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_13_500_f9a001f0() {
    // Thumb encoding (32): 0xF9A001F0
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=15, Rm=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_14_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, index_align=0, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_15_500_f9a00101() {
    // Thumb encoding (32): 0xF9A00101
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: size=0, Rn=0, D=0, index_align=0, Rm=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_16_500_f9a10101() {
    // Thumb encoding (32): 0xF9A10101
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, Vd=0, size=0, index_align=0, Rm=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_1_t2a2_a_combo_17_500_f9af010f() {
    // Thumb encoding (32): 0xF9AF010F
    // Test aarch32_VLD2_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=0, Rn=31, D=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF010F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_0_size_variant_0_1280_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: index_align=0, Vd=0, Rn=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_1_size_variant_1_1280_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=0, D=0, Rm=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_2_size_variant_2_1280_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=2, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_1_t2a2_a_special_size_3_size_variant_3_1280_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, index_align=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t2a2_a_invalid_0_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t2a2_a_invalid_1_500_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, Vd=0, Rm=0, Rn=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_d_0_min_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_d_1_max_900_f9e00100() {
    // Thumb encoding (32): 0xF9E00100
    // Test aarch32_VLD2_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=1, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rn_0_min_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rn_1_poweroftwo_900_f9a10100() {
    // Thumb encoding (32): 0xF9A10100
    // Test aarch32_VLD2_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, Rn=1, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_vd_0_min_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, index_align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_vd_1_poweroftwo_900_f9a01100() {
    // Thumb encoding (32): 0xF9A01100
    // Test aarch32_VLD2_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rn=0, D=0, size=0, Rm=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_0_min_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, index_align=0, Vd=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_1_poweroftwo_900_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, D=0, Vd=0, Rn=0, Rm=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_2_poweroftwo_900_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, D=0, Rn=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_size_3_max_900_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, size=3, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_0_min_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, index_align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_1_poweroftwo_900_f9a00110() {
    // Thumb encoding (32): 0xF9A00110
    // Test aarch32_VLD2_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=1, Rn=0, Vd=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_7_poweroftwominusone_900_f9a00170() {
    // Thumb encoding (32): 0xF9A00170
    // Test aarch32_VLD2_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, index_align=7, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_index_align_15_max_900_f9a001f0() {
    // Thumb encoding (32): 0xF9A001F0
    // Test aarch32_VLD2_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, D=0, Vd=0, size=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rm_0_min_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, index_align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_1_t3a3_a_field_rm_1_poweroftwo_900_f9a00101() {
    // Thumb encoding (32): 0xF9A00101
    // Test aarch32_VLD2_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rn=0, size=0, Rm=1, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_0_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_1_900_f9e00100() {
    // Thumb encoding (32): 0xF9E00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, Vd=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_2_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, index_align=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_3_900_f9a10100() {
    // Thumb encoding (32): 0xF9A10100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, D=0, Vd=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_4_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_5_900_f9a01100() {
    // Thumb encoding (32): 0xF9A01100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Vd=1, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_6_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_7_900_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, size=1, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_8_900_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=2, Rn=0, Vd=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_9_900_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=3, Rm=0, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_10_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_11_900_f9a00110() {
    // Thumb encoding (32): 0xF9A00110
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, Rm=0, index_align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_12_900_f9a00170() {
    // Thumb encoding (32): 0xF9A00170
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, index_align=7, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_13_900_f9a001f0() {
    // Thumb encoding (32): 0xF9A001F0
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=15, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_14_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, index_align=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_15_900_f9a00101() {
    // Thumb encoding (32): 0xF9A00101
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=0, size=0, Rm=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_16_900_f9a10101() {
    // Thumb encoding (32): 0xF9A10101
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, Rm=1, D=0, size=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_1_t3a3_a_combo_17_900_f9af010f() {
    // Thumb encoding (32): 0xF9AF010F
    // Test aarch32_VLD2_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, D=0, size=0, index_align=0, Rm=31, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF010F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_0_size_variant_0_2304_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_1_size_variant_1_2304_f9a00500() {
    // Thumb encoding (32): 0xF9A00500
    // Test aarch32_VLD2_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, index_align=0, D=0, Vd=0, size=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_2_size_variant_2_2304_f9a00900() {
    // Thumb encoding (32): 0xF9A00900
    // Test aarch32_VLD2_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Rn=0, size=2, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_1_t3a3_a_special_size_3_size_variant_3_2304_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, size=3, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_0_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: index_align=0, Vd=0, size=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_1_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, index_align=0, Rm=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_2_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, size=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_1_t3a3_a_invalid_3_900_f9a00100() {
    // Thumb encoding (32): 0xF9A00100
    // Test aarch32_VLD2_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD4_1_A Tests
// ============================================================================

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_d_0_min_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, D=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_d_1_max_300_f4e00300() {
    // Encoding: 0xF4E00300
    // Test aarch32_VLD4_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, Rn=0, D=1, Vd=0
    let encoding: u32 = 0xF4E00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rn_0_min_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, Vd=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rn_1_poweroftwo_300_f4a10300() {
    // Encoding: 0xF4A10300
    // Test aarch32_VLD4_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, index_align=0, D=0, Rn=1, Vd=0, size=0
    let encoding: u32 = 0xF4A10300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_vd_0_min_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, Rm=0, index_align=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_vd_1_poweroftwo_300_f4a01300() {
    // Encoding: 0xF4A01300
    // Test aarch32_VLD4_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, D=0, index_align=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0xF4A01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_0_min_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_1_poweroftwo_300_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rn=0, Rm=0, D=0, size=1
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_2_poweroftwo_300_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, Rn=0, D=0, Vd=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_3_max_300_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=0, size=3, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_0_min_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_1_poweroftwo_300_f4a00310() {
    // Encoding: 0xF4A00310
    // Test aarch32_VLD4_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, index_align=1, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_7_poweroftwominusone_300_f4a00370() {
    // Encoding: 0xF4A00370
    // Test aarch32_VLD4_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, Rm=0, D=0, index_align=7
    let encoding: u32 = 0xF4A00370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_15_max_300_f4a003f0() {
    // Encoding: 0xF4A003F0
    // Test aarch32_VLD4_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=15, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rm_0_min_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rm_1_poweroftwo_300_f4a00301() {
    // Encoding: 0xF4A00301
    // Test aarch32_VLD4_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rm=1, Rn=0
    let encoding: u32 = 0xF4A00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_0_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_1_300_f4e00300() {
    // Encoding: 0xF4E00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=1, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF4E00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_2_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_3_300_f4a10300() {
    // Encoding: 0xF4A10300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, Rn=1, index_align=0, Vd=0
    let encoding: u32 = 0xF4A10300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_4_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_5_300_f4a01300() {
    // Encoding: 0xF4A01300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, index_align=0, D=0, Rn=0, Vd=1, Rm=0
    let encoding: u32 = 0xF4A01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_6_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_7_300_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=1, Rn=0, index_align=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_8_300_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=2, D=0, Rn=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_9_300_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, Rm=0, index_align=0, size=3
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_10_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_11_300_f4a00310() {
    // Encoding: 0xF4A00310
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, index_align=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_12_300_f4a00370() {
    // Encoding: 0xF4A00370
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: index_align=7, D=0, Vd=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_13_300_f4a003f0() {
    // Encoding: 0xF4A003F0
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Vd=0, index_align=15, size=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4A003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_14_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rn=0, Rm=0, size=0, D=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_15_300_f4a00301() {
    // Encoding: 0xF4A00301
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rn=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4A00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_16_300_f4a10301() {
    // Encoding: 0xF4A10301
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: index_align=0, D=0, size=0, Rn=1, Vd=0, Rm=1
    let encoding: u32 = 0xF4A10301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_17_300_f4af030f() {
    // Encoding: 0xF4AF030F
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: size=0, index_align=0, Vd=0, Rn=31, D=0, Rm=31
    let encoding: u32 = 0xF4AF030F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_0_size_variant_0_768_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Rm=0, Vd=0, size=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_1_size_variant_1_768_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: index_align=0, size=1, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_2_size_variant_2_768_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_3_size_variant_3_768_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, D=0, Vd=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t1a1_a_invalid_0_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: size=0, index_align=0, D=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t1a1_a_invalid_1_300_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_d_0_min_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, index_align=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_d_1_max_700_f4e00300() {
    // Encoding: 0xF4E00300
    // Test aarch32_VLD4_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, index_align=0, D=1, Rn=0
    let encoding: u32 = 0xF4E00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rn_0_min_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, Vd=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rn_1_poweroftwo_700_f4a10300() {
    // Encoding: 0xF4A10300
    // Test aarch32_VLD4_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, size=0, Vd=0, Rn=1
    let encoding: u32 = 0xF4A10300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_vd_0_min_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_vd_1_poweroftwo_700_f4a01300() {
    // Encoding: 0xF4A01300
    // Test aarch32_VLD4_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=1, size=0, D=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_0_min_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_1_poweroftwo_700_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=1, D=0, Vd=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_2_poweroftwo_700_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=2, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_3_max_700_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, index_align=0, Rn=0, size=3, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_0_min_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, index_align=0, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_1_poweroftwo_700_f4a00310() {
    // Encoding: 0xF4A00310
    // Test aarch32_VLD4_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, index_align=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_7_poweroftwominusone_700_f4a00370() {
    // Encoding: 0xF4A00370
    // Test aarch32_VLD4_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: index_align=7, Rm=0, Vd=0, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4A00370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_15_max_700_f4a003f0() {
    // Encoding: 0xF4A003F0
    // Test aarch32_VLD4_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, size=0, Vd=0, index_align=15
    let encoding: u32 = 0xF4A003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rm_0_min_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, D=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rm_1_poweroftwo_700_f4a00301() {
    // Encoding: 0xF4A00301
    // Test aarch32_VLD4_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=1
    let encoding: u32 = 0xF4A00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_0_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, size=0, D=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_1_700_f4e00300() {
    // Encoding: 0xF4E00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=1, Rm=0, Rn=0, size=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4E00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_2_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rm=0, Vd=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_3_700_f4a10300() {
    // Encoding: 0xF4A10300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, index_align=0, Rm=0, Rn=1, Vd=0, size=0
    let encoding: u32 = 0xF4A10300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_4_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_5_700_f4a01300() {
    // Encoding: 0xF4A01300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, D=0, Vd=1, size=0
    let encoding: u32 = 0xF4A01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_6_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rm=0, index_align=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_7_700_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, size=1, index_align=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_8_700_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, size=2, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_9_700_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=3, index_align=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_10_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, Rm=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_11_700_f4a00310() {
    // Encoding: 0xF4A00310
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, Rn=0, Rm=0, index_align=1
    let encoding: u32 = 0xF4A00310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_12_700_f4a00370() {
    // Encoding: 0xF4A00370
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=7, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_13_700_f4a003f0() {
    // Encoding: 0xF4A003F0
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, index_align=15, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF4A003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_14_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=0, size=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_15_700_f4a00301() {
    // Encoding: 0xF4A00301
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rn=0, index_align=0, D=0, size=0, Rm=1, Vd=0
    let encoding: u32 = 0xF4A00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_16_700_f4a10301() {
    // Encoding: 0xF4A10301
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rm=1, Rn=1, D=0, size=0
    let encoding: u32 = 0xF4A10301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_17_700_f4af030f() {
    // Encoding: 0xF4AF030F
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: index_align=0, Rm=31, Vd=0, D=0, Rn=31, size=0
    let encoding: u32 = 0xF4AF030F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_0_size_variant_0_1792_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_1_size_variant_1_1792_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, size=1, Rm=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_2_size_variant_2_1792_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: index_align=0, Vd=0, D=0, Rn=0, Rm=0, size=2
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_3_size_variant_3_1792_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, index_align=0, Vd=0, size=3
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t2a2_a_invalid_0_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, Rm=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t2a2_a_invalid_1_700_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, index_align=0, size=0, Rn=0, D=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_d_0_min_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_d_1_max_b00_f4e00300() {
    // Encoding: 0xF4E00300
    // Test aarch32_VLD4_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, size=0, D=1, Vd=0, index_align=0
    let encoding: u32 = 0xF4E00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rn_0_min_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rn_1_poweroftwo_b00_f4a10300() {
    // Encoding: 0xF4A10300
    // Test aarch32_VLD4_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rm=0, Vd=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4A10300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_vd_0_min_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_vd_1_poweroftwo_b00_f4a01300() {
    // Encoding: 0xF4A01300
    // Test aarch32_VLD4_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=1, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_0_min_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_1_poweroftwo_b00_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=1, D=0, Rm=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_2_poweroftwo_b00_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, size=2, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_3_max_b00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, Rm=0, Vd=0, size=3
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_0_min_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rm=0, Rn=0, size=0, index_align=0, D=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_1_poweroftwo_b00_f4a00310() {
    // Encoding: 0xF4A00310
    // Test aarch32_VLD4_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, index_align=1, Vd=0, Rn=0
    let encoding: u32 = 0xF4A00310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_7_poweroftwominusone_b00_f4a00370() {
    // Encoding: 0xF4A00370
    // Test aarch32_VLD4_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: index_align=7, Rn=0, size=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_15_max_b00_f4a003f0() {
    // Encoding: 0xF4A003F0
    // Test aarch32_VLD4_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, Rn=0, index_align=15, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4A003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rm_0_min_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rm_1_poweroftwo_b00_f4a00301() {
    // Encoding: 0xF4A00301
    // Test aarch32_VLD4_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, D=0, Vd=0, Rm=1, Rn=0, size=0
    let encoding: u32 = 0xF4A00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_0_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_1_b00_f4e00300() {
    // Encoding: 0xF4E00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, size=0, Vd=0, D=1
    let encoding: u32 = 0xF4E00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_2_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, index_align=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_3_b00_f4a10300() {
    // Encoding: 0xF4A10300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=1, Vd=0, D=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A10300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_4_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, size=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_5_b00_f4a01300() {
    // Encoding: 0xF4A01300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=1, Rn=0, index_align=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4A01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_6_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, Rm=0, D=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_7_b00_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=1, index_align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_8_b00_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, size=2, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_9_b00_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, Vd=0, size=3
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_10_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_11_b00_f4a00310() {
    // Encoding: 0xF4A00310
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=1, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4A00310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_12_b00_f4a00370() {
    // Encoding: 0xF4A00370
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, Vd=0, index_align=7, Rm=0
    let encoding: u32 = 0xF4A00370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_13_b00_f4a003f0() {
    // Encoding: 0xF4A003F0
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=15, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4A003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_14_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, size=0, Vd=0, index_align=0, D=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_15_b00_f4a00301() {
    // Encoding: 0xF4A00301
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, Vd=0, D=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4A00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_16_b00_f4a10301() {
    // Encoding: 0xF4A10301
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Vd=0, Rm=1, Rn=1
    let encoding: u32 = 0xF4A10301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_17_b00_f4af030f() {
    // Encoding: 0xF4AF030F
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=31, index_align=0, Rm=31, size=0
    let encoding: u32 = 0xF4AF030F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_0_size_variant_0_2816_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, index_align=0, Rn=0, Vd=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_1_size_variant_1_2816_f4a00700() {
    // Encoding: 0xF4A00700
    // Test aarch32_VLD4_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, index_align=0, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_2_size_variant_2_2816_f4a00b00() {
    // Encoding: 0xF4A00B00
    // Test aarch32_VLD4_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, size=2, Rn=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4A00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_3_size_variant_3_2816_f4a00f00() {
    // Encoding: 0xF4A00F00
    // Test aarch32_VLD4_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Vd=0, size=3, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4A00F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_0_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_1_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_2_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_3_b00_f4a00300() {
    // Encoding: 0xF4A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_d_0_min_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_d_1_max_300_f9e00300() {
    // Thumb encoding (32): 0xF9E00300
    // Test aarch32_VLD4_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=1, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rn_0_min_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, D=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rn_1_poweroftwo_300_f9a10300() {
    // Thumb encoding (32): 0xF9A10300
    // Test aarch32_VLD4_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, index_align=0, D=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_vd_0_min_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, size=0, Vd=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_vd_1_poweroftwo_300_f9a01300() {
    // Thumb encoding (32): 0xF9A01300
    // Test aarch32_VLD4_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=1, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_0_min_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_1_poweroftwo_300_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, index_align=0, size=1, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_2_poweroftwo_300_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, Rn=0, Rm=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_size_3_max_300_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, D=0, Vd=0, index_align=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_0_min_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_1_poweroftwo_300_f9a00310() {
    // Thumb encoding (32): 0xF9A00310
    // Test aarch32_VLD4_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, Rm=0, Rn=0, index_align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_7_poweroftwominusone_300_f9a00370() {
    // Thumb encoding (32): 0xF9A00370
    // Test aarch32_VLD4_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, Rm=0, index_align=7, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_index_align_15_max_300_f9a003f0() {
    // Thumb encoding (32): 0xF9A003F0
    // Test aarch32_VLD4_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, Vd=0, Rn=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rm_0_min_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Rm=0, Rn=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t1a1_a_field_rm_1_poweroftwo_300_f9a00301() {
    // Thumb encoding (32): 0xF9A00301
    // Test aarch32_VLD4_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, Vd=0, size=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_0_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_1_300_f9e00300() {
    // Thumb encoding (32): 0xF9E00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=1, Vd=0, Rn=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_2_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, index_align=0, D=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_3_300_f9a10300() {
    // Thumb encoding (32): 0xF9A10300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, Rn=1, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_4_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, size=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_5_300_f9a01300() {
    // Thumb encoding (32): 0xF9A01300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=1, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_6_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_7_300_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, size=1, Rn=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_8_300_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_9_300_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, Vd=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_10_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=0, Rm=0, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_11_300_f9a00310() {
    // Thumb encoding (32): 0xF9A00310
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: index_align=1, size=0, Rm=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_12_300_f9a00370() {
    // Thumb encoding (32): 0xF9A00370
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, index_align=7, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_13_300_f9a003f0() {
    // Thumb encoding (32): 0xF9A003F0
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, index_align=15, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_14_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_15_300_f9a00301() {
    // Thumb encoding (32): 0xF9A00301
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=1, Rn=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_16_300_f9a10301() {
    // Thumb encoding (32): 0xF9A10301
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, D=0, Vd=0, Rn=1, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_1_t1a1_a_combo_17_300_f9af030f() {
    // Thumb encoding (32): 0xF9AF030F
    // Test aarch32_VLD4_1_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, index_align=0, Rm=31, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF030F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_0_size_variant_0_768_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, Rm=0, index_align=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_1_size_variant_1_768_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, Rn=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_2_size_variant_2_768_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, index_align=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_1_t1a1_a_special_size_3_size_variant_3_768_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, D=0, size=3, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t1a1_a_invalid_0_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rm=0, size=0, Rn=0, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t1a1_a_invalid_1_300_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_d_0_min_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_d_1_max_700_f9e00300() {
    // Thumb encoding (32): 0xF9E00300
    // Test aarch32_VLD4_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=1, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rn_0_min_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rn_1_poweroftwo_700_f9a10300() {
    // Thumb encoding (32): 0xF9A10300
    // Test aarch32_VLD4_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, size=0, index_align=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_vd_0_min_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_vd_1_poweroftwo_700_f9a01300() {
    // Thumb encoding (32): 0xF9A01300
    // Test aarch32_VLD4_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, D=0, size=0, Rn=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_0_min_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Rn=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_1_poweroftwo_700_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, size=1, Rn=0, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_2_poweroftwo_700_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, index_align=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_size_3_max_700_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=3, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_0_min_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_1_poweroftwo_700_f9a00310() {
    // Thumb encoding (32): 0xF9A00310
    // Test aarch32_VLD4_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, size=0, index_align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_7_poweroftwominusone_700_f9a00370() {
    // Thumb encoding (32): 0xF9A00370
    // Test aarch32_VLD4_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, index_align=7, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_index_align_15_max_700_f9a003f0() {
    // Thumb encoding (32): 0xF9A003F0
    // Test aarch32_VLD4_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=15, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rm_0_min_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, Rm=0, Rn=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t2a2_a_field_rm_1_poweroftwo_700_f9a00301() {
    // Thumb encoding (32): 0xF9A00301
    // Test aarch32_VLD4_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rn=0, Rm=1, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_0_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_1_700_f9e00300() {
    // Thumb encoding (32): 0xF9E00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_2_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, Rn=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_3_700_f9a10300() {
    // Thumb encoding (32): 0xF9A10300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Rn=1, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_4_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_5_700_f9a01300() {
    // Thumb encoding (32): 0xF9A01300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, index_align=0, Rm=0, Vd=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_6_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_7_700_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=0, Vd=0, size=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_8_700_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, size=2, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_9_700_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, index_align=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_10_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, D=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_11_700_f9a00310() {
    // Thumb encoding (32): 0xF9A00310
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Rm=0, index_align=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_12_700_f9a00370() {
    // Thumb encoding (32): 0xF9A00370
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: index_align=7, Rm=0, Vd=0, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_13_700_f9a003f0() {
    // Thumb encoding (32): 0xF9A003F0
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=15, Rm=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_14_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_15_700_f9a00301() {
    // Thumb encoding (32): 0xF9A00301
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=1, Rn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_16_700_f9a10301() {
    // Thumb encoding (32): 0xF9A10301
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: Vd=0, D=0, Rm=1, Rn=1, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_1_t2a2_a_combo_17_700_f9af030f() {
    // Thumb encoding (32): 0xF9AF030F
    // Test aarch32_VLD4_1_T2A2_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: D=0, Rn=31, index_align=0, Vd=0, size=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF030F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_0_size_variant_0_1792_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_1_size_variant_1_1792_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, size=1, index_align=0, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_2_size_variant_2_1792_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=2, index_align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_1_t2a2_a_special_size_3_size_variant_3_1792_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=3, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t2a2_a_invalid_0_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, size=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t2a2_a_invalid_1_700_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, index_align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_d_0_min_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_d_1_max_b00_f9e00300() {
    // Thumb encoding (32): 0xF9E00300
    // Test aarch32_VLD4_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=0, index_align=0, D=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rn_0_min_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, index_align=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rn_1_poweroftwo_b00_f9a10300() {
    // Thumb encoding (32): 0xF9A10300
    // Test aarch32_VLD4_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rn=1, D=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_vd_0_min_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_vd_1_poweroftwo_b00_f9a01300() {
    // Thumb encoding (32): 0xF9A01300
    // Test aarch32_VLD4_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, Vd=1, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_0_min_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, index_align=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_1_poweroftwo_b00_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=1, Rm=0, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_2_poweroftwo_b00_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=2, D=0, Rn=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_size_3_max_b00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, size=3, index_align=0, Rn=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_0_min_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_1_poweroftwo_b00_f9a00310() {
    // Thumb encoding (32): 0xF9A00310
    // Test aarch32_VLD4_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=1, Vd=0, Rm=0, Rn=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_7_poweroftwominusone_b00_f9a00370() {
    // Thumb encoding (32): 0xF9A00370
    // Test aarch32_VLD4_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Rm=0, index_align=7, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_index_align_15_max_b00_f9a003f0() {
    // Thumb encoding (32): 0xF9A003F0
    // Test aarch32_VLD4_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=15, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rm_0_min_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, index_align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld4_1_t3a3_a_field_rm_1_poweroftwo_b00_f9a00301() {
    // Thumb encoding (32): 0xF9A00301
    // Test aarch32_VLD4_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, D=0, size=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_0_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, D=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_1_b00_f9e00300() {
    // Thumb encoding (32): 0xF9E00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=1, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=0, Vd=0, Rm=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_2_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_3_b00_f9a10300() {
    // Thumb encoding (32): 0xF9A10300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Vd=0, Rn=1, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_4_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_5_b00_f9a01300() {
    // Thumb encoding (32): 0xF9A01300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=1, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_6_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_7_b00_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=1, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, size=1, D=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_8_b00_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=2, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=0, D=0, Rm=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_9_b00_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=0 (minimum value)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_10_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=1 (value 1)
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_11_b00_f9a00310() {
    // Thumb encoding (32): 0xF9A00310
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, index_align=1, Rn=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=7 (midpoint (7))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_12_b00_f9a00370() {
    // Thumb encoding (32): 0xF9A00370
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    // ISET: T32
    // Fields: Vd=0, index_align=7, Rm=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// index_align=15 (maximum value (15))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_13_b00_f9a003f0() {
    // Thumb encoding (32): 0xF9A003F0
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=15, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=15, Vd=0, Rm=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_14_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, index_align=0, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_15_b00_f9a00301() {
    // Thumb encoding (32): 0xF9A00301
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: size=0, Rn=0, Rm=1, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_16_b00_f9a10301() {
    // Thumb encoding (32): 0xF9A10301
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=1, Vd=0, size=0, index_align=0, Rm=1
    // ISET: T32
    // Fields: D=0, Rm=1, Rn=1, index_align=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld4_1_t3a3_a_combo_17_b00_f9af030f() {
    // Thumb encoding (32): 0xF9AF030F
    // Test aarch32_VLD4_1_T3A3_A field combination: D=0, Rn=31, Vd=0, size=0, index_align=0, Rm=31
    // ISET: T32
    // Fields: size=0, Rm=31, Rn=31, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF030F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_0_size_variant_0_2816_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_1_size_variant_1_2816_f9a00700() {
    // Thumb encoding (32): 0xF9A00700
    // Test aarch32_VLD4_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, size=1, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_2_size_variant_2_2816_f9a00b00() {
    // Thumb encoding (32): 0xF9A00B00
    // Test aarch32_VLD4_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Rm=0, index_align=0, Vd=0, Rn=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld4_1_t3a3_a_special_size_3_size_variant_3_2816_f9a00f00() {
    // Thumb encoding (32): 0xF9A00F00
    // Test aarch32_VLD4_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, size=3, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_0_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, index_align=0, Vd=0, Rm=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_1_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_2_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, D=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD4_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld4_1_t3a3_a_invalid_3_b00_f9a00300() {
    // Thumb encoding (32): 0xF9A00300
    // Test aarch32_VLD4_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VLD2_a_A Tests
// ============================================================================

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_d_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, a=0, Vd=0, size=0, Rm=0, T=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_d_1_max_d00_f4e00d00() {
    // Encoding: 0xF4E00D00
    // Test aarch32_VLD2_a_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: a=0, D=1, Vd=0, T=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0xF4E00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rn_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, T=0, a=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rn_1_poweroftwo_d00_f4a10d00() {
    // Encoding: 0xF4A10D00
    // Test aarch32_VLD2_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: T=0, Rm=0, Rn=1, D=0, Vd=0, a=0, size=0
    let encoding: u32 = 0xF4A10D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_vd_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: a=0, T=0, D=0, Vd=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_vd_1_poweroftwo_d00_f4a01d00() {
    // Encoding: 0xF4A01D00
    // Test aarch32_VLD2_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, size=0, Vd=1, a=0, T=0, Rn=0
    let encoding: u32 = 0xF4A01D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, D=0, size=0, a=0, Vd=0, Rn=0, T=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_1_poweroftwo_d00_f4a00d40() {
    // Encoding: 0xF4A00D40
    // Test aarch32_VLD2_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, T=0, Rm=0, a=0, size=1, Rn=0
    let encoding: u32 = 0xF4A00D40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_2_poweroftwo_d00_f4a00d80() {
    // Encoding: 0xF4A00D80
    // Test aarch32_VLD2_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, size=2, Rn=0, T=0, a=0
    let encoding: u32 = 0xF4A00D80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_3_max_d00_f4a00dc0() {
    // Encoding: 0xF4A00DC0
    // Test aarch32_VLD2_a_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: T=0, Rm=0, Vd=0, D=0, a=0, size=3, Rn=0
    let encoding: u32 = 0xF4A00DC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_t_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field T = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, T=0, D=0, a=0, Rm=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_t_1_max_d00_f4a00d20() {
    // Encoding: 0xF4A00D20
    // Test aarch32_VLD2_a_T1A1_A field T = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, T=1, a=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xF4A00D20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_a_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field a = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, T=0, a=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_a_1_max_d00_f4a00d10() {
    // Encoding: 0xF4A00D10
    // Test aarch32_VLD2_a_T1A1_A field a = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, size=0, Rn=0, T=0, a=1
    let encoding: u32 = 0xF4A00D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rm_0_min_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, a=0, Rm=0, T=0, D=0, Vd=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rm_1_poweroftwo_d00_f4a00d01() {
    // Encoding: 0xF4A00D01
    // Test aarch32_VLD2_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: a=0, D=0, Rn=0, Vd=0, T=0, size=0, Rm=1
    let encoding: u32 = 0xF4A00D01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_0_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: T=0, Rm=0, D=0, Rn=0, size=0, a=0, Vd=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_1_d00_f4e00d00() {
    // Encoding: 0xF4E00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, a=0, Rn=0, T=0, D=1, Rm=0, size=0
    let encoding: u32 = 0xF4E00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_2_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, T=0, a=0, D=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_3_d00_f4a10d00() {
    // Encoding: 0xF4A10D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=1, T=0, Vd=0, Rm=0, size=0, a=0
    let encoding: u32 = 0xF4A10D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_4_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, a=0, Rm=0, T=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_5_d00_f4a01d00() {
    // Encoding: 0xF4A01D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, T=0, Rm=0, Vd=1, Rn=0, a=0
    let encoding: u32 = 0xF4A01D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_6_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, D=0, T=0, Rn=0, a=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_7_d00_f4a00d40() {
    // Encoding: 0xF4A00D40
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: T=0, size=1, a=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4A00D40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_8_d00_f4a00d80() {
    // Encoding: 0xF4A00D80
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=2, a=0, Rm=0, T=0, D=0
    let encoding: u32 = 0xF4A00D80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_9_d00_f4a00dc0() {
    // Encoding: 0xF4A00DC0
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, a=0, Vd=0, size=3, T=0
    let encoding: u32 = 0xF4A00DC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_10_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, T=0, Rm=0, Vd=0, a=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_11_d00_f4a00d20() {
    // Encoding: 0xF4A00D20
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, T=1, D=0, Rm=0, a=0
    let encoding: u32 = 0xF4A00D20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_12_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, T=0, Rm=0, D=0, a=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_13_d00_f4a00d10() {
    // Encoding: 0xF4A00D10
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: A32
    // Fields: size=0, T=0, a=1, D=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4A00D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_14_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, a=0, T=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_15_d00_f4a00d01() {
    // Encoding: 0xF4A00D01
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: Vd=0, size=0, T=0, D=0, a=0, Rm=1, Rn=0
    let encoding: u32 = 0xF4A00D01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_16_d00_f4a10d01() {
    // Encoding: 0xF4A10D01
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: A32
    // Fields: T=0, size=0, a=0, Rn=1, D=0, Vd=0, Rm=1
    let encoding: u32 = 0xF4A10D01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_17_d00_f4af0d0f() {
    // Encoding: 0xF4AF0D0F
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: A32
    // Fields: D=0, Rm=31, Rn=31, size=0, T=0, Vd=0, a=0
    let encoding: u32 = 0xF4AF0D0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_0_size_variant_0_3328_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: a=0, Rm=0, T=0, Vd=0, size=0, Rn=0, D=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_1_size_variant_1_3328_f4a00d40() {
    // Encoding: 0xF4A00D40
    // Test aarch32_VLD2_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, size=1, a=0, Rm=0, D=0, Vd=0, T=0
    let encoding: u32 = 0xF4A00D40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_2_size_variant_2_3328_f4a00d80() {
    // Encoding: 0xF4A00D80
    // Test aarch32_VLD2_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: a=0, size=2, Rn=0, Rm=0, T=0, Vd=0, D=0
    let encoding: u32 = 0xF4A00D80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_3_size_variant_3_3328_f4a00dc0() {
    // Encoding: 0xF4A00DC0
    // Test aarch32_VLD2_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, a=0, size=3, Rn=0, Rm=0, Vd=0, T=0
    let encoding: u32 = 0xF4A00DC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_0_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, a=0, T=0, Rm=0, size=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_1_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, T=0, a=0, D=0, Rn=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_2_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Rn=0, a=0, Vd=0, Rm=0, T=0, D=0, size=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_3_d00_f4a00d00() {
    // Encoding: 0xF4A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, T=0, Vd=0, Rn=0, a=0, D=0, size=0
    let encoding: u32 = 0xF4A00D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_d_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, a=0, size=0, Vd=0, T=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_d_1_max_d00_f9e00d00() {
    // Thumb encoding (32): 0xF9E00D00
    // Test aarch32_VLD2_a_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, T=0, Rn=0, a=0, Rm=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rn_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, size=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rn_1_poweroftwo_d00_f9a10d00() {
    // Thumb encoding (32): 0xF9A10D00
    // Test aarch32_VLD2_a_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: a=0, D=0, Rn=1, Rm=0, Vd=0, T=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_vd_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, T=0, Vd=0, Rn=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_vd_1_poweroftwo_d00_f9a01d00() {
    // Thumb encoding (32): 0xF9A01D00
    // Test aarch32_VLD2_a_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, Rm=0, size=0, T=0, a=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: T=0, Vd=0, a=0, size=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_1_poweroftwo_d00_f9a00d40() {
    // Thumb encoding (32): 0xF9A00D40
    // Test aarch32_VLD2_a_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, a=0, Vd=0, D=0, Rn=0, size=1, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_2_poweroftwo_d00_f9a00d80() {
    // Thumb encoding (32): 0xF9A00D80
    // Test aarch32_VLD2_a_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rm=0, a=0, size=2, D=0, Rn=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_size_3_max_d00_f9a00dc0() {
    // Thumb encoding (32): 0xF9A00DC0
    // Test aarch32_VLD2_a_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, D=0, Rn=0, Vd=0, T=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00DC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_t_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field T = 0 (Min)
    // ISET: T32
    // Fields: size=0, T=0, D=0, a=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field T 5 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_t_1_max_d00_f9a00d20() {
    // Thumb encoding (32): 0xF9A00D20
    // Test aarch32_VLD2_a_T1A1_A field T = 1 (Max)
    // ISET: T32
    // Fields: D=0, size=0, a=0, Rm=0, T=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_a_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field a = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, a=0, D=0, T=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field a 4 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_a_1_max_d00_f9a00d10() {
    // Thumb encoding (32): 0xF9A00D10
    // Test aarch32_VLD2_a_T1A1_A field a = 1 (Max)
    // ISET: T32
    // Fields: D=0, T=0, size=0, a=1, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rm_0_min_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, Vd=0, a=0, Rn=0, T=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vld2_a_t1a1_a_field_rm_1_poweroftwo_d00_f9a00d01() {
    // Thumb encoding (32): 0xF9A00D01
    // Test aarch32_VLD2_a_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, D=0, a=0, Vd=0, Rn=0, size=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_0_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, a=0, Vd=0, Rm=0, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_1_d00_f9e00d00() {
    // Thumb encoding (32): 0xF9E00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=1, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=1, size=0, a=0, Rm=0, Rn=0, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9E00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_2_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, T=0, a=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_3_d00_f9a10d00() {
    // Thumb encoding (32): 0xF9A10D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, T=0, Vd=0, D=0, size=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_4_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, a=0, Rn=0, Rm=0, Vd=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_5_d00_f9a01d00() {
    // Thumb encoding (32): 0xF9A01D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=1, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=1, a=0, size=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A01D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_6_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, Vd=0, D=0, size=0, Rn=0, Rm=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_7_d00_f9a00d40() {
    // Thumb encoding (32): 0xF9A00D40
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=1, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, a=0, size=1, Rn=0, T=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_8_d00_f9a00d80() {
    // Thumb encoding (32): 0xF9A00D80
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=2, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, T=0, a=0, size=2, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_9_d00_f9a00dc0() {
    // Thumb encoding (32): 0xF9A00DC0
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=3, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, size=3, T=0, a=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00DC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=0 (minimum value)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_10_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, a=0, Vd=0, Rn=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// T=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_11_d00_f9a00d20() {
    // Thumb encoding (32): 0xF9A00D20
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=1, a=0, Rm=0
    // ISET: T32
    // Fields: size=0, a=0, Rn=0, T=1, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_12_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: T=0, D=0, Rn=0, a=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_13_d00_f9a00d10() {
    // Thumb encoding (32): 0xF9A00D10
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=1, Rm=0
    // ISET: T32
    // Fields: size=0, a=1, Rm=0, T=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_14_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, a=0, T=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_15_d00_f9a00d01() {
    // Thumb encoding (32): 0xF9A00D01
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, T=0, Rn=0, Vd=0, size=0, D=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_16_d00_f9a10d01() {
    // Thumb encoding (32): 0xF9A10D01
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=1, Vd=0, size=0, T=0, a=0, Rm=1
    // ISET: T32
    // Fields: size=0, T=0, Rn=1, Vd=0, D=0, a=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A10D01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_vld2_a_t1a1_a_combo_17_d00_f9af0d0f() {
    // Thumb encoding (32): 0xF9AF0D0F
    // Test aarch32_VLD2_a_T1A1_A field combination: D=0, Rn=31, Vd=0, size=0, T=0, a=0, Rm=31
    // ISET: T32
    // Fields: D=0, T=0, size=0, a=0, Vd=0, Rn=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9AF0D0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_0_size_variant_0_3328_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, T=0, Rm=0, D=0, Vd=0, a=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_1_size_variant_1_3328_f9a00d40() {
    // Thumb encoding (32): 0xF9A00D40
    // Test aarch32_VLD2_a_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: a=0, size=1, T=0, Rm=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_2_size_variant_2_3328_f9a00d80() {
    // Thumb encoding (32): 0xF9A00D80
    // Test aarch32_VLD2_a_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Vd=0, size=2, T=0, Rn=0, a=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vld2_a_t1a1_a_special_size_3_size_variant_3_3328_f9a00dc0() {
    // Thumb encoding (32): 0xF9A00DC0
    // Test aarch32_VLD2_a_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Rm=0, Rn=0, Vd=0, D=0, T=0, a=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00DC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_0_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: size=0, Rn=0, T=0, D=0, a=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_1_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: T=0, Vd=0, size=0, Rn=0, a=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_2_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: T=0, Rn=0, a=0, Rm=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VLD2_a_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vld2_a_t1a1_a_invalid_3_d00_f9a00d00() {
    // Thumb encoding (32): 0xF9A00D00
    // Test aarch32_VLD2_a_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, T=0, Vd=0, a=0, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9A00D00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

