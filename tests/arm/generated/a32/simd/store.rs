//! A32 simd store tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_VST4_m_A Tests
// ============================================================================

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_d_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, type1=0, size=0, align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_d_1_max_0_f4400000() {
    // Encoding: 0xF4400000
    // Test aarch32_VST4_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=1, align=0, Rn=0, size=0, Rm=0, type1=0
    let encoding: u32 = 0xF4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rn_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, align=0, Rn=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rn_1_poweroftwo_0_f4010000() {
    // Encoding: 0xF4010000
    // Test aarch32_VST4_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, type1=0, D=0, Rn=1, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_vd_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, type1=0, Rn=0, D=0, align=0, Rm=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_vd_1_poweroftwo_0_f4001000() {
    // Encoding: 0xF4001000
    // Test aarch32_VST4_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, size=0, align=0, type1=0, Vd=1
    let encoding: u32 = 0xF4001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Rn=0, type1=0, Vd=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_1_poweroftwo_0_f4000100() {
    // Encoding: 0xF4000100
    // Test aarch32_VST4_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, align=0, Vd=0, Rm=0, type1=1
    let encoding: u32 = 0xF4000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_7_poweroftwominusone_0_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST4_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=7, Rn=0, size=0, align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_15_max_0_f4000f00() {
    // Encoding: 0xF4000F00
    // Test aarch32_VST4_m_T1A1_A field type1 = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, type1=15, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, type1=0, Vd=0, size=0, D=0, Rn=0, align=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_1_poweroftwo_0_f4000040() {
    // Encoding: 0xF4000040
    // Test aarch32_VST4_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, Rm=0, type1=0, size=1, D=0
    let encoding: u32 = 0xF4000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_2_poweroftwo_0_f4000080() {
    // Encoding: 0xF4000080
    // Test aarch32_VST4_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rm=0, size=2, D=0, Rn=0, type1=0, Vd=0
    let encoding: u32 = 0xF4000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_3_max_0_f40000c0() {
    // Encoding: 0xF40000C0
    // Test aarch32_VST4_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Rm=0, D=0, align=0, Rn=0, Vd=0, type1=0
    let encoding: u32 = 0xF40000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_align_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, align=0, Rn=0, type1=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_align_1_poweroftwo_0_f4000010() {
    // Encoding: 0xF4000010
    // Test aarch32_VST4_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, type1=0, size=0, align=1, Rm=0
    let encoding: u32 = 0xF4000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_align_3_max_0_f4000030() {
    // Encoding: 0xF4000030
    // Test aarch32_VST4_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: Vd=0, type1=0, size=0, D=0, Rn=0, align=3, Rm=0
    let encoding: u32 = 0xF4000030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rm_0_min_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, type1=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rm_1_poweroftwo_0_f4000001() {
    // Encoding: 0xF4000001
    // Test aarch32_VST4_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, align=0, Rn=0, Vd=0, type1=0, Rm=1
    let encoding: u32 = 0xF4000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_m_t1a1_a_combo_0_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: type1=0, size=0, align=0, Rn=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_0_size_variant_0_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: type1=0, align=0, Rm=0, size=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_1_size_variant_1_0_f4000040() {
    // Encoding: 0xF4000040
    // Test aarch32_VST4_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, type1=0, size=1, align=0, Rm=0
    let encoding: u32 = 0xF4000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_2_size_variant_2_0_f4000080() {
    // Encoding: 0xF4000080
    // Test aarch32_VST4_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, type1=0, align=0, Rm=0, Rn=0, size=2, D=0
    let encoding: u32 = 0xF4000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_3_size_variant_3_0_f40000c0() {
    // Encoding: 0xF40000C0
    // Test aarch32_VST4_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, Rn=0, Vd=0, type1=0, align=0, Rm=0, D=0
    let encoding: u32 = 0xF40000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_0_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, type1=0, align=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_1_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: type1=0, Rm=0, align=0, Rn=0, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_2_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: align=0, type1=0, Rm=0, Vd=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_3_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: align=0, Rm=0, size=0, Vd=0, Rn=0, type1=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_d_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, type1=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_d_1_max_0_f9400000() {
    // Thumb encoding (32): 0xF9400000
    // Test aarch32_VST4_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: align=0, size=0, Rn=0, Vd=0, type1=0, Rm=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rn_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, align=0, Rm=0, Rn=0, type1=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rn_1_poweroftwo_0_f9010000() {
    // Thumb encoding (32): 0xF9010000
    // Test aarch32_VST4_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, size=0, Rm=0, align=0, type1=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_vd_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, Rn=0, size=0, D=0, type1=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_vd_1_poweroftwo_0_f9001000() {
    // Thumb encoding (32): 0xF9001000
    // Test aarch32_VST4_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, type1=0, Vd=1, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, align=0, Vd=0, type1=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_1_poweroftwo_0_f9000100() {
    // Thumb encoding (32): 0xF9000100
    // Test aarch32_VST4_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, type1=1, D=0, Vd=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_7_poweroftwominusone_0_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST4_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, type1=7, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_type1_15_max_0_f9000f00() {
    // Thumb encoding (32): 0xF9000F00
    // Test aarch32_VST4_m_T1A1_A field type1 = 15 (Max)
    // ISET: T32
    // Fields: size=0, Rm=0, Vd=0, Rn=0, type1=15, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, type1=0, align=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_1_poweroftwo_0_f9000040() {
    // Thumb encoding (32): 0xF9000040
    // Test aarch32_VST4_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, size=1, align=0, Rm=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_2_poweroftwo_0_f9000080() {
    // Thumb encoding (32): 0xF9000080
    // Test aarch32_VST4_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, align=0, Vd=0, Rn=0, type1=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_size_3_max_0_f90000c0() {
    // Thumb encoding (32): 0xF90000C0
    // Test aarch32_VST4_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, type1=0, Rm=0, Vd=0, size=3, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_align_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, Vd=0, D=0, Rn=0, type1=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_align_1_poweroftwo_0_f9000010() {
    // Thumb encoding (32): 0xF9000010
    // Test aarch32_VST4_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=1, D=0, type1=0, Rm=0, size=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_align_3_max_0_f9000030() {
    // Thumb encoding (32): 0xF9000030
    // Test aarch32_VST4_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, type1=0, D=0, size=0, Rn=0, Rm=0, align=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rm_0_min_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, type1=0, D=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_m_t1a1_a_field_rm_1_poweroftwo_0_f9000001() {
    // Thumb encoding (32): 0xF9000001
    // Test aarch32_VST4_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, align=0, Vd=0, size=0, type1=0, D=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_m_t1a1_a_combo_0_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, type1=0, size=0, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_0_size_variant_0_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, type1=0, Rn=0, Vd=0, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_1_size_variant_1_0_f9000040() {
    // Thumb encoding (32): 0xF9000040
    // Test aarch32_VST4_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, Vd=0, D=0, type1=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_2_size_variant_2_0_f9000080() {
    // Thumb encoding (32): 0xF9000080
    // Test aarch32_VST4_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, type1=0, Rn=0, size=2, Rm=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_m_t1a1_a_special_size_3_size_variant_3_0_f90000c0() {
    // Thumb encoding (32): 0xF90000C0
    // Test aarch32_VST4_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Vd=0, align=0, Rm=0, type1=0, D=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_0_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, type1=0, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_1_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, Rn=0, align=0, size=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_2_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: align=0, Vd=0, D=0, Rm=0, size=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_m_t1a1_a_invalid_3_0_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST4_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, Vd=0, type1=0, Rm=0, align=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_0_f4010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_1_f4010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_2_f4010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_3_f4010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst4_m_t1a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst4_m_t1a1_a_t32_oracle_0_f9010002() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF9010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst4_m_t1a1_a_t32_oracle_1_f9010002() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst4_m_t1a1_a_t32_oracle_2_f9010002() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF9010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst4_m_t1a1_a_t32_oracle_3_f9010002() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF9010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_0_f9010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_1_f9010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_2_f9010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_m_t1a1_a_store_3_f9010000() {
    // Test aarch32_VST4_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST2_m_A Tests
// ============================================================================

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_d_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, type1=0, align=0, D=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_d_1_max_800_f4400000() {
    // Encoding: 0xF4400000
    // Test aarch32_VST2_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, D=1, Rn=0, align=0, type1=0
    let encoding: u32 = 0xF4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rn_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, type1=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rn_1_poweroftwo_800_f4010000() {
    // Encoding: 0xF4010000
    // Test aarch32_VST2_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, type1=0, Vd=0, D=0, Rn=1, align=0, Rm=0
    let encoding: u32 = 0xF4010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_vd_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, type1=0, size=0, D=0, Rn=0, align=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_vd_1_poweroftwo_800_f4001000() {
    // Encoding: 0xF4001000
    // Test aarch32_VST2_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=1, D=0, type1=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=0, type1=0, Rn=0, size=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_1_poweroftwo_800_f4000100() {
    // Encoding: 0xF4000100
    // Test aarch32_VST2_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, type1=1, D=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_7_poweroftwominusone_800_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST2_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, D=0, Rn=0, Vd=0, type1=7
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_15_max_800_f4000f00() {
    // Encoding: 0xF4000F00
    // Test aarch32_VST2_m_T1A1_A field type1 = 15 (Max)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0, type1=15
    let encoding: u32 = 0xF4000F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, type1=0, align=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_1_poweroftwo_800_f4000040() {
    // Encoding: 0xF4000040
    // Test aarch32_VST2_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=1, align=0, Vd=0, Rm=0, Rn=0, D=0, type1=0
    let encoding: u32 = 0xF4000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_2_poweroftwo_800_f4000080() {
    // Encoding: 0xF4000080
    // Test aarch32_VST2_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, type1=0, align=0, Rn=0, Rm=0, size=2, D=0
    let encoding: u32 = 0xF4000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_3_max_800_f40000c0() {
    // Encoding: 0xF40000C0
    // Test aarch32_VST2_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Rm=0, type1=0, Vd=0, Rn=0, D=0, align=0
    let encoding: u32 = 0xF40000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_align_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, align=0, Vd=0, type1=0, Rm=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_align_1_poweroftwo_800_f4000010() {
    // Encoding: 0xF4000010
    // Test aarch32_VST2_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rn=0, type1=0, D=0, align=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_align_3_max_800_f4000030() {
    // Encoding: 0xF4000030
    // Test aarch32_VST2_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, size=0, align=3, D=0, type1=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4000030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rm_0_min_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: type1=0, size=0, Rn=0, Vd=0, D=0, align=0, Rm=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rm_1_poweroftwo_800_f4000001() {
    // Encoding: 0xF4000001
    // Test aarch32_VST2_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=1, size=0, D=0, align=0, type1=0
    let encoding: u32 = 0xF4000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_m_t1a1_a_combo_0_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, align=0, Rm=0, Vd=0, type1=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_0_size_variant_0_2048_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, D=0, align=0, Rn=0, Rm=0, Vd=0, type1=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_1_size_variant_1_2048_f4000040() {
    // Encoding: 0xF4000040
    // Test aarch32_VST2_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: type1=0, size=1, Vd=0, D=0, align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_2_size_variant_2_2048_f4000080() {
    // Encoding: 0xF4000080
    // Test aarch32_VST2_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, type1=0, size=2, align=0, Rm=0
    let encoding: u32 = 0xF4000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_3_size_variant_3_2048_f40000c0() {
    // Encoding: 0xF40000C0
    // Test aarch32_VST2_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: align=0, Rm=0, D=0, type1=0, size=3, Vd=0, Rn=0
    let encoding: u32 = 0xF40000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_0_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rn=0, type1=0, align=0, Vd=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_1_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, type1=0, size=0, Rm=0, Rn=0, Vd=0, align=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_2_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, align=0, Vd=0, Rn=0, D=0, type1=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_3_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=0, Rn=0, type1=0, D=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_4_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: align=0, D=0, Vd=0, Rn=0, type1=0, Rm=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_5_800_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, size=0, align=0, type1=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_d_0_min_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, align=0, D=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_d_1_max_300_f4400300() {
    // Encoding: 0xF4400300
    // Test aarch32_VST2_m_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: align=0, Vd=0, D=1, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4400300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rn_0_min_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rn_1_poweroftwo_300_f4010300() {
    // Encoding: 0xF4010300
    // Test aarch32_VST2_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, Vd=0, Rn=1, align=0
    let encoding: u32 = 0xF4010300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_vd_0_min_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, Rm=0, size=0, align=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_vd_1_poweroftwo_300_f4001300() {
    // Encoding: 0xF4001300
    // Test aarch32_VST2_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, D=0, Rm=0, size=0, Vd=1, Rn=0
    let encoding: u32 = 0xF4001300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_0_min_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: align=0, Rm=0, size=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_1_poweroftwo_300_f4000340() {
    // Encoding: 0xF4000340
    // Test aarch32_VST2_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rn=0, Vd=0, D=0, size=1, Rm=0
    let encoding: u32 = 0xF4000340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_2_poweroftwo_300_f4000380() {
    // Encoding: 0xF4000380
    // Test aarch32_VST2_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, D=0, size=2, Rm=0
    let encoding: u32 = 0xF4000380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_3_max_300_f40003c0() {
    // Encoding: 0xF40003C0
    // Test aarch32_VST2_m_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, size=3, align=0, Vd=0
    let encoding: u32 = 0xF40003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_align_0_min_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field align = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, align=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_align_1_poweroftwo_300_f4000310() {
    // Encoding: 0xF4000310
    // Test aarch32_VST2_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=1, D=0, Vd=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4000310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_align_3_max_300_f4000330() {
    // Encoding: 0xF4000330
    // Test aarch32_VST2_m_T2A2_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, size=0, align=3, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4000330;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rm_0_min_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: align=0, Vd=0, Rm=0, D=0, size=0, Rn=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rm_1_poweroftwo_300_f4000301() {
    // Encoding: 0xF4000301
    // Test aarch32_VST2_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, D=0, Rn=0, Rm=1, Vd=0, size=0
    let encoding: u32 = 0xF4000301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_m_t2a2_a_combo_0_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_0_size_variant_0_768_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_1_size_variant_1_768_f4000340() {
    // Encoding: 0xF4000340
    // Test aarch32_VST2_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: align=0, Rn=0, D=0, size=1, Vd=0, Rm=0
    let encoding: u32 = 0xF4000340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_2_size_variant_2_768_f4000380() {
    // Encoding: 0xF4000380
    // Test aarch32_VST2_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=2, align=0, Rm=0
    let encoding: u32 = 0xF4000380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_3_size_variant_3_768_f40003c0() {
    // Encoding: 0xF40003C0
    // Test aarch32_VST2_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, Rm=0, size=3, Rn=0, align=0, D=0
    let encoding: u32 = 0xF40003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_0_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, Vd=0, align=0, D=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_1_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_2_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: Vd=0, Rm=0, Rn=0, D=0, size=0, align=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_3_300_f4000300() {
    // Encoding: 0xF4000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: align=0, Vd=0, size=0, Rn=0, Rm=0, D=0
    let encoding: u32 = 0xF4000300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_d_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, type1=0, size=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_d_1_max_800_f9400000() {
    // Thumb encoding (32): 0xF9400000
    // Test aarch32_VST2_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, size=0, type1=0, Rn=0, Vd=0, D=1, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rn_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, type1=0, Rn=0, size=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rn_1_poweroftwo_800_f9010000() {
    // Thumb encoding (32): 0xF9010000
    // Test aarch32_VST2_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=0, align=0, Rm=0, D=0, Rn=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_vd_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, align=0, Rm=0, Rn=0, type1=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_vd_1_poweroftwo_800_f9001000() {
    // Thumb encoding (32): 0xF9001000
    // Test aarch32_VST2_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=1, type1=0, D=0, size=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, Rm=0, D=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_1_poweroftwo_800_f9000100() {
    // Thumb encoding (32): 0xF9000100
    // Test aarch32_VST2_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, align=0, D=0, Vd=0, size=0, Rn=0, type1=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_7_poweroftwominusone_800_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST2_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, type1=7, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_type1_15_max_800_f9000f00() {
    // Thumb encoding (32): 0xF9000F00
    // Test aarch32_VST2_m_T1A1_A field type1 = 15 (Max)
    // ISET: T32
    // Fields: type1=15, Rn=0, Vd=0, size=0, Rm=0, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: align=0, Rm=0, size=0, D=0, Vd=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_1_poweroftwo_800_f9000040() {
    // Thumb encoding (32): 0xF9000040
    // Test aarch32_VST2_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=0, align=0, Rm=0, size=1, D=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_2_poweroftwo_800_f9000080() {
    // Thumb encoding (32): 0xF9000080
    // Test aarch32_VST2_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, align=0, D=0, Vd=0, type1=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_size_3_max_800_f90000c0() {
    // Thumb encoding (32): 0xF90000C0
    // Test aarch32_VST2_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, D=0, size=3, align=0, Rm=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_align_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, align=0, type1=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_align_1_poweroftwo_800_f9000010() {
    // Thumb encoding (32): 0xF9000010
    // Test aarch32_VST2_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=0, align=1, Rm=0, Rn=0, D=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_align_3_max_800_f9000030() {
    // Thumb encoding (32): 0xF9000030
    // Test aarch32_VST2_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: type1=0, D=0, size=0, align=3, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rm_0_min_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, type1=0, size=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t1a1_a_field_rm_1_poweroftwo_800_f9000001() {
    // Thumb encoding (32): 0xF9000001
    // Test aarch32_VST2_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=1, D=0, size=0, type1=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_m_t1a1_a_combo_0_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, Rn=0, type1=0, D=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_0_size_variant_0_2048_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, align=0, size=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_1_size_variant_1_2048_f9000040() {
    // Thumb encoding (32): 0xF9000040
    // Test aarch32_VST2_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, size=1, align=0, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_2_size_variant_2_2048_f9000080() {
    // Thumb encoding (32): 0xF9000080
    // Test aarch32_VST2_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Rn=0, Rm=0, Vd=0, type1=0, size=2, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_m_t1a1_a_special_size_3_size_variant_3_2048_f90000c0() {
    // Thumb encoding (32): 0xF90000C0
    // Test aarch32_VST2_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: type1=0, Rm=0, size=3, align=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_0_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, type1=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_1_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, type1=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_2_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, Vd=0, align=0, Rn=0, Rm=0, size=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_3_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vd=0, type1=0, size=0, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_4_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Rm=0, type1=0, Rn=0, Vd=0, D=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t1a1_a_invalid_5_800_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST2_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: align=0, Vd=0, D=0, type1=0, size=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_d_0_min_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, align=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_d_1_max_300_f9400300() {
    // Thumb encoding (32): 0xF9400300
    // Test aarch32_VST2_m_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, D=1, align=0, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rn_0_min_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, align=0, size=0, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rn_1_poweroftwo_300_f9010300() {
    // Thumb encoding (32): 0xF9010300
    // Test aarch32_VST2_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=1, align=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_vd_0_min_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, align=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_vd_1_poweroftwo_300_f9001300() {
    // Thumb encoding (32): 0xF9001300
    // Test aarch32_VST2_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, align=0, Rn=0, Vd=1, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_0_min_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, size=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_1_poweroftwo_300_f9000340() {
    // Thumb encoding (32): 0xF9000340
    // Test aarch32_VST2_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, align=0, size=1, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_2_poweroftwo_300_f9000380() {
    // Thumb encoding (32): 0xF9000380
    // Test aarch32_VST2_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, Rm=0, Vd=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_size_3_max_300_f90003c0() {
    // Thumb encoding (32): 0xF90003C0
    // Test aarch32_VST2_m_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, align=0, size=3, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_align_0_min_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, Vd=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_align_1_poweroftwo_300_f9000310() {
    // Thumb encoding (32): 0xF9000310
    // Test aarch32_VST2_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=1, Rm=0, size=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_align_3_max_300_f9000330() {
    // Thumb encoding (32): 0xF9000330
    // Test aarch32_VST2_m_T2A2_A field align = 3 (Max)
    // ISET: T32
    // Fields: align=3, D=0, Rn=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000330;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rm_0_min_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_m_t2a2_a_field_rm_1_poweroftwo_300_f9000301() {
    // Thumb encoding (32): 0xF9000301
    // Test aarch32_VST2_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Rm=1, D=0, size=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_m_t2a2_a_combo_0_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Vd=0, align=0, Rn=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_0_size_variant_0_768_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, Rm=0, align=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_1_size_variant_1_768_f9000340() {
    // Thumb encoding (32): 0xF9000340
    // Test aarch32_VST2_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Rn=0, size=1, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_2_size_variant_2_768_f9000380() {
    // Thumb encoding (32): 0xF9000380
    // Test aarch32_VST2_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, align=0, Vd=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_m_t2a2_a_special_size_3_size_variant_3_768_f90003c0() {
    // Thumb encoding (32): 0xF90003C0
    // Test aarch32_VST2_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, D=0, align=0, Rm=0, size=3, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_0_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: size=0, align=0, D=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_1_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, Rn=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_2_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Rn=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_m_t2a2_a_invalid_3_300_f9000300() {
    // Thumb encoding (32): 0xF9000300
    // Test aarch32_VST2_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t1a1_a_store_0_f4010000() {
    // Test aarch32_VST2_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t1a1_a_store_1_f4010000() {
    // Test aarch32_VST2_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t2a2_a_store_0_f4010300() {
    // Test aarch32_VST2_m_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4010300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t2a2_a_store_1_f4010300() {
    // Test aarch32_VST2_m_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4010300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst2_m_t1a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst2_m_t1a1_a_t32_oracle_0_f9010802() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF9010802;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst2_m_t1a1_a_t32_oracle_1_f9010802() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010802;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst2_m_t1a1_a_t32_oracle_2_f9010802() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF9010802;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst2_m_t1a1_a_t32_oracle_3_f9010802() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF9010802;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t1a1_a_store_0_f9010000() {
    // Test aarch32_VST2_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t1a1_a_store_1_f9010000() {
    // Test aarch32_VST2_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst2_m_t2a2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst2_m_t2a2_a_t32_oracle_0_f9010302() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9010302;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst2_m_t2a2_a_t32_oracle_1_f9010302() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9010302;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst2_m_t2a2_a_t32_oracle_2_f9010302() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF9010302;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst2_m_t2a2_a_t32_oracle_3_f9010302() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF9010302;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t2a2_a_store_0_f9010300() {
    // Test aarch32_VST2_m_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_m_t2a2_a_store_1_f9010300() {
    // Test aarch32_VST2_m_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VSTR_A Tests
// ============================================================================

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_0_min_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, imm8=0, Vd=0, D=0, size=0, cond=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_1_poweroftwo_800_1d000800() {
    // Encoding: 0x1D000800
    // Test aarch32_VSTR_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm8=0, U=0, Rn=0, Vd=0, cond=1, size=0
    let encoding: u32 = 0x1D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_2_poweroftwo_800_2d000800() {
    // Encoding: 0x2D000800
    // Test aarch32_VSTR_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, Rn=0, Vd=0, D=0, cond=2, size=0, U=0
    let encoding: u32 = 0x2D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_3_poweroftwo_800_3d000800() {
    // Encoding: 0x3D000800
    // Test aarch32_VSTR_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=3, size=0, D=0, imm8=0, Vd=0
    let encoding: u32 = 0x3D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_4_poweroftwo_800_4d000800() {
    // Encoding: 0x4D000800
    // Test aarch32_VSTR_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, imm8=0, size=0, D=0, U=0, cond=4
    let encoding: u32 = 0x4D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_5_poweroftwo_800_5d000800() {
    // Encoding: 0x5D000800
    // Test aarch32_VSTR_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, cond=5, U=0, Rn=0, imm8=0
    let encoding: u32 = 0x5D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_6_poweroftwo_800_6d000800() {
    // Encoding: 0x6D000800
    // Test aarch32_VSTR_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, U=0, Rn=0, Vd=0, imm8=0, cond=6
    let encoding: u32 = 0x6D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_7_poweroftwo_800_7d000800() {
    // Encoding: 0x7D000800
    // Test aarch32_VSTR_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=7, Rn=0, D=0, Vd=0, imm8=0, size=0
    let encoding: u32 = 0x7D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_8_poweroftwo_800_8d000800() {
    // Encoding: 0x8D000800
    // Test aarch32_VSTR_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=8, Vd=0, Rn=0, imm8=0, U=0, size=0
    let encoding: u32 = 0x8D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_9_poweroftwo_800_9d000800() {
    // Encoding: 0x9D000800
    // Test aarch32_VSTR_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, U=0, Rn=0, size=0, cond=9, imm8=0
    let encoding: u32 = 0x9D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_10_poweroftwo_800_ad000800() {
    // Encoding: 0xAD000800
    // Test aarch32_VSTR_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, U=0, size=0, D=0, cond=10, Rn=0, imm8=0
    let encoding: u32 = 0xAD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_11_poweroftwo_800_bd000800() {
    // Encoding: 0xBD000800
    // Test aarch32_VSTR_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, Vd=0, imm8=0, size=0, U=0, D=0
    let encoding: u32 = 0xBD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_12_poweroftwo_800_cd000800() {
    // Encoding: 0xCD000800
    // Test aarch32_VSTR_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, imm8=0, D=0, cond=12, U=0, Rn=0
    let encoding: u32 = 0xCD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_13_poweroftwo_800_dd000800() {
    // Encoding: 0xDD000800
    // Test aarch32_VSTR_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, D=0, size=0, cond=13, Vd=0, imm8=0
    let encoding: u32 = 0xDD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_14_poweroftwo_800_ed000800() {
    // Encoding: 0xED000800
    // Test aarch32_VSTR_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=14, imm8=0, Rn=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xED000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vstr_a1_a_field_cond_15_max_800_fd000800() {
    // Encoding: 0xFD000800
    // Test aarch32_VSTR_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=15, D=0, Vd=0, size=0, imm8=0
    let encoding: u32 = 0xFD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstr_a1_a_field_u_0_min_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, D=0, size=0, imm8=0, cond=0, Vd=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstr_a1_a_field_u_1_max_800_0d800800() {
    // Encoding: 0x0D800800
    // Test aarch32_VSTR_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Vd=0, size=0, imm8=0, cond=0, D=0, Rn=0
    let encoding: u32 = 0x0D800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstr_a1_a_field_d_0_min_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, U=0, D=0, cond=0, imm8=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstr_a1_a_field_d_1_max_800_0d400800() {
    // Encoding: 0x0D400800
    // Test aarch32_VSTR_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: U=0, cond=0, D=1, imm8=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0x0D400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstr_a1_a_field_rn_0_min_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, D=0, cond=0, Vd=0, size=0, imm8=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstr_a1_a_field_rn_1_poweroftwo_800_0d010800() {
    // Encoding: 0x0D010800
    // Test aarch32_VSTR_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, size=0, U=0, cond=0, D=0, Vd=0, Rn=1
    let encoding: u32 = 0x0D010800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstr_a1_a_field_vd_0_min_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Vd=0, U=0, size=0, D=0, Rn=0, imm8=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstr_a1_a_field_vd_1_poweroftwo_800_0d001800() {
    // Encoding: 0x0D001800
    // Test aarch32_VSTR_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, Rn=0, size=0, imm8=0, cond=0, U=0, D=0
    let encoding: u32 = 0x0D001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vstr_a1_a_field_size_0_min_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: cond=0, size=0, Rn=0, U=0, imm8=0, Vd=0, D=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vstr_a1_a_field_size_1_poweroftwo_800_0d000900() {
    // Encoding: 0x0D000900
    // Test aarch32_VSTR_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, size=1, Rn=0, Vd=0, imm8=0, D=0, U=0
    let encoding: u32 = 0x0D000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vstr_a1_a_field_size_2_poweroftwo_800_0d000a00() {
    // Encoding: 0x0D000A00
    // Test aarch32_VSTR_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, U=0, cond=0, Vd=0, size=2, imm8=0, Rn=0
    let encoding: u32 = 0x0D000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vstr_a1_a_field_size_3_max_800_0d000b00() {
    // Encoding: 0x0D000B00
    // Test aarch32_VSTR_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, cond=0, U=0, Rn=0, size=3, imm8=0
    let encoding: u32 = 0x0D000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_0_zero_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: U=0, Vd=0, imm8=0, cond=0, Rn=0, D=0, size=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_1_poweroftwo_800_0d000801() {
    // Encoding: 0x0D000801
    // Test aarch32_VSTR_A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=0, Rn=0, Vd=0, imm8=1, size=0, U=0
    let encoding: u32 = 0x0D000801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_3_poweroftwominusone_800_0d000803() {
    // Encoding: 0x0D000803
    // Test aarch32_VSTR_A1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, cond=0, D=0, size=0, imm8=3, Rn=0, U=0
    let encoding: u32 = 0x0D000803;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_4_poweroftwo_800_0d000804() {
    // Encoding: 0x0D000804
    // Test aarch32_VSTR_A1_A field imm8 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vd=0, D=0, Rn=0, imm8=4, size=0, cond=0
    let encoding: u32 = 0x0D000804;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_7_poweroftwominusone_800_0d000807() {
    // Encoding: 0x0D000807
    // Test aarch32_VSTR_A1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm8=7, cond=0, Vd=0, U=0, D=0, size=0, Rn=0
    let encoding: u32 = 0x0D000807;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_8_poweroftwo_800_0d000808() {
    // Encoding: 0x0D000808
    // Test aarch32_VSTR_A1_A field imm8 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, imm8=8, U=0, Vd=0, cond=0
    let encoding: u32 = 0x0D000808;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_15_poweroftwominusone_800_0d00080f() {
    // Encoding: 0x0D00080F
    // Test aarch32_VSTR_A1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=15, cond=0, Vd=0, U=0, size=0
    let encoding: u32 = 0x0D00080F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_16_poweroftwo_800_0d000810() {
    // Encoding: 0x0D000810
    // Test aarch32_VSTR_A1_A field imm8 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Vd=0, D=0, U=0, imm8=16, size=0
    let encoding: u32 = 0x0D000810;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_31_poweroftwominusone_800_0d00081f() {
    // Encoding: 0x0D00081F
    // Test aarch32_VSTR_A1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Vd=0, U=0, D=0, Rn=0, size=0, imm8=31
    let encoding: u32 = 0x0D00081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_32_poweroftwo_800_0d000820() {
    // Encoding: 0x0D000820
    // Test aarch32_VSTR_A1_A field imm8 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, U=0, Rn=0, imm8=32, D=0, cond=0
    let encoding: u32 = 0x0D000820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_63_poweroftwominusone_800_0d00083f() {
    // Encoding: 0x0D00083F
    // Test aarch32_VSTR_A1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, size=0, imm8=63, cond=0, U=0, D=0, Rn=0
    let encoding: u32 = 0x0D00083F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_64_poweroftwo_800_0d000840() {
    // Encoding: 0x0D000840
    // Test aarch32_VSTR_A1_A field imm8 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, imm8=64, U=0, cond=0, Rn=0
    let encoding: u32 = 0x0D000840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_127_poweroftwominusone_800_0d00087f() {
    // Encoding: 0x0D00087F
    // Test aarch32_VSTR_A1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, D=0, imm8=127, U=0, cond=0, Rn=0, size=0
    let encoding: u32 = 0x0D00087F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_128_poweroftwo_800_0d000880() {
    // Encoding: 0x0D000880
    // Test aarch32_VSTR_A1_A field imm8 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, cond=0, size=0, D=0, imm8=128, U=0
    let encoding: u32 = 0x0D000880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vstr_a1_a_field_imm8_255_max_800_0d0008ff() {
    // Encoding: 0x0D0008FF
    // Test aarch32_VSTR_A1_A field imm8 = 255 (Max)
    // ISET: A32
    // Fields: imm8=255, U=0, Rn=0, size=0, cond=0, D=0, Vd=0
    let encoding: u32 = 0x0D0008FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vstr_a1_a_combo_0_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A field combination: cond=0, U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: A32
    // Fields: imm8=0, Vd=0, Rn=0, cond=0, size=0, D=0, U=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vstr_a1_a_special_cond_0_condition_eq_2048_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, imm8=0, cond=0, U=0, Vd=0, D=0, size=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vstr_a1_a_special_cond_1_condition_ne_2048_1d000800() {
    // Encoding: 0x1D000800
    // Test aarch32_VSTR_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=0, imm8=0, cond=1, U=0
    let encoding: u32 = 0x1D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vstr_a1_a_special_cond_2_condition_cs_hs_2048_2d000800() {
    // Encoding: 0x2D000800
    // Test aarch32_VSTR_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: size=0, D=0, imm8=0, Rn=0, cond=2, Vd=0, U=0
    let encoding: u32 = 0x2D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vstr_a1_a_special_cond_3_condition_cc_lo_2048_3d000800() {
    // Encoding: 0x3D000800
    // Test aarch32_VSTR_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, imm8=0, D=0, size=0, Vd=0, cond=3, U=0
    let encoding: u32 = 0x3D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vstr_a1_a_special_cond_4_condition_mi_2048_4d000800() {
    // Encoding: 0x4D000800
    // Test aarch32_VSTR_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, U=0, Vd=0, size=0, D=0, imm8=0, cond=4
    let encoding: u32 = 0x4D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vstr_a1_a_special_cond_5_condition_pl_2048_5d000800() {
    // Encoding: 0x5D000800
    // Test aarch32_VSTR_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, size=0, imm8=0, Vd=0, cond=5, D=0, Rn=0
    let encoding: u32 = 0x5D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vstr_a1_a_special_cond_6_condition_vs_2048_6d000800() {
    // Encoding: 0x6D000800
    // Test aarch32_VSTR_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm8=0, size=0, cond=6, U=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0x6D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vstr_a1_a_special_cond_7_condition_vc_2048_7d000800() {
    // Encoding: 0x7D000800
    // Test aarch32_VSTR_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: D=0, size=0, U=0, imm8=0, Vd=0, Rn=0, cond=7
    let encoding: u32 = 0x7D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vstr_a1_a_special_cond_8_condition_hi_2048_8d000800() {
    // Encoding: 0x8D000800
    // Test aarch32_VSTR_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, cond=8, Rn=0, Vd=0, imm8=0, size=0, D=0
    let encoding: u32 = 0x8D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vstr_a1_a_special_cond_9_condition_ls_2048_9d000800() {
    // Encoding: 0x9D000800
    // Test aarch32_VSTR_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, size=0, imm8=0, U=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0x9D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vstr_a1_a_special_cond_10_condition_ge_2048_ad000800() {
    // Encoding: 0xAD000800
    // Test aarch32_VSTR_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Vd=0, size=0, U=0, imm8=0, D=0, cond=10, Rn=0
    let encoding: u32 = 0xAD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vstr_a1_a_special_cond_11_condition_lt_2048_bd000800() {
    // Encoding: 0xBD000800
    // Test aarch32_VSTR_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Vd=0, cond=11, size=0, U=0, D=0, Rn=0, imm8=0
    let encoding: u32 = 0xBD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vstr_a1_a_special_cond_12_condition_gt_2048_cd000800() {
    // Encoding: 0xCD000800
    // Test aarch32_VSTR_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Vd=0, size=0, U=0, imm8=0, Rn=0, D=0, cond=12
    let encoding: u32 = 0xCD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vstr_a1_a_special_cond_13_condition_le_2048_dd000800() {
    // Encoding: 0xDD000800
    // Test aarch32_VSTR_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, D=0, Rn=0, Vd=0, size=0, imm8=0, U=0
    let encoding: u32 = 0xDD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vstr_a1_a_special_cond_14_condition_al_2048_ed000800() {
    // Encoding: 0xED000800
    // Test aarch32_VSTR_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Vd=0, size=0, imm8=0, Rn=0, U=0, cond=14, D=0
    let encoding: u32 = 0xED000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vstr_a1_a_special_cond_15_condition_nv_2048_fd000800() {
    // Encoding: 0xFD000800
    // Test aarch32_VSTR_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: size=0, D=0, cond=15, Rn=0, U=0, Vd=0, imm8=0
    let encoding: u32 = 0xFD000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vstr_a1_a_special_size_0_size_variant_0_2048_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, size=0, imm8=0, Rn=0, U=0, Vd=0, cond=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vstr_a1_a_special_size_1_size_variant_1_2048_0d000900() {
    // Encoding: 0x0D000900
    // Test aarch32_VSTR_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, cond=0, D=0, Rn=0, Vd=0, U=0, imm8=0
    let encoding: u32 = 0x0D000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vstr_a1_a_special_size_2_size_variant_2_2048_0d000a00() {
    // Encoding: 0x0D000A00
    // Test aarch32_VSTR_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, imm8=0, cond=0, Rn=0, D=0, Vd=0, U=0
    let encoding: u32 = 0x0D000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vstr_a1_a_special_size_3_size_variant_3_2048_0d000b00() {
    // Encoding: 0x0D000B00
    // Test aarch32_VSTR_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=0, U=0, cond=0, Vd=0, size=3
    let encoding: u32 = 0x0D000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstr_a1_a_invalid_0_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: imm8=0, cond=0, Rn=0, D=0, Vd=0, U=0, size=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstr_a1_a_invalid_1_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: cond=0, D=0, imm8=0, size=0, Rn=0, U=0, Vd=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }) } }, rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_a1_a_invalid_2_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: Vd=0, imm8=0, U=0, size=0, cond=0, D=0, Rn=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_a1_a_invalid_3_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, cond=0, U=0, imm8=0, D=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_a1_a_invalid_4_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) }
    // ISET: A32
    // Fields: cond=0, size=0, imm8=0, Rn=0, D=0, Vd=0, U=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_a1_a_invalid_5_800_0d000800() {
    // Encoding: 0x0D000800
    // Test aarch32_VSTR_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, cond=0, Vd=0, imm8=0, Rn=0, D=0, size=0
    let encoding: u32 = 0x0D000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstr_t1_a_field_u_0_min_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rn=0, size=0, Vd=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstr_t1_a_field_u_1_max_800_ed800800() {
    // Thumb encoding (32): 0xED800800
    // Test aarch32_VSTR_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, size=0, U=1, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstr_t1_a_field_d_0_min_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, U=0, size=0, D=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstr_t1_a_field_d_1_max_800_ed400800() {
    // Thumb encoding (32): 0xED400800
    // Test aarch32_VSTR_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, imm8=0, Rn=0, U=0, D=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstr_t1_a_field_rn_0_min_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, U=0, imm8=0, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstr_t1_a_field_rn_1_poweroftwo_800_ed010800() {
    // Thumb encoding (32): 0xED010800
    // Test aarch32_VSTR_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=1, imm8=0, U=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstr_t1_a_field_vd_0_min_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: U=0, size=0, D=0, Rn=0, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstr_t1_a_field_vd_1_poweroftwo_800_ed001800() {
    // Thumb encoding (32): 0xED001800
    // Test aarch32_VSTR_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=1, size=0, D=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED001800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vstr_t1_a_field_size_0_min_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, imm8=0, U=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vstr_t1_a_field_size_1_poweroftwo_800_ed000900() {
    // Thumb encoding (32): 0xED000900
    // Test aarch32_VSTR_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rn=0, D=0, imm8=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vstr_t1_a_field_size_2_poweroftwo_800_ed000a00() {
    // Thumb encoding (32): 0xED000A00
    // Test aarch32_VSTR_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Vd=0, size=2, imm8=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vstr_t1_a_field_size_3_max_800_ed000b00() {
    // Thumb encoding (32): 0xED000B00
    // Test aarch32_VSTR_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: imm8=0, U=0, Rn=0, Vd=0, D=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_0_zero_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, Vd=0, D=0, Rn=0, imm8=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_1_poweroftwo_800_ed000801() {
    // Thumb encoding (32): 0xED000801
    // Test aarch32_VSTR_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=0, imm8=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_3_poweroftwominusone_800_ed000803() {
    // Thumb encoding (32): 0xED000803
    // Test aarch32_VSTR_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, imm8=3, Rn=0, U=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_4_poweroftwo_800_ed000804() {
    // Thumb encoding (32): 0xED000804
    // Test aarch32_VSTR_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, imm8=4, Rn=0, size=0, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_7_poweroftwominusone_800_ed000807() {
    // Thumb encoding (32): 0xED000807
    // Test aarch32_VSTR_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, D=0, U=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_8_poweroftwo_800_ed000808() {
    // Thumb encoding (32): 0xED000808
    // Test aarch32_VSTR_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=0, imm8=8, U=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_15_poweroftwominusone_800_ed00080f() {
    // Thumb encoding (32): 0xED00080F
    // Test aarch32_VSTR_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, U=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED00080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_16_poweroftwo_800_ed000810() {
    // Thumb encoding (32): 0xED000810
    // Test aarch32_VSTR_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Vd=0, size=0, Rn=0, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_31_poweroftwominusone_800_ed00081f() {
    // Thumb encoding (32): 0xED00081F
    // Test aarch32_VSTR_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, U=0, Vd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED00081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_32_poweroftwo_800_ed000820() {
    // Thumb encoding (32): 0xED000820
    // Test aarch32_VSTR_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rn=0, imm8=32, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_63_poweroftwominusone_800_ed00083f() {
    // Thumb encoding (32): 0xED00083F
    // Test aarch32_VSTR_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, imm8=63, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED00083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_64_poweroftwo_800_ed000840() {
    // Thumb encoding (32): 0xED000840
    // Test aarch32_VSTR_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, D=0, imm8=64, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_127_poweroftwominusone_800_ed00087f() {
    // Thumb encoding (32): 0xED00087F
    // Test aarch32_VSTR_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, D=0, imm8=127, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED00087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_128_poweroftwo_800_ed000880() {
    // Thumb encoding (32): 0xED000880
    // Test aarch32_VSTR_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, imm8=128, U=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vstr_t1_a_field_imm8_255_max_800_ed0008ff() {
    // Thumb encoding (32): 0xED0008FF
    // Test aarch32_VSTR_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: U=0, Vd=0, size=0, D=0, Rn=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED0008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vstr_t1_a_combo_0_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A field combination: U=0, D=0, Rn=0, Vd=0, size=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, U=0, D=0, Rn=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vstr_t1_a_special_size_0_size_variant_0_2048_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, U=0, imm8=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vstr_t1_a_special_size_1_size_variant_1_2048_ed000900() {
    // Thumb encoding (32): 0xED000900
    // Test aarch32_VSTR_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, U=0, Rn=0, Vd=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vstr_t1_a_special_size_2_size_variant_2_2048_ed000a00() {
    // Thumb encoding (32): 0xED000A00
    // Test aarch32_VSTR_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: U=0, Rn=0, Vd=0, D=0, size=2, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vstr_t1_a_special_size_3_size_variant_3_2048_ed000b00() {
    // Thumb encoding (32): 0xED000B00
    // Test aarch32_VSTR_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, imm8=0, U=0, size=3, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstr_t1_a_invalid_0_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: size=0, Vd=0, U=0, imm8=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstr_t1_a_invalid_1_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Rn=0, U=0, Vd=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_t1_a_invalid_2_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: D=0, Vd=0, imm8=0, Rn=0, size=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_t1_a_invalid_3_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, Vd=0, Rn=0, D=0, size=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_t1_a_invalid_4_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) }
    // ISET: T32
    // Fields: D=0, imm8=0, size=0, Vd=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstr_t1_a_invalid_5_800_ed000800() {
    // Thumb encoding (32): 0xED000800
    // Test aarch32_VSTR_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, imm8=0, size=0, Rn=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_a1_a_store_0_0d010800() {
    // Test aarch32_VSTR_A1_A memory store: 8 bytes
    // Encoding: 0x0D010800
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0D010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_a1_a_store_1_0d010800() {
    // Test aarch32_VSTR_A1_A memory store: 8 bytes
    // Encoding: 0x0D010800
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0D010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_a1_a_store_2_0d010800() {
    // Test aarch32_VSTR_A1_A memory store: 8 bytes
    // Encoding: 0x0D010800
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0D010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_a1_a_store_3_0d010800() {
    // Test aarch32_VSTR_A1_A memory store: 8 bytes
    // Encoding: 0x0D010800
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0D010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_t1_a_store_0_ed010800() {
    // Test aarch32_VSTR_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xED010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_t1_a_store_1_ed010800() {
    // Test aarch32_VSTR_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xED010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_t1_a_store_2_ed010800() {
    // Test aarch32_VSTR_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xED010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTR_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstr_t1_a_store_3_ed010800() {
    // Test aarch32_VSTR_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xED010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST3_m_A Tests
// ============================================================================

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_d_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, D=0, align=0, Vd=0, Rn=0, type1=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_d_1_max_400_f4400000() {
    // Encoding: 0xF4400000
    // Test aarch32_VST3_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, align=0, Rm=0, D=1, type1=0
    let encoding: u32 = 0xF4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rn_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, align=0, Rm=0, D=0, type1=0, size=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rn_1_poweroftwo_400_f4010000() {
    // Encoding: 0xF4010000
    // Test aarch32_VST3_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, align=0, D=0, size=0, Rm=0, Rn=1, Vd=0
    let encoding: u32 = 0xF4010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_vd_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, type1=0, size=0, align=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_vd_1_poweroftwo_400_f4001000() {
    // Encoding: 0xF4001000
    // Test aarch32_VST3_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=1, D=0, size=0, align=0, type1=0
    let encoding: u32 = 0xF4001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: align=0, type1=0, D=0, Rm=0, size=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_1_poweroftwo_400_f4000100() {
    // Encoding: 0xF4000100
    // Test aarch32_VST3_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=1, Vd=0, D=0, align=0, size=0
    let encoding: u32 = 0xF4000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_7_poweroftwominusone_400_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST3_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: align=0, Rn=0, D=0, Vd=0, size=0, type1=7, Rm=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_15_max_400_f4000f00() {
    // Encoding: 0xF4000F00
    // Test aarch32_VST3_m_T1A1_A field type1 = 15 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, Rm=0, type1=15, Rn=0, align=0
    let encoding: u32 = 0xF4000F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, align=0, Rm=0, Rn=0, D=0, type1=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_1_poweroftwo_400_f4000040() {
    // Encoding: 0xF4000040
    // Test aarch32_VST3_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, align=0, type1=0, size=1, Rm=0, Rn=0
    let encoding: u32 = 0xF4000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_2_poweroftwo_400_f4000080() {
    // Encoding: 0xF4000080
    // Test aarch32_VST3_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, align=0, Rm=0, Vd=0, D=0, type1=0, size=2
    let encoding: u32 = 0xF4000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_3_max_400_f40000c0() {
    // Encoding: 0xF40000C0
    // Test aarch32_VST3_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Vd=0, D=0, type1=0, size=3, align=0
    let encoding: u32 = 0xF40000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_align_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, align=0, D=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_align_1_poweroftwo_400_f4000010() {
    // Encoding: 0xF4000010
    // Test aarch32_VST3_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=0, type1=0, Vd=0, align=1, D=0, Rm=0
    let encoding: u32 = 0xF4000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_align_3_max_400_f4000030() {
    // Encoding: 0xF4000030
    // Test aarch32_VST3_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: align=3, Rn=0, type1=0, size=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4000030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rm_0_min_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, align=0, Rn=0, D=0, type1=0, size=0, Vd=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rm_1_poweroftwo_400_f4000001() {
    // Encoding: 0xF4000001
    // Test aarch32_VST3_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, type1=0, align=0, Rm=1, Vd=0
    let encoding: u32 = 0xF4000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_m_t1a1_a_combo_0_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, D=0, Vd=0, type1=0, align=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_0_size_variant_0_1024_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: align=0, Rm=0, type1=0, Rn=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_1_size_variant_1_1024_f4000040() {
    // Encoding: 0xF4000040
    // Test aarch32_VST3_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, type1=0, D=0, align=0, size=1
    let encoding: u32 = 0xF4000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_2_size_variant_2_1024_f4000080() {
    // Encoding: 0xF4000080
    // Test aarch32_VST3_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, type1=0, size=2, align=0, Vd=0
    let encoding: u32 = 0xF4000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_3_size_variant_3_1024_f40000c0() {
    // Encoding: 0xF40000C0
    // Test aarch32_VST3_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, size=3, Rm=0, type1=0, D=0
    let encoding: u32 = 0xF40000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_0_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, align=0, Rn=0, Vd=0, type1=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_1_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, D=0, Rm=0, align=0, type1=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_2_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Rm=0, type1=0, size=0, align=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_3_400_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, size=0, Vd=0, align=0, D=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_d_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Rm=0, size=0, type1=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_d_1_max_400_f9400000() {
    // Thumb encoding (32): 0xF9400000
    // Test aarch32_VST3_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, Vd=0, Rn=0, size=0, type1=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rn_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, type1=0, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rn_1_poweroftwo_400_f9010000() {
    // Thumb encoding (32): 0xF9010000
    // Test aarch32_VST3_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, align=0, Rn=1, type1=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_vd_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: align=0, D=0, Rn=0, size=0, Rm=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_vd_1_poweroftwo_400_f9001000() {
    // Thumb encoding (32): 0xF9001000
    // Test aarch32_VST3_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, type1=0, size=0, Vd=1, align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, align=0, Rn=0, Rm=0, D=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_1_poweroftwo_400_f9000100() {
    // Thumb encoding (32): 0xF9000100
    // Test aarch32_VST3_m_T1A1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, type1=1, D=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_7_poweroftwominusone_400_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST3_m_T1A1_A field type1 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, type1=7, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field type1 8 +: 4`
/// Requirement: FieldBoundary { field: "type1", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_type1_15_max_400_f9000f00() {
    // Thumb encoding (32): 0xF9000F00
    // Test aarch32_VST3_m_T1A1_A field type1 = 15 (Max)
    // ISET: T32
    // Fields: align=0, Rn=0, Vd=0, size=0, D=0, type1=15, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: align=0, Rm=0, Vd=0, D=0, Rn=0, type1=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_1_poweroftwo_400_f9000040() {
    // Thumb encoding (32): 0xF9000040
    // Test aarch32_VST3_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, align=0, Vd=0, Rm=0, D=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_2_poweroftwo_400_f9000080() {
    // Thumb encoding (32): 0xF9000080
    // Test aarch32_VST3_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, size=2, align=0, Rm=0, Rn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_size_3_max_400_f90000c0() {
    // Thumb encoding (32): 0xF90000C0
    // Test aarch32_VST3_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, type1=0, size=3, Rn=0, Vd=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_align_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_align_1_poweroftwo_400_f9000010() {
    // Thumb encoding (32): 0xF9000010
    // Test aarch32_VST3_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, align=1, type1=0, Rn=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_align_3_max_400_f9000030() {
    // Thumb encoding (32): 0xF9000030
    // Test aarch32_VST3_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: size=0, align=3, Rn=0, Rm=0, D=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rm_0_min_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: align=0, Rm=0, size=0, type1=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_m_t1a1_a_field_rm_1_poweroftwo_400_f9000001() {
    // Thumb encoding (32): 0xF9000001
    // Test aarch32_VST3_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rm=1, Rn=0, type1=0, size=0, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_m_t1a1_a_combo_0_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A field combination: D=0, Rn=0, Vd=0, type1=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, D=0, Rn=0, size=0, Vd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_0_size_variant_0_1024_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, align=0, Vd=0, size=0, D=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_1_size_variant_1_1024_f9000040() {
    // Thumb encoding (32): 0xF9000040
    // Test aarch32_VST3_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: align=0, Rm=0, Vd=0, Rn=0, type1=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_2_size_variant_2_1024_f9000080() {
    // Thumb encoding (32): 0xF9000080
    // Test aarch32_VST3_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, type1=0, size=2, Rn=0, Vd=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_m_t1a1_a_special_size_3_size_variant_3_1024_f90000c0() {
    // Thumb encoding (32): 0xF90000C0
    // Test aarch32_VST3_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, align=0, size=3, Rm=0, Vd=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_0_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: size=0, type1=0, Vd=0, Rn=0, align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_1_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, size=0, type1=0, D=0, Rn=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_2_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: align=0, Vd=0, Rn=0, D=0, size=0, Rm=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_m_t1a1_a_invalid_3_400_f9000000() {
    // Thumb encoding (32): 0xF9000000
    // Test aarch32_VST3_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, type1=0, Vd=0, size=0, align=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_m_t1a1_a_store_0_f4010000() {
    // Test aarch32_VST3_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_m_t1a1_a_store_1_f4010000() {
    // Test aarch32_VST3_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_m_t1a1_a_store_2_f4010000() {
    // Test aarch32_VST3_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst3_m_t1a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst3_m_t1a1_a_t32_oracle_0_f9010402() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF9010402;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst3_m_t1a1_a_t32_oracle_1_f9010402() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9010402;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst3_m_t1a1_a_t32_oracle_2_f9010402() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF9010402;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst3_m_t1a1_a_t32_oracle_3_f9010402() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF9010402;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_m_t1a1_a_store_0_f9010000() {
    // Test aarch32_VST3_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_m_t1a1_a_store_1_f9010000() {
    // Test aarch32_VST3_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_m_t1a1_a_store_2_f9010000() {
    // Test aarch32_VST3_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VSTM_A Tests
// ============================================================================

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, cond=0, P=0, Rn=0, imm8=0, U=0, D=0, W=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_1_poweroftwo_b01_1c000b01() {
    // Encoding: 0x1C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=0, cond=1, P=0, W=0, Vd=0, U=0
    let encoding: u32 = 0x1C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_2_poweroftwo_b01_2c000b01() {
    // Encoding: 0x2C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm8=0, cond=2, P=0, W=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0x2C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_3_poweroftwo_b01_3c000b01() {
    // Encoding: 0x3C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=3, P=0, U=0, D=0, imm8=0, Rn=0, Vd=0
    let encoding: u32 = 0x3C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_4_poweroftwo_b01_4c000b01() {
    // Encoding: 0x4C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, D=0, W=0, cond=4, Vd=0, P=0, imm8=0
    let encoding: u32 = 0x4C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_5_poweroftwo_b01_5c000b01() {
    // Encoding: 0x5C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, cond=5, U=0, imm8=0, Rn=0, W=0, P=0, D=0
    let encoding: u32 = 0x5C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_6_poweroftwo_b01_6c000b01() {
    // Encoding: 0x6C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, P=0, Rn=0, imm8=0, Vd=0, D=0, W=0
    let encoding: u32 = 0x6C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_7_poweroftwo_b01_7c000b01() {
    // Encoding: 0x7C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, U=0, D=0, W=0, cond=7, Vd=0, Rn=0, P=0
    let encoding: u32 = 0x7C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_8_poweroftwo_b01_8c000b01() {
    // Encoding: 0x8C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vd=0, D=0, Rn=0, cond=8, P=0, W=0, imm8=0
    let encoding: u32 = 0x8C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_9_poweroftwo_b01_9c000b01() {
    // Encoding: 0x9C000B01
    // Test aarch32_VSTM_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, cond=9, W=0, imm8=0, P=0, D=0
    let encoding: u32 = 0x9C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_10_poweroftwo_b01_ac000b01() {
    // Encoding: 0xAC000B01
    // Test aarch32_VSTM_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, U=0, W=0, Vd=0, cond=10, Rn=0, P=0, imm8=0
    let encoding: u32 = 0xAC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_11_poweroftwo_b01_bc000b01() {
    // Encoding: 0xBC000B01
    // Test aarch32_VSTM_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm8=0, P=0, W=0, U=0, cond=11, Vd=0, D=0
    let encoding: u32 = 0xBC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_12_poweroftwo_b01_cc000b01() {
    // Encoding: 0xCC000B01
    // Test aarch32_VSTM_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, W=0, P=0, Rn=0, imm8=0, cond=12, U=0, D=0
    let encoding: u32 = 0xCC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_13_poweroftwo_b01_dc000b01() {
    // Encoding: 0xDC000B01
    // Test aarch32_VSTM_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm8=0, U=0, D=0, Vd=0, W=0, cond=13, Rn=0
    let encoding: u32 = 0xDC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_14_poweroftwo_b01_ec000b01() {
    // Encoding: 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, W=0, Rn=0, Vd=0, U=0, P=0, cond=14, imm8=0
    let encoding: u32 = 0xEC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_15_max_b01_fc000b01() {
    // Encoding: 0xFC000B01
    // Test aarch32_VSTM_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, P=0, cond=15, Rn=0, W=0, imm8=0, D=0, U=0
    let encoding: u32 = 0xFC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, Vd=0, imm8=0, P=0, D=0, U=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_1_max_b01_0d000b01() {
    // Encoding: 0x0D000B01
    // Test aarch32_VSTM_T1A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: U=0, P=1, cond=0, Rn=0, Vd=0, imm8=0, W=0, D=0
    let encoding: u32 = 0x0D000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: P=0, D=0, W=0, Rn=0, imm8=0, cond=0, Vd=0, U=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_1_max_b01_0c800b01() {
    // Encoding: 0x0C800B01
    // Test aarch32_VSTM_T1A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Vd=0, U=1, imm8=0, Rn=0, D=0
    let encoding: u32 = 0x0C800B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: U=0, W=0, Vd=0, cond=0, imm8=0, Rn=0, P=0, D=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_1_max_b01_0c400b01() {
    // Encoding: 0x0C400B01
    // Test aarch32_VSTM_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: cond=0, P=0, D=1, Rn=0, W=0, U=0, Vd=0, imm8=0
    let encoding: u32 = 0x0C400B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, U=0, W=0, imm8=0, Rn=0, D=0, P=0, cond=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_1_max_b01_0c200b01() {
    // Encoding: 0x0C200B01
    // Test aarch32_VSTM_T1A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, W=1, Vd=0, D=0, imm8=0, P=0, U=0
    let encoding: u32 = 0x0C200B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, Vd=0, imm8=0, Rn=0, P=0, cond=0, W=0, D=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_1_poweroftwo_b01_0c010b01() {
    // Encoding: 0x0C010B01
    // Test aarch32_VSTM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, P=0, cond=0, D=0, Rn=1, U=0, W=0, Vd=0
    let encoding: u32 = 0x0C010B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_0_min_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm8=0, D=0, W=0, P=0, Vd=0, U=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_1_poweroftwo_b01_0c001b01() {
    // Encoding: 0x0C001B01
    // Test aarch32_VSTM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, D=0, imm8=0, cond=0, P=0, Vd=1, Rn=0
    let encoding: u32 = 0x0C001B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_0_zero_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: imm8=0, Vd=0, P=0, W=0, cond=0, Rn=0, U=0, D=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_1_poweroftwo_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=1, Rn=0, D=0, U=0, P=0, cond=0, W=0, Vd=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vstm_t1a1_a_combo_0_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: P=0, W=0, Vd=0, D=0, cond=0, U=0, imm8=0, Rn=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_0_condition_eq_2817_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: W=0, imm8=0, P=0, Rn=0, cond=0, U=0, D=0, Vd=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_1_condition_ne_2817_1c000b01() {
    // Encoding: 0x1C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: D=0, U=0, imm8=0, Vd=0, cond=1, Rn=0, P=0, W=0
    let encoding: u32 = 0x1C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_2_condition_cs_hs_2817_2c000b01() {
    // Encoding: 0x2C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm8=0, P=0, Vd=0, Rn=0, U=0, cond=2, W=0, D=0
    let encoding: u32 = 0x2C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_3_condition_cc_lo_2817_3c000b01() {
    // Encoding: 0x3C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, D=0, imm8=0, Vd=0, P=0, U=0, W=0, cond=3
    let encoding: u32 = 0x3C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_4_condition_mi_2817_4c000b01() {
    // Encoding: 0x4C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, P=0, U=0, Rn=0, W=0, D=0, imm8=0, Vd=0
    let encoding: u32 = 0x4C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_5_condition_pl_2817_5c000b01() {
    // Encoding: 0x5C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, P=0, imm8=0, W=0, Rn=0, D=0, Vd=0, cond=5
    let encoding: u32 = 0x5C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_6_condition_vs_2817_6c000b01() {
    // Encoding: 0x6C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Vd=0, imm8=0, cond=6, D=0, P=0, W=0, U=0, Rn=0
    let encoding: u32 = 0x6C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_7_condition_vc_2817_7c000b01() {
    // Encoding: 0x7C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: D=0, Rn=0, W=0, imm8=0, P=0, Vd=0, cond=7, U=0
    let encoding: u32 = 0x7C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_8_condition_hi_2817_8c000b01() {
    // Encoding: 0x8C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, W=0, imm8=0, D=0, Vd=0, cond=8
    let encoding: u32 = 0x8C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_9_condition_ls_2817_9c000b01() {
    // Encoding: 0x9C000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: D=0, Rn=0, P=0, cond=9, W=0, imm8=0, Vd=0, U=0
    let encoding: u32 = 0x9C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_10_condition_ge_2817_ac000b01() {
    // Encoding: 0xAC000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, D=0, Rn=0, imm8=0, P=0, cond=10, Vd=0, W=0
    let encoding: u32 = 0xAC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_11_condition_lt_2817_bc000b01() {
    // Encoding: 0xBC000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: D=0, P=0, W=0, U=0, Rn=0, imm8=0, cond=11, Vd=0
    let encoding: u32 = 0xBC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_12_condition_gt_2817_cc000b01() {
    // Encoding: 0xCC000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Vd=0, imm8=0, U=0, Rn=0, P=0, W=0, cond=12, D=0
    let encoding: u32 = 0xCC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_13_condition_le_2817_dc000b01() {
    // Encoding: 0xDC000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, P=0, imm8=0, Vd=0, U=0, Rn=0, W=0, D=0
    let encoding: u32 = 0xDC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_14_condition_al_2817_ec000b01() {
    // Encoding: 0xEC000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, D=0, Vd=0, P=0, Rn=0, W=0, imm8=0, cond=14
    let encoding: u32 = 0xEC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_15_condition_nv_2817_fc000b01() {
    // Encoding: 0xFC000B01
    // Test aarch32_VSTM_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: D=0, imm8=0, W=0, U=0, Rn=0, Vd=0, P=0, cond=15
    let encoding: u32 = 0xFC000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_0_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, imm8=0, D=0, U=0, cond=0, Vd=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_1_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, cond=0, P=0, W=0, Vd=0, Rn=0, U=0, imm8=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_2_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, W=0, Vd=0, D=0, cond=0, imm8=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_3_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, D=0, Vd=0, imm8=0, cond=0, U=0, Rn=0, P=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_4_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: A32
    // Fields: D=0, Vd=0, U=0, P=0, Rn=0, cond=0, W=0, imm8=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_5_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, Rn=0, U=0, imm8=0, W=0, cond=0, Vd=0, D=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_6_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: A32
    // Fields: imm8=0, P=0, Rn=0, Vd=0, cond=0, U=0, D=0, W=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_7_b01_0c000b01() {
    // Encoding: 0x0C000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, W=0, cond=0, P=0, U=0, imm8=0
    let encoding: u32 = 0x0C000B01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_0_min_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field P = 0 (Min)
    // ISET: T32
    // Fields: U=0, P=0, imm8=0, Rn=0, D=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_1_max_b01_ed000b01() {
    // Thumb encoding (32): 0xED000B01
    // Test aarch32_VSTM_T1A1_A field P = 1 (Max)
    // ISET: T32
    // Fields: P=1, imm8=0, Vd=0, D=0, W=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_0_min_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, P=0, D=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_1_max_b01_ec800b01() {
    // Thumb encoding (32): 0xEC800B01
    // Test aarch32_VSTM_T1A1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, W=0, D=0, Vd=0, P=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC800B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_0_min_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: P=0, D=0, W=0, imm8=0, Rn=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_1_max_b01_ec400b01() {
    // Thumb encoding (32): 0xEC400B01
    // Test aarch32_VSTM_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: U=0, Vd=0, D=1, W=0, P=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_0_min_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, Rn=0, U=0, Vd=0, P=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_1_max_b01_ec200b01() {
    // Thumb encoding (32): 0xEC200B01
    // Test aarch32_VSTM_T1A1_A field W = 1 (Max)
    // ISET: T32
    // Fields: P=0, imm8=0, W=1, D=0, Rn=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC200B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_0_min_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, W=0, U=0, P=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_1_poweroftwo_b01_ec010b01() {
    // Thumb encoding (32): 0xEC010B01
    // Test aarch32_VSTM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Vd=0, imm8=0, W=0, P=0, U=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_0_min_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, U=0, D=0, P=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_1_poweroftwo_b01_ec001b01() {
    // Thumb encoding (32): 0xEC001B01
    // Test aarch32_VSTM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, P=0, imm8=0, W=0, U=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC001B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_0_zero_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, D=0, W=0, imm8=0, P=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_1_poweroftwo_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, U=0, D=0, Vd=0, P=0, imm8=1, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vstm_t1a1_a_combo_0_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, D=0, W=0, imm8=0, Vd=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_0_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, Vd=0, imm8=0, U=0, P=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_1_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm8=0, D=0, W=0, P=0, Vd=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_2_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: T32
    // Fields: P=0, Vd=0, Rn=0, imm8=0, D=0, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_3_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, imm8=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_4_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, U=0, D=0, P=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_5_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, P=0, imm8=0, Rn=0, D=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_6_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: T32
    // Fields: Vd=0, P=0, U=0, imm8=0, W=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_7_b01_ec000b01() {
    // Thumb encoding (32): 0xEC000B01
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, U=0, W=0, Rn=0, Vd=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B01;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_0_0c010b01() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // Encoding: 0x0C010B01
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0C010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_1_0c010b01() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // Encoding: 0x0C010B01
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0C010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_2_0c010b01() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // Encoding: 0x0C010B01
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0C010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_0_ec010b01() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_1_ec010b01() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_2_ec010b01() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010B01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST1_m_A Tests
// ============================================================================

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_d_0_min_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_d_1_max_700_f4400700() {
    // Encoding: 0xF4400700
    // Test aarch32_VST1_m_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, size=0, Vd=0, Rn=0, Rm=0, align=0
    let encoding: u32 = 0xF4400700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rn_0_min_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, Rn=0, D=0, align=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rn_1_poweroftwo_700_f4010700() {
    // Encoding: 0xF4010700
    // Test aarch32_VST1_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rm=0, align=0, Rn=1
    let encoding: u32 = 0xF4010700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_vd_0_min_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, align=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_vd_1_poweroftwo_700_f4001700() {
    // Encoding: 0xF4001700
    // Test aarch32_VST1_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, align=0, Vd=1, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4001700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_0_min_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, align=0, Rn=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_1_poweroftwo_700_f4000740() {
    // Encoding: 0xF4000740
    // Test aarch32_VST1_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, align=0, D=0, Rm=0, Vd=0, size=1
    let encoding: u32 = 0xF4000740;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_2_poweroftwo_700_f4000780() {
    // Encoding: 0xF4000780
    // Test aarch32_VST1_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=2, Rn=0, Vd=0, align=0, Rm=0
    let encoding: u32 = 0xF4000780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_3_max_700_f40007c0() {
    // Encoding: 0xF40007C0
    // Test aarch32_VST1_m_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Vd=0, align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF40007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_align_0_min_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field align = 0 (Min)
    // ISET: A32
    // Fields: align=0, Vd=0, Rm=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_align_1_poweroftwo_700_f4000710() {
    // Encoding: 0xF4000710
    // Test aarch32_VST1_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, Rm=0, D=0, align=1
    let encoding: u32 = 0xF4000710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_align_3_max_700_f4000730() {
    // Encoding: 0xF4000730
    // Test aarch32_VST1_m_T1A1_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, align=3, Vd=0, D=0
    let encoding: u32 = 0xF4000730;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rm_0_min_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rm_1_poweroftwo_700_f4000701() {
    // Encoding: 0xF4000701
    // Test aarch32_VST1_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, Vd=0, align=0, Rm=1
    let encoding: u32 = 0xF4000701;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t1a1_a_combo_0_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, align=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_0_size_variant_0_1792_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, align=0, size=0, Vd=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_1_size_variant_1_1792_f4000740() {
    // Encoding: 0xF4000740
    // Test aarch32_VST1_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=1, align=0
    let encoding: u32 = 0xF4000740;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_2_size_variant_2_1792_f4000780() {
    // Encoding: 0xF4000780
    // Test aarch32_VST1_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=2, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4000780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_3_size_variant_3_1792_f40007c0() {
    // Encoding: 0xF40007C0
    // Test aarch32_VST1_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: align=0, Rm=0, Rn=0, Vd=0, D=0, size=3
    let encoding: u32 = 0xF40007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_0_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rm=0, align=0, size=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_1_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, size=0, D=0, align=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_2_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: size=0, align=0, Rn=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_3_700_f4000700() {
    // Encoding: 0xF4000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, align=0, Rm=0, D=0
    let encoding: u32 = 0xF4000700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_d_0_min_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, align=0, Vd=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_d_1_max_a00_f4400a00() {
    // Encoding: 0xF4400A00
    // Test aarch32_VST1_m_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: align=0, Vd=0, D=1, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4400A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rn_0_min_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, size=0, align=0, Vd=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rn_1_poweroftwo_a00_f4010a00() {
    // Encoding: 0xF4010A00
    // Test aarch32_VST1_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, align=0, Rm=0, Vd=0, Rn=1
    let encoding: u32 = 0xF4010A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_vd_0_min_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_vd_1_poweroftwo_a00_f4001a00() {
    // Encoding: 0xF4001A00
    // Test aarch32_VST1_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, Vd=1, align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4001A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_0_min_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, Rm=0, size=0, align=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_1_poweroftwo_a00_f4000a40() {
    // Encoding: 0xF4000A40
    // Test aarch32_VST1_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: align=0, Rm=0, Vd=0, D=0, Rn=0, size=1
    let encoding: u32 = 0xF4000A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_2_poweroftwo_a00_f4000a80() {
    // Encoding: 0xF4000A80
    // Test aarch32_VST1_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, size=2, Rn=0, align=0, Rm=0
    let encoding: u32 = 0xF4000A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_3_max_a00_f4000ac0() {
    // Encoding: 0xF4000AC0
    // Test aarch32_VST1_m_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: align=0, D=0, size=3, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000AC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_align_0_min_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, align=0, D=0, Vd=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_align_1_poweroftwo_a00_f4000a10() {
    // Encoding: 0xF4000A10
    // Test aarch32_VST1_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, align=1, D=0, Rn=0
    let encoding: u32 = 0xF4000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_align_3_max_a00_f4000a30() {
    // Encoding: 0xF4000A30
    // Test aarch32_VST1_m_T2A2_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, size=0, align=3, D=0
    let encoding: u32 = 0xF4000A30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rm_0_min_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, align=0, size=0, Rm=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rm_1_poweroftwo_a00_f4000a01() {
    // Encoding: 0xF4000A01
    // Test aarch32_VST1_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=1, Vd=0, align=0, size=0, Rn=0
    let encoding: u32 = 0xF4000A01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t2a2_a_combo_0_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, D=0, align=0, Vd=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_0_size_variant_0_2560_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_1_size_variant_1_2560_f4000a40() {
    // Encoding: 0xF4000A40
    // Test aarch32_VST1_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, D=0, size=1, Rm=0
    let encoding: u32 = 0xF4000A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_2_size_variant_2_2560_f4000a80() {
    // Encoding: 0xF4000A80
    // Test aarch32_VST1_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=2, align=0
    let encoding: u32 = 0xF4000A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_3_size_variant_3_2560_f4000ac0() {
    // Encoding: 0xF4000AC0
    // Test aarch32_VST1_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, align=0, Rm=0, D=0, Rn=0, size=3
    let encoding: u32 = 0xF4000AC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_0_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: size=0, Vd=0, align=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_1_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, align=0, Rm=0, size=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_2_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: size=0, Vd=0, align=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_3_a00_f4000a00() {
    // Encoding: 0xF4000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: align=0, Rn=0, D=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_d_0_min_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, align=0, D=0, Vd=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_d_1_max_600_f4400600() {
    // Encoding: 0xF4400600
    // Test aarch32_VST1_m_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, Rm=0, D=1, align=0
    let encoding: u32 = 0xF4400600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rn_0_min_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, Rn=0, D=0, align=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rn_1_poweroftwo_600_f4010600() {
    // Encoding: 0xF4010600
    // Test aarch32_VST1_m_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, align=0, Rm=0, Vd=0, Rn=1
    let encoding: u32 = 0xF4010600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_vd_0_min_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_vd_1_poweroftwo_600_f4001600() {
    // Encoding: 0xF4001600
    // Test aarch32_VST1_m_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Rm=0, align=0, Rn=0, Vd=1
    let encoding: u32 = 0xF4001600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_0_min_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_1_poweroftwo_600_f4000640() {
    // Encoding: 0xF4000640
    // Test aarch32_VST1_m_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=1, Rm=0, Vd=0, Rn=0, align=0
    let encoding: u32 = 0xF4000640;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_2_poweroftwo_600_f4000680() {
    // Encoding: 0xF4000680
    // Test aarch32_VST1_m_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, Rm=0, size=2, align=0
    let encoding: u32 = 0xF4000680;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_3_max_600_f40006c0() {
    // Encoding: 0xF40006C0
    // Test aarch32_VST1_m_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, size=3, D=0, Rn=0, align=0, Vd=0
    let encoding: u32 = 0xF40006C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_align_0_min_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_align_1_poweroftwo_600_f4000610() {
    // Encoding: 0xF4000610
    // Test aarch32_VST1_m_T3A3_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, align=1, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4000610;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_align_3_max_600_f4000630() {
    // Encoding: 0xF4000630
    // Test aarch32_VST1_m_T3A3_A field align = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, Vd=0, align=3, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4000630;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rm_0_min_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, align=0, Rn=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rm_1_poweroftwo_600_f4000601() {
    // Encoding: 0xF4000601
    // Test aarch32_VST1_m_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, align=0, size=0, D=0, Rm=1, Rn=0
    let encoding: u32 = 0xF4000601;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t3a3_a_combo_0_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_0_size_variant_0_1536_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, Rn=0, align=0, D=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_1_size_variant_1_1536_f4000640() {
    // Encoding: 0xF4000640
    // Test aarch32_VST1_m_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: align=0, size=1, D=0, Rn=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000640;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_2_size_variant_2_1536_f4000680() {
    // Encoding: 0xF4000680
    // Test aarch32_VST1_m_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, size=2, align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4000680;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_3_size_variant_3_1536_f40006c0() {
    // Encoding: 0xF40006C0
    // Test aarch32_VST1_m_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=3, align=0
    let encoding: u32 = 0xF40006C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_0_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, align=0, size=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_1_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, align=0, Vd=0, D=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_2_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: Vd=0, size=0, align=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_3_600_f4000600() {
    // Encoding: 0xF4000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, align=0, Vd=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4000600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_d_0_min_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=0, align=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_d_1_max_200_f4400200() {
    // Encoding: 0xF4400200
    // Test aarch32_VST1_m_T4A4_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, Rm=0, D=1, size=0, Rn=0, align=0
    let encoding: u32 = 0xF4400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rn_0_min_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rn_1_poweroftwo_200_f4010200() {
    // Encoding: 0xF4010200
    // Test aarch32_VST1_m_T4A4_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=1, Vd=0, size=0, align=0, Rm=0
    let encoding: u32 = 0xF4010200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_vd_0_min_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, Vd=0, align=0, Rm=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_vd_1_poweroftwo_200_f4001200() {
    // Encoding: 0xF4001200
    // Test aarch32_VST1_m_T4A4_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, D=0, size=0, Rm=0, Rn=0, align=0
    let encoding: u32 = 0xF4001200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_0_min_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_1_poweroftwo_200_f4000240() {
    // Encoding: 0xF4000240
    // Test aarch32_VST1_m_T4A4_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, Rm=0, D=0, size=1, align=0
    let encoding: u32 = 0xF4000240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_2_poweroftwo_200_f4000280() {
    // Encoding: 0xF4000280
    // Test aarch32_VST1_m_T4A4_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=2, D=0, align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4000280;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_3_max_200_f40002c0() {
    // Encoding: 0xF40002C0
    // Test aarch32_VST1_m_T4A4_A field size = 3 (Max)
    // ISET: A32
    // Fields: align=0, Rn=0, D=0, Rm=0, Vd=0, size=3
    let encoding: u32 = 0xF40002C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_align_0_min_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field align = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, align=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_align_1_poweroftwo_200_f4000210() {
    // Encoding: 0xF4000210
    // Test aarch32_VST1_m_T4A4_A field align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, align=1, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4000210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_align_3_max_200_f4000230() {
    // Encoding: 0xF4000230
    // Test aarch32_VST1_m_T4A4_A field align = 3 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, align=3, Rn=0, Rm=0
    let encoding: u32 = 0xF4000230;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rm_0_min_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, align=0, size=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rm_1_poweroftwo_200_f4000201() {
    // Encoding: 0xF4000201
    // Test aarch32_VST1_m_T4A4_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, Rn=0, align=0, Rm=1
    let encoding: u32 = 0xF4000201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t4a4_a_combo_0_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, align=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_0_size_variant_0_512_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, size=0, align=0, Vd=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_1_size_variant_1_512_f4000240() {
    // Encoding: 0xF4000240
    // Test aarch32_VST1_m_T4A4_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: align=0, Rm=0, Rn=0, Vd=0, D=0, size=1
    let encoding: u32 = 0xF4000240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_2_size_variant_2_512_f4000280() {
    // Encoding: 0xF4000280
    // Test aarch32_VST1_m_T4A4_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, Rn=0, Vd=0, D=0, align=0, Rm=0
    let encoding: u32 = 0xF4000280;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_3_size_variant_3_512_f40002c0() {
    // Encoding: 0xF40002C0
    // Test aarch32_VST1_m_T4A4_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, size=3, align=0, Rm=0
    let encoding: u32 = 0xF40002C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t4a4_a_invalid_0_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: A32
    // Fields: size=0, align=0, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t4a4_a_invalid_1_200_f4000200() {
    // Encoding: 0xF4000200
    // Test aarch32_VST1_m_T4A4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, size=0, align=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_d_0_min_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, Rm=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_d_1_max_700_f9400700() {
    // Thumb encoding (32): 0xF9400700
    // Test aarch32_VST1_m_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=1, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rn_0_min_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: align=0, size=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rn_1_poweroftwo_700_f9010700() {
    // Thumb encoding (32): 0xF9010700
    // Test aarch32_VST1_m_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rn=1, Vd=0, align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_vd_0_min_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_vd_1_poweroftwo_700_f9001700() {
    // Thumb encoding (32): 0xF9001700
    // Test aarch32_VST1_m_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Vd=1, D=0, size=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_0_min_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, align=0, D=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_1_poweroftwo_700_f9000740() {
    // Thumb encoding (32): 0xF9000740
    // Test aarch32_VST1_m_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, size=1, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000740;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_2_poweroftwo_700_f9000780() {
    // Thumb encoding (32): 0xF9000780
    // Test aarch32_VST1_m_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, align=0, size=2, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_size_3_max_700_f90007c0() {
    // Thumb encoding (32): 0xF90007C0
    // Test aarch32_VST1_m_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, size=3, align=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_align_0_min_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field align = 0 (Min)
    // ISET: T32
    // Fields: align=0, Vd=0, Rm=0, Rn=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_align_1_poweroftwo_700_f9000710() {
    // Thumb encoding (32): 0xF9000710
    // Test aarch32_VST1_m_T1A1_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=1, Vd=0, Rm=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_align_3_max_700_f9000730() {
    // Thumb encoding (32): 0xF9000730
    // Test aarch32_VST1_m_T1A1_A field align = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, Vd=0, Rm=0, align=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000730;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rm_0_min_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, align=0, Rm=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t1a1_a_field_rm_1_poweroftwo_700_f9000701() {
    // Thumb encoding (32): 0xF9000701
    // Test aarch32_VST1_m_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, align=0, Rm=1, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000701;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t1a1_a_combo_0_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: align=0, Rm=0, Rn=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_0_size_variant_0_1792_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_1_size_variant_1_1792_f9000740() {
    // Thumb encoding (32): 0xF9000740
    // Test aarch32_VST1_m_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, align=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000740;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_2_size_variant_2_1792_f9000780() {
    // Thumb encoding (32): 0xF9000780
    // Test aarch32_VST1_m_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, Rn=0, size=2, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t1a1_a_special_size_3_size_variant_3_1792_f90007c0() {
    // Thumb encoding (32): 0xF90007C0
    // Test aarch32_VST1_m_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Rm=0, Rn=0, Vd=0, align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_0_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vd=0, align=0, size=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_1_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_2_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Vd=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t1a1_a_invalid_3_700_f9000700() {
    // Thumb encoding (32): 0xF9000700
    // Test aarch32_VST1_m_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Vd=0, align=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000700;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_d_0_min_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, align=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_d_1_max_a00_f9400a00() {
    // Thumb encoding (32): 0xF9400A00
    // Test aarch32_VST1_m_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vd=0, Rm=0, D=1, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rn_0_min_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, align=0, size=0, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rn_1_poweroftwo_a00_f9010a00() {
    // Thumb encoding (32): 0xF9010A00
    // Test aarch32_VST1_m_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, align=0, size=0, D=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_vd_0_min_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_vd_1_poweroftwo_a00_f9001a00() {
    // Thumb encoding (32): 0xF9001A00
    // Test aarch32_VST1_m_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=1, D=0, align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_0_min_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, align=0, Rn=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_1_poweroftwo_a00_f9000a40() {
    // Thumb encoding (32): 0xF9000A40
    // Test aarch32_VST1_m_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, align=0, Rm=0, Vd=0, size=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_2_poweroftwo_a00_f9000a80() {
    // Thumb encoding (32): 0xF9000A80
    // Test aarch32_VST1_m_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, size=2, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_size_3_max_a00_f9000ac0() {
    // Thumb encoding (32): 0xF9000AC0
    // Test aarch32_VST1_m_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, size=3, Rn=0, D=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000AC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_align_0_min_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field align = 0 (Min)
    // ISET: T32
    // Fields: align=0, Rn=0, Vd=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_align_1_poweroftwo_a00_f9000a10() {
    // Thumb encoding (32): 0xF9000A10
    // Test aarch32_VST1_m_T2A2_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, size=0, align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_align_3_max_a00_f9000a30() {
    // Thumb encoding (32): 0xF9000A30
    // Test aarch32_VST1_m_T2A2_A field align = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, D=0, align=3, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rm_0_min_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Rm=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t2a2_a_field_rm_1_poweroftwo_a00_f9000a01() {
    // Thumb encoding (32): 0xF9000A01
    // Test aarch32_VST1_m_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, D=0, Rm=1, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t2a2_a_combo_0_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_0_size_variant_0_2560_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: align=0, size=0, Rn=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_1_size_variant_1_2560_f9000a40() {
    // Thumb encoding (32): 0xF9000A40
    // Test aarch32_VST1_m_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: align=0, Vd=0, Rm=0, D=0, size=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_2_size_variant_2_2560_f9000a80() {
    // Thumb encoding (32): 0xF9000A80
    // Test aarch32_VST1_m_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, align=0, Rn=0, D=0, Rm=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t2a2_a_special_size_3_size_variant_3_2560_f9000ac0() {
    // Thumb encoding (32): 0xF9000AC0
    // Test aarch32_VST1_m_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Vd=0, align=0, D=0, Rm=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000AC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_0_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_1_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_2_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Rn=0, align=0, D=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t2a2_a_invalid_3_a00_f9000a00() {
    // Thumb encoding (32): 0xF9000A00
    // Test aarch32_VST1_m_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: align=0, Rm=0, size=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_d_0_min_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, align=0, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_d_1_max_600_f9400600() {
    // Thumb encoding (32): 0xF9400600
    // Test aarch32_VST1_m_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, align=0, Rm=0, size=0, Vd=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rn_0_min_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, size=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rn_1_poweroftwo_600_f9010600() {
    // Thumb encoding (32): 0xF9010600
    // Test aarch32_VST1_m_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, align=0, D=0, Vd=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_vd_0_min_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, align=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_vd_1_poweroftwo_600_f9001600() {
    // Thumb encoding (32): 0xF9001600
    // Test aarch32_VST1_m_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, size=0, Rm=0, align=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_0_min_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, align=0, Rm=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_1_poweroftwo_600_f9000640() {
    // Thumb encoding (32): 0xF9000640
    // Test aarch32_VST1_m_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Rm=0, Vd=0, Rn=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000640;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_2_poweroftwo_600_f9000680() {
    // Thumb encoding (32): 0xF9000680
    // Test aarch32_VST1_m_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, align=0, D=0, Vd=0, size=2, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_size_3_max_600_f90006c0() {
    // Thumb encoding (32): 0xF90006C0
    // Test aarch32_VST1_m_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, Rn=0, size=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90006C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_align_0_min_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field align = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, align=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_align_1_poweroftwo_600_f9000610() {
    // Thumb encoding (32): 0xF9000610
    // Test aarch32_VST1_m_T3A3_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Rm=0, align=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000610;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_align_3_max_600_f9000630() {
    // Thumb encoding (32): 0xF9000630
    // Test aarch32_VST1_m_T3A3_A field align = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, Rm=0, size=0, align=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000630;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rm_0_min_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Rm=0, Vd=0, align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t3a3_a_field_rm_1_poweroftwo_600_f9000601() {
    // Thumb encoding (32): 0xF9000601
    // Test aarch32_VST1_m_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, size=0, D=0, align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000601;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t3a3_a_combo_0_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=0, align=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_0_size_variant_0_1536_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_1_size_variant_1_1536_f9000640() {
    // Thumb encoding (32): 0xF9000640
    // Test aarch32_VST1_m_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, size=1, Rm=0, align=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000640;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_2_size_variant_2_1536_f9000680() {
    // Thumb encoding (32): 0xF9000680
    // Test aarch32_VST1_m_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, align=0, Vd=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t3a3_a_special_size_3_size_variant_3_1536_f90006c0() {
    // Thumb encoding (32): 0xF90006C0
    // Test aarch32_VST1_m_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, align=0, Rn=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90006C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_0_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_1_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: align=0, Vd=0, Rn=0, size=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_2_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: Vd=0, Rm=0, Rn=0, D=0, size=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t3a3_a_invalid_3_600_f9000600() {
    // Thumb encoding (32): 0xF9000600
    // Test aarch32_VST1_m_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, D=0, align=0, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000600;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_d_0_min_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, size=0, align=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_d_1_max_200_f9400200() {
    // Thumb encoding (32): 0xF9400200
    // Test aarch32_VST1_m_T4A4_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, D=1, Rn=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9400200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rn_0_min_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, align=0, Rm=0, Vd=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rn_1_poweroftwo_200_f9010200() {
    // Thumb encoding (32): 0xF9010200
    // Test aarch32_VST1_m_T4A4_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, align=0, D=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_vd_0_min_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, D=0, Vd=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_vd_1_poweroftwo_200_f9001200() {
    // Thumb encoding (32): 0xF9001200
    // Test aarch32_VST1_m_T4A4_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Vd=1, D=0, size=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9001200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_0_min_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, align=0, D=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_1_poweroftwo_200_f9000240() {
    // Thumb encoding (32): 0xF9000240
    // Test aarch32_VST1_m_T4A4_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, align=0, size=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_2_poweroftwo_200_f9000280() {
    // Thumb encoding (32): 0xF9000280
    // Test aarch32_VST1_m_T4A4_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, D=0, size=2, Rn=0, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000280;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size 6 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_size_3_max_200_f90002c0() {
    // Thumb encoding (32): 0xF90002C0
    // Test aarch32_VST1_m_T4A4_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, D=0, Rm=0, size=3, align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90002C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_align_0_min_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, align=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_align_1_poweroftwo_200_f9000210() {
    // Thumb encoding (32): 0xF9000210
    // Test aarch32_VST1_m_T4A4_A field align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=1, Rm=0, D=0, size=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field align 4 +: 2`
/// Requirement: FieldBoundary { field: "align", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_align_3_max_200_f9000230() {
    // Thumb encoding (32): 0xF9000230
    // Test aarch32_VST1_m_T4A4_A field align = 3 (Max)
    // ISET: T32
    // Fields: size=0, align=3, Rm=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000230;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rm_0_min_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_m_t4a4_a_field_rm_1_poweroftwo_200_f9000201() {
    // Thumb encoding (32): 0xF9000201
    // Test aarch32_VST1_m_T4A4_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: align=0, Rm=1, Vd=0, Rn=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_m_t4a4_a_combo_0_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A field combination: D=0, Rn=0, Vd=0, size=0, align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_0_size_variant_0_512_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: align=0, Rn=0, Vd=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_1_size_variant_1_512_f9000240() {
    // Thumb encoding (32): 0xF9000240
    // Test aarch32_VST1_m_T4A4_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, align=0, Vd=0, Rn=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_2_size_variant_2_512_f9000280() {
    // Thumb encoding (32): 0xF9000280
    // Test aarch32_VST1_m_T4A4_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, Rm=0, size=2, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000280;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_m_t4a4_a_special_size_3_size_variant_3_512_f90002c0() {
    // Thumb encoding (32): 0xF90002C0
    // Test aarch32_VST1_m_T4A4_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, size=3, D=0, align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF90002C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: LitInt(32) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t4a4_a_invalid_0_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A invalid encoding: Binary { op: Add, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Gt, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: LitInt(32) } }
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, Rm=0, align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_m_t4a4_a_invalid_1_200_f9000200() {
    // Thumb encoding (32): 0xF9000200
    // Test aarch32_VST1_m_T4A4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: align=0, D=0, Vd=0, size=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9000200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t1a1_a_store_0_f4010700() {
    // Test aarch32_VST1_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010700
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t1a1_a_store_1_f4010700() {
    // Test aarch32_VST1_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010700
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t1a1_a_store_2_f4010700() {
    // Test aarch32_VST1_m_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4010700
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t2a2_a_store_0_f4010a00() {
    // Test aarch32_VST1_m_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4010A00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t2a2_a_store_1_f4010a00() {
    // Test aarch32_VST1_m_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4010A00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t2a2_a_store_2_f4010a00() {
    // Test aarch32_VST1_m_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4010A00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t3a3_a_store_0_f4010600() {
    // Test aarch32_VST1_m_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4010600
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t3a3_a_store_1_f4010600() {
    // Test aarch32_VST1_m_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4010600
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t3a3_a_store_2_f4010600() {
    // Test aarch32_VST1_m_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4010600
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t4a4_a_store_0_f4010200() {
    // Test aarch32_VST1_m_T4A4_A memory store: 8 bytes
    // Encoding: 0xF4010200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t4a4_a_store_1_f4010200() {
    // Test aarch32_VST1_m_T4A4_A memory store: 8 bytes
    // Encoding: 0xF4010200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t4a4_a_store_2_f4010200() {
    // Test aarch32_VST1_m_T4A4_A memory store: 8 bytes
    // Encoding: 0xF4010200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst1_m_t1a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst1_m_t1a1_a_t32_oracle_0_f9010702() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF9010702;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst1_m_t1a1_a_t32_oracle_1_f9010702() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010702;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst1_m_t1a1_a_t32_oracle_2_f9010702() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF9010702;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst1_m_t1a1_a_t32_oracle_3_f9010702() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF9010702;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t1a1_a_store_0_f9010700() {
    // Test aarch32_VST1_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t1a1_a_store_1_f9010700() {
    // Test aarch32_VST1_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t1a1_a_store_2_f9010700() {
    // Test aarch32_VST1_m_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst1_m_t2a2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst1_m_t2a2_a_t32_oracle_0_f9010a02() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9010A02;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst1_m_t2a2_a_t32_oracle_1_f9010a02() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9010A02;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst1_m_t2a2_a_t32_oracle_2_f9010a02() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF9010A02;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst1_m_t2a2_a_t32_oracle_3_f9010a02() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF9010A02;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t2a2_a_store_0_f9010a00() {
    // Test aarch32_VST1_m_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t2a2_a_store_1_f9010a00() {
    // Test aarch32_VST1_m_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t2a2_a_store_2_f9010a00() {
    // Test aarch32_VST1_m_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst1_m_t3a3_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst1_m_t3a3_a_t32_oracle_0_f9010602() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9010602;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst1_m_t3a3_a_t32_oracle_1_f9010602() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9010602;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst1_m_t3a3_a_t32_oracle_2_f9010602() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF9010602;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst1_m_t3a3_a_t32_oracle_3_f9010602() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF9010602;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t3a3_a_store_0_f9010600() {
    // Test aarch32_VST1_m_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t3a3_a_store_1_f9010600() {
    // Test aarch32_VST1_m_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t3a3_a_store_2_f9010600() {
    // Test aarch32_VST1_m_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vst1_m_t4a4_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vst1_m_t4a4_a_t32_oracle_0_f9010202() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF9010202;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vst1_m_t4a4_a_t32_oracle_1_f9010202() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9010202;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vst1_m_t4a4_a_t32_oracle_2_f9010202() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF9010202;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vst1_m_t4a4_a_t32_oracle_3_f9010202() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF9010202;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t4a4_a_store_0_f9010200() {
    // Test aarch32_VST1_m_T4A4_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t4a4_a_store_1_f9010200() {
    // Test aarch32_VST1_m_T4A4_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_m_T4A4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_m_t4a4_a_store_2_f9010200() {
    // Test aarch32_VST1_m_T4A4_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9010200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VSTM_A Tests
// ============================================================================

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, Rn=0, U=0, D=0, cond=0, Vd=0, imm8=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_1_poweroftwo_b00_1c000b00() {
    // Encoding: 0x1C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, D=0, cond=1, U=0, Rn=0, W=0, P=0, Vd=0
    let encoding: u32 = 0x1C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_2_poweroftwo_b00_2c000b00() {
    // Encoding: 0x2C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=2, imm8=0, D=0, U=0, Vd=0, P=0
    let encoding: u32 = 0x2C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_3_poweroftwo_b00_3c000b00() {
    // Encoding: 0x3C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Vd=0, W=0, P=0, imm8=0, D=0, cond=3
    let encoding: u32 = 0x3C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_4_poweroftwo_b00_4c000b00() {
    // Encoding: 0x4C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm8=0, P=0, D=0, U=0, cond=4, W=0, Vd=0
    let encoding: u32 = 0x4C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_5_poweroftwo_b00_5c000b00() {
    // Encoding: 0x5C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=5, P=0, Rn=0, W=0, imm8=0, Vd=0, D=0
    let encoding: u32 = 0x5C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_6_poweroftwo_b00_6c000b00() {
    // Encoding: 0x6C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, P=0, imm8=0, Rn=0, W=0, cond=6, U=0
    let encoding: u32 = 0x6C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_7_poweroftwo_b00_7c000b00() {
    // Encoding: 0x7C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, imm8=0, cond=7, Rn=0, Vd=0, D=0, U=0
    let encoding: u32 = 0x7C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_8_poweroftwo_b00_8c000b00() {
    // Encoding: 0x8C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, D=0, Vd=0, Rn=0, W=0, P=0, imm8=0, cond=8
    let encoding: u32 = 0x8C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_9_poweroftwo_b00_9c000b00() {
    // Encoding: 0x9C000B00
    // Test aarch32_VSTM_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, U=0, W=0, imm8=0, cond=9, Vd=0, P=0, Rn=0
    let encoding: u32 = 0x9C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_10_poweroftwo_b00_ac000b00() {
    // Encoding: 0xAC000B00
    // Test aarch32_VSTM_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, cond=10, Vd=0, W=0, Rn=0, imm8=0, D=0
    let encoding: u32 = 0xAC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_11_poweroftwo_b00_bc000b00() {
    // Encoding: 0xBC000B00
    // Test aarch32_VSTM_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm8=0, Rn=0, Vd=0, U=0, cond=11, D=0, W=0
    let encoding: u32 = 0xBC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_12_poweroftwo_b00_cc000b00() {
    // Encoding: 0xCC000B00
    // Test aarch32_VSTM_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, cond=12, Rn=0, D=0, Vd=0, imm8=0, W=0
    let encoding: u32 = 0xCC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_13_poweroftwo_b00_dc000b00() {
    // Encoding: 0xDC000B00
    // Test aarch32_VSTM_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm8=0, D=0, Rn=0, Vd=0, U=0, cond=13, W=0, P=0
    let encoding: u32 = 0xDC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_14_poweroftwo_b00_ec000b00() {
    // Encoding: 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, U=0, W=0, imm8=0, D=0, Rn=0, Vd=0, P=0
    let encoding: u32 = 0xEC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vstm_t1a1_a_field_cond_15_max_b00_fc000b00() {
    // Encoding: 0xFC000B00
    // Test aarch32_VSTM_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Vd=0, P=0, U=0, D=0, W=0, Rn=0, imm8=0
    let encoding: u32 = 0xFC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, Vd=0, D=0, Rn=0, W=0, imm8=0, P=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_1_max_b00_0d000b00() {
    // Encoding: 0x0D000B00
    // Test aarch32_VSTM_T1A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: cond=0, W=0, Vd=0, P=1, U=0, Rn=0, imm8=0, D=0
    let encoding: u32 = 0x0D000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm8=0, cond=0, D=0, U=0, Vd=0, W=0, P=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_1_max_b00_0c800b00() {
    // Encoding: 0x0C800B00
    // Test aarch32_VSTM_T1A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: D=0, cond=0, Vd=0, Rn=0, imm8=0, U=1, P=0, W=0
    let encoding: u32 = 0x0C800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: W=0, U=0, D=0, cond=0, P=0, Vd=0, Rn=0, imm8=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_1_max_b00_0c400b00() {
    // Encoding: 0x0C400B00
    // Test aarch32_VSTM_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: U=0, D=1, Rn=0, imm8=0, cond=0, Vd=0, W=0, P=0
    let encoding: u32 = 0x0C400B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, W=0, D=0, imm8=0, Rn=0, Vd=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_1_max_b00_0c200b00() {
    // Encoding: 0x0C200B00
    // Test aarch32_VSTM_T1A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, imm8=0, D=0, W=1, Rn=0, Vd=0, P=0
    let encoding: u32 = 0x0C200B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, W=0, imm8=0, Rn=0, cond=0, D=0, Vd=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_1_poweroftwo_b00_0c010b00() {
    // Encoding: 0x0C010B00
    // Test aarch32_VSTM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=1, imm8=0, U=0, D=0, cond=0, Vd=0, W=0
    let encoding: u32 = 0x0C010B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_0_min_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, P=0, U=0, W=0, Vd=0, Rn=0, cond=0, imm8=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_1_poweroftwo_b00_0c001b00() {
    // Encoding: 0x0C001B00
    // Test aarch32_VSTM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Vd=1, imm8=0, Rn=0, cond=0, W=0, U=0, D=0
    let encoding: u32 = 0x0C001B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_0_zero_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: Vd=0, U=0, P=0, cond=0, Rn=0, D=0, imm8=0, W=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_1_poweroftwo_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Vd=0, W=0, U=0, Rn=0, imm8=1, D=0, P=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vstm_t1a1_a_combo_0_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: W=0, D=0, cond=0, Vd=0, imm8=0, Rn=0, P=0, U=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_0_condition_eq_2816_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Vd=0, W=0, P=0, D=0, imm8=0, cond=0, U=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_1_condition_ne_2816_1c000b00() {
    // Encoding: 0x1C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: P=0, W=0, imm8=0, cond=1, Rn=0, Vd=0, U=0, D=0
    let encoding: u32 = 0x1C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_2_condition_cs_hs_2816_2c000b00() {
    // Encoding: 0x2C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, Vd=0, imm8=0, cond=2, W=0, D=0
    let encoding: u32 = 0x2C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_3_condition_cc_lo_2816_3c000b00() {
    // Encoding: 0x3C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, W=0, U=0, cond=3, D=0, Rn=0, imm8=0, Vd=0
    let encoding: u32 = 0x3C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_4_condition_mi_2816_4c000b00() {
    // Encoding: 0x4C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: W=0, imm8=0, Vd=0, D=0, cond=4, P=0, U=0, Rn=0
    let encoding: u32 = 0x4C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_5_condition_pl_2816_5c000b00() {
    // Encoding: 0x5C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: D=0, U=0, Rn=0, W=0, imm8=0, Vd=0, P=0, cond=5
    let encoding: u32 = 0x5C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_6_condition_vs_2816_6c000b00() {
    // Encoding: 0x6C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Vd=0, cond=6, U=0, P=0, D=0, W=0, imm8=0, Rn=0
    let encoding: u32 = 0x6C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_7_condition_vc_2816_7c000b00() {
    // Encoding: 0x7C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, imm8=0, W=0, D=0, P=0, Vd=0, Rn=0, cond=7
    let encoding: u32 = 0x7C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_8_condition_hi_2816_8c000b00() {
    // Encoding: 0x8C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm8=0, W=0, Rn=0, D=0, P=0, U=0, cond=8, Vd=0
    let encoding: u32 = 0x8C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_9_condition_ls_2816_9c000b00() {
    // Encoding: 0x9C000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, imm8=0, Vd=0, P=0, U=0, W=0, D=0
    let encoding: u32 = 0x9C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_10_condition_ge_2816_ac000b00() {
    // Encoding: 0xAC000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: W=0, cond=10, U=0, D=0, P=0, Rn=0, Vd=0, imm8=0
    let encoding: u32 = 0xAC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_11_condition_lt_2816_bc000b00() {
    // Encoding: 0xBC000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: P=0, W=0, Vd=0, cond=11, U=0, imm8=0, D=0, Rn=0
    let encoding: u32 = 0xBC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_12_condition_gt_2816_cc000b00() {
    // Encoding: 0xCC000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, imm8=0, Rn=0, D=0, cond=12, P=0, U=0, Vd=0
    let encoding: u32 = 0xCC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_13_condition_le_2816_dc000b00() {
    // Encoding: 0xDC000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: W=0, Rn=0, U=0, cond=13, D=0, imm8=0, Vd=0, P=0
    let encoding: u32 = 0xDC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_14_condition_al_2816_ec000b00() {
    // Encoding: 0xEC000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Vd=0, Rn=0, P=0, U=0, W=0, D=0, cond=14, imm8=0
    let encoding: u32 = 0xEC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vstm_t1a1_a_special_cond_15_condition_nv_2816_fc000b00() {
    // Encoding: 0xFC000B00
    // Test aarch32_VSTM_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, P=0, cond=15, U=0, Vd=0, imm8=0, D=0, W=0
    let encoding: u32 = 0xFC000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_0_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, Rn=0, cond=0, Vd=0, imm8=0, W=0, P=0, U=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_1_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: imm8=0, P=0, W=0, Vd=0, D=0, Rn=0, U=0, cond=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_2_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, U=0, imm8=0, W=0, D=0, Vd=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_3_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, D=0, Vd=0, cond=0, U=0, imm8=0, Rn=0, W=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_4_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: A32
    // Fields: Vd=0, cond=0, U=0, imm8=0, D=0, P=0, Rn=0, W=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_5_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rn=0, W=0, cond=0, Vd=0, imm8=0, P=0, D=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_6_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: A32
    // Fields: imm8=0, cond=0, Vd=0, W=0, Rn=0, U=0, P=0, D=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_7_b00_0c000b00() {
    // Encoding: 0x0C000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, U=0, cond=0, imm8=0, P=0, Rn=0, Vd=0, W=0
    let encoding: u32 = 0x0C000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, U=0, imm8=0, Vd=0, P=0, D=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_1_poweroftwo_a00_1c000a00() {
    // Encoding: 0x1C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=1, D=0, imm8=0, P=0, U=0, Rn=0, Vd=0
    let encoding: u32 = 0x1C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_2_poweroftwo_a00_2c000a00() {
    // Encoding: 0x2C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, D=0, W=0, imm8=0, U=0, Vd=0, P=0
    let encoding: u32 = 0x2C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_3_poweroftwo_a00_3c000a00() {
    // Encoding: 0x3C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, D=0, P=0, W=0, U=0, Vd=0, imm8=0, Rn=0
    let encoding: u32 = 0x3C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_4_poweroftwo_a00_4c000a00() {
    // Encoding: 0x4C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, Vd=0, D=0, Rn=0, U=0, cond=4, imm8=0
    let encoding: u32 = 0x4C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_5_poweroftwo_a00_5c000a00() {
    // Encoding: 0x5C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, cond=5, U=0, imm8=0, W=0, Vd=0, D=0
    let encoding: u32 = 0x5C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_6_poweroftwo_a00_6c000a00() {
    // Encoding: 0x6C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, D=0, imm8=0, W=0, Vd=0, Rn=0, cond=6
    let encoding: u32 = 0x6C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_7_poweroftwo_a00_7c000a00() {
    // Encoding: 0x7C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, P=0, imm8=0, Rn=0, U=0, Vd=0, cond=7, W=0
    let encoding: u32 = 0x7C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_8_poweroftwo_a00_8c000a00() {
    // Encoding: 0x8C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, imm8=0, U=0, P=0, cond=8, W=0
    let encoding: u32 = 0x8C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_9_poweroftwo_a00_9c000a00() {
    // Encoding: 0x9C000A00
    // Test aarch32_VSTM_T2A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, imm8=0, Rn=0, W=0, U=0, Vd=0, D=0, P=0
    let encoding: u32 = 0x9C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_10_poweroftwo_a00_ac000a00() {
    // Encoding: 0xAC000A00
    // Test aarch32_VSTM_T2A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=10, U=0, Vd=0, imm8=0, D=0, Rn=0, P=0
    let encoding: u32 = 0xAC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_11_poweroftwo_a00_bc000a00() {
    // Encoding: 0xBC000A00
    // Test aarch32_VSTM_T2A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm8=0, cond=11, W=0, Vd=0, U=0, Rn=0, D=0
    let encoding: u32 = 0xBC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_12_poweroftwo_a00_cc000a00() {
    // Encoding: 0xCC000A00
    // Test aarch32_VSTM_T2A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=12, W=0, U=0, P=0, imm8=0, Rn=0, Vd=0
    let encoding: u32 = 0xCC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_13_poweroftwo_a00_dc000a00() {
    // Encoding: 0xDC000A00
    // Test aarch32_VSTM_T2A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Vd=0, imm8=0, cond=13, P=0, D=0, Rn=0
    let encoding: u32 = 0xDC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_14_poweroftwo_a00_ec000a00() {
    // Encoding: 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, P=0, W=0, U=0, Rn=0, D=0, imm8=0, Vd=0
    let encoding: u32 = 0xEC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vstm_t2a2_a_field_cond_15_max_a00_fc000a00() {
    // Encoding: 0xFC000A00
    // Test aarch32_VSTM_T2A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm8=0, P=0, U=0, W=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xFC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_p_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, D=0, imm8=0, U=0, Rn=0, Vd=0, P=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_p_1_max_a00_0d000a00() {
    // Encoding: 0x0D000A00
    // Test aarch32_VSTM_T2A2_A field P = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, cond=0, U=0, P=1, W=0, imm8=0
    let encoding: u32 = 0x0D000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_u_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, Vd=0, U=0, D=0, cond=0, P=0, imm8=0, Rn=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_u_1_max_a00_0c800a00() {
    // Encoding: 0x0C800A00
    // Test aarch32_VSTM_T2A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, Vd=0, P=0, imm8=0, U=1, D=0, W=0
    let encoding: u32 = 0x0C800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_d_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm8=0, Rn=0, U=0, Vd=0, W=0, P=0, D=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_d_1_max_a00_0c400a00() {
    // Encoding: 0x0C400A00
    // Test aarch32_VSTM_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, imm8=0, U=0, Vd=0, W=0, D=1
    let encoding: u32 = 0x0C400A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_w_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field W = 0 (Min)
    // ISET: A32
    // Fields: imm8=0, P=0, W=0, U=0, Rn=0, cond=0, Vd=0, D=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_w_1_max_a00_0c200a00() {
    // Encoding: 0x0C200A00
    // Test aarch32_VSTM_T2A2_A field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, cond=0, D=0, U=0, P=0, Rn=0, imm8=0, Vd=0
    let encoding: u32 = 0x0C200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstm_t2a2_a_field_rn_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm8=0, W=0, cond=0, Vd=0, Rn=0, D=0, P=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstm_t2a2_a_field_rn_1_poweroftwo_a00_0c010a00() {
    // Encoding: 0x0C010A00
    // Test aarch32_VSTM_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, D=0, W=0, Rn=1, Vd=0, imm8=0, P=0
    let encoding: u32 = 0x0C010A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstm_t2a2_a_field_vd_0_min_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, P=0, U=0, imm8=0, D=0, W=0, Vd=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstm_t2a2_a_field_vd_1_poweroftwo_a00_0c001a00() {
    // Encoding: 0x0C001A00
    // Test aarch32_VSTM_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, imm8=0, Vd=1, Rn=0, W=0, U=0, D=0
    let encoding: u32 = 0x0C001A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_0_zero_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field imm8 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, D=0, U=0, Rn=0, W=0, imm8=0, P=0, Vd=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_1_poweroftwo_a00_0c000a01() {
    // Encoding: 0x0C000A01
    // Test aarch32_VSTM_T2A2_A field imm8 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Vd=0, imm8=1, D=0, Rn=0, W=0, P=0
    let encoding: u32 = 0x0C000A01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_3_poweroftwominusone_a00_0c000a03() {
    // Encoding: 0x0C000A03
    // Test aarch32_VSTM_T2A2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, Rn=0, Vd=0, P=0, D=0, cond=0, imm8=3, U=0
    let encoding: u32 = 0x0C000A03;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_4_poweroftwo_a00_0c000a04() {
    // Encoding: 0x0C000A04
    // Test aarch32_VSTM_T2A2_A field imm8 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, D=0, W=0, cond=0, P=0, Rn=0, Vd=0, imm8=4
    let encoding: u32 = 0x0C000A04;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_7_poweroftwominusone_a00_0c000a07() {
    // Encoding: 0x0C000A07
    // Test aarch32_VSTM_T2A2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, D=0, U=0, W=0, imm8=7, cond=0, Rn=0, Vd=0
    let encoding: u32 = 0x0C000A07;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_8_poweroftwo_a00_0c000a08() {
    // Encoding: 0x0C000A08
    // Test aarch32_VSTM_T2A2_A field imm8 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, D=0, Vd=0, P=0, imm8=8, Rn=0, U=0
    let encoding: u32 = 0x0C000A08;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_15_poweroftwominusone_a00_0c000a0f() {
    // Encoding: 0x0C000A0F
    // Test aarch32_VSTM_T2A2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, D=0, cond=0, Rn=0, imm8=15, P=0, W=0, U=0
    let encoding: u32 = 0x0C000A0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_16_poweroftwo_a00_0c000a10() {
    // Encoding: 0x0C000A10
    // Test aarch32_VSTM_T2A2_A field imm8 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, D=0, Vd=0, Rn=0, cond=0, imm8=16, P=0, U=0
    let encoding: u32 = 0x0C000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_31_poweroftwominusone_a00_0c000a1f() {
    // Encoding: 0x0C000A1F
    // Test aarch32_VSTM_T2A2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, Vd=0, U=0, Rn=0, imm8=31, D=0, P=0, cond=0
    let encoding: u32 = 0x0C000A1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_32_poweroftwo_a00_0c000a20() {
    // Encoding: 0x0C000A20
    // Test aarch32_VSTM_T2A2_A field imm8 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, Vd=0, imm8=32, cond=0, P=0, D=0, W=0
    let encoding: u32 = 0x0C000A20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_63_poweroftwominusone_a00_0c000a3f() {
    // Encoding: 0x0C000A3F
    // Test aarch32_VSTM_T2A2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm8=63, W=0, cond=0, P=0, U=0, Vd=0, D=0
    let encoding: u32 = 0x0C000A3F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_64_poweroftwo_a00_0c000a40() {
    // Encoding: 0x0C000A40
    // Test aarch32_VSTM_T2A2_A field imm8 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm8=64, Rn=0, W=0, P=0, Vd=0, D=0, cond=0
    let encoding: u32 = 0x0C000A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_127_poweroftwominusone_a00_0c000a7f() {
    // Encoding: 0x0C000A7F
    // Test aarch32_VSTM_T2A2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Rn=0, imm8=127, W=0, U=0, cond=0, Vd=0, P=0
    let encoding: u32 = 0x0C000A7F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_128_poweroftwo_a00_0c000a80() {
    // Encoding: 0x0C000A80
    // Test aarch32_VSTM_T2A2_A field imm8 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm8=128, cond=0, D=0, Rn=0, Vd=0, P=0, U=0
    let encoding: u32 = 0x0C000A80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_255_max_a00_0c000aff() {
    // Encoding: 0x0C000AFF
    // Test aarch32_VSTM_T2A2_A field imm8 = 255 (Max)
    // ISET: A32
    // Fields: W=0, P=0, U=0, Vd=0, Rn=0, imm8=255, D=0, cond=0
    let encoding: u32 = 0x0C000AFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vstm_t2a2_a_combo_0_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A field combination: cond=0, P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: A32
    // Fields: U=0, imm8=0, Rn=0, W=0, P=0, Vd=0, D=0, cond=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_0_condition_eq_2560_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm8=0, cond=0, U=0, P=0, W=0, Vd=0, Rn=0, D=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_1_condition_ne_2560_1c000a00() {
    // Encoding: 0x1C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=1, Vd=0, P=0, imm8=0, D=0, W=0
    let encoding: u32 = 0x1C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_2_condition_cs_hs_2560_2c000a00() {
    // Encoding: 0x2C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, imm8=0, U=0, P=0, D=0, cond=2, W=0, Vd=0
    let encoding: u32 = 0x2C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_3_condition_cc_lo_2560_3c000a00() {
    // Encoding: 0x3C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, imm8=0, W=0, D=0, cond=3, Vd=0, U=0, P=0
    let encoding: u32 = 0x3C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_4_condition_mi_2560_4c000a00() {
    // Encoding: 0x4C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm8=0, Rn=0, U=0, D=0, Vd=0, cond=4, P=0, W=0
    let encoding: u32 = 0x4C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_5_condition_pl_2560_5c000a00() {
    // Encoding: 0x5C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, Vd=0, W=0, imm8=0, Rn=0, cond=5, P=0, D=0
    let encoding: u32 = 0x5C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_6_condition_vs_2560_6c000a00() {
    // Encoding: 0x6C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: W=0, imm8=0, cond=6, Rn=0, D=0, U=0, Vd=0, P=0
    let encoding: u32 = 0x6C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_7_condition_vc_2560_7c000a00() {
    // Encoding: 0x7C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, W=0, U=0, cond=7, imm8=0, P=0
    let encoding: u32 = 0x7C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_8_condition_hi_2560_8c000a00() {
    // Encoding: 0x8C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm8=0, cond=8, P=0, Rn=0, D=0, Vd=0, U=0, W=0
    let encoding: u32 = 0x8C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_9_condition_ls_2560_9c000a00() {
    // Encoding: 0x9C000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, D=0, W=0, cond=9, imm8=0, Vd=0
    let encoding: u32 = 0x9C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_10_condition_ge_2560_ac000a00() {
    // Encoding: 0xAC000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, D=0, Vd=0, W=0, Rn=0, U=0, imm8=0, P=0
    let encoding: u32 = 0xAC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_11_condition_lt_2560_bc000a00() {
    // Encoding: 0xBC000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: D=0, cond=11, imm8=0, Vd=0, U=0, P=0, W=0, Rn=0
    let encoding: u32 = 0xBC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_12_condition_gt_2560_cc000a00() {
    // Encoding: 0xCC000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm8=0, P=0, cond=12, Rn=0, W=0, Vd=0, U=0, D=0
    let encoding: u32 = 0xCC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_13_condition_le_2560_dc000a00() {
    // Encoding: 0xDC000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, P=0, imm8=0, D=0, cond=13, W=0, Vd=0, Rn=0
    let encoding: u32 = 0xDC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_14_condition_al_2560_ec000a00() {
    // Encoding: 0xEC000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, P=0, D=0, Rn=0, Vd=0, imm8=0, W=0, cond=14
    let encoding: u32 = 0xEC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vstm_t2a2_a_special_cond_15_condition_nv_2560_fc000a00() {
    // Encoding: 0xFC000A00
    // Test aarch32_VSTM_T2A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: D=0, W=0, imm8=0, U=0, cond=15, Rn=0, Vd=0, P=0
    let encoding: u32 = 0xFC000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_0_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rn=0, imm8=0, W=0, D=0, cond=0, U=0, Vd=0, P=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_1_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, imm8=0, D=0, Rn=0, U=0, W=0, P=0, cond=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_2_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: A32
    // Fields: W=0, P=0, cond=0, Vd=0, U=0, Rn=0, imm8=0, D=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_3_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, cond=0, Vd=0, Rn=0, P=0, imm8=0, D=0, W=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_4_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: A32
    // Fields: cond=0, W=0, imm8=0, D=0, U=0, Rn=0, Vd=0, P=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_5_a00_0c000a00() {
    // Encoding: 0x0C000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, cond=0, imm8=0, W=0, P=0, U=0, Vd=0, Rn=0
    let encoding: u32 = 0x0C000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_0_min_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field P = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, U=0, D=0, P=0, Rn=0, W=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_p_1_max_b00_ed000b00() {
    // Thumb encoding (32): 0xED000B00
    // Test aarch32_VSTM_T1A1_A field P = 1 (Max)
    // ISET: T32
    // Fields: U=0, imm8=0, P=1, Vd=0, Rn=0, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_0_min_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, Vd=0, imm8=0, D=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_u_1_max_b00_ec800b00() {
    // Thumb encoding (32): 0xEC800B00
    // Test aarch32_VSTM_T1A1_A field U = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, W=0, Rn=0, U=1, D=0, P=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_0_min_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, U=0, W=0, Rn=0, imm8=0, P=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_d_1_max_b00_ec400b00() {
    // Thumb encoding (32): 0xEC400B00
    // Test aarch32_VSTM_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, W=0, D=1, Rn=0, Vd=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_0_min_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, D=0, P=0, Rn=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t1a1_a_field_w_1_max_b00_ec200b00() {
    // Thumb encoding (32): 0xEC200B00
    // Test aarch32_VSTM_T1A1_A field W = 1 (Max)
    // ISET: T32
    // Fields: W=1, P=0, Vd=0, Rn=0, U=0, imm8=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC200B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_0_min_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, W=0, U=0, imm8=0, D=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstm_t1a1_a_field_rn_1_poweroftwo_b00_ec010b00() {
    // Thumb encoding (32): 0xEC010B00
    // Test aarch32_VSTM_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, P=0, D=0, U=0, Rn=1, Vd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_0_min_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, U=0, D=0, W=0, P=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstm_t1a1_a_field_vd_1_poweroftwo_b00_ec001b00() {
    // Thumb encoding (32): 0xEC001B00
    // Test aarch32_VSTM_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, U=0, W=0, Vd=1, imm8=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC001B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_0_zero_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Vd=0, W=0, imm8=0, U=0, D=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field imm8 1 +: 0`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstm_t1a1_a_field_imm8_1_poweroftwo_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, P=0, W=0, Rn=0, Vd=0, D=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vstm_t1a1_a_combo_0_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, D=0, imm8=0, P=0, Vd=0, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_0_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: P=0, D=0, W=0, Rn=0, imm8=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_1_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: U=0, D=0, P=0, Vd=0, W=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_2_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: T32
    // Fields: imm8=0, P=0, W=0, D=0, Rn=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_3_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, U=0, P=0, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_4_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } }, rhs: Binary { op: Or, lhs: LitInt(16), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, U=0, D=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_5_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, U=0, Rn=0, imm8=0, P=0, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"imm8\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(16) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_6_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "imm8" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(16) }
    // ISET: T32
    // Fields: Vd=0, P=0, imm8=0, U=0, D=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t1a1_a_invalid_7_b00_ec000b00() {
    // Thumb encoding (32): 0xEC000B00
    // Test aarch32_VSTM_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, imm8=0, U=0, Rn=0, D=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000B00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_p_0_min_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field P = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, P=0, D=0, Rn=0, imm8=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_p_1_max_a00_ed000a00() {
    // Thumb encoding (32): 0xED000A00
    // Test aarch32_VSTM_T2A2_A field P = 1 (Max)
    // ISET: T32
    // Fields: P=1, U=0, W=0, Rn=0, imm8=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xED000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_u_0_min_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field U = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, P=0, D=0, Vd=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_u_1_max_a00_ec800a00() {
    // Thumb encoding (32): 0xEC800A00
    // Test aarch32_VSTM_T2A2_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, P=0, U=1, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_d_0_min_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, Vd=0, P=0, Rn=0, U=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_d_1_max_a00_ec400a00() {
    // Thumb encoding (32): 0xEC400A00
    // Test aarch32_VSTM_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: P=0, D=1, Vd=0, imm8=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vstm_t2a2_a_field_w_0_min_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, imm8=0, P=0, U=0, W=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vstm_t2a2_a_field_w_1_max_a00_ec200a00() {
    // Thumb encoding (32): 0xEC200A00
    // Test aarch32_VSTM_T2A2_A field W = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, D=0, W=1, P=0, Rn=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vstm_t2a2_a_field_rn_0_min_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, U=0, P=0, imm8=0, D=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vstm_t2a2_a_field_rn_1_poweroftwo_a00_ec010a00() {
    // Thumb encoding (32): 0xEC010A00
    // Test aarch32_VSTM_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rn=1, Vd=0, D=0, imm8=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vstm_t2a2_a_field_vd_0_min_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: P=0, D=0, U=0, Vd=0, Rn=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vstm_t2a2_a_field_vd_1_poweroftwo_a00_ec001a00() {
    // Thumb encoding (32): 0xEC001A00
    // Test aarch32_VSTM_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, P=0, U=0, imm8=0, W=0, Rn=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC001A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_0_zero_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rn=0, P=0, D=0, W=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_1_poweroftwo_a00_ec000a01() {
    // Thumb encoding (32): 0xEC000A01
    // Test aarch32_VSTM_T2A2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, D=0, W=0, P=0, Rn=0, Vd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_3_poweroftwominusone_a00_ec000a03() {
    // Thumb encoding (32): 0xEC000A03
    // Test aarch32_VSTM_T2A2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, P=0, D=0, W=0, Vd=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_4_poweroftwo_a00_ec000a04() {
    // Thumb encoding (32): 0xEC000A04
    // Test aarch32_VSTM_T2A2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, W=0, D=0, imm8=4, U=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_7_poweroftwominusone_a00_ec000a07() {
    // Thumb encoding (32): 0xEC000A07
    // Test aarch32_VSTM_T2A2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, W=0, Vd=0, imm8=7, Rn=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_8_poweroftwo_a00_ec000a08() {
    // Thumb encoding (32): 0xEC000A08
    // Test aarch32_VSTM_T2A2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, U=0, imm8=8, D=0, Vd=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_15_poweroftwominusone_a00_ec000a0f() {
    // Thumb encoding (32): 0xEC000A0F
    // Test aarch32_VSTM_T2A2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, Vd=0, P=0, Rn=0, imm8=15, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_16_poweroftwo_a00_ec000a10() {
    // Thumb encoding (32): 0xEC000A10
    // Test aarch32_VSTM_T2A2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, P=0, D=0, U=0, W=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_31_poweroftwominusone_a00_ec000a1f() {
    // Thumb encoding (32): 0xEC000A1F
    // Test aarch32_VSTM_T2A2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, W=0, Rn=0, imm8=31, P=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_32_poweroftwo_a00_ec000a20() {
    // Thumb encoding (32): 0xEC000A20
    // Test aarch32_VSTM_T2A2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Vd=0, U=0, P=0, Rn=0, imm8=32, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_63_poweroftwominusone_a00_ec000a3f() {
    // Thumb encoding (32): 0xEC000A3F
    // Test aarch32_VSTM_T2A2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, U=0, D=0, W=0, imm8=63, Vd=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_64_poweroftwo_a00_ec000a40() {
    // Thumb encoding (32): 0xEC000A40
    // Test aarch32_VSTM_T2A2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, D=0, W=0, Rn=0, U=0, imm8=64, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_127_poweroftwominusone_a00_ec000a7f() {
    // Thumb encoding (32): 0xEC000A7F
    // Test aarch32_VSTM_T2A2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, U=0, D=0, W=0, Vd=0, Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_128_poweroftwo_a00_ec000a80() {
    // Thumb encoding (32): 0xEC000A80
    // Test aarch32_VSTM_T2A2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rn=0, Vd=0, imm8=128, U=0, W=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_vstm_t2a2_a_field_imm8_255_max_a00_ec000aff() {
    // Thumb encoding (32): 0xEC000AFF
    // Test aarch32_VSTM_T2A2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rn=0, W=0, Vd=0, P=0, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000AFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_vstm_t2a2_a_combo_0_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A field combination: P=0, U=0, D=0, W=0, Rn=0, Vd=0, imm8=0
    // ISET: T32
    // Fields: Vd=0, imm8=0, P=0, W=0, Rn=0, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_0_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, imm8=0, P=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_1_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: U=0, imm8=0, Rn=0, Vd=0, W=0, D=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"CurrentInstrSet\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"InstrSet_A32\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_2_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Binary { op: Ne, lhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "CurrentInstrSet" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "InstrSet_A32" }) } } }
    // ISET: T32
    // Fields: Vd=0, U=0, Rn=0, W=0, imm8=0, D=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_3_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, imm8=0, U=0, Vd=0, P=0, W=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"regs\" }) } } }, rhs: LitInt(32) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_4_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }), rhs: Binary { op: Or, lhs: LitInt(0), rhs: Binary { op: Add, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "regs" }) } } }, rhs: LitInt(32) }
    // ISET: T32
    // Fields: D=0, W=0, U=0, Rn=0, Vd=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vstm_t2a2_a_invalid_5_a00_ec000a00() {
    // Thumb encoding (32): 0xEC000A00
    // Test aarch32_VSTM_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, W=0, imm8=0, D=0, U=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC000A00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_0_0c010b00() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // Encoding: 0x0C010B00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0C010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_1_0c010b00() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // Encoding: 0x0C010B00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0C010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_2_0c010b00() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // Encoding: 0x0C010B00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0C010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t2a2_a_store_0_0c010a00() {
    // Test aarch32_VSTM_T2A2_A memory store: 8 bytes
    // Encoding: 0x0C010A00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0C010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t2a2_a_store_1_0c010a00() {
    // Test aarch32_VSTM_T2A2_A memory store: 8 bytes
    // Encoding: 0x0C010A00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x0C010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t2a2_a_store_2_0c010a00() {
    // Test aarch32_VSTM_T2A2_A memory store: 8 bytes
    // Encoding: 0x0C010A00
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0C010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_0_ec010b00() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_1_ec010b00() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEC010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t1a1_a_store_2_ec010b00() {
    // Test aarch32_VSTM_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t2a2_a_store_0_ec010a00() {
    // Test aarch32_VSTM_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t2a2_a_store_1_ec010a00() {
    // Test aarch32_VSTM_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VSTM_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vstm_t2a2_a_store_2_ec010a00() {
    // Test aarch32_VSTM_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xEC010A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST1_1_A Tests
// ============================================================================

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_d_0_min_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, size=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_d_1_max_0_f4c00000() {
    // Encoding: 0xF4C00000
    // Test aarch32_VST1_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, Rm=0, index_align=0, D=1, Rn=0, size=0
    let encoding: u32 = 0xF4C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rn_0_min_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, Vd=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rn_1_poweroftwo_0_f4810000() {
    // Encoding: 0xF4810000
    // Test aarch32_VST1_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Vd=0, D=0, Rn=1, size=0, Rm=0
    let encoding: u32 = 0xF4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_vd_0_min_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, index_align=0, size=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_vd_1_poweroftwo_0_f4801000() {
    // Encoding: 0xF4801000
    // Test aarch32_VST1_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=0, Rn=0, Vd=1, size=0, Rm=0
    let encoding: u32 = 0xF4801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_0_min_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, Vd=0, Rn=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_1_poweroftwo_0_f4800400() {
    // Encoding: 0xF4800400
    // Test aarch32_VST1_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=1, Rn=0, Rm=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_2_poweroftwo_0_f4800800() {
    // Encoding: 0xF4800800
    // Test aarch32_VST1_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, size=2, Rm=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_3_max_0_f4800c00() {
    // Encoding: 0xF4800C00
    // Test aarch32_VST1_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, index_align=0, D=0, Rm=0, size=3, Vd=0
    let encoding: u32 = 0xF4800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_0_min_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=0, Vd=0, D=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_1_poweroftwo_0_f4800010() {
    // Encoding: 0xF4800010
    // Test aarch32_VST1_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, D=0, index_align=1
    let encoding: u32 = 0xF4800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_7_poweroftwominusone_0_f4800070() {
    // Encoding: 0xF4800070
    // Test aarch32_VST1_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Vd=0, index_align=7, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4800070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_15_max_0_f48000f0() {
    // Encoding: 0xF48000F0
    // Test aarch32_VST1_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, Rm=0, Vd=0, index_align=15
    let encoding: u32 = 0xF48000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rm_0_min_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, size=0, D=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rm_1_poweroftwo_0_f4800001() {
    // Encoding: 0xF4800001
    // Test aarch32_VST1_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, index_align=0, size=0, Rm=1
    let encoding: u32 = 0xF4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_1_t1a1_a_combo_0_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Rn=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_0_size_variant_0_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: index_align=0, Rn=0, Vd=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_1_size_variant_1_0_f4800400() {
    // Encoding: 0xF4800400
    // Test aarch32_VST1_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, Rn=0, Rm=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_2_size_variant_2_0_f4800800() {
    // Encoding: 0xF4800800
    // Test aarch32_VST1_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: D=0, size=2, Rm=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_3_size_variant_3_0_f4800c00() {
    // Encoding: 0xF4800C00
    // Test aarch32_VST1_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, index_align=0, Rn=0, size=3, Rm=0, Vd=0
    let encoding: u32 = 0xF4800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_0_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, index_align=0, size=0, Rn=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_1_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=0, index_align=0, Rn=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_2_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_3_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, D=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_4_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_5_0_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_d_0_min_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rn=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_d_1_max_400_f4c00000() {
    // Encoding: 0xF4C00000
    // Test aarch32_VST1_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: index_align=0, D=1, Rn=0, Rm=0, Vd=0, size=0
    let encoding: u32 = 0xF4C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rn_0_min_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, D=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rn_1_poweroftwo_400_f4810000() {
    // Encoding: 0xF4810000
    // Test aarch32_VST1_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, size=0, Rn=1
    let encoding: u32 = 0xF4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_vd_0_min_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_vd_1_poweroftwo_400_f4801000() {
    // Encoding: 0xF4801000
    // Test aarch32_VST1_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Rm=0, Vd=1, index_align=0, Rn=0
    let encoding: u32 = 0xF4801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_0_min_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_1_poweroftwo_400_f4800400() {
    // Encoding: 0xF4800400
    // Test aarch32_VST1_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rn=0, size=1, Rm=0
    let encoding: u32 = 0xF4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_2_poweroftwo_400_f4800800() {
    // Encoding: 0xF4800800
    // Test aarch32_VST1_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, Rm=0, Rn=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_3_max_400_f4800c00() {
    // Encoding: 0xF4800C00
    // Test aarch32_VST1_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, D=0, Rm=0, index_align=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_0_min_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Rn=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_1_poweroftwo_400_f4800010() {
    // Encoding: 0xF4800010
    // Test aarch32_VST1_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=1, D=0, Rm=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_7_poweroftwominusone_400_f4800070() {
    // Encoding: 0xF4800070
    // Test aarch32_VST1_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=0, index_align=7, Rm=0
    let encoding: u32 = 0xF4800070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_15_max_400_f48000f0() {
    // Encoding: 0xF48000F0
    // Test aarch32_VST1_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: size=0, index_align=15, Rn=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF48000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rm_0_min_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, Rn=0, D=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rm_1_poweroftwo_400_f4800001() {
    // Encoding: 0xF4800001
    // Test aarch32_VST1_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Rn=0, Vd=0, Rm=1
    let encoding: u32 = 0xF4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_1_t2a2_a_combo_0_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rn=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_0_size_variant_0_1024_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_1_size_variant_1_1024_f4800400() {
    // Encoding: 0xF4800400
    // Test aarch32_VST1_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, Vd=0, index_align=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_2_size_variant_2_1024_f4800800() {
    // Encoding: 0xF4800800
    // Test aarch32_VST1_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, D=0, size=2, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_3_size_variant_3_1024_f4800c00() {
    // Encoding: 0xF4800C00
    // Test aarch32_VST1_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, Rm=0, size=3, index_align=0
    let encoding: u32 = 0xF4800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_0_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_1_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, Rm=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_2_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, size=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_3_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rm=0, Rn=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_4_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Vd=0, Rn=0, index_align=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_5_400_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, size=0, index_align=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_d_0_min_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_d_1_max_800_f4c00000() {
    // Encoding: 0xF4C00000
    // Test aarch32_VST1_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, D=1, Vd=0
    let encoding: u32 = 0xF4C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rn_0_min_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rn_1_poweroftwo_800_f4810000() {
    // Encoding: 0xF4810000
    // Test aarch32_VST1_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rn=1, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_vd_0_min_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_vd_1_poweroftwo_800_f4801000() {
    // Encoding: 0xF4801000
    // Test aarch32_VST1_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Vd=1, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_0_min_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_1_poweroftwo_800_f4800400() {
    // Encoding: 0xF4800400
    // Test aarch32_VST1_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=0, size=1, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_2_poweroftwo_800_f4800800() {
    // Encoding: 0xF4800800
    // Test aarch32_VST1_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=2, index_align=0, Vd=0, Rm=0, D=0
    let encoding: u32 = 0xF4800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_3_max_800_f4800c00() {
    // Encoding: 0xF4800C00
    // Test aarch32_VST1_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, size=3, D=0, Rm=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_0_min_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, Vd=0, D=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_1_poweroftwo_800_f4800010() {
    // Encoding: 0xF4800010
    // Test aarch32_VST1_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, index_align=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_7_poweroftwominusone_800_f4800070() {
    // Encoding: 0xF4800070
    // Test aarch32_VST1_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, size=0, index_align=7, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_15_max_800_f48000f0() {
    // Encoding: 0xF48000F0
    // Test aarch32_VST1_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, index_align=15, size=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF48000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rm_0_min_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, D=0, Vd=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rm_1_poweroftwo_800_f4800001() {
    // Encoding: 0xF4800001
    // Test aarch32_VST1_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=1
    let encoding: u32 = 0xF4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_1_t3a3_a_combo_0_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Rm=0, Rn=0, Vd=0, D=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_0_size_variant_0_2048_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=0, Vd=0, index_align=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_1_size_variant_1_2048_f4800400() {
    // Encoding: 0xF4800400
    // Test aarch32_VST1_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, size=1, Rn=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_2_size_variant_2_2048_f4800800() {
    // Encoding: 0xF4800800
    // Test aarch32_VST1_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: D=0, Vd=0, size=2, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_3_size_variant_3_2048_f4800c00() {
    // Encoding: 0xF4800C00
    // Test aarch32_VST1_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=3, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_0_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, size=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_1_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_2_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: index_align=0, Rm=0, D=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_3_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, Rm=0, index_align=0, D=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_4_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_5_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_6_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, D=0, index_align=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_7_800_f4800000() {
    // Encoding: 0xF4800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: size=0, Rn=0, Rm=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_d_0_min_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=0, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_d_1_max_0_f9c00000() {
    // Thumb encoding (32): 0xF9C00000
    // Test aarch32_VST1_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, size=0, index_align=0, D=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rn_0_min_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, Rm=0, D=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rn_1_poweroftwo_0_f9810000() {
    // Thumb encoding (32): 0xF9810000
    // Test aarch32_VST1_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rm=0, Vd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_vd_0_min_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, Rm=0, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_vd_1_poweroftwo_0_f9801000() {
    // Thumb encoding (32): 0xF9801000
    // Test aarch32_VST1_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=1, Rm=0, D=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_0_min_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_1_poweroftwo_0_f9800400() {
    // Thumb encoding (32): 0xF9800400
    // Test aarch32_VST1_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, index_align=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_2_poweroftwo_0_f9800800() {
    // Thumb encoding (32): 0xF9800800
    // Test aarch32_VST1_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, Vd=0, D=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_size_3_max_0_f9800c00() {
    // Thumb encoding (32): 0xF9800C00
    // Test aarch32_VST1_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Rn=0, Vd=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_0_min_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_1_poweroftwo_0_f9800010() {
    // Thumb encoding (32): 0xF9800010
    // Test aarch32_VST1_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=1, Rm=0, D=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_7_poweroftwominusone_0_f9800070() {
    // Thumb encoding (32): 0xF9800070
    // Test aarch32_VST1_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, index_align=7, Rm=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_index_align_15_max_0_f98000f0() {
    // Thumb encoding (32): 0xF98000F0
    // Test aarch32_VST1_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, size=0, index_align=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rm_0_min_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rn=0, size=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t1a1_a_field_rm_1_poweroftwo_0_f9800001() {
    // Thumb encoding (32): 0xF9800001
    // Test aarch32_VST1_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rm=1, Rn=0, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_1_t1a1_a_combo_0_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_0_size_variant_0_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_1_size_variant_1_0_f9800400() {
    // Thumb encoding (32): 0xF9800400
    // Test aarch32_VST1_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, size=1, Rn=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_2_size_variant_2_0_f9800800() {
    // Thumb encoding (32): 0xF9800800
    // Test aarch32_VST1_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rm=0, size=2, D=0, Vd=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_1_t1a1_a_special_size_3_size_variant_3_0_f9800c00() {
    // Thumb encoding (32): 0xF9800C00
    // Test aarch32_VST1_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, size=3, Rm=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_0_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_1_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: index_align=0, Vd=0, size=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_2_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: index_align=0, size=0, Vd=0, D=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_3_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_4_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: index_align=0, size=0, Vd=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t1a1_a_invalid_5_0_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, Vd=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_d_0_min_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_d_1_max_400_f9c00000() {
    // Thumb encoding (32): 0xF9C00000
    // Test aarch32_VST1_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, Rn=0, index_align=0, size=0, D=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rn_0_min_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=0, size=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rn_1_poweroftwo_400_f9810000() {
    // Thumb encoding (32): 0xF9810000
    // Test aarch32_VST1_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, size=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_vd_0_min_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_vd_1_poweroftwo_400_f9801000() {
    // Thumb encoding (32): 0xF9801000
    // Test aarch32_VST1_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=1, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_0_min_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_1_poweroftwo_400_f9800400() {
    // Thumb encoding (32): 0xF9800400
    // Test aarch32_VST1_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, size=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_2_poweroftwo_400_f9800800() {
    // Thumb encoding (32): 0xF9800800
    // Test aarch32_VST1_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, size=2, Rm=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_size_3_max_400_f9800c00() {
    // Thumb encoding (32): 0xF9800C00
    // Test aarch32_VST1_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, index_align=0, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_0_min_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_1_poweroftwo_400_f9800010() {
    // Thumb encoding (32): 0xF9800010
    // Test aarch32_VST1_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, index_align=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_7_poweroftwominusone_400_f9800070() {
    // Thumb encoding (32): 0xF9800070
    // Test aarch32_VST1_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, index_align=7, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_index_align_15_max_400_f98000f0() {
    // Thumb encoding (32): 0xF98000F0
    // Test aarch32_VST1_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, Rn=0, Vd=0, D=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rm_0_min_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, Vd=0, D=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t2a2_a_field_rm_1_poweroftwo_400_f9800001() {
    // Thumb encoding (32): 0xF9800001
    // Test aarch32_VST1_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, index_align=0, Rm=1, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_1_t2a2_a_combo_0_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, D=0, index_align=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_0_size_variant_0_1024_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, Rm=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_1_size_variant_1_1024_f9800400() {
    // Thumb encoding (32): 0xF9800400
    // Test aarch32_VST1_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_2_size_variant_2_1024_f9800800() {
    // Thumb encoding (32): 0xF9800800
    // Test aarch32_VST1_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, size=2, index_align=0, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_1_t2a2_a_special_size_3_size_variant_3_1024_f9800c00() {
    // Thumb encoding (32): 0xF9800C00
    // Test aarch32_VST1_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, index_align=0, D=0, Vd=0, size=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_0_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=0, size=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_1_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, Vd=0, index_align=0, Rn=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_2_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_3_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_4_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: size=0, Rm=0, index_align=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t2a2_a_invalid_5_400_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, size=0, Rm=0, D=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_d_0_min_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, Rm=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_d_1_max_800_f9c00000() {
    // Thumb encoding (32): 0xF9C00000
    // Test aarch32_VST1_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, Rn=0, Vd=0, size=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rn_0_min_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, size=0, D=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rn_1_poweroftwo_800_f9810000() {
    // Thumb encoding (32): 0xF9810000
    // Test aarch32_VST1_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, index_align=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_vd_0_min_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, Rn=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_vd_1_poweroftwo_800_f9801000() {
    // Thumb encoding (32): 0xF9801000
    // Test aarch32_VST1_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=1, Rm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_0_min_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_1_poweroftwo_800_f9800400() {
    // Thumb encoding (32): 0xF9800400
    // Test aarch32_VST1_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, index_align=0, Rm=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_2_poweroftwo_800_f9800800() {
    // Thumb encoding (32): 0xF9800800
    // Test aarch32_VST1_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, index_align=0, Vd=0, Rm=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_size_3_max_800_f9800c00() {
    // Thumb encoding (32): 0xF9800C00
    // Test aarch32_VST1_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, size=3, Vd=0, Rm=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_0_min_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rn=0, Rm=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_1_poweroftwo_800_f9800010() {
    // Thumb encoding (32): 0xF9800010
    // Test aarch32_VST1_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=1, D=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_7_poweroftwominusone_800_f9800070() {
    // Thumb encoding (32): 0xF9800070
    // Test aarch32_VST1_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_index_align_15_max_800_f98000f0() {
    // Thumb encoding (32): 0xF98000F0
    // Test aarch32_VST1_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=15, Rm=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rm_0_min_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst1_1_t3a3_a_field_rm_1_poweroftwo_800_f9800001() {
    // Thumb encoding (32): 0xF9800001
    // Test aarch32_VST1_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rm=1, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst1_1_t3a3_a_combo_0_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Vd=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_0_size_variant_0_2048_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, Rm=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_1_size_variant_1_2048_f9800400() {
    // Thumb encoding (32): 0xF9800400
    // Test aarch32_VST1_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, Rn=0, D=0, Rm=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_2_size_variant_2_2048_f9800800() {
    // Thumb encoding (32): 0xF9800800
    // Test aarch32_VST1_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, Vd=0, Rn=0, index_align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst1_1_t3a3_a_special_size_3_size_variant_3_2048_f9800c00() {
    // Thumb encoding (32): 0xF9800C00
    // Test aarch32_VST1_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Rm=0, Vd=0, Rn=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_0_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: index_align=0, Vd=0, size=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_1_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, Vd=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_2_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(2))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_3_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_4_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: Binary { op: And, lhs: LitBits([false, false]), rhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] } } }, rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Vd=0, D=0, Rm=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_5_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, index_align=0, D=0, Rn=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_6_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst1_1_t3a3_a_invalid_7_800_f9800000() {
    // Thumb encoding (32): 0xF9800000
    // Test aarch32_VST1_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: index_align=0, size=0, D=0, Rn=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_1_t1a1_a_store_0_f4810000() {
    // Test aarch32_VST1_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_1_t2a2_a_store_0_f4810000() {
    // Test aarch32_VST1_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_1_t3a3_a_store_0_f4810000() {
    // Test aarch32_VST1_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_1_t1a1_a_store_0_f9810000() {
    // Test aarch32_VST1_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_1_t2a2_a_store_0_f9810000() {
    // Test aarch32_VST1_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST1_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst1_1_t3a3_a_store_0_f9810000() {
    // Test aarch32_VST1_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST3_1_A Tests
// ============================================================================

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_d_0_min_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_d_1_max_200_f4c00200() {
    // Encoding: 0xF4C00200
    // Test aarch32_VST3_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, D=1, size=0, Rm=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rn_0_min_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, D=0, index_align=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rn_1_poweroftwo_200_f4810200() {
    // Encoding: 0xF4810200
    // Test aarch32_VST3_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, index_align=0, Rn=1, Rm=0
    let encoding: u32 = 0xF4810200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_vd_0_min_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, D=0, index_align=0, size=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_vd_1_poweroftwo_200_f4801200() {
    // Encoding: 0xF4801200
    // Test aarch32_VST3_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, D=0, Vd=1, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4801200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_0_min_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_1_poweroftwo_200_f4800600() {
    // Encoding: 0xF4800600
    // Test aarch32_VST3_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, size=1, index_align=0, Rn=0
    let encoding: u32 = 0xF4800600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_2_poweroftwo_200_f4800a00() {
    // Encoding: 0xF4800A00
    // Test aarch32_VST3_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=2, D=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_3_max_200_f4800e00() {
    // Encoding: 0xF4800E00
    // Test aarch32_VST3_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Vd=0, size=3, Rn=0, D=0
    let encoding: u32 = 0xF4800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_0_min_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_1_poweroftwo_200_f4800210() {
    // Encoding: 0xF4800210
    // Test aarch32_VST3_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, index_align=1, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_7_poweroftwominusone_200_f4800270() {
    // Encoding: 0xF4800270
    // Test aarch32_VST3_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, Rm=0, index_align=7, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4800270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_15_max_200_f48002f0() {
    // Encoding: 0xF48002F0
    // Test aarch32_VST3_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, index_align=15
    let encoding: u32 = 0xF48002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rm_0_min_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, index_align=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rm_1_poweroftwo_200_f4800201() {
    // Encoding: 0xF4800201
    // Test aarch32_VST3_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, index_align=0, Rm=1, Vd=0
    let encoding: u32 = 0xF4800201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_1_t1a1_a_combo_0_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_0_size_variant_0_512_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, size=0, Vd=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_1_size_variant_1_512_f4800600() {
    // Encoding: 0xF4800600
    // Test aarch32_VST3_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, D=0, size=1, Rm=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_2_size_variant_2_512_f4800a00() {
    // Encoding: 0xF4800A00
    // Test aarch32_VST3_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rm=0, Rn=0, size=2, D=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_3_size_variant_3_512_f4800e00() {
    // Encoding: 0xF4800E00
    // Test aarch32_VST3_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rn=0, Rm=0, Vd=0, index_align=0, size=3
    let encoding: u32 = 0xF4800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_0_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_1_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_2_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: index_align=0, size=0, Vd=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_3_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_4_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_5_200_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_d_0_min_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_d_1_max_600_f4c00200() {
    // Encoding: 0xF4C00200
    // Test aarch32_VST3_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, Vd=0, index_align=0, D=1
    let encoding: u32 = 0xF4C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rn_0_min_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rn_1_poweroftwo_600_f4810200() {
    // Encoding: 0xF4810200
    // Test aarch32_VST3_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=1, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4810200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_vd_0_min_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_vd_1_poweroftwo_600_f4801200() {
    // Encoding: 0xF4801200
    // Test aarch32_VST3_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=1, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4801200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_0_min_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, index_align=0, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_1_poweroftwo_600_f4800600() {
    // Encoding: 0xF4800600
    // Test aarch32_VST3_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Vd=0, D=0, size=1, index_align=0
    let encoding: u32 = 0xF4800600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_2_poweroftwo_600_f4800a00() {
    // Encoding: 0xF4800A00
    // Test aarch32_VST3_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rn=0, size=2, Rm=0
    let encoding: u32 = 0xF4800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_3_max_600_f4800e00() {
    // Encoding: 0xF4800E00
    // Test aarch32_VST3_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, size=3, index_align=0, Rm=0
    let encoding: u32 = 0xF4800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_0_min_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, index_align=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_1_poweroftwo_600_f4800210() {
    // Encoding: 0xF4800210
    // Test aarch32_VST3_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, index_align=1, Rn=0, D=0, Rm=0, size=0
    let encoding: u32 = 0xF4800210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_7_poweroftwominusone_600_f4800270() {
    // Encoding: 0xF4800270
    // Test aarch32_VST3_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, index_align=7, size=0, Vd=0
    let encoding: u32 = 0xF4800270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_15_max_600_f48002f0() {
    // Encoding: 0xF48002F0
    // Test aarch32_VST3_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, index_align=15, Rn=0, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF48002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rm_0_min_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, Rn=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rm_1_poweroftwo_600_f4800201() {
    // Encoding: 0xF4800201
    // Test aarch32_VST3_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rm=1, Rn=0, Vd=0, size=0, index_align=0
    let encoding: u32 = 0xF4800201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_1_t2a2_a_combo_0_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, size=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_0_size_variant_0_1536_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, Rn=0, Rm=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_1_size_variant_1_1536_f4800600() {
    // Encoding: 0xF4800600
    // Test aarch32_VST3_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, size=1, Rn=0
    let encoding: u32 = 0xF4800600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_2_size_variant_2_1536_f4800a00() {
    // Encoding: 0xF4800A00
    // Test aarch32_VST3_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, size=2, Rn=0, Rm=0
    let encoding: u32 = 0xF4800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_3_size_variant_3_1536_f4800e00() {
    // Encoding: 0xF4800E00
    // Test aarch32_VST3_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: index_align=0, Vd=0, D=0, size=3, Rm=0, Rn=0
    let encoding: u32 = 0xF4800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_0_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, index_align=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_1_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_2_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, size=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_3_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_4_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_5_600_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, D=0, size=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_d_0_min_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, Rn=0, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_d_1_max_a00_f4c00200() {
    // Encoding: 0xF4C00200
    // Test aarch32_VST3_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, D=1, index_align=0, Rn=0
    let encoding: u32 = 0xF4C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rn_0_min_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rn=0, Vd=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rn_1_poweroftwo_a00_f4810200() {
    // Encoding: 0xF4810200
    // Test aarch32_VST3_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rn=1, Rm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF4810200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_vd_0_min_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, Vd=0, Rn=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_vd_1_poweroftwo_a00_f4801200() {
    // Encoding: 0xF4801200
    // Test aarch32_VST3_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, size=0, D=0, Rn=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4801200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_0_min_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, index_align=0, D=0, Vd=0, Rn=0, size=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_1_poweroftwo_a00_f4800600() {
    // Encoding: 0xF4800600
    // Test aarch32_VST3_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=0, Rn=0, Rm=0, size=1, Vd=0
    let encoding: u32 = 0xF4800600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_2_poweroftwo_a00_f4800a00() {
    // Encoding: 0xF4800A00
    // Test aarch32_VST3_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rn=0, size=2, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_3_max_a00_f4800e00() {
    // Encoding: 0xF4800E00
    // Test aarch32_VST3_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, size=3, Vd=0, index_align=0
    let encoding: u32 = 0xF4800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_0_min_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, Rn=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_1_poweroftwo_a00_f4800210() {
    // Encoding: 0xF4800210
    // Test aarch32_VST3_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=1, Rn=0, Vd=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_7_poweroftwominusone_a00_f4800270() {
    // Encoding: 0xF4800270
    // Test aarch32_VST3_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, index_align=7, size=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4800270;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_15_max_a00_f48002f0() {
    // Encoding: 0xF48002F0
    // Test aarch32_VST3_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=15, Rm=0
    let encoding: u32 = 0xF48002F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rm_0_min_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, D=0, Vd=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rm_1_poweroftwo_a00_f4800201() {
    // Encoding: 0xF4800201
    // Test aarch32_VST3_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=0, Rm=1, D=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4800201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_1_t3a3_a_combo_0_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, D=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_0_size_variant_0_2560_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_1_size_variant_1_2560_f4800600() {
    // Encoding: 0xF4800600
    // Test aarch32_VST3_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, size=1, Vd=0, Rm=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_2_size_variant_2_2560_f4800a00() {
    // Encoding: 0xF4800A00
    // Test aarch32_VST3_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, size=2, D=0
    let encoding: u32 = 0xF4800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_3_size_variant_3_2560_f4800e00() {
    // Encoding: 0xF4800E00
    // Test aarch32_VST3_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=3, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_0_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: D=0, Rm=0, size=0, Rn=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_1_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Vd=0, index_align=0, Rn=0, size=0, D=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_2_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: D=0, Vd=0, Rm=0, index_align=0, Rn=0, size=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_3_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Rm=0, index_align=0, D=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_4_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, Rn=0, D=0, Vd=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_5_a00_f4800200() {
    // Encoding: 0xF4800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, D=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_d_0_min_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_d_1_max_200_f9c00200() {
    // Thumb encoding (32): 0xF9C00200
    // Test aarch32_VST3_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rm=0, size=0, Rn=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rn_0_min_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, index_align=0, Vd=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rn_1_poweroftwo_200_f9810200() {
    // Thumb encoding (32): 0xF9810200
    // Test aarch32_VST3_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=1, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_vd_0_min_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=0, Rm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_vd_1_poweroftwo_200_f9801200() {
    // Thumb encoding (32): 0xF9801200
    // Test aarch32_VST3_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, size=0, index_align=0, Rn=0, D=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_0_min_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, D=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_1_poweroftwo_200_f9800600() {
    // Thumb encoding (32): 0xF9800600
    // Test aarch32_VST3_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=1, index_align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_2_poweroftwo_200_f9800a00() {
    // Thumb encoding (32): 0xF9800A00
    // Test aarch32_VST3_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, size=2, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_size_3_max_200_f9800e00() {
    // Thumb encoding (32): 0xF9800E00
    // Test aarch32_VST3_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, size=3, Rn=0, index_align=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_0_min_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_1_poweroftwo_200_f9800210() {
    // Thumb encoding (32): 0xF9800210
    // Test aarch32_VST3_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=0, index_align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_7_poweroftwominusone_200_f9800270() {
    // Thumb encoding (32): 0xF9800270
    // Test aarch32_VST3_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: index_align=7, Rm=0, size=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_index_align_15_max_200_f98002f0() {
    // Thumb encoding (32): 0xF98002F0
    // Test aarch32_VST3_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Rm=0, index_align=15, Rn=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rm_0_min_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t1a1_a_field_rm_1_poweroftwo_200_f9800201() {
    // Thumb encoding (32): 0xF9800201
    // Test aarch32_VST3_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rm=1, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_1_t1a1_a_combo_0_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, index_align=0, D=0, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_0_size_variant_0_512_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: index_align=0, Rn=0, Vd=0, size=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_1_size_variant_1_512_f9800600() {
    // Thumb encoding (32): 0xF9800600
    // Test aarch32_VST3_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Rm=0, size=1, Vd=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_2_size_variant_2_512_f9800a00() {
    // Thumb encoding (32): 0xF9800A00
    // Test aarch32_VST3_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, Vd=0, size=2, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_1_t1a1_a_special_size_3_size_variant_3_512_f9800e00() {
    // Thumb encoding (32): 0xF9800E00
    // Test aarch32_VST3_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, size=3, index_align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_0_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Vd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_1_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rm=0, index_align=0, Vd=0, Rn=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_2_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, size=0, index_align=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_3_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, Rn=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_4_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, index_align=0, D=0, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t1a1_a_invalid_5_200_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, size=0, Rn=0, Vd=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_d_0_min_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, index_align=0, D=0, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_d_1_max_600_f9c00200() {
    // Thumb encoding (32): 0xF9C00200
    // Test aarch32_VST3_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, D=1, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rn_0_min_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, D=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rn_1_poweroftwo_600_f9810200() {
    // Thumb encoding (32): 0xF9810200
    // Test aarch32_VST3_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rm=0, D=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_vd_0_min_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Rn=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_vd_1_poweroftwo_600_f9801200() {
    // Thumb encoding (32): 0xF9801200
    // Test aarch32_VST3_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vd=1, Rn=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_0_min_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_1_poweroftwo_600_f9800600() {
    // Thumb encoding (32): 0xF9800600
    // Test aarch32_VST3_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_2_poweroftwo_600_f9800a00() {
    // Thumb encoding (32): 0xF9800A00
    // Test aarch32_VST3_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Rm=0, size=2, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_size_3_max_600_f9800e00() {
    // Thumb encoding (32): 0xF9800E00
    // Test aarch32_VST3_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, size=3, D=0, index_align=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_0_min_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, size=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_1_poweroftwo_600_f9800210() {
    // Thumb encoding (32): 0xF9800210
    // Test aarch32_VST3_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, Rn=0, D=0, index_align=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_7_poweroftwominusone_600_f9800270() {
    // Thumb encoding (32): 0xF9800270
    // Test aarch32_VST3_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, D=0, Rm=0, Vd=0, index_align=7, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_index_align_15_max_600_f98002f0() {
    // Thumb encoding (32): 0xF98002F0
    // Test aarch32_VST3_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=15, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rm_0_min_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t2a2_a_field_rm_1_poweroftwo_600_f9800201() {
    // Thumb encoding (32): 0xF9800201
    // Test aarch32_VST3_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, size=0, D=0, Rn=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_1_t2a2_a_combo_0_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_0_size_variant_0_1536_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_1_size_variant_1_1536_f9800600() {
    // Thumb encoding (32): 0xF9800600
    // Test aarch32_VST3_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: index_align=0, D=0, size=1, Vd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_2_size_variant_2_1536_f9800a00() {
    // Thumb encoding (32): 0xF9800A00
    // Test aarch32_VST3_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, Rm=0, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_1_t2a2_a_special_size_3_size_variant_3_1536_f9800e00() {
    // Thumb encoding (32): 0xF9800E00
    // Test aarch32_VST3_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, index_align=0, size=3, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_0_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_1_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: index_align=0, Rm=0, D=0, size=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_2_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(0))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, D=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_3_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, Rm=0, index_align=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_4_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: index_align=0, size=0, Rn=0, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t2a2_a_invalid_5_600_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, size=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_d_0_min_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, index_align=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_d_1_max_a00_f9c00200() {
    // Thumb encoding (32): 0xF9C00200
    // Test aarch32_VST3_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, size=0, Rn=0, Rm=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rn_0_min_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rn_1_poweroftwo_a00_f9810200() {
    // Thumb encoding (32): 0xF9810200
    // Test aarch32_VST3_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rm=0, Rn=1, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_vd_0_min_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_vd_1_poweroftwo_a00_f9801200() {
    // Thumb encoding (32): 0xF9801200
    // Test aarch32_VST3_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, index_align=0, Vd=1, size=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_0_min_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=0, Vd=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_1_poweroftwo_a00_f9800600() {
    // Thumb encoding (32): 0xF9800600
    // Test aarch32_VST3_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rm=0, Vd=0, index_align=0, size=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_2_poweroftwo_a00_f9800a00() {
    // Thumb encoding (32): 0xF9800A00
    // Test aarch32_VST3_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Rm=0, Rn=0, index_align=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_size_3_max_a00_f9800e00() {
    // Thumb encoding (32): 0xF9800E00
    // Test aarch32_VST3_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, index_align=0, Vd=0, Rn=0, Rm=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_0_min_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, Rn=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_1_poweroftwo_a00_f9800210() {
    // Thumb encoding (32): 0xF9800210
    // Test aarch32_VST3_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=1, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800210;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_7_poweroftwominusone_a00_f9800270() {
    // Thumb encoding (32): 0xF9800270
    // Test aarch32_VST3_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, size=0, Vd=0, D=0, index_align=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800270;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_index_align_15_max_a00_f98002f0() {
    // Thumb encoding (32): 0xF98002F0
    // Test aarch32_VST3_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Rm=0, Vd=0, index_align=15, D=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98002F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rm_0_min_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, D=0, Rn=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst3_1_t3a3_a_field_rm_1_poweroftwo_a00_f9800201() {
    // Thumb encoding (32): 0xF9800201
    // Test aarch32_VST3_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=0, size=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst3_1_t3a3_a_combo_0_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_0_size_variant_0_2560_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, Rn=0, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_1_size_variant_1_2560_f9800600() {
    // Thumb encoding (32): 0xF9800600
    // Test aarch32_VST3_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800600;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_2_size_variant_2_2560_f9800a00() {
    // Thumb encoding (32): 0xF9800A00
    // Test aarch32_VST3_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, size=2, Vd=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst3_1_t3a3_a_special_size_3_size_variant_3_2560_f9800e00() {
    // Thumb encoding (32): 0xF9800E00
    // Test aarch32_VST3_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Vd=0, Rm=0, Rn=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_0_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Vd=0, Rm=0, size=0, Rn=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_1_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=0, Rm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_2_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rn=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_3_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d3\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_4_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d3" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst3_1_t3a3_a_invalid_5_a00_f9800200() {
    // Thumb encoding (32): 0xF9800200
    // Test aarch32_VST3_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, index_align=0, size=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800200;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t1a1_a_store_0_f4810200() {
    // Test aarch32_VST3_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t1a1_a_store_1_f4810200() {
    // Test aarch32_VST3_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t1a1_a_store_2_f4810200() {
    // Test aarch32_VST3_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t2a2_a_store_0_f4810200() {
    // Test aarch32_VST3_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t2a2_a_store_1_f4810200() {
    // Test aarch32_VST3_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t2a2_a_store_2_f4810200() {
    // Test aarch32_VST3_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t3a3_a_store_0_f4810200() {
    // Test aarch32_VST3_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t3a3_a_store_1_f4810200() {
    // Test aarch32_VST3_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t3a3_a_store_2_f4810200() {
    // Test aarch32_VST3_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810200
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t1a1_a_store_0_f9810200() {
    // Test aarch32_VST3_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t1a1_a_store_1_f9810200() {
    // Test aarch32_VST3_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t1a1_a_store_2_f9810200() {
    // Test aarch32_VST3_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t2a2_a_store_0_f9810200() {
    // Test aarch32_VST3_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t2a2_a_store_1_f9810200() {
    // Test aarch32_VST3_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t2a2_a_store_2_f9810200() {
    // Test aarch32_VST3_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t3a3_a_store_0_f9810200() {
    // Test aarch32_VST3_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t3a3_a_store_1_f9810200() {
    // Test aarch32_VST3_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST3_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst3_1_t3a3_a_store_2_f9810200() {
    // Test aarch32_VST3_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST4_1_A Tests
// ============================================================================

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_d_0_min_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rn=0, Vd=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_d_1_max_300_f4c00300() {
    // Encoding: 0xF4C00300
    // Test aarch32_VST4_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, size=0, Rn=0, Rm=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4C00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rn_0_min_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rn=0, index_align=0, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rn_1_poweroftwo_300_f4810300() {
    // Encoding: 0xF4810300
    // Test aarch32_VST4_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, index_align=0, Rm=0, Rn=1
    let encoding: u32 = 0xF4810300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_vd_0_min_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, Rn=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_vd_1_poweroftwo_300_f4801300() {
    // Encoding: 0xF4801300
    // Test aarch32_VST4_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, Vd=1, Rm=0, size=0
    let encoding: u32 = 0xF4801300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_0_min_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, Vd=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_1_poweroftwo_300_f4800700() {
    // Encoding: 0xF4800700
    // Test aarch32_VST4_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, size=1, Rn=0, index_align=0
    let encoding: u32 = 0xF4800700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_2_poweroftwo_300_f4800b00() {
    // Encoding: 0xF4800B00
    // Test aarch32_VST4_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, size=2, Rn=0
    let encoding: u32 = 0xF4800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_3_max_300_f4800f00() {
    // Encoding: 0xF4800F00
    // Test aarch32_VST4_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rm=0, size=3, Rn=0
    let encoding: u32 = 0xF4800F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_0_min_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, size=0, D=0, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_1_poweroftwo_300_f4800310() {
    // Encoding: 0xF4800310
    // Test aarch32_VST4_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, size=0, Vd=0, index_align=1, Rm=0, D=0
    let encoding: u32 = 0xF4800310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_7_poweroftwominusone_300_f4800370() {
    // Encoding: 0xF4800370
    // Test aarch32_VST4_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, index_align=7, D=0, Rm=0
    let encoding: u32 = 0xF4800370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_15_max_300_f48003f0() {
    // Encoding: 0xF48003F0
    // Test aarch32_VST4_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, size=0, Rn=0, Vd=0, index_align=15, Rm=0
    let encoding: u32 = 0xF48003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rm_0_min_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rm=0, Rn=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rm_1_poweroftwo_300_f4800301() {
    // Encoding: 0xF4800301
    // Test aarch32_VST4_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, index_align=0, Rm=1, D=0
    let encoding: u32 = 0xF4800301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_1_t1a1_a_combo_0_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rm=0, size=0, Rn=0, D=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_0_size_variant_0_768_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, size=0, Rm=0, index_align=0, Rn=0, D=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_1_size_variant_1_768_f4800700() {
    // Encoding: 0xF4800700
    // Test aarch32_VST4_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=1, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_2_size_variant_2_768_f4800b00() {
    // Encoding: 0xF4800B00
    // Test aarch32_VST4_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, Rn=0, Vd=0, D=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_3_size_variant_3_768_f4800f00() {
    // Encoding: 0xF4800F00
    // Test aarch32_VST4_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=3, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4800F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_0_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, index_align=0, D=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_1_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_2_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rm=0, Rn=0, D=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_3_300_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_d_0_min_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, D=0, Vd=0, size=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_d_1_max_700_f4c00300() {
    // Encoding: 0xF4C00300
    // Test aarch32_VST4_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, size=0, index_align=0, D=1, Rn=0, Vd=0
    let encoding: u32 = 0xF4C00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rn_0_min_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, D=0, size=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rn_1_poweroftwo_700_f4810300() {
    // Encoding: 0xF4810300
    // Test aarch32_VST4_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=1, size=0, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4810300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_vd_0_min_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, Rm=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_vd_1_poweroftwo_700_f4801300() {
    // Encoding: 0xF4801300
    // Test aarch32_VST4_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, size=0, Rm=0, D=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4801300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_0_min_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rm=0, Rn=0, size=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_1_poweroftwo_700_f4800700() {
    // Encoding: 0xF4800700
    // Test aarch32_VST4_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=1, Rm=0, D=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_2_poweroftwo_700_f4800b00() {
    // Encoding: 0xF4800B00
    // Test aarch32_VST4_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=0, Vd=0, size=2, Rm=0
    let encoding: u32 = 0xF4800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_3_max_700_f4800f00() {
    // Encoding: 0xF4800F00
    // Test aarch32_VST4_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: index_align=0, Vd=0, size=3, Rn=0, Rm=0, D=0
    let encoding: u32 = 0xF4800F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_0_min_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_1_poweroftwo_700_f4800310() {
    // Encoding: 0xF4800310
    // Test aarch32_VST4_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, index_align=1, Vd=0, D=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_7_poweroftwominusone_700_f4800370() {
    // Encoding: 0xF4800370
    // Test aarch32_VST4_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, index_align=7, Rm=0, Vd=0
    let encoding: u32 = 0xF4800370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_15_max_700_f48003f0() {
    // Encoding: 0xF48003F0
    // Test aarch32_VST4_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: D=0, index_align=15, size=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF48003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rm_0_min_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, D=0, Rn=0, Rm=0, size=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rm_1_poweroftwo_700_f4800301() {
    // Encoding: 0xF4800301
    // Test aarch32_VST4_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, Rm=1, size=0, index_align=0
    let encoding: u32 = 0xF4800301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_1_t2a2_a_combo_0_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_0_size_variant_0_1792_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_1_size_variant_1_1792_f4800700() {
    // Encoding: 0xF4800700
    // Test aarch32_VST4_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, D=0, Rn=0, size=1, Rm=0, index_align=0
    let encoding: u32 = 0xF4800700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_2_size_variant_2_1792_f4800b00() {
    // Encoding: 0xF4800B00
    // Test aarch32_VST4_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, size=2, D=0, Vd=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_3_size_variant_3_1792_f4800f00() {
    // Encoding: 0xF4800F00
    // Test aarch32_VST4_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    let encoding: u32 = 0xF4800F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_0_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=0, Vd=0, D=0, Rn=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_1_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, Rm=0, index_align=0, D=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_2_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_3_700_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: size=0, D=0, index_align=0, Rm=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_d_0_min_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rm=0, Rn=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_d_1_max_b00_f4c00300() {
    // Encoding: 0xF4C00300
    // Test aarch32_VST4_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=1, size=0, Rm=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4C00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rn_0_min_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, Rn=0, size=0, D=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rn_1_poweroftwo_b00_f4810300() {
    // Encoding: 0xF4810300
    // Test aarch32_VST4_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, Rn=1, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4810300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_vd_0_min_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, index_align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_vd_1_poweroftwo_b00_f4801300() {
    // Encoding: 0xF4801300
    // Test aarch32_VST4_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rm=0, Vd=1, Rn=0, index_align=0, D=0
    let encoding: u32 = 0xF4801300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_0_min_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Vd=0, size=0, D=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_1_poweroftwo_b00_f4800700() {
    // Encoding: 0xF4800700
    // Test aarch32_VST4_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, size=1, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4800700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_2_poweroftwo_b00_f4800b00() {
    // Encoding: 0xF4800B00
    // Test aarch32_VST4_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, Vd=0, index_align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_3_max_b00_f4800f00() {
    // Encoding: 0xF4800F00
    // Test aarch32_VST4_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, D=0, size=3, Rm=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_0_min_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_1_poweroftwo_b00_f4800310() {
    // Encoding: 0xF4800310
    // Test aarch32_VST4_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=1, Vd=0, Rm=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4800310;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_7_poweroftwominusone_b00_f4800370() {
    // Encoding: 0xF4800370
    // Test aarch32_VST4_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Vd=0, D=0, size=0, index_align=7, Rm=0
    let encoding: u32 = 0xF4800370;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_15_max_b00_f48003f0() {
    // Encoding: 0xF48003F0
    // Test aarch32_VST4_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, Vd=0, size=0, D=0, Rn=0, index_align=15
    let encoding: u32 = 0xF48003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rm_0_min_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rn=0, size=0, Rm=0, D=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rm_1_poweroftwo_b00_f4800301() {
    // Encoding: 0xF4800301
    // Test aarch32_VST4_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Rm=1, index_align=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4800301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_1_t3a3_a_combo_0_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, D=0, index_align=0, Rn=0, Vd=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_0_size_variant_0_2816_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, D=0, Vd=0, index_align=0, Rm=0, size=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_1_size_variant_1_2816_f4800700() {
    // Encoding: 0xF4800700
    // Test aarch32_VST4_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: index_align=0, size=1, Rm=0, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800700;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_2_size_variant_2_2816_f4800b00() {
    // Encoding: 0xF4800B00
    // Test aarch32_VST4_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: D=0, size=2, Rn=0, Vd=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4800B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_3_size_variant_3_2816_f4800f00() {
    // Encoding: 0xF4800F00
    // Test aarch32_VST4_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, size=3, index_align=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4800F00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_0_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Vd=0, index_align=0, D=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_1_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_2_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: index_align=0, Rn=0, D=0, size=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_3_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, D=0, Rm=0, Rn=0, index_align=0, Vd=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_4_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: size=0, D=0, Rn=0, Rm=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_5_b00_f4800300() {
    // Encoding: 0xF4800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: index_align=0, D=0, size=0, Vd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_d_0_min_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, Vd=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_d_1_max_300_f9c00300() {
    // Thumb encoding (32): 0xF9C00300
    // Test aarch32_VST4_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rm=0, D=1, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rn_0_min_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, size=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rn_1_poweroftwo_300_f9810300() {
    // Thumb encoding (32): 0xF9810300
    // Test aarch32_VST4_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_vd_0_min_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_vd_1_poweroftwo_300_f9801300() {
    // Thumb encoding (32): 0xF9801300
    // Test aarch32_VST4_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, Rn=0, D=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_0_min_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rm=0, D=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_1_poweroftwo_300_f9800700() {
    // Thumb encoding (32): 0xF9800700
    // Test aarch32_VST4_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, index_align=0, size=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_2_poweroftwo_300_f9800b00() {
    // Thumb encoding (32): 0xF9800B00
    // Test aarch32_VST4_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=2, Rn=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_size_3_max_300_f9800f00() {
    // Thumb encoding (32): 0xF9800F00
    // Test aarch32_VST4_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, index_align=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_0_min_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_1_poweroftwo_300_f9800310() {
    // Thumb encoding (32): 0xF9800310
    // Test aarch32_VST4_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Rm=0, Vd=0, D=0, Rn=0, index_align=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_7_poweroftwominusone_300_f9800370() {
    // Thumb encoding (32): 0xF9800370
    // Test aarch32_VST4_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, index_align=7, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_index_align_15_max_300_f98003f0() {
    // Thumb encoding (32): 0xF98003F0
    // Test aarch32_VST4_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=15, Rm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rm_0_min_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t1a1_a_field_rm_1_poweroftwo_300_f9800301() {
    // Thumb encoding (32): 0xF9800301
    // Test aarch32_VST4_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, D=0, Rm=1, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_1_t1a1_a_combo_0_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, index_align=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_0_size_variant_0_768_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, size=0, Rn=0, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_1_size_variant_1_768_f9800700() {
    // Thumb encoding (32): 0xF9800700
    // Test aarch32_VST4_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=1, Vd=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_2_size_variant_2_768_f9800b00() {
    // Thumb encoding (32): 0xF9800B00
    // Test aarch32_VST4_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, index_align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_1_t1a1_a_special_size_3_size_variant_3_768_f9800f00() {
    // Thumb encoding (32): 0xF9800F00
    // Test aarch32_VST4_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, Vd=0, index_align=0, Rm=0, Rn=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_0_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Rm=0, Vd=0, index_align=0, Rn=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_1_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_2_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t1a1_a_invalid_3_300_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, D=0, Rn=0, Vd=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_d_0_min_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=0, size=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_d_1_max_700_f9c00300() {
    // Thumb encoding (32): 0xF9C00300
    // Test aarch32_VST4_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Vd=0, D=1, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rn_0_min_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rn_1_poweroftwo_700_f9810300() {
    // Thumb encoding (32): 0xF9810300
    // Test aarch32_VST4_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, Rn=1, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_vd_0_min_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rm=0, Rn=0, size=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_vd_1_poweroftwo_700_f9801300() {
    // Thumb encoding (32): 0xF9801300
    // Test aarch32_VST4_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=1, Rn=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_0_min_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rn=0, Vd=0, index_align=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_1_poweroftwo_700_f9800700() {
    // Thumb encoding (32): 0xF9800700
    // Test aarch32_VST4_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=1, index_align=0, Rn=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_2_poweroftwo_700_f9800b00() {
    // Thumb encoding (32): 0xF9800B00
    // Test aarch32_VST4_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, size=2, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_size_3_max_700_f9800f00() {
    // Thumb encoding (32): 0xF9800F00
    // Test aarch32_VST4_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_0_min_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_1_poweroftwo_700_f9800310() {
    // Thumb encoding (32): 0xF9800310
    // Test aarch32_VST4_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=1, Vd=0, Rn=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_7_poweroftwominusone_700_f9800370() {
    // Thumb encoding (32): 0xF9800370
    // Test aarch32_VST4_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, index_align=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_index_align_15_max_700_f98003f0() {
    // Thumb encoding (32): 0xF98003F0
    // Test aarch32_VST4_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, index_align=15, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rm_0_min_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rn=0, index_align=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t2a2_a_field_rm_1_poweroftwo_700_f9800301() {
    // Thumb encoding (32): 0xF9800301
    // Test aarch32_VST4_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=1, Rn=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_1_t2a2_a_combo_0_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_0_size_variant_0_1792_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Vd=0, size=0, index_align=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_1_size_variant_1_1792_f9800700() {
    // Thumb encoding (32): 0xF9800700
    // Test aarch32_VST4_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Vd=0, size=1, Rm=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_2_size_variant_2_1792_f9800b00() {
    // Thumb encoding (32): 0xF9800B00
    // Test aarch32_VST4_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=2, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_1_t2a2_a_special_size_3_size_variant_3_1792_f9800f00() {
    // Thumb encoding (32): 0xF9800F00
    // Test aarch32_VST4_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Rm=0, D=0, Vd=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_0_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: size=0, Rm=0, Rn=0, Vd=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_1_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rn=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_2_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: size=0, Rm=0, index_align=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t2a2_a_invalid_3_700_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, size=0, D=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_d_0_min_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_d_1_max_b00_f9c00300() {
    // Thumb encoding (32): 0xF9C00300
    // Test aarch32_VST4_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: index_align=0, Vd=0, D=1, Rn=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rn_0_min_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rn_1_poweroftwo_b00_f9810300() {
    // Thumb encoding (32): 0xF9810300
    // Test aarch32_VST4_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, index_align=0, size=0, D=0, Rn=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_vd_0_min_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_vd_1_poweroftwo_b00_f9801300() {
    // Thumb encoding (32): 0xF9801300
    // Test aarch32_VST4_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, size=0, index_align=0, Rm=0, Rn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_0_min_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Rm=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_1_poweroftwo_b00_f9800700() {
    // Thumb encoding (32): 0xF9800700
    // Test aarch32_VST4_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, index_align=0, size=1, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_2_poweroftwo_b00_f9800b00() {
    // Thumb encoding (32): 0xF9800B00
    // Test aarch32_VST4_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Vd=0, index_align=0, Rn=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_size_3_max_b00_f9800f00() {
    // Thumb encoding (32): 0xF9800F00
    // Test aarch32_VST4_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, D=0, size=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_0_min_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, size=0, Vd=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_1_poweroftwo_b00_f9800310() {
    // Thumb encoding (32): 0xF9800310
    // Test aarch32_VST4_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=1, size=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800310;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_7_poweroftwominusone_b00_f9800370() {
    // Thumb encoding (32): 0xF9800370
    // Test aarch32_VST4_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, size=0, D=0, index_align=7, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800370;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_index_align_15_max_b00_f98003f0() {
    // Thumb encoding (32): 0xF98003F0
    // Test aarch32_VST4_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, Rm=0, D=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98003F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rm_0_min_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, Rm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst4_1_t3a3_a_field_rm_1_poweroftwo_b00_f9800301() {
    // Thumb encoding (32): 0xF9800301
    // Test aarch32_VST4_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, D=0, index_align=0, Rn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst4_1_t3a3_a_combo_0_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, index_align=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_0_size_variant_0_2816_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, D=0, Rm=0, Vd=0, Rn=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_1_size_variant_1_2816_f9800700() {
    // Thumb encoding (32): 0xF9800700
    // Test aarch32_VST4_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, size=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_2_size_variant_2_2816_f9800b00() {
    // Thumb encoding (32): 0xF9800B00
    // Test aarch32_VST4_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, size=2, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst4_1_t3a3_a_special_size_3_size_variant_3_2816_f9800f00() {
    // Thumb encoding (32): 0xF9800F00
    // Test aarch32_VST4_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=3, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_0_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: index_align=0, Rm=0, Vd=0, Rn=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_1_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, index_align=0, size=0, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_2_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Slice { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), slices: [Range { hi: LitInt(1), lo: LitInt(0) }] }, rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_3_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: index_align=0, Rm=0, D=0, Vd=0, size=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d4\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_4_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d4" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, Vd=0, size=0, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst4_1_t3a3_a_invalid_5_b00_f9800300() {
    // Thumb encoding (32): 0xF9800300
    // Test aarch32_VST4_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_0_f4810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_1_f4810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_2_f4810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_3_f4810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_0_f4810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_1_f4810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_2_f4810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_3_f4810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_0_f4810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_1_f4810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_2_f4810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_3_f4810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810300
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_0_f9810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_1_f9810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_2_f9810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t1a1_a_store_3_f9810300() {
    // Test aarch32_VST4_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_0_f9810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_1_f9810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_2_f9810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t2a2_a_store_3_f9810300() {
    // Test aarch32_VST4_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_0_f9810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_1_f9810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_2_f9810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST4_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst4_1_t3a3_a_store_3_f9810300() {
    // Test aarch32_VST4_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_VST2_1_A Tests
// ============================================================================

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_d_0_min_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, Rm=0, index_align=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_d_1_max_100_f4c00100() {
    // Encoding: 0xF4C00100
    // Test aarch32_VST2_1_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vd=0, index_align=0, Rm=0, D=1, Rn=0
    let encoding: u32 = 0xF4C00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rn_0_min_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, Vd=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rn_1_poweroftwo_100_f4810100() {
    // Encoding: 0xF4810100
    // Test aarch32_VST2_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Vd=0, index_align=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4810100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_vd_0_min_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, Vd=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_vd_1_poweroftwo_100_f4801100() {
    // Encoding: 0xF4801100
    // Test aarch32_VST2_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, Vd=1, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4801100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_0_min_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, Rm=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_1_poweroftwo_100_f4800500() {
    // Encoding: 0xF4800500
    // Test aarch32_VST2_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Vd=0, Rm=0, D=0, Rn=0, size=1
    let encoding: u32 = 0xF4800500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_2_poweroftwo_100_f4800900() {
    // Encoding: 0xF4800900
    // Test aarch32_VST2_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, size=2, Vd=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4800900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_3_max_100_f4800d00() {
    // Encoding: 0xF4800D00
    // Test aarch32_VST2_1_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Rm=0, Vd=0, Rn=0, index_align=0, D=0
    let encoding: u32 = 0xF4800D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_0_min_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, Rm=0, D=0, Rn=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_1_poweroftwo_100_f4800110() {
    // Encoding: 0xF4800110
    // Test aarch32_VST2_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=1, size=0, Rn=0, Vd=0, Rm=0, D=0
    let encoding: u32 = 0xF4800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_7_poweroftwominusone_100_f4800170() {
    // Encoding: 0xF4800170
    // Test aarch32_VST2_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, Vd=0, Rm=0, D=0, Rn=0, index_align=7
    let encoding: u32 = 0xF4800170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_15_max_100_f48001f0() {
    // Encoding: 0xF48001F0
    // Test aarch32_VST2_1_T1A1_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, size=0, index_align=15, D=0, Vd=0
    let encoding: u32 = 0xF48001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rm_0_min_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, index_align=0, size=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rm_1_poweroftwo_100_f4800101() {
    // Encoding: 0xF4800101
    // Test aarch32_VST2_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, index_align=0, Rm=1, D=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_1_t1a1_a_combo_0_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: size=0, Vd=0, index_align=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_0_size_variant_0_256_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Vd=0, D=0, size=0, index_align=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_1_size_variant_1_256_f4800500() {
    // Encoding: 0xF4800500
    // Test aarch32_VST2_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, D=0, size=1, Rm=0, index_align=0, Rn=0
    let encoding: u32 = 0xF4800500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_2_size_variant_2_256_f4800900() {
    // Encoding: 0xF4800900
    // Test aarch32_VST2_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, D=0, size=2, index_align=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_3_size_variant_3_256_f4800d00() {
    // Encoding: 0xF4800D00
    // Test aarch32_VST2_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=3, Rm=0, index_align=0
    let encoding: u32 = 0xF4800D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_0_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Vd=0, Rm=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_1_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, index_align=0, D=0, Vd=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_2_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_3_100_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, size=0, D=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_d_0_min_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_d_1_max_500_f4c00100() {
    // Encoding: 0xF4C00100
    // Test aarch32_VST2_1_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Vd=0, size=0, D=1, index_align=0
    let encoding: u32 = 0xF4C00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rn_0_min_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, Vd=0, D=0, Rn=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rn_1_poweroftwo_500_f4810100() {
    // Encoding: 0xF4810100
    // Test aarch32_VST2_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, D=0, Rn=1, Rm=0
    let encoding: u32 = 0xF4810100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_vd_0_min_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, index_align=0, Vd=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_vd_1_poweroftwo_500_f4801100() {
    // Encoding: 0xF4801100
    // Test aarch32_VST2_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=1
    let encoding: u32 = 0xF4801100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_0_min_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, size=0, Rm=0, Rn=0, Vd=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_1_poweroftwo_500_f4800500() {
    // Encoding: 0xF4800500
    // Test aarch32_VST2_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, index_align=0, Vd=0, size=1
    let encoding: u32 = 0xF4800500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_2_poweroftwo_500_f4800900() {
    // Encoding: 0xF4800900
    // Test aarch32_VST2_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=2, index_align=0
    let encoding: u32 = 0xF4800900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_3_max_500_f4800d00() {
    // Encoding: 0xF4800D00
    // Test aarch32_VST2_1_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, Vd=0, size=3, index_align=0
    let encoding: u32 = 0xF4800D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_0_min_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, size=0, D=0, index_align=0, Rm=0, Vd=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_1_poweroftwo_500_f4800110() {
    // Encoding: 0xF4800110
    // Test aarch32_VST2_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Vd=0, D=0, Rn=0, size=0, index_align=1
    let encoding: u32 = 0xF4800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_7_poweroftwominusone_500_f4800170() {
    // Encoding: 0xF4800170
    // Test aarch32_VST2_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: index_align=7, Vd=0, Rn=0, Rm=0, size=0, D=0
    let encoding: u32 = 0xF4800170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_15_max_500_f48001f0() {
    // Encoding: 0xF48001F0
    // Test aarch32_VST2_1_T2A2_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: size=0, Rn=0, D=0, Vd=0, index_align=15, Rm=0
    let encoding: u32 = 0xF48001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rm_0_min_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, index_align=0, Rm=0, D=0, Rn=0, size=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rm_1_poweroftwo_500_f4800101() {
    // Encoding: 0xF4800101
    // Test aarch32_VST2_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, D=0, Vd=0, Rn=0, index_align=0, size=0
    let encoding: u32 = 0xF4800101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_1_t2a2_a_combo_0_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Vd=0, index_align=0, Rm=0, D=0, size=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_0_size_variant_0_1280_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_1_size_variant_1_1280_f4800500() {
    // Encoding: 0xF4800500
    // Test aarch32_VST2_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, Rn=0, index_align=0, size=1, Rm=0, Vd=0
    let encoding: u32 = 0xF4800500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_2_size_variant_2_1280_f4800900() {
    // Encoding: 0xF4800900
    // Test aarch32_VST2_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, Rm=0, Vd=0, D=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_3_size_variant_3_1280_f4800d00() {
    // Encoding: 0xF4800D00
    // Test aarch32_VST2_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, D=0, size=3, index_align=0, Rn=0, Vd=0
    let encoding: u32 = 0xF4800D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_0_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: index_align=0, Rm=0, Vd=0, size=0, D=0, Rn=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_1_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rn=0, size=0, Rm=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_2_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: size=0, index_align=0, D=0, Rm=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_3_500_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Vd=0, Rm=0, size=0, D=0, index_align=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_d_0_min_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_d_1_max_900_f4c00100() {
    // Encoding: 0xF4C00100
    // Test aarch32_VST2_1_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: index_align=0, size=0, Vd=0, Rn=0, D=1, Rm=0
    let encoding: u32 = 0xF4C00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rn_0_min_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: size=0, Rn=0, Vd=0, Rm=0, index_align=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rn_1_poweroftwo_900_f4810100() {
    // Encoding: 0xF4810100
    // Test aarch32_VST2_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, D=0, Vd=0, size=0, index_align=0, Rm=0
    let encoding: u32 = 0xF4810100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_vd_0_min_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, index_align=0, Rn=0, D=0, Vd=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_vd_1_poweroftwo_900_f4801100() {
    // Encoding: 0xF4801100
    // Test aarch32_VST2_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, size=0, Vd=1, index_align=0
    let encoding: u32 = 0xF4801100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_0_min_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, index_align=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_1_poweroftwo_900_f4800500() {
    // Encoding: 0xF4800500
    // Test aarch32_VST2_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, size=1, D=0, index_align=0, Vd=0, Rn=0
    let encoding: u32 = 0xF4800500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_2_poweroftwo_900_f4800900() {
    // Encoding: 0xF4800900
    // Test aarch32_VST2_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, index_align=0, size=2, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4800900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_3_max_900_f4800d00() {
    // Encoding: 0xF4800D00
    // Test aarch32_VST2_1_T3A3_A field size = 3 (Max)
    // ISET: A32
    // Fields: Rn=0, Vd=0, size=3, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4800D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_0_min_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field index_align = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, index_align=0, Rm=0, Rn=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_1_poweroftwo_900_f4800110() {
    // Encoding: 0xF4800110
    // Test aarch32_VST2_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, index_align=1, Rn=0, Vd=0, size=0, Rm=0
    let encoding: u32 = 0xF4800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_7_poweroftwominusone_900_f4800170() {
    // Encoding: 0xF4800170
    // Test aarch32_VST2_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, D=0, Rm=0, Vd=0, index_align=7, size=0
    let encoding: u32 = 0xF4800170;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_15_max_900_f48001f0() {
    // Encoding: 0xF48001F0
    // Test aarch32_VST2_1_T3A3_A field index_align = 15 (Max)
    // ISET: A32
    // Fields: size=0, index_align=15, Rm=0, D=0, Vd=0, Rn=0
    let encoding: u32 = 0xF48001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rm_0_min_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: index_align=0, Rn=0, Rm=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rm_1_poweroftwo_900_f4800101() {
    // Encoding: 0xF4800101
    // Test aarch32_VST2_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: index_align=0, Rm=1, Rn=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF4800101;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_1_t3a3_a_combo_0_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: A32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_0_size_variant_0_2304_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, Rn=0, size=0, index_align=0, Rm=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_1_size_variant_1_2304_f4800500() {
    // Encoding: 0xF4800500
    // Test aarch32_VST2_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, size=1, D=0, index_align=0, Rm=0, Rn=0
    let encoding: u32 = 0xF4800500;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_2_size_variant_2_2304_f4800900() {
    // Encoding: 0xF4800900
    // Test aarch32_VST2_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rn=0, size=2, Rm=0, D=0, Vd=0, index_align=0
    let encoding: u32 = 0xF4800900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_3_size_variant_3_2304_f4800d00() {
    // Encoding: 0xF4800D00
    // Test aarch32_VST2_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, size=3, index_align=0
    let encoding: u32 = 0xF4800D00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_0_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: size=0, Rm=0, D=0, Vd=0, Rn=0, index_align=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_1_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Rn=0, Vd=0, size=0, Rm=0, index_align=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_2_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: A32
    // Fields: Vd=0, Rn=0, index_align=0, D=0, size=0, Rm=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_3_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rm=0, Rn=0, D=0, index_align=0, Vd=0, size=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_4_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: index_align=0, Rm=0, size=0, Vd=0, Rn=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_5_900_f4800100() {
    // Encoding: 0xF4800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, size=0, index_align=0, Rm=0, Vd=0, D=0
    let encoding: u32 = 0xF4800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_d_0_min_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rn=0, size=0, D=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_d_1_max_100_f9c00100() {
    // Thumb encoding (32): 0xF9C00100
    // Test aarch32_VST2_1_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, size=0, index_align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rn_0_min_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, Rn=0, Rm=0, index_align=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rn_1_poweroftwo_100_f9810100() {
    // Thumb encoding (32): 0xF9810100
    // Test aarch32_VST2_1_T1A1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rn=1, Rm=0, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_vd_0_min_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_vd_1_poweroftwo_100_f9801100() {
    // Thumb encoding (32): 0xF9801100
    // Test aarch32_VST2_1_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, index_align=0, size=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_0_min_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, Rm=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_1_poweroftwo_100_f9800500() {
    // Thumb encoding (32): 0xF9800500
    // Test aarch32_VST2_1_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=1, Rm=0, index_align=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_2_poweroftwo_100_f9800900() {
    // Thumb encoding (32): 0xF9800900
    // Test aarch32_VST2_1_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, index_align=0, size=2, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_size_3_max_100_f9800d00() {
    // Thumb encoding (32): 0xF9800D00
    // Test aarch32_VST2_1_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, D=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_0_min_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, index_align=0, Vd=0, size=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_1_poweroftwo_100_f9800110() {
    // Thumb encoding (32): 0xF9800110
    // Test aarch32_VST2_1_T1A1_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, size=0, index_align=1, D=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_7_poweroftwominusone_100_f9800170() {
    // Thumb encoding (32): 0xF9800170
    // Test aarch32_VST2_1_T1A1_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: index_align=7, D=0, Rn=0, size=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_index_align_15_max_100_f98001f0() {
    // Thumb encoding (32): 0xF98001F0
    // Test aarch32_VST2_1_T1A1_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: index_align=15, size=0, Rm=0, D=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rm_0_min_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t1a1_a_field_rm_1_poweroftwo_100_f9800101() {
    // Thumb encoding (32): 0xF9800101
    // Test aarch32_VST2_1_T1A1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, index_align=0, Rm=1, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_1_t1a1_a_combo_0_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: index_align=0, Rm=0, Rn=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_0_size_variant_0_256_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, D=0, Vd=0, size=0, index_align=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_1_size_variant_1_256_f9800500() {
    // Thumb encoding (32): 0xF9800500
    // Test aarch32_VST2_1_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, size=1, D=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_2_size_variant_2_256_f9800900() {
    // Thumb encoding (32): 0xF9800900
    // Test aarch32_VST2_1_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, D=0, index_align=0, Rn=0, size=2, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_1_t1a1_a_special_size_3_size_variant_3_256_f9800d00() {
    // Thumb encoding (32): 0xF9800D00
    // Test aarch32_VST2_1_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, Vd=0, Rm=0, D=0, index_align=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_0_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, Rn=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_1_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Rm=0, Rn=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_2_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: size=0, index_align=0, Rn=0, Rm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t1a1_a_invalid_3_100_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: index_align=0, Rm=0, D=0, size=0, Vd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_d_0_min_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rm=0, Rn=0, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_d_1_max_500_f9c00100() {
    // Thumb encoding (32): 0xF9C00100
    // Test aarch32_VST2_1_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, D=1, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rn_0_min_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: size=0, D=0, index_align=0, Rm=0, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rn_1_poweroftwo_500_f9810100() {
    // Thumb encoding (32): 0xF9810100
    // Test aarch32_VST2_1_T2A2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Vd=0, D=0, index_align=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_vd_0_min_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, Rn=0, D=0, size=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_vd_1_poweroftwo_500_f9801100() {
    // Thumb encoding (32): 0xF9801100
    // Test aarch32_VST2_1_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=1, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_0_min_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, index_align=0, Rm=0, Vd=0, Rn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_1_poweroftwo_500_f9800500() {
    // Thumb encoding (32): 0xF9800500
    // Test aarch32_VST2_1_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, index_align=0, Vd=0, Rm=0, Rn=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_2_poweroftwo_500_f9800900() {
    // Thumb encoding (32): 0xF9800900
    // Test aarch32_VST2_1_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, D=0, index_align=0, size=2, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_size_3_max_500_f9800d00() {
    // Thumb encoding (32): 0xF9800D00
    // Test aarch32_VST2_1_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, size=3, Vd=0, index_align=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_0_min_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_1_poweroftwo_500_f9800110() {
    // Thumb encoding (32): 0xF9800110
    // Test aarch32_VST2_1_T2A2_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, index_align=1, size=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_7_poweroftwominusone_500_f9800170() {
    // Thumb encoding (32): 0xF9800170
    // Test aarch32_VST2_1_T2A2_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, D=0, size=0, Rn=0, index_align=7, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_index_align_15_max_500_f98001f0() {
    // Thumb encoding (32): 0xF98001F0
    // Test aarch32_VST2_1_T2A2_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, size=0, index_align=15, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rm_0_min_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, size=0, Vd=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t2a2_a_field_rm_1_poweroftwo_500_f9800101() {
    // Thumb encoding (32): 0xF9800101
    // Test aarch32_VST2_1_T2A2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=0, Rn=0, D=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_1_t2a2_a_combo_0_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: Vd=0, D=0, Rn=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_0_size_variant_0_1280_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, D=0, Vd=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_1_size_variant_1_1280_f9800500() {
    // Thumb encoding (32): 0xF9800500
    // Test aarch32_VST2_1_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, Rn=0, D=0, size=1, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_2_size_variant_2_1280_f9800900() {
    // Thumb encoding (32): 0xF9800900
    // Test aarch32_VST2_1_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: index_align=0, Vd=0, Rn=0, Rm=0, size=2, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_1_t2a2_a_special_size_3_size_variant_3_1280_f9800d00() {
    // Thumb encoding (32): 0xF9800D00
    // Test aarch32_VST2_1_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: index_align=0, D=0, Rm=0, Vd=0, size=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_0_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: D=0, Rn=0, Rm=0, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_1_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, index_align=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_2_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Vd=0, size=0, index_align=0, Rn=0, Rm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t2a2_a_invalid_3_500_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T2A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, Vd=0, size=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_d_0_min_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=0, Rm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_d_1_max_900_f9c00100() {
    // Thumb encoding (32): 0xF9C00100
    // Test aarch32_VST2_1_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, D=1, Rn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rn_0_min_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=0, Rm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rn_1_poweroftwo_900_f9810100() {
    // Thumb encoding (32): 0xF9810100
    // Test aarch32_VST2_1_T3A3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, D=0, Rn=1, Vd=0, size=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_vd_0_min_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Vd=0, size=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_vd_1_poweroftwo_900_f9801100() {
    // Thumb encoding (32): 0xF9801100
    // Test aarch32_VST2_1_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=0, Rm=0, size=0, D=0, Vd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9801100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_0_min_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_1_poweroftwo_900_f9800500() {
    // Thumb encoding (32): 0xF9800500
    // Test aarch32_VST2_1_T3A3_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, index_align=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_2_poweroftwo_900_f9800900() {
    // Thumb encoding (32): 0xF9800900
    // Test aarch32_VST2_1_T3A3_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Rn=0, size=2, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size 10 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_size_3_max_900_f9800d00() {
    // Thumb encoding (32): 0xF9800D00
    // Test aarch32_VST2_1_T3A3_A field size = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, size=3, index_align=0, D=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_0_min_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field index_align = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, index_align=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_1_poweroftwo_900_f9800110() {
    // Thumb encoding (32): 0xF9800110
    // Test aarch32_VST2_1_T3A3_A field index_align = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: index_align=1, D=0, Rn=0, size=0, Vd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_7_poweroftwominusone_900_f9800170() {
    // Thumb encoding (32): 0xF9800170
    // Test aarch32_VST2_1_T3A3_A field index_align = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, Vd=0, Rn=0, size=0, index_align=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field index_align 4 +: 4`
/// Requirement: FieldBoundary { field: "index_align", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_index_align_15_max_900_f98001f0() {
    // Thumb encoding (32): 0xF98001F0
    // Test aarch32_VST2_1_T3A3_A field index_align = 15 (Max)
    // ISET: T32
    // Fields: D=0, Rn=0, index_align=15, Rm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF98001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rm_0_min_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: D=0, index_align=0, Rn=0, Vd=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vst2_1_t3a3_a_field_rm_1_poweroftwo_900_f9800101() {
    // Thumb encoding (32): 0xF9800101
    // Test aarch32_VST2_1_T3A3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, index_align=0, Rn=0, Vd=0, Rm=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800101;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vst2_1_t3a3_a_combo_0_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A field combination: D=0, Rn=0, Vd=0, size=0, index_align=0, Rm=0
    // ISET: T32
    // Fields: size=0, index_align=0, Rm=0, Rn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_0_size_variant_0_2304_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Rn=0, D=0, size=0, index_align=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_1_size_variant_1_2304_f9800500() {
    // Thumb encoding (32): 0xF9800500
    // Test aarch32_VST2_1_T3A3_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, D=0, Rn=0, Vd=0, index_align=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800500;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_2_size_variant_2_2304_f9800900() {
    // Thumb encoding (32): 0xF9800900
    // Test aarch32_VST2_1_T3A3_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Rn=0, Vd=0, index_align=0, Rm=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vst2_1_t3a3_a_special_size_3_size_variant_3_2304_f9800d00() {
    // Thumb encoding (32): 0xF9800D00
    // Test aarch32_VST2_1_T3A3_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, size=3, index_align=0, D=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800D00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_0_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Vd=0, index_align=0, Rn=0, D=0, Rm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_1_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, index_align=0, Vd=0, Rm=0, D=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"index_align\" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_2_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Binary { op: Ne, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "index_align" }), indices: [Single(LitInt(1))] }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: D=0, Rn=0, size=0, index_align=0, Rm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_3_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, size=0, Vd=0, D=0, index_align=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d2\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_4_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Binary { op: Gt, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d2" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Rm=0, Vd=0, Rn=0, D=0, size=0, index_align=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vst2_1_t3a3_a_invalid_5_900_f9800100() {
    // Thumb encoding (32): 0xF9800100
    // Test aarch32_VST2_1_T3A3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, size=0, Rn=0, Vd=0, index_align=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9800100;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t1a1_a_store_0_f4810100() {
    // Test aarch32_VST2_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810100
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t1a1_a_store_1_f4810100() {
    // Test aarch32_VST2_1_T1A1_A memory store: 8 bytes
    // Encoding: 0xF4810100
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t2a2_a_store_0_f4810100() {
    // Test aarch32_VST2_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810100
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t2a2_a_store_1_f4810100() {
    // Test aarch32_VST2_1_T2A2_A memory store: 8 bytes
    // Encoding: 0xF4810100
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t3a3_a_store_0_f4810100() {
    // Test aarch32_VST2_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810100
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF4810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t3a3_a_store_1_f4810100() {
    // Test aarch32_VST2_1_T3A3_A memory store: 8 bytes
    // Encoding: 0xF4810100
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF4810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t1a1_a_store_0_f9810100() {
    // Test aarch32_VST2_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T1A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t1a1_a_store_1_f9810100() {
    // Test aarch32_VST2_1_T1A1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t2a2_a_store_0_f9810100() {
    // Test aarch32_VST2_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T2A2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t2a2_a_store_1_f9810100() {
    // Test aarch32_VST2_1_T2A2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t3a3_a_store_0_f9810100() {
    // Test aarch32_VST2_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_VST2_1_T3A3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_vst2_1_t3a3_a_store_1_f9810100() {
    // Test aarch32_VST2_1_T3A3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF9810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}
