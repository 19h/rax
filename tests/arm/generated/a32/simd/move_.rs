//! A32 simd move_ tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_VMOVL_A Tests
// ============================================================================

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovl_t1a1_a_field_u_0_min_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, U=0, Vd=0, imm3H=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_u_1_max_a10_f3800a10() {
    // Encoding: 0xF3800A10
    // Test aarch32_VMOVL_T1A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: imm3H=0, U=1, M=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovl_t1a1_a_field_d_0_min_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, U=0, Vd=0, D=0, imm3H=0, M=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_d_1_max_a10_f2c00a10() {
    // Encoding: 0xF2C00A10
    // Test aarch32_VMOVL_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, U=0, Vd=0, M=0, Vm=0, imm3H=0
    let encoding: u32 = 0xF2C00A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_0_zero_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 0 (Zero)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, imm3H=0, D=0, U=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_1_poweroftwo_a10_f2880a10() {
    // Encoding: 0xF2880A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Vd=0, M=0, D=0, U=0, imm3H=1
    let encoding: u32 = 0xF2880A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_3_poweroftwominusone_a10_f2980a10() {
    // Encoding: 0xF2980A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vm=0, U=0, M=0, D=0, imm3H=3, Vd=0
    let encoding: u32 = 0xF2980A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_7_max_a10_f2b80a10() {
    // Encoding: 0xF2B80A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 7 (Max)
    // ISET: A32
    // Fields: U=0, imm3H=7, M=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2B80A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vd_0_min_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: imm3H=0, Vd=0, M=0, D=0, Vm=0, U=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vd_1_poweroftwo_a10_f2801a10() {
    // Encoding: 0xF2801A10
    // Test aarch32_VMOVL_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, imm3H=0, M=0, D=0, Vm=0, U=0
    let encoding: u32 = 0xF2801A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovl_t1a1_a_field_m_0_min_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: imm3H=0, Vd=0, M=0, D=0, U=0, Vm=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_m_1_max_a10_f2800a30() {
    // Encoding: 0xF2800A30
    // Test aarch32_VMOVL_T1A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, U=0, Vd=0, imm3H=0, M=1, D=0
    let encoding: u32 = 0xF2800A30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vm_0_min_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=0, U=0, M=0, imm3H=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vm_1_poweroftwo_a10_f2800a11() {
    // Encoding: 0xF2800A11
    // Test aarch32_VMOVL_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vm=1, D=0, U=0, imm3H=0, Vd=0
    let encoding: u32 = 0xF2800A11;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_0_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: imm3H=0, D=0, Vd=0, U=0, M=0, Vm=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_1_a10_f3800a10() {
    // Encoding: 0xF3800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=1, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, imm3H=0, D=0, U=1, Vd=0, M=0
    let encoding: u32 = 0xF3800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_2_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, Vm=0, imm3H=0, U=0, Vd=0, M=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_3_a10_f2c00a10() {
    // Encoding: 0xF2C00A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=1, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, D=1, imm3H=0, U=0
    let encoding: u32 = 0xF2C00A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=0 (immediate value 0)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_4_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: U=0, M=0, Vm=0, imm3H=0, D=0, Vd=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=1 (immediate value 1)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_5_a10_f2880a10() {
    // Encoding: 0xF2880A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=1, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, U=0, M=0, imm3H=1, Vm=0, D=0
    let encoding: u32 = 0xF2880A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_6_a10_f2980a10() {
    // Encoding: 0xF2980A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=3, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: imm3H=3, M=0, Vm=0, Vd=0, D=0, U=0
    let encoding: u32 = 0xF2980A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_7_a10_f2b80a10() {
    // Encoding: 0xF2B80A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=7, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: imm3H=7, Vm=0, D=0, U=0, Vd=0, M=0
    let encoding: u32 = 0xF2B80A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_8_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, imm3H=0, U=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_9_a10_f2801a10() {
    // Encoding: 0xF2801A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=1, M=0, Vm=0
    // ISET: A32
    // Fields: imm3H=0, M=0, Vm=0, Vd=1, U=0, D=0
    let encoding: u32 = 0xF2801A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_10_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, U=0, imm3H=0, Vd=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_11_a10_f2800a30() {
    // Encoding: 0xF2800A30
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=1, Vm=0
    // ISET: A32
    // Fields: Vd=0, M=1, imm3H=0, U=0, D=0, Vm=0
    let encoding: u32 = 0xF2800A30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_12_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, imm3H=0, Vm=0, Vd=0, U=0, M=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_13_a10_f2800a11() {
    // Encoding: 0xF2800A11
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=1
    // ISET: A32
    // Fields: Vm=1, imm3H=0, U=0, Vd=0, D=0, M=0
    let encoding: u32 = 0xF2800A11;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovl_t1a1_a_invalid_0_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: U=0, M=0, Vd=0, D=0, Vm=0, imm3H=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovl_t1a1_a_invalid_1_a10_f2800a10() {
    // Encoding: 0xF2800A10
    // Test aarch32_VMOVL_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, M=0, imm3H=0, Vm=0, U=0, D=0
    let encoding: u32 = 0xF2800A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovl_t1a1_a_field_u_0_min_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field U = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, U=0, D=0, M=0, imm3H=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_u_1_max_a10_ff800a10() {
    // Thumb encoding (32): 0xFF800A10
    // Test aarch32_VMOVL_T1A1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, D=0, M=0, Vd=0, Vm=0, imm3H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovl_t1a1_a_field_d_0_min_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: imm3H=0, M=0, Vd=0, U=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_d_1_max_a10_efc00a10() {
    // Thumb encoding (32): 0xEFC00A10
    // Test aarch32_VMOVL_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, imm3H=0, Vd=0, U=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_0_zero_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 0 (Zero)
    // ISET: T32
    // Fields: imm3H=0, Vm=0, D=0, U=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_1_poweroftwo_a10_ef880a10() {
    // Thumb encoding (32): 0xEF880A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, imm3H=1, M=0, Vm=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF880A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_3_poweroftwominusone_a10_ef980a10() {
    // Thumb encoding (32): 0xEF980A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M=0, D=0, imm3H=3, Vm=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF980A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field imm3H 19 +: 3`
/// Requirement: FieldBoundary { field: "imm3H", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_imm3h_7_max_a10_efb80a10() {
    // Thumb encoding (32): 0xEFB80A10
    // Test aarch32_VMOVL_T1A1_A field imm3H = 7 (Max)
    // ISET: T32
    // Fields: imm3H=7, U=0, Vd=0, D=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB80A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vd_0_min_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: imm3H=0, D=0, U=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vd_1_poweroftwo_a10_ef801a10() {
    // Thumb encoding (32): 0xEF801A10
    // Test aarch32_VMOVL_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, Vd=1, U=0, imm3H=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovl_t1a1_a_field_m_0_min_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field M = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, U=0, Vm=0, imm3H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovl_t1a1_a_field_m_1_max_a10_ef800a30() {
    // Thumb encoding (32): 0xEF800A30
    // Test aarch32_VMOVL_T1A1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, imm3H=0, U=0, M=1, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vm_0_min_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, U=0, Vd=0, D=0, imm3H=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovl_t1a1_a_field_vm_1_poweroftwo_a10_ef800a11() {
    // Thumb encoding (32): 0xEF800A11
    // Test aarch32_VMOVL_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Vd=0, imm3H=0, D=0, M=0, Vm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_0_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, D=0, U=0, imm3H=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_1_a10_ff800a10() {
    // Thumb encoding (32): 0xFF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=1, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vd=0, Vm=0, U=1, D=0, imm3H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_2_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: imm3H=0, M=0, Vm=0, D=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_3_a10_efc00a10() {
    // Thumb encoding (32): 0xEFC00A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=1, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: U=0, Vm=0, M=0, D=1, Vd=0, imm3H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=0 (immediate value 0)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_4_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: U=0, D=0, imm3H=0, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=1 (immediate value 1)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_5_a10_ef880a10() {
    // Thumb encoding (32): 0xEF880A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=1, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, U=0, M=0, imm3H=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF880A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_6_a10_ef980a10() {
    // Thumb encoding (32): 0xEF980A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=3, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, imm3H=3, U=0, M=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF980A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3H=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_7_a10_efb80a10() {
    // Thumb encoding (32): 0xEFB80A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=7, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: U=0, Vm=0, Vd=0, D=0, imm3H=7, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB80A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_8_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, U=0, imm3H=0, Vd=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_9_a10_ef801a10() {
    // Thumb encoding (32): 0xEF801A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=1, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, imm3H=0, M=0, U=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_10_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, imm3H=0, M=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_11_a10_ef800a30() {
    // Thumb encoding (32): 0xEF800A30
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=1, Vm=0
    // ISET: T32
    // Fields: M=1, U=0, imm3H=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_12_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, imm3H=0, M=0, D=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovl_t1a1_a_combo_13_a10_ef800a11() {
    // Thumb encoding (32): 0xEF800A11
    // Test aarch32_VMOVL_T1A1_A field combination: U=0, D=0, imm3H=0, Vd=0, M=0, Vm=1
    // ISET: T32
    // Fields: imm3H=0, Vm=1, U=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovl_t1a1_a_invalid_0_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: U=0, Vd=0, Vm=0, imm3H=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovl_t1a1_a_invalid_1_a10_ef800a10() {
    // Thumb encoding (32): 0xEF800A10
    // Test aarch32_VMOVL_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm3H=0, D=0, Vm=0, M=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_0_f2802a30() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFF6, "X16 should be 0xFFFFFFFFFFFFFFF6");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_0_f2802a30() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFF6, "X16 should be 0xFFFFFFFFFFFFFFF6");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_1_f2800a30() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_1_f2800a30() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_2_f2800e30() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_2_f2800e30() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_3_f2bffe30() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_3_f2bffe30() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_4_f2fffe30() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_4_f2fffe30() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_5_f2800e30() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_5_f2800e30() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_6_f2800e30() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_6_f2800e30() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_7_f2800e30() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_7_f2800e30() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_8_f2800e30() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_8_f2800e30() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_9_f2800e30() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_9_f2800e30() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_10_f2800e30() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_10_f2800e30() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_32_rd31_sp_f2802a3f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802A3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmovl_t1a1_a_add_oracle_64_rd31_sp_f2802a3f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802A3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMOVL_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmovl_t1a1_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMOV_rs_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_0_min_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, opc2=0, Vd=0, cond=0, opc1=0, D=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_1_poweroftwo_b10_1e000b10() {
    // Encoding: 0x1E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rt=0, Vd=0, D=0, opc1=0, opc2=0
    let encoding: u32 = 0x1E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_2_poweroftwo_b10_2e000b10() {
    // Encoding: 0x2E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, opc1=0, Rt=0, cond=2, opc2=0
    let encoding: u32 = 0x2E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_3_poweroftwo_b10_3e000b10() {
    // Encoding: 0x3E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=0, Rt=0, D=0, cond=3, opc2=0, Vd=0
    let encoding: u32 = 0x3E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_4_poweroftwo_b10_4e000b10() {
    // Encoding: 0x4E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, cond=4, opc1=0, Rt=0, opc2=0
    let encoding: u32 = 0x4E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_5_poweroftwo_b10_5e000b10() {
    // Encoding: 0x5E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=0, Rt=0, opc2=0, Vd=0, D=0, cond=5
    let encoding: u32 = 0x5E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_6_poweroftwo_b10_6e000b10() {
    // Encoding: 0x6E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=6, Rt=0, Vd=0, opc1=0, opc2=0
    let encoding: u32 = 0x6E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_7_poweroftwo_b10_7e000b10() {
    // Encoding: 0x7E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Vd=0, D=0, opc2=0, cond=7, opc1=0
    let encoding: u32 = 0x7E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_8_poweroftwo_b10_8e000b10() {
    // Encoding: 0x8E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Vd=0, opc1=0, cond=8, D=0, opc2=0
    let encoding: u32 = 0x8E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_9_poweroftwo_b10_9e000b10() {
    // Encoding: 0x9E000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=0, D=0, Vd=0, Rt=0, opc2=0, cond=9
    let encoding: u32 = 0x9E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_10_poweroftwo_b10_ae000b10() {
    // Encoding: 0xAE000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Vd=0, Rt=0, D=0, opc1=0, opc2=0
    let encoding: u32 = 0xAE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_11_poweroftwo_b10_be000b10() {
    // Encoding: 0xBE000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, D=0, cond=11, opc2=0, opc1=0, Vd=0
    let encoding: u32 = 0xBE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_12_poweroftwo_b10_ce000b10() {
    // Encoding: 0xCE000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Rt=0, opc2=0, D=0, cond=12, opc1=0
    let encoding: u32 = 0xCE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_13_poweroftwo_b10_de000b10() {
    // Encoding: 0xDE000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: opc2=0, Vd=0, opc1=0, cond=13, D=0, Rt=0
    let encoding: u32 = 0xDE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_14_poweroftwo_b10_ee000b10() {
    // Encoding: 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: opc2=0, Rt=0, cond=14, D=0, Vd=0, opc1=0
    let encoding: u32 = 0xEE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_cond_15_max_b10_fe000b10() {
    // Encoding: 0xFE000B10
    // Test aarch32_VMOV_rs_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: opc2=0, Vd=0, Rt=0, cond=15, opc1=0, D=0
    let encoding: u32 = 0xFE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc1_0_min_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field opc1 = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Rt=0, opc1=0, D=0, cond=0, opc2=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc1_1_poweroftwo_b10_0e200b10() {
    // Encoding: 0x0E200B10
    // Test aarch32_VMOV_rs_T1A1_A field opc1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, opc1=1, cond=0, Vd=0, Rt=0, opc2=0
    let encoding: u32 = 0x0E200B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc1_3_max_b10_0e600b10() {
    // Encoding: 0x0E600B10
    // Test aarch32_VMOV_rs_T1A1_A field opc1 = 3 (Max)
    // ISET: A32
    // Fields: D=0, cond=0, opc1=3, Rt=0, Vd=0, opc2=0
    let encoding: u32 = 0x0E600B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Vd 16 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_vd_0_min_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Vd=0, opc1=0, cond=0, opc2=0, D=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Vd 16 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_vd_1_poweroftwo_b10_0e010b10() {
    // Encoding: 0x0E010B10
    // Test aarch32_VMOV_rs_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, opc1=0, cond=0, opc2=0, Vd=1, Rt=0
    let encoding: u32 = 0x0E010B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_rt_0_min_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: opc1=0, opc2=0, cond=0, Rt=0, Vd=0, D=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_rt_1_poweroftwo_b10_0e001b10() {
    // Encoding: 0x0E001B10
    // Test aarch32_VMOV_rs_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=1, opc2=0, opc1=0, Vd=0, D=0, cond=0
    let encoding: u32 = 0x0E001B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field D 7 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_d_0_min_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, cond=0, opc2=0, opc1=0, Vd=0, Rt=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field D 7 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_d_1_max_b10_0e000b90() {
    // Encoding: 0x0E000B90
    // Test aarch32_VMOV_rs_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: cond=0, opc2=0, Vd=0, D=1, Rt=0, opc1=0
    let encoding: u32 = 0x0E000B90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc2_0_min_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field opc2 = 0 (Min)
    // ISET: A32
    // Fields: opc2=0, Vd=0, D=0, opc1=0, cond=0, Rt=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc2_1_poweroftwo_b10_0e000b30() {
    // Encoding: 0x0E000B30
    // Test aarch32_VMOV_rs_T1A1_A field opc2 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=0, Vd=0, Rt=0, cond=0, D=0, opc2=1
    let encoding: u32 = 0x0E000B30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc2_3_max_b10_0e000b70() {
    // Encoding: 0x0E000B70
    // Test aarch32_VMOV_rs_T1A1_A field opc2 = 3 (Max)
    // ISET: A32
    // Fields: cond=0, opc1=0, opc2=3, Vd=0, Rt=0, D=0
    let encoding: u32 = 0x0E000B70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_0_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=0, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc2=0, D=0, Vd=0, cond=0, opc1=0, Rt=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_1_b10_1e000b10() {
    // Encoding: 0x1E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=1, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, opc2=0, Vd=0, opc1=0, cond=1, D=0
    let encoding: u32 = 0x1E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_2_b10_2e000b10() {
    // Encoding: 0x2E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=2, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, D=0, cond=2, Vd=0, opc2=0, Rt=0
    let encoding: u32 = 0x2E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_3_b10_3e000b10() {
    // Encoding: 0x3E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=3, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Vd=0, opc2=0, cond=3, Rt=0, D=0, opc1=0
    let encoding: u32 = 0x3E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_4_b10_4e000b10() {
    // Encoding: 0x4E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=4, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, Vd=0, Rt=0, opc2=0, cond=4, D=0
    let encoding: u32 = 0x4E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_5_b10_5e000b10() {
    // Encoding: 0x5E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=5, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: cond=5, opc2=0, Vd=0, D=0, Rt=0, opc1=0
    let encoding: u32 = 0x5E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_6_b10_6e000b10() {
    // Encoding: 0x6E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=6, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, Vd=0, D=0, opc2=0, opc1=0, cond=6
    let encoding: u32 = 0x6E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_7_b10_7e000b10() {
    // Encoding: 0x7E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=7, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, opc2=0, Vd=0, cond=7, D=0, opc1=0
    let encoding: u32 = 0x7E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_8_b10_8e000b10() {
    // Encoding: 0x8E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=8, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, opc1=0, D=0, cond=8, Vd=0, opc2=0
    let encoding: u32 = 0x8E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_9_b10_9e000b10() {
    // Encoding: 0x9E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=9, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, cond=9, Vd=0, Rt=0, D=0, opc2=0
    let encoding: u32 = 0x9E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_10_b10_ae000b10() {
    // Encoding: 0xAE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=10, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, D=0, Rt=0, opc2=0, Vd=0, cond=10
    let encoding: u32 = 0xAE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_11_b10_be000b10() {
    // Encoding: 0xBE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=11, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, opc1=0, Vd=0, cond=11, D=0, opc2=0
    let encoding: u32 = 0xBE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_12_b10_ce000b10() {
    // Encoding: 0xCE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=12, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: D=0, Rt=0, opc2=0, cond=12, opc1=0, Vd=0
    let encoding: u32 = 0xCE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_13_b10_de000b10() {
    // Encoding: 0xDE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=13, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, cond=13, opc1=0, D=0, Vd=0, opc2=0
    let encoding: u32 = 0xDE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_14_b10_ee000b10() {
    // Encoding: 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=14, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Vd=0, opc2=0, cond=14, D=0, Rt=0, opc1=0
    let encoding: u32 = 0xEE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_15_b10_fe000b10() {
    // Encoding: 0xFE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=15, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, D=0, opc2=0, cond=15, Vd=0, Rt=0
    let encoding: u32 = 0xFE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=0 (minimum value)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_16_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=0, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Vd=0, opc1=0, Rt=0, opc2=0, cond=0, D=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=1 (value 1)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_17_b10_0e200b10() {
    // Encoding: 0x0E200B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=0, opc1=1, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: Vd=0, cond=0, Rt=0, D=0, opc1=1, opc2=0
    let encoding: u32 = 0x0E200B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=3 (maximum value (3))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_18_b10_0e600b10() {
    // Encoding: 0x0E600B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=0, opc1=3, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc1=3, Rt=0, opc2=0, Vd=0, D=0, cond=0
    let encoding: u32 = 0x0E600B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_19_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: cond=0, opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: A32
    // Fields: opc2=0, Rt=0, D=0, cond=0, Vd=0, opc1=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_0_condition_eq_2832_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Vd=0, D=0, opc1=0, cond=0, Rt=0, opc2=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_1_condition_ne_2832_1e000b10() {
    // Encoding: 0x1E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, opc2=0, Vd=0, Rt=0, D=0, opc1=0
    let encoding: u32 = 0x1E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_2_condition_cs_hs_2832_2e000b10() {
    // Encoding: 0x2E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, opc1=0, Vd=0, opc2=0, cond=2, D=0
    let encoding: u32 = 0x2E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_3_condition_cc_lo_2832_3e000b10() {
    // Encoding: 0x3E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: opc1=0, D=0, cond=3, opc2=0, Rt=0, Vd=0
    let encoding: u32 = 0x3E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_4_condition_mi_2832_4e000b10() {
    // Encoding: 0x4E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, D=0, opc2=0, opc1=0, Vd=0, cond=4
    let encoding: u32 = 0x4E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_5_condition_pl_2832_5e000b10() {
    // Encoding: 0x5E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: opc2=0, D=0, Vd=0, cond=5, Rt=0, opc1=0
    let encoding: u32 = 0x5E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_6_condition_vs_2832_6e000b10() {
    // Encoding: 0x6E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, opc2=0, opc1=0, Vd=0, Rt=0, D=0
    let encoding: u32 = 0x6E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_7_condition_vc_2832_7e000b10() {
    // Encoding: 0x7E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rt=0, D=0, opc1=0, Vd=0, opc2=0
    let encoding: u32 = 0x7E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_8_condition_hi_2832_8e000b10() {
    // Encoding: 0x8E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Vd=0, opc2=0, D=0, opc1=0, Rt=0
    let encoding: u32 = 0x8E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_9_condition_ls_2832_9e000b10() {
    // Encoding: 0x9E000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, D=0, opc1=0, Vd=0, opc2=0, cond=9
    let encoding: u32 = 0x9E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_10_condition_ge_2832_ae000b10() {
    // Encoding: 0xAE000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: D=0, opc2=0, Rt=0, cond=10, Vd=0, opc1=0
    let encoding: u32 = 0xAE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_11_condition_lt_2832_be000b10() {
    // Encoding: 0xBE000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: D=0, cond=11, opc1=0, Vd=0, Rt=0, opc2=0
    let encoding: u32 = 0xBE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_12_condition_gt_2832_ce000b10() {
    // Encoding: 0xCE000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: opc2=0, Rt=0, Vd=0, D=0, cond=12, opc1=0
    let encoding: u32 = 0xCE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_13_condition_le_2832_de000b10() {
    // Encoding: 0xDE000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, D=0, Rt=0, Vd=0, opc2=0, opc1=0
    let encoding: u32 = 0xDE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_14_condition_al_2832_ee000b10() {
    // Encoding: 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: opc1=0, Vd=0, opc2=0, cond=14, D=0, Rt=0
    let encoding: u32 = 0xEE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_rs_t1a1_a_special_cond_15_condition_nv_2832_fe000b10() {
    // Encoding: 0xFE000B10
    // Test aarch32_VMOV_rs_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: opc1=0, cond=15, opc2=0, Rt=0, D=0, Vd=0
    let encoding: u32 = 0xFE000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_rs_t1a1_a_invalid_0_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: opc2=0, Vd=0, D=0, cond=0, opc1=0, Rt=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_rs_t1a1_a_invalid_1_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: D=0, cond=0, Vd=0, opc2=0, opc1=0, Rt=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_rs_t1a1_a_invalid_2_b10_0e000b10() {
    // Encoding: 0x0E000B10
    // Test aarch32_VMOV_rs_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vd=0, Rt=0, opc2=0, D=0, opc1=0, cond=0
    let encoding: u32 = 0x0E000B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc1_0_min_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field opc1 = 0 (Min)
    // ISET: T32
    // Fields: D=0, opc2=0, opc1=0, Vd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc1_1_poweroftwo_b10_ee200b10() {
    // Thumb encoding (32): 0xEE200B10
    // Test aarch32_VMOV_rs_T1A1_A field opc1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: opc2=0, opc1=1, D=0, Rt=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc1_3_max_b10_ee600b10() {
    // Thumb encoding (32): 0xEE600B10
    // Test aarch32_VMOV_rs_T1A1_A field opc1 = 3 (Max)
    // ISET: T32
    // Fields: opc2=0, Vd=0, opc1=3, D=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE600B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Vd 16 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_vd_0_min_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: opc2=0, Rt=0, opc1=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Vd 16 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_vd_1_poweroftwo_b10_ee010b10() {
    // Thumb encoding (32): 0xEE010B10
    // Test aarch32_VMOV_rs_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: opc2=0, opc1=0, D=0, Rt=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_rt_0_min_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: opc1=0, D=0, opc2=0, Vd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_rt_1_poweroftwo_b10_ee001b10() {
    // Thumb encoding (32): 0xEE001B10
    // Test aarch32_VMOV_rs_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: opc1=0, D=0, opc2=0, Vd=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field D 7 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_d_0_min_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, opc1=0, Vd=0, Rt=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field D 7 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_d_1_max_b10_ee000b90() {
    // Thumb encoding (32): 0xEE000B90
    // Test aarch32_VMOV_rs_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, opc1=0, D=1, opc2=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc2_0_min_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field opc2 = 0 (Min)
    // ISET: T32
    // Fields: opc1=0, D=0, Vd=0, Rt=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc2_1_poweroftwo_b10_ee000b30() {
    // Thumb encoding (32): 0xEE000B30
    // Test aarch32_VMOV_rs_T1A1_A field opc2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, opc1=0, Rt=0, opc2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_field_opc2_3_max_b10_ee000b70() {
    // Thumb encoding (32): 0xEE000B70
    // Test aarch32_VMOV_rs_T1A1_A field opc2 = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, D=0, opc2=3, opc1=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B70;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=0 (minimum value)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_0_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: opc2=0, opc1=0, Vd=0, Rt=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=1 (value 1)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_1_b10_ee200b10() {
    // Thumb encoding (32): 0xEE200B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=1, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: Vd=0, opc2=0, opc1=1, Rt=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=3 (maximum value (3))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_2_b10_ee600b10() {
    // Thumb encoding (32): 0xEE600B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=3, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: D=0, Vd=0, opc2=0, opc1=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE600B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_3_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: opc2=0, Rt=0, opc1=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_4_b10_ee010b10() {
    // Thumb encoding (32): 0xEE010B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=1, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: opc2=0, opc1=0, Rt=0, Vd=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_5_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: opc1=0, Rt=0, D=0, opc2=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_6_b10_ee001b10() {
    // Thumb encoding (32): 0xEE001B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=1, D=0, opc2=0
    // ISET: T32
    // Fields: Vd=0, opc1=0, D=0, Rt=1, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_7_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: Vd=0, Rt=0, D=0, opc2=0, opc1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_8_b10_ee000b90() {
    // Thumb encoding (32): 0xEE000B90
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=1, opc2=0
    // ISET: T32
    // Fields: opc2=0, Vd=0, opc1=0, Rt=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=0 (minimum value)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_9_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=0
    // ISET: T32
    // Fields: opc1=0, Rt=0, Vd=0, D=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=1 (value 1)
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_10_b10_ee000b30() {
    // Thumb encoding (32): 0xEE000B30
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=1
    // ISET: T32
    // Fields: Vd=0, D=0, opc1=0, opc2=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=3 (maximum value (3))
#[test]
fn test_aarch32_vmov_rs_t1a1_a_combo_11_b10_ee000b70() {
    // Thumb encoding (32): 0xEE000B70
    // Test aarch32_VMOV_rs_T1A1_A field combination: opc1=0, Vd=0, Rt=0, D=0, opc2=3
    // ISET: T32
    // Fields: Vd=0, Rt=0, opc2=3, opc1=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B70;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_rs_t1a1_a_invalid_0_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: opc1=0, Vd=0, D=0, opc2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_rs_t1a1_a_invalid_1_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: D=0, opc2=0, opc1=0, Rt=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_rs_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_rs_t1a1_a_invalid_2_b10_ee000b10() {
    // Thumb encoding (32): 0xEE000B10
    // Test aarch32_VMOV_rs_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, opc2=0, opc1=0, Vd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VMOVX_A Tests
// ============================================================================

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovx_a1_a_field_d_0_min_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vm=0, M=0, D=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovx_a1_a_field_d_1_max_a40_fef00a40() {
    // Encoding: 0xFEF00A40
    // Test aarch32_VMOVX_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=1, M=0
    let encoding: u32 = 0xFEF00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovx_a1_a_field_vd_0_min_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovx_a1_a_field_vd_1_poweroftwo_a40_feb01a40() {
    // Encoding: 0xFEB01A40
    // Test aarch32_VMOVX_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=1, M=0, Vm=0
    let encoding: u32 = 0xFEB01A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovx_a1_a_field_m_0_min_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, Vm=0, M=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovx_a1_a_field_m_1_max_a40_feb00a60() {
    // Encoding: 0xFEB00A60
    // Test aarch32_VMOVX_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=0, M=1
    let encoding: u32 = 0xFEB00A60;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovx_a1_a_field_vm_0_min_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovx_a1_a_field_vm_1_poweroftwo_a40_feb00a41() {
    // Encoding: 0xFEB00A41
    // Test aarch32_VMOVX_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=1, D=0
    let encoding: u32 = 0xFEB00A41;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmovx_a1_a_combo_0_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, D=0, M=0, Vd=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmovx_a1_a_combo_1_a40_fef00a40() {
    // Encoding: 0xFEF00A40
    // Test aarch32_VMOVX_A1_A field combination: D=1, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=1, Vm=0, M=0, Vd=0
    let encoding: u32 = 0xFEF00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovx_a1_a_combo_2_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovx_a1_a_combo_3_a40_feb01a40() {
    // Encoding: 0xFEB01A40
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=1, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=1, M=0
    let encoding: u32 = 0xFEB01A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmovx_a1_a_combo_4_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, D=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmovx_a1_a_combo_5_a40_feb00a60() {
    // Encoding: 0xFEB00A60
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=0, M=1, Vm=0
    // ISET: A32
    // Fields: M=1, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xFEB00A60;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovx_a1_a_combo_6_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, D=0, Vm=0, M=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovx_a1_a_combo_7_a40_feb00a41() {
    // Encoding: 0xFEB00A41
    // Test aarch32_VMOVX_A1_A field combination: D=0, Vd=0, M=0, Vm=1
    // ISET: A32
    // Fields: D=0, Vm=1, Vd=0, M=0
    let encoding: u32 = 0xFEB00A41;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_a1_a_invalid_0_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=0, D=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_a1_a_invalid_1_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_a1_a_invalid_2_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: D=0, M=0, Vd=0, Vm=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVX_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_a1_a_invalid_3_a40_feb00a40() {
    // Encoding: 0xFEB00A40
    // Test aarch32_VMOVX_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xFEB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovx_t1_a_field_d_0_min_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, M=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovx_t1_a_field_d_1_max_a40_fef00a40() {
    // Thumb encoding (32): 0xFEF00A40
    // Test aarch32_VMOVX_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, Vd=0, M=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEF00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovx_t1_a_field_vd_0_min_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovx_t1_a_field_vd_1_poweroftwo_a40_feb01a40() {
    // Thumb encoding (32): 0xFEB01A40
    // Test aarch32_VMOVX_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=1, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB01A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovx_t1_a_field_m_0_min_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovx_t1_a_field_m_1_max_a40_feb00a60() {
    // Thumb encoding (32): 0xFEB00A60
    // Test aarch32_VMOVX_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, Vm=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovx_t1_a_field_vm_0_min_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovx_t1_a_field_vm_1_poweroftwo_a40_feb00a41() {
    // Thumb encoding (32): 0xFEB00A41
    // Test aarch32_VMOVX_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, Vm=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A41;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmovx_t1_a_combo_0_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmovx_t1_a_combo_1_a40_fef00a40() {
    // Thumb encoding (32): 0xFEF00A40
    // Test aarch32_VMOVX_T1_A field combination: D=1, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vm=0, D=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEF00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovx_t1_a_combo_2_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, Vm=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovx_t1_a_combo_3_a40_feb01a40() {
    // Thumb encoding (32): 0xFEB01A40
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=1, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB01A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmovx_t1_a_combo_4_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, Vm=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmovx_t1_a_combo_5_a40_feb00a60() {
    // Thumb encoding (32): 0xFEB00A60
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=0, M=1, Vm=0
    // ISET: T32
    // Fields: M=1, Vd=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovx_t1_a_combo_6_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovx_t1_a_combo_7_a40_feb00a41() {
    // Thumb encoding (32): 0xFEB00A41
    // Test aarch32_VMOVX_T1_A field combination: D=0, Vd=0, M=0, Vm=1
    // ISET: T32
    // Fields: M=0, Vm=1, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A41;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmovx_t1_a_invalid_0_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vd=0, Vm=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmovx_t1_a_invalid_1_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vm=0, Vd=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_t1_a_invalid_2_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // ISET: T32
    // Fields: D=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_t1_a_invalid_3_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: M=0, Vm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_t1_a_invalid_4_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: Vd=0, Vm=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVX_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovx_t1_a_invalid_5_a40_feb00a40() {
    // Thumb encoding (32): 0xFEB00A40
    // Test aarch32_VMOVX_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: M=0, Vm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

// ============================================================================
// aarch32_VMOVN_A Tests
// ============================================================================

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovn_t1a1_a_field_d_0_min_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovn_t1a1_a_field_d_1_max_200_f3f20200() {
    // Encoding: 0xF3F20200
    // Test aarch32_VMOVN_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=0, D=1, size=0
    let encoding: u32 = 0xF3F20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_0_min_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_1_poweroftwo_200_f3b60200() {
    // Encoding: 0xF3B60200
    // Test aarch32_VMOVN_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vd=0, size=1, D=0, Vm=0
    let encoding: u32 = 0xF3B60200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_2_poweroftwo_200_f3ba0200() {
    // Encoding: 0xF3BA0200
    // Test aarch32_VMOVN_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=2, Vm=0, D=0, M=0
    let encoding: u32 = 0xF3BA0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_3_max_200_f3be0200() {
    // Encoding: 0xF3BE0200
    // Test aarch32_VMOVN_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, size=3, M=0, Vm=0
    let encoding: u32 = 0xF3BE0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vd_0_min_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, Vm=0, D=0, M=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vd_1_poweroftwo_200_f3b21200() {
    // Encoding: 0xF3B21200
    // Test aarch32_VMOVN_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=1, Vm=0, size=0, M=0
    let encoding: u32 = 0xF3B21200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovn_t1a1_a_field_m_0_min_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovn_t1a1_a_field_m_1_max_200_f3b20220() {
    // Encoding: 0xF3B20220
    // Test aarch32_VMOVN_T1A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, M=1, Vm=0
    let encoding: u32 = 0xF3B20220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vm_0_min_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: M=0, D=0, size=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vm_1_poweroftwo_200_f3b20201() {
    // Encoding: 0xF3B20201
    // Test aarch32_VMOVN_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, size=0, M=0, D=0, Vd=0
    let encoding: u32 = 0xF3B20201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_0_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_1_200_f3f20200() {
    // Encoding: 0xF3F20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=1, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, D=1, size=0, Vd=0
    let encoding: u32 = 0xF3F20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_2_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, D=0, size=0, Vd=0, M=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_3_200_f3b60200() {
    // Encoding: 0xF3B60200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=1, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=1, D=0, Vm=0, M=0, Vd=0
    let encoding: u32 = 0xF3B60200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_4_200_f3ba0200() {
    // Encoding: 0xF3BA0200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=2, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=2, Vm=0, D=0, M=0, Vd=0
    let encoding: u32 = 0xF3BA0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_5_200_f3be0200() {
    // Encoding: 0xF3BE0200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=3, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, Vm=0, size=3, M=0, D=0
    let encoding: u32 = 0xF3BE0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_6_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, Vd=0, size=0, M=0, D=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_7_200_f3b21200() {
    // Encoding: 0xF3B21200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=1, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, size=0, D=0, Vm=0, Vd=1
    let encoding: u32 = 0xF3B21200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_8_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_9_200_f3b20220() {
    // Encoding: 0xF3B20220
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=1, Vm=0
    // ISET: A32
    // Fields: Vd=0, M=1, Vm=0, D=0, size=0
    let encoding: u32 = 0xF3B20220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_10_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, D=0, size=0, Vd=0, M=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_11_200_f3b20201() {
    // Encoding: 0xF3B20201
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=1
    // ISET: A32
    // Fields: size=0, Vm=1, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3B20201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_0_size_variant_0_512_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=0, size=0, M=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_1_size_variant_1_512_f3b60200() {
    // Encoding: 0xF3B60200
    // Test aarch32_VMOVN_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, Vm=0, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3B60200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_2_size_variant_2_512_f3ba0200() {
    // Encoding: 0xF3BA0200
    // Test aarch32_VMOVN_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, M=0, size=2, D=0, Vm=0
    let encoding: u32 = 0xF3BA0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_3_size_variant_3_512_f3be0200() {
    // Encoding: 0xF3BE0200
    // Test aarch32_VMOVN_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, M=0, size=3, Vm=0, D=0
    let encoding: u32 = 0xF3BE0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_0_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: D=0, Vd=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_1_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, size=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_2_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_3_200_f3b20200() {
    // Encoding: 0xF3B20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3B20200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovn_t1a1_a_field_d_0_min_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovn_t1a1_a_field_d_1_max_200_fff20200() {
    // Thumb encoding (32): 0xFFF20200
    // Test aarch32_VMOVN_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, D=1, M=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_0_min_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vm=0, size=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_1_poweroftwo_200_ffb60200() {
    // Thumb encoding (32): 0xFFB60200
    // Test aarch32_VMOVN_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vm=0, M=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB60200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_2_poweroftwo_200_ffba0200() {
    // Thumb encoding (32): 0xFFBA0200
    // Test aarch32_VMOVN_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=2, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmovn_t1a1_a_field_size_3_max_200_ffbe0200() {
    // Thumb encoding (32): 0xFFBE0200
    // Test aarch32_VMOVN_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, M=0, size=3, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vd_0_min_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vd_1_poweroftwo_200_ffb21200() {
    // Thumb encoding (32): 0xFFB21200
    // Test aarch32_VMOVN_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, D=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB21200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmovn_t1a1_a_field_m_0_min_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmovn_t1a1_a_field_m_1_max_200_ffb20220() {
    // Thumb encoding (32): 0xFFB20220
    // Test aarch32_VMOVN_T1A1_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, M=1, size=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20220;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vm_0_min_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vd=0, M=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmovn_t1a1_a_field_vm_1_poweroftwo_200_ffb20201() {
    // Thumb encoding (32): 0xFFB20201
    // Test aarch32_VMOVN_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vm=1, size=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_0_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: size=0, M=0, Vd=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_1_200_fff20200() {
    // Thumb encoding (32): 0xFFF20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=1, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=1, M=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_2_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, M=0, size=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_3_200_ffb60200() {
    // Thumb encoding (32): 0xFFB60200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=1, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, size=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB60200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_4_200_ffba0200() {
    // Thumb encoding (32): 0xFFBA0200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=2, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, size=2, Vm=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_5_200_ffbe0200() {
    // Thumb encoding (32): 0xFFBE0200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=3, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, M=0, size=3, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_6_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_7_200_ffb21200() {
    // Thumb encoding (32): 0xFFB21200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=1, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, Vd=1, M=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB21200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_8_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_9_200_ffb20220() {
    // Thumb encoding (32): 0xFFB20220
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=1, Vm=0
    // ISET: T32
    // Fields: size=0, Vd=0, M=1, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20220;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_10_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmovn_t1a1_a_combo_11_200_ffb20201() {
    // Thumb encoding (32): 0xFFB20201
    // Test aarch32_VMOVN_T1A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=1
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, Vm=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20201;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_0_size_variant_0_512_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Vd=0, Vm=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_1_size_variant_1_512_ffb60200() {
    // Thumb encoding (32): 0xFFB60200
    // Test aarch32_VMOVN_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, Vd=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB60200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_2_size_variant_2_512_ffba0200() {
    // Thumb encoding (32): 0xFFBA0200
    // Test aarch32_VMOVN_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: M=0, Vm=0, D=0, size=2, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmovn_t1a1_a_special_size_3_size_variant_3_512_ffbe0200() {
    // Thumb encoding (32): 0xFFBE0200
    // Test aarch32_VMOVN_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Vm=0, Vd=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_0_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: Vd=0, size=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_1_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_2_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmovn_t1a1_a_invalid_3_200_ffb20200() {
    // Thumb encoding (32): 0xFFB20200
    // Test aarch32_VMOVN_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_32_0_f3b24680() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24680
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_64_0_f3b24680() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24680
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24680;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_32_1_f3b77ba0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B77BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B77BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_64_1_f3b77ba0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B77BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B77BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "X0 should be 0x00000000ABCD0000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_32_3_f3b20200() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B20200
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_64_3_f3b20200() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B20200
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B20200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_64_4_f3facf00() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACF00
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACF00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_vmovn_t1a1_a_movz_oracle_64_5_f3fbd7a0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7A0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_vmovn_t1a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_vmovn_t1a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_vmovn_t1a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_vmovn_t1a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMOVN_T1A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_vmovn_t1a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_VMOV_d_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_0_min_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Vm=0, Rt2=0, op=0, Rt=0, M=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_1_poweroftwo_b10_1c400b10() {
    // Encoding: 0x1C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, M=0, Rt2=0, Rt=0, cond=1, Vm=0
    let encoding: u32 = 0x1C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_2_poweroftwo_b10_2c400b10() {
    // Encoding: 0x2C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, op=0, Rt=0, Rt2=0, M=0, Vm=0
    let encoding: u32 = 0x2C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_3_poweroftwo_b10_3c400b10() {
    // Encoding: 0x3C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rt2=0, Vm=0, M=0, Rt=0, op=0
    let encoding: u32 = 0x3C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_4_poweroftwo_b10_4c400b10() {
    // Encoding: 0x4C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Rt=0, cond=4, Rt2=0, M=0, op=0
    let encoding: u32 = 0x4C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_5_poweroftwo_b10_5c400b10() {
    // Encoding: 0x5C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rt=0, M=0, Vm=0, Rt2=0, op=0
    let encoding: u32 = 0x5C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_6_poweroftwo_b10_6c400b10() {
    // Encoding: 0x6C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, M=0, cond=6, Rt2=0, Rt=0, op=0
    let encoding: u32 = 0x6C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_7_poweroftwo_b10_7c400b10() {
    // Encoding: 0x7C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rt2=0, op=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x7C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_8_poweroftwo_b10_8c400b10() {
    // Encoding: 0x8C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=8, op=0, Vm=0, M=0, Rt2=0
    let encoding: u32 = 0x8C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_9_poweroftwo_b10_9c400b10() {
    // Encoding: 0x9C400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vm=0, Rt=0, cond=9, op=0, Rt2=0
    let encoding: u32 = 0x9C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_10_poweroftwo_b10_ac400b10() {
    // Encoding: 0xAC400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, M=0, Vm=0, op=0, Rt2=0, Rt=0
    let encoding: u32 = 0xAC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_11_poweroftwo_b10_bc400b10() {
    // Encoding: 0xBC400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rt2=0, M=0, Vm=0, op=0
    let encoding: u32 = 0xBC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_12_poweroftwo_b10_cc400b10() {
    // Encoding: 0xCC400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, op=0, cond=12, Vm=0, M=0, Rt2=0
    let encoding: u32 = 0xCC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_13_poweroftwo_b10_dc400b10() {
    // Encoding: 0xDC400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, op=0, Vm=0, cond=13, M=0, Rt2=0
    let encoding: u32 = 0xDC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_14_poweroftwo_b10_ec400b10() {
    // Encoding: 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt2=0, Vm=0, M=0, cond=14, op=0, Rt=0
    let encoding: u32 = 0xEC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_cond_15_max_b10_fc400b10() {
    // Encoding: 0xFC400B10
    // Test aarch32_VMOV_d_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Vm=0, Rt=0, op=0, cond=15, Rt2=0, M=0
    let encoding: u32 = 0xFC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_op_0_min_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, cond=0, Rt=0, op=0, Rt2=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_op_1_max_b10_0c500b10() {
    // Encoding: 0x0C500B10
    // Test aarch32_VMOV_d_T1A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rt=0, op=1, M=0, Vm=0, Rt2=0
    let encoding: u32 = 0x0C500B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt2_0_min_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field Rt2 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, M=0, Rt=0, op=0, Vm=0, Rt2=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt2_1_poweroftwo_b10_0c410b10() {
    // Encoding: 0x0C410B10
    // Test aarch32_VMOV_d_T1A1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Rt2=1, op=0, cond=0, M=0, Rt=0
    let encoding: u32 = 0x0C410B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt_0_min_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, op=0, Rt2=0, Rt=0, M=0, cond=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt_1_poweroftwo_b10_0c401b10() {
    // Encoding: 0x0C401B10
    // Test aarch32_VMOV_d_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Rt2=0, op=0, Rt=1, cond=0, M=0
    let encoding: u32 = 0x0C401B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_m_0_min_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: op=0, Rt2=0, M=0, Vm=0, Rt=0, cond=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_m_1_max_b10_0c400b30() {
    // Encoding: 0x0C400B30
    // Test aarch32_VMOV_d_T1A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rt2=0, Rt=0, M=1, Vm=0, op=0
    let encoding: u32 = 0x0C400B30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_vm_0_min_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Vm=0, Rt2=0, op=0, M=0, Rt=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_vm_1_poweroftwo_b10_0c400b11() {
    // Encoding: 0x0C400B11
    // Test aarch32_VMOV_d_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, M=0, op=0, Vm=1, Rt2=0, Rt=0
    let encoding: u32 = 0x0C400B11;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_0_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=0, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, Rt2=0, Rt=0, M=0, cond=0, op=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_1_b10_1c400b10() {
    // Encoding: 0x1C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=1, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, op=0, cond=1, Rt=0, M=0, Rt2=0
    let encoding: u32 = 0x1C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_2_b10_2c400b10() {
    // Encoding: 0x2C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=2, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, op=0, Rt2=0, cond=2, Vm=0, M=0
    let encoding: u32 = 0x2C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_3_b10_3c400b10() {
    // Encoding: 0x3C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=3, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=3, Rt=0, M=0, Vm=0, Rt2=0, op=0
    let encoding: u32 = 0x3C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_4_b10_4c400b10() {
    // Encoding: 0x4C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=4, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, Rt=0, M=0, Vm=0, Rt2=0, cond=4
    let encoding: u32 = 0x4C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_5_b10_5c400b10() {
    // Encoding: 0x5C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=5, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Rt2=0, Rt=0, Vm=0, op=0, cond=5
    let encoding: u32 = 0x5C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_6_b10_6c400b10() {
    // Encoding: 0x6C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=6, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt2=0, Vm=0, op=0, cond=6, Rt=0, M=0
    let encoding: u32 = 0x6C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_7_b10_7c400b10() {
    // Encoding: 0x7C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=7, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, cond=7, op=0, Rt=0, Rt2=0
    let encoding: u32 = 0x7C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_8_b10_8c400b10() {
    // Encoding: 0x8C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=8, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt2=0, M=0, Vm=0, op=0, cond=8, Rt=0
    let encoding: u32 = 0x8C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_9_b10_9c400b10() {
    // Encoding: 0x9C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=9, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=9, op=0, Rt=0, Vm=0, Rt2=0, M=0
    let encoding: u32 = 0x9C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_10_b10_ac400b10() {
    // Encoding: 0xAC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=10, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, M=0, Vm=0, cond=10, Rt=0, Rt2=0
    let encoding: u32 = 0xAC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_11_b10_bc400b10() {
    // Encoding: 0xBC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=11, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, cond=11, Rt=0, op=0, Rt2=0
    let encoding: u32 = 0xBC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_12_b10_cc400b10() {
    // Encoding: 0xCC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=12, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, M=0, Vm=0, cond=12, op=0, Rt2=0
    let encoding: u32 = 0xCC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_13_b10_dc400b10() {
    // Encoding: 0xDC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=13, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, Rt=0, M=0, Vm=0, cond=13, Rt2=0
    let encoding: u32 = 0xDC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_14_b10_ec400b10() {
    // Encoding: 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=14, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, M=0, Rt2=0, Vm=0, cond=14, op=0
    let encoding: u32 = 0xEC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_15_b10_fc400b10() {
    // Encoding: 0xFC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=15, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=15, op=0, Rt2=0, Rt=0, Vm=0, M=0
    let encoding: u32 = 0xFC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_16_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=0, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=0, Vm=0, op=0, M=0, Rt2=0, Rt=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_17_b10_0c500b10() {
    // Encoding: 0x0C500B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=0, op=1, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, Rt2=0, cond=0, M=0, Vm=0, op=1
    let encoding: u32 = 0x0C500B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_18_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=0, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, M=0, Vm=0, Rt=0, cond=0, Rt2=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_19_b10_0c410b10() {
    // Encoding: 0x0C410B10
    // Test aarch32_VMOV_d_T1A1_A field combination: cond=0, op=0, Rt2=1, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, op=0, Vm=0, Rt2=1, M=0, cond=0
    let encoding: u32 = 0x0C410B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_0_condition_eq_2832_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt2=0, Rt=0, M=0, op=0, Vm=0, cond=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_1_condition_ne_2832_1c400b10() {
    // Encoding: 0x1C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, op=0, Rt2=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x1C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_2_condition_cs_hs_2832_2c400b10() {
    // Encoding: 0x2C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Vm=0, Rt2=0, M=0, op=0, Rt=0
    let encoding: u32 = 0x2C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_3_condition_cc_lo_2832_3c400b10() {
    // Encoding: 0x3C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, op=0, Rt2=0, M=0, Rt=0, Vm=0
    let encoding: u32 = 0x3C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_4_condition_mi_2832_4c400b10() {
    // Encoding: 0x4C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: M=0, Rt=0, cond=4, Rt2=0, op=0, Vm=0
    let encoding: u32 = 0x4C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_5_condition_pl_2832_5c400b10() {
    // Encoding: 0x5C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt2=0, Vm=0, op=0, M=0, cond=5, Rt=0
    let encoding: u32 = 0x5C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_6_condition_vs_2832_6c400b10() {
    // Encoding: 0x6C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt2=0, Rt=0, cond=6, op=0, M=0, Vm=0
    let encoding: u32 = 0x6C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_7_condition_vc_2832_7c400b10() {
    // Encoding: 0x7C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, M=0, op=0, Rt2=0, Vm=0, cond=7
    let encoding: u32 = 0x7C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_8_condition_hi_2832_8c400b10() {
    // Encoding: 0x8C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt2=0, op=0, cond=8, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x8C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_9_condition_ls_2832_9c400b10() {
    // Encoding: 0x9C400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, op=0, Rt=0, M=0, Vm=0, Rt2=0
    let encoding: u32 = 0x9C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_10_condition_ge_2832_ac400b10() {
    // Encoding: 0xAC400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rt2=0, M=0, Rt=0, op=0, Vm=0
    let encoding: u32 = 0xAC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_11_condition_lt_2832_bc400b10() {
    // Encoding: 0xBC400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: M=0, Rt=0, Vm=0, cond=11, op=0, Rt2=0
    let encoding: u32 = 0xBC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_12_condition_gt_2832_cc400b10() {
    // Encoding: 0xCC400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, op=0, Rt2=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0xCC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_13_condition_le_2832_dc400b10() {
    // Encoding: 0xDC400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: M=0, cond=13, Rt2=0, Vm=0, op=0, Rt=0
    let encoding: u32 = 0xDC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_14_condition_al_2832_ec400b10() {
    // Encoding: 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt2=0, Vm=0, cond=14, Rt=0, M=0, op=0
    let encoding: u32 = 0xEC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_d_t1a1_a_special_cond_15_condition_nv_2832_fc400b10() {
    // Encoding: 0xFC400B10
    // Test aarch32_VMOV_d_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: M=0, Rt=0, cond=15, Vm=0, op=0, Rt2=0
    let encoding: u32 = 0xFC400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_0_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Vm=0, cond=0, op=0, M=0, Rt=0, Rt2=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_1_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rt2=0, Vm=0, M=0, op=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"to_arm_registers\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_2_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: A32
    // Fields: op=0, M=0, cond=0, Rt2=0, Rt=0, Vm=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_3_b10_0c400b10() {
    // Encoding: 0x0C400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: op=0, Vm=0, Rt2=0, cond=0, Rt=0, M=0
    let encoding: u32 = 0x0C400B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_op_0_min_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field op = 0 (Min)
    // ISET: T32
    // Fields: op=0, Rt=0, Rt2=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_op_1_max_b10_ec500b10() {
    // Thumb encoding (32): 0xEC500B10
    // Test aarch32_VMOV_d_T1A1_A field op = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, op=1, Rt=0, Rt2=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt2_0_min_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vm=0, Rt=0, M=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt2_1_poweroftwo_b10_ec410b10() {
    // Thumb encoding (32): 0xEC410B10
    // Test aarch32_VMOV_d_T1A1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, Rt2=1, Rt=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC410B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt_0_min_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vm=0, Rt2=0, Rt=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_rt_1_poweroftwo_b10_ec401b10() {
    // Thumb encoding (32): 0xEC401B10
    // Test aarch32_VMOV_d_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, M=0, Vm=0, Rt2=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC401B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_m_0_min_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field M = 0 (Min)
    // ISET: T32
    // Fields: op=0, Rt2=0, Vm=0, M=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_m_1_max_b10_ec400b30() {
    // Thumb encoding (32): 0xEC400B30
    // Test aarch32_VMOV_d_T1A1_A field M = 1 (Max)
    // ISET: T32
    // Fields: op=0, Vm=0, Rt=0, M=1, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_vm_0_min_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rt=0, Vm=0, op=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_d_t1a1_a_field_vm_1_poweroftwo_b10_ec400b11() {
    // Thumb encoding (32): 0xEC400B11
    // Test aarch32_VMOV_d_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Rt=0, Rt2=0, op=0, Vm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_0_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, Rt2=0, M=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_1_b10_ec500b10() {
    // Thumb encoding (32): 0xEC500B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=1, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, M=0, op=1, Vm=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_2_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, Vm=0, op=0, Rt2=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_3_b10_ec410b10() {
    // Thumb encoding (32): 0xEC410B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=1, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, M=0, Rt2=1, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC410B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_4_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt2=0, Rt=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_5_b10_ec401b10() {
    // Thumb encoding (32): 0xEC401B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=1, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt2=0, Vm=0, Rt=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC401B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_6_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt=0, Rt2=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_7_b10_ec400b30() {
    // Thumb encoding (32): 0xEC400B30
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=1, Vm=0
    // ISET: T32
    // Fields: op=0, Rt=0, Rt2=0, M=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_8_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, M=0, Rt=0, Rt2=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_9_b10_ec400b11() {
    // Thumb encoding (32): 0xEC400B11
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=1
    // ISET: T32
    // Fields: Rt=0, op=0, Rt2=0, M=0, Vm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_10_b10_ec411b10() {
    // Thumb encoding (32): 0xEC411B10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=1, Rt=1, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=1, M=0, Rt2=1, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC411B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_vmov_d_t1a1_a_combo_11_b10_ec4ffb10() {
    // Thumb encoding (32): 0xEC4FFB10
    // Test aarch32_VMOV_d_T1A1_A field combination: op=0, Rt2=31, Rt=31, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt=31, Rt2=31, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC4FFB10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_0_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, M=0, Rt2=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_1_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, M=0, Vm=0, Rt2=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"to_arm_registers\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_2_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: T32
    // Fields: Rt2=0, M=0, Vm=0, Rt=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_d_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_d_t1a1_a_invalid_3_b10_ec400b10() {
    // Thumb encoding (32): 0xEC400B10
    // Test aarch32_VMOV_d_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: op=0, Rt=0, Rt2=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VMOV_s_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_0_min_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, cond=0, op=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_1_poweroftwo_a10_1e000a10() {
    // Encoding: 0x1E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, op=0, Vn=0, N=0
    let encoding: u32 = 0x1E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_2_poweroftwo_a10_2e000a10() {
    // Encoding: 0x2E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, op=0, cond=2, Vn=0, Rt=0
    let encoding: u32 = 0x2E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_3_poweroftwo_a10_3e000a10() {
    // Encoding: 0x3E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Vn=0, cond=3, N=0, op=0
    let encoding: u32 = 0x3E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_4_poweroftwo_a10_4e000a10() {
    // Encoding: 0x4E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Vn=0, Rt=0, op=0, N=0
    let encoding: u32 = 0x4E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_5_poweroftwo_a10_5e000a10() {
    // Encoding: 0x5E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Vn=0, Rt=0, op=0, N=0
    let encoding: u32 = 0x5E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_6_poweroftwo_a10_6e000a10() {
    // Encoding: 0x6E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Rt=0, op=0, Vn=0, cond=6
    let encoding: u32 = 0x6E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_7_poweroftwo_a10_7e000a10() {
    // Encoding: 0x7E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Vn=0, N=0, Rt=0, cond=7
    let encoding: u32 = 0x7E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_8_poweroftwo_a10_8e000a10() {
    // Encoding: 0x8E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, op=0, Rt=0, Vn=0, N=0
    let encoding: u32 = 0x8E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_9_poweroftwo_a10_9e000a10() {
    // Encoding: 0x9E000A10
    // Test aarch32_VMOV_s_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rt=0, N=0, Vn=0, op=0
    let encoding: u32 = 0x9E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_10_poweroftwo_a10_ae000a10() {
    // Encoding: 0xAE000A10
    // Test aarch32_VMOV_s_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, N=0, Rt=0, Vn=0, op=0
    let encoding: u32 = 0xAE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_11_poweroftwo_a10_be000a10() {
    // Encoding: 0xBE000A10
    // Test aarch32_VMOV_s_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, cond=11, op=0
    let encoding: u32 = 0xBE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_12_poweroftwo_a10_ce000a10() {
    // Encoding: 0xCE000A10
    // Test aarch32_VMOV_s_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Rt=0, cond=12, op=0, N=0
    let encoding: u32 = 0xCE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_13_poweroftwo_a10_de000a10() {
    // Encoding: 0xDE000A10
    // Test aarch32_VMOV_s_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, N=0, Rt=0, op=0, cond=13
    let encoding: u32 = 0xDE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_14_poweroftwo_a10_ee000a10() {
    // Encoding: 0xEE000A10
    // Test aarch32_VMOV_s_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Vn=0, cond=14, Rt=0, N=0
    let encoding: u32 = 0xEE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_s_a1_a_field_cond_15_max_a10_fe000a10() {
    // Encoding: 0xFE000A10
    // Test aarch32_VMOV_s_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: op=0, Vn=0, Rt=0, cond=15, N=0
    let encoding: u32 = 0xFE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_s_a1_a_field_op_0_min_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, op=0, Vn=0, N=0, cond=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_s_a1_a_field_op_1_max_a10_0e100a10() {
    // Encoding: 0x0E100A10
    // Test aarch32_VMOV_s_A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, op=1, N=0, cond=0, Vn=0
    let encoding: u32 = 0x0E100A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_s_a1_a_field_vn_0_min_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: op=0, N=0, Rt=0, cond=0, Vn=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_s_a1_a_field_vn_1_poweroftwo_a10_0e010a10() {
    // Encoding: 0x0E010A10
    // Test aarch32_VMOV_s_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=0, Vn=1, op=0, Rt=0
    let encoding: u32 = 0x0E010A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_s_a1_a_field_rt_0_min_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, op=0, Vn=0, N=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_s_a1_a_field_rt_1_poweroftwo_a10_0e001a10() {
    // Encoding: 0x0E001A10
    // Test aarch32_VMOV_s_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, cond=0, Vn=0, Rt=1, N=0
    let encoding: u32 = 0x0E001A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_s_a1_a_field_n_0_min_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: op=0, cond=0, N=0, Rt=0, Vn=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_s_a1_a_field_n_1_max_a10_0e000a90() {
    // Encoding: 0x0E000A90
    // Test aarch32_VMOV_s_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, op=0, cond=0, Rt=0, N=1
    let encoding: u32 = 0x0E000A90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_0_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=0, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Vn=0, N=0, Rt=0, cond=0, op=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_1_a10_1e000a10() {
    // Encoding: 0x1E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=1, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, N=0, Vn=0, op=0, cond=1
    let encoding: u32 = 0x1E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_2_a10_2e000a10() {
    // Encoding: 0x2E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=2, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Vn=0, Rt=0, op=0, N=0, cond=2
    let encoding: u32 = 0x2E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_3_a10_3e000a10() {
    // Encoding: 0x3E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=3, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Vn=0, Rt=0, op=0, cond=3, N=0
    let encoding: u32 = 0x3E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_4_a10_4e000a10() {
    // Encoding: 0x4E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=4, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, cond=4, Vn=0, op=0, N=0
    let encoding: u32 = 0x4E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_5_a10_5e000a10() {
    // Encoding: 0x5E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=5, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=5, N=0, op=0, Vn=0, Rt=0
    let encoding: u32 = 0x5E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_6_a10_6e000a10() {
    // Encoding: 0x6E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=6, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=6, Rt=0, N=0, op=0, Vn=0
    let encoding: u32 = 0x6E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_7_a10_7e000a10() {
    // Encoding: 0x7E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=7, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=7, op=0, N=0, Rt=0, Vn=0
    let encoding: u32 = 0x7E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_8_a10_8e000a10() {
    // Encoding: 0x8E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=8, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, cond=8, op=0, Rt=0, Vn=0
    let encoding: u32 = 0x8E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_9_a10_9e000a10() {
    // Encoding: 0x9E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=9, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, Vn=0, N=0, op=0, cond=9
    let encoding: u32 = 0x9E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_10_a10_ae000a10() {
    // Encoding: 0xAE000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=10, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=10, Vn=0, Rt=0, N=0, op=0
    let encoding: u32 = 0xAE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_11_a10_be000a10() {
    // Encoding: 0xBE000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=11, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, cond=11, op=0, Vn=0, N=0
    let encoding: u32 = 0xBE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_12_a10_ce000a10() {
    // Encoding: 0xCE000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=12, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=12, Vn=0, op=0, Rt=0, N=0
    let encoding: u32 = 0xCE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_13_a10_de000a10() {
    // Encoding: 0xDE000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=13, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, Rt=0, cond=13, Vn=0, N=0
    let encoding: u32 = 0xDE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_14_a10_ee000a10() {
    // Encoding: 0xEE000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=14, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, cond=14, N=0, op=0, Vn=0
    let encoding: u32 = 0xEE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_15_a10_fe000a10() {
    // Encoding: 0xFE000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=15, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, cond=15, Vn=0, Rt=0, op=0
    let encoding: u32 = 0xFE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_s_a1_a_combo_16_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=0, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, Rt=0, cond=0, op=0, Vn=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_s_a1_a_combo_17_a10_0e100a10() {
    // Encoding: 0x0E100A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=0, op=1, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, Rt=0, cond=0, Vn=0, op=1
    let encoding: u32 = 0x0E100A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_s_a1_a_combo_18_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=0, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, op=0, cond=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_s_a1_a_combo_19_a10_0e010a10() {
    // Encoding: 0x0E010A10
    // Test aarch32_VMOV_s_A1_A field combination: cond=0, op=0, Vn=1, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, N=0, op=0, Vn=1, cond=0
    let encoding: u32 = 0x0E010A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_0_condition_eq_2576_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, cond=0, Vn=0, op=0, N=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_1_condition_ne_2576_1e000a10() {
    // Encoding: 0x1E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: op=0, Vn=0, cond=1, N=0, Rt=0
    let encoding: u32 = 0x1E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_2_condition_cs_hs_2576_2e000a10() {
    // Encoding: 0x2E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, op=0, N=0, Vn=0
    let encoding: u32 = 0x2E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_3_condition_cc_lo_2576_3e000a10() {
    // Encoding: 0x3E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Vn=0, Rt=0, N=0, op=0
    let encoding: u32 = 0x3E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_4_condition_mi_2576_4e000a10() {
    // Encoding: 0x4E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Vn=0, op=0, Rt=0, N=0
    let encoding: u32 = 0x4E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_5_condition_pl_2576_5e000a10() {
    // Encoding: 0x5E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: op=0, cond=5, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x5E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_6_condition_vs_2576_6e000a10() {
    // Encoding: 0x6E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, op=0, cond=6, Vn=0, N=0
    let encoding: u32 = 0x6E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_7_condition_vc_2576_7e000a10() {
    // Encoding: 0x7E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, op=0, cond=7
    let encoding: u32 = 0x7E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_8_condition_hi_2576_8e000a10() {
    // Encoding: 0x8E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: op=0, N=0, Vn=0, cond=8, Rt=0
    let encoding: u32 = 0x8E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_9_condition_ls_2576_9e000a10() {
    // Encoding: 0x9E000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, op=0, Rt=0, Vn=0, N=0
    let encoding: u32 = 0x9E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_10_condition_ge_2576_ae000a10() {
    // Encoding: 0xAE000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, N=0, Vn=0, op=0, cond=10
    let encoding: u32 = 0xAE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_11_condition_lt_2576_be000a10() {
    // Encoding: 0xBE000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: op=0, Rt=0, N=0, Vn=0, cond=11
    let encoding: u32 = 0xBE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_12_condition_gt_2576_ce000a10() {
    // Encoding: 0xCE000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rt=0, Vn=0, N=0, op=0
    let encoding: u32 = 0xCE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_13_condition_le_2576_de000a10() {
    // Encoding: 0xDE000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, N=0, op=0, Vn=0, Rt=0
    let encoding: u32 = 0xDE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_14_condition_al_2576_ee000a10() {
    // Encoding: 0xEE000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Vn=0, cond=14, N=0, Rt=0, op=0
    let encoding: u32 = 0xEE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_s_a1_a_special_cond_15_condition_nv_2576_fe000a10() {
    // Encoding: 0xFE000A10
    // Test aarch32_VMOV_s_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, N=0, op=0, Vn=0
    let encoding: u32 = 0xFE000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_s_a1_a_invalid_0_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: N=0, Rt=0, cond=0, op=0, Vn=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_s_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_s_a1_a_invalid_1_a10_0e000a10() {
    // Encoding: 0x0E000A10
    // Test aarch32_VMOV_s_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, cond=0, op=0
    let encoding: u32 = 0x0E000A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_s_t1_a_field_op_0_min_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field op = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_s_t1_a_field_op_1_max_a10_ee100a10() {
    // Thumb encoding (32): 0xEE100A10
    // Test aarch32_VMOV_s_T1_A field op = 1 (Max)
    // ISET: T32
    // Fields: op=1, Rt=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_s_t1_a_field_vn_0_min_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, op=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_s_t1_a_field_vn_1_poweroftwo_a10_ee010a10() {
    // Thumb encoding (32): 0xEE010A10
    // Test aarch32_VMOV_s_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Rt=0, Vn=1, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_s_t1_a_field_rt_0_min_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vn=0, N=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_s_t1_a_field_rt_1_poweroftwo_a10_ee001a10() {
    // Thumb encoding (32): 0xEE001A10
    // Test aarch32_VMOV_s_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, N=0, Rt=1, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_s_t1_a_field_n_0_min_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Vn=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_s_t1_a_field_n_1_max_a10_ee000a90() {
    // Thumb encoding (32): 0xEE000A90
    // Test aarch32_VMOV_s_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, N=1, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_s_t1_a_combo_0_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: op=0, N=0, Rt=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_s_t1_a_combo_1_a10_ee100a10() {
    // Thumb encoding (32): 0xEE100A10
    // Test aarch32_VMOV_s_T1_A field combination: op=1, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: op=1, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_s_t1_a_combo_2_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: op=0, Rt=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_s_t1_a_combo_3_a10_ee010a10() {
    // Thumb encoding (32): 0xEE010A10
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=1, Rt=0, N=0
    // ISET: T32
    // Fields: Vn=1, op=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_s_t1_a_combo_4_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: N=0, Rt=0, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_s_t1_a_combo_5_a10_ee001a10() {
    // Thumb encoding (32): 0xEE001A10
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=0, Rt=1, N=0
    // ISET: T32
    // Fields: op=0, N=0, Rt=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// N=0 (minimum value)
#[test]
fn test_aarch32_vmov_s_t1_a_combo_6_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: op=0, Rt=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// N=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_s_t1_a_combo_7_a10_ee000a90() {
    // Thumb encoding (32): 0xEE000A90
    // Test aarch32_VMOV_s_T1_A field combination: op=0, Vn=0, Rt=0, N=1
    // ISET: T32
    // Fields: N=1, Vn=0, Rt=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_s_t1_a_invalid_0_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: op=0, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_s_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_s_t1_a_invalid_1_a10_ee000a10() {
    // Thumb encoding (32): 0xEE000A10
    // Test aarch32_VMOV_s_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vn=0, N=0, Rt=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VMOV_r_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_0_min_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Vm=0, D=0, Vd=0, size=0, M=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_1_poweroftwo_a40_1eb00840() {
    // Encoding: 0x1EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=1, Vm=0, Vd=0, size=0, D=0
    let encoding: u32 = 0x1EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_2_poweroftwo_a40_2eb00840() {
    // Encoding: 0x2EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, cond=2, M=0, Vm=0
    let encoding: u32 = 0x2EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_3_poweroftwo_a40_3eb00840() {
    // Encoding: 0x3EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=3, Vm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0x3EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_4_poweroftwo_a40_4eb00840() {
    // Encoding: 0x4EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, M=0, D=0, Vd=0, Vm=0, cond=4
    let encoding: u32 = 0x4EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_5_poweroftwo_a40_5eb00840() {
    // Encoding: 0x5EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, size=0, Vm=0, cond=5, Vd=0, D=0
    let encoding: u32 = 0x5EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_6_poweroftwo_a40_6eb00840() {
    // Encoding: 0x6EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, M=0, size=0, cond=6, D=0, Vd=0
    let encoding: u32 = 0x6EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_7_poweroftwo_a40_7eb00840() {
    // Encoding: 0x7EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, cond=7, size=0, Vd=0
    let encoding: u32 = 0x7EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_8_poweroftwo_a40_8eb00840() {
    // Encoding: 0x8EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, cond=8, Vm=0, Vd=0, size=0
    let encoding: u32 = 0x8EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_9_poweroftwo_a40_9eb00840() {
    // Encoding: 0x9EB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=0, Vm=0, D=0, M=0, cond=9
    let encoding: u32 = 0x9EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_10_poweroftwo_a40_aeb00840() {
    // Encoding: 0xAEB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, cond=10, Vd=0, D=0, M=0, size=0
    let encoding: u32 = 0xAEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_11_poweroftwo_a40_beb00840() {
    // Encoding: 0xBEB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, cond=11, Vm=0, size=0, Vd=0
    let encoding: u32 = 0xBEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_12_poweroftwo_a40_ceb00840() {
    // Encoding: 0xCEB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vm=0, cond=12, size=0, D=0, Vd=0
    let encoding: u32 = 0xCEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_13_poweroftwo_a40_deb00840() {
    // Encoding: 0xDEB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=13, size=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xDEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_14_poweroftwo_a40_eeb00840() {
    // Encoding: 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, D=0, Vd=0, size=0, M=0, Vm=0
    let encoding: u32 = 0xEEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_cond_15_max_a40_feb00840() {
    // Encoding: 0xFEB00840
    // Test aarch32_VMOV_r_T2A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: D=0, size=0, Vm=0, cond=15, M=0, Vd=0
    let encoding: u32 = 0xFEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_d_0_min_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Vd=0, size=0, Vm=0, D=0, M=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_d_1_max_a40_0ef00840() {
    // Encoding: 0x0EF00840
    // Test aarch32_VMOV_r_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, cond=0, size=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0x0EF00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vd_0_min_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, M=0, Vd=0, cond=0, D=0, Vm=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vd_1_poweroftwo_a40_0eb01840() {
    // Encoding: 0x0EB01840
    // Test aarch32_VMOV_r_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, cond=0, Vd=1, M=0, Vm=0
    let encoding: u32 = 0x0EB01840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_0_min_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, cond=0, size=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_1_poweroftwo_a40_0eb00940() {
    // Encoding: 0x0EB00940
    // Test aarch32_VMOV_r_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=1, M=0, cond=0, Vm=0, Vd=0
    let encoding: u32 = 0x0EB00940;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_2_poweroftwo_a40_0eb00a40() {
    // Encoding: 0x0EB00A40
    // Test aarch32_VMOV_r_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, M=0, D=0, cond=0, size=2, Vd=0
    let encoding: u32 = 0x0EB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_3_max_a40_0eb00b40() {
    // Encoding: 0x0EB00B40
    // Test aarch32_VMOV_r_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vm=0, M=0, D=0, Vd=0, cond=0, size=3
    let encoding: u32 = 0x0EB00B40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_m_0_min_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: cond=0, size=0, D=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_m_1_max_a40_0eb00860() {
    // Encoding: 0x0EB00860
    // Test aarch32_VMOV_r_T2A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, M=1, cond=0, D=0, size=0, Vm=0
    let encoding: u32 = 0x0EB00860;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vm_0_min_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, size=0, Vd=0, D=0, cond=0, M=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vm_1_poweroftwo_a40_0eb00841() {
    // Encoding: 0x0EB00841
    // Test aarch32_VMOV_r_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, size=0, D=0, M=0, Vm=1, Vd=0
    let encoding: u32 = 0x0EB00841;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_0_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=0, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, Vm=0, D=0, size=0, M=0, cond=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_1_a40_1eb00840() {
    // Encoding: 0x1EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=1, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, cond=1, Vd=0, size=0, D=0, M=0
    let encoding: u32 = 0x1EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_2_a40_2eb00840() {
    // Encoding: 0x2EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=2, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, size=0, Vm=0, Vd=0, cond=2, D=0
    let encoding: u32 = 0x2EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_3_a40_3eb00840() {
    // Encoding: 0x3EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=3, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0, cond=3
    let encoding: u32 = 0x3EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_4_a40_4eb00840() {
    // Encoding: 0x4EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=4, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, D=0, M=0, cond=4, Vm=0, Vd=0
    let encoding: u32 = 0x4EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_5_a40_5eb00840() {
    // Encoding: 0x5EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=5, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vm=0, cond=5, D=0, M=0, Vd=0
    let encoding: u32 = 0x5EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_6_a40_6eb00840() {
    // Encoding: 0x6EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=6, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, Vm=0, D=0, cond=6
    let encoding: u32 = 0x6EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_7_a40_7eb00840() {
    // Encoding: 0x7EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=7, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, D=0, Vm=0, cond=7
    let encoding: u32 = 0x7EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_8_a40_8eb00840() {
    // Encoding: 0x8EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=8, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=8, size=0, M=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0x8EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_9_a40_9eb00840() {
    // Encoding: 0x9EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=9, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, Vd=0, cond=9, M=0, size=0, Vm=0
    let encoding: u32 = 0x9EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_10_a40_aeb00840() {
    // Encoding: 0xAEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=10, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, M=0, cond=10, Vd=0, D=0, Vm=0
    let encoding: u32 = 0xAEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_11_a40_beb00840() {
    // Encoding: 0xBEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=11, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, cond=11, D=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xBEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_12_a40_ceb00840() {
    // Encoding: 0xCEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=12, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, cond=12, Vd=0, D=0, size=0
    let encoding: u32 = 0xCEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_13_a40_deb00840() {
    // Encoding: 0xDEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=13, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=13, size=0, M=0, Vd=0, Vm=0, D=0
    let encoding: u32 = 0xDEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_14_a40_eeb00840() {
    // Encoding: 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=14, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, D=0, size=0, cond=14
    let encoding: u32 = 0xEEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_15_a40_feb00840() {
    // Encoding: 0xFEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=15, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, Vm=0, D=0, cond=15
    let encoding: u32 = 0xFEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_16_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=0, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, M=0, Vm=0, cond=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_17_a40_0ef00840() {
    // Encoding: 0x0EF00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=0, D=1, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, M=0, Vm=0, cond=0, D=1, Vd=0
    let encoding: u32 = 0x0EF00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_18_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=0, D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, cond=0, D=0, Vm=0, Vd=0, size=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_19_a40_0eb01840() {
    // Encoding: 0x0EB01840
    // Test aarch32_VMOV_r_T2A2_A field combination: cond=0, D=0, Vd=1, size=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, M=0, Vm=0, cond=0, Vd=1, D=0
    let encoding: u32 = 0x0EB01840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_0_condition_eq_2624_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, cond=0, size=0, Vd=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_1_condition_ne_2624_1eb00840() {
    // Encoding: 0x1EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: M=0, size=0, D=0, Vd=0, cond=1, Vm=0
    let encoding: u32 = 0x1EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_2_condition_cs_hs_2624_2eb00840() {
    // Encoding: 0x2EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, Vm=0, cond=2, D=0
    let encoding: u32 = 0x2EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_3_condition_cc_lo_2624_3eb00840() {
    // Encoding: 0x3EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, M=0, D=0, Vm=0, Vd=0, size=0
    let encoding: u32 = 0x3EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_4_condition_mi_2624_4eb00840() {
    // Encoding: 0x4EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, size=0, Vd=0, cond=4
    let encoding: u32 = 0x4EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_5_condition_pl_2624_5eb00840() {
    // Encoding: 0x5EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, M=0, Vd=0, size=0, Vm=0, D=0
    let encoding: u32 = 0x5EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_6_condition_vs_2624_6eb00840() {
    // Encoding: 0x6EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, D=0, size=0, M=0, Vd=0, Vm=0
    let encoding: u32 = 0x6EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_7_condition_vc_2624_7eb00840() {
    // Encoding: 0x7EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Vm=0, D=0, cond=7, size=0, M=0, Vd=0
    let encoding: u32 = 0x7EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_8_condition_hi_2624_8eb00840() {
    // Encoding: 0x8EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, cond=8, Vd=0, size=0
    let encoding: u32 = 0x8EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_9_condition_ls_2624_9eb00840() {
    // Encoding: 0x9EB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, Vm=0, cond=9, D=0
    let encoding: u32 = 0x9EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_10_condition_ge_2624_aeb00840() {
    // Encoding: 0xAEB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=0, D=0, size=0, cond=10
    let encoding: u32 = 0xAEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_11_condition_lt_2624_beb00840() {
    // Encoding: 0xBEB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Vm=0, M=0, D=0, Vd=0, size=0, cond=11
    let encoding: u32 = 0xBEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_12_condition_gt_2624_ceb00840() {
    // Encoding: 0xCEB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: size=0, D=0, cond=12, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xCEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_13_condition_le_2624_deb00840() {
    // Encoding: 0xDEB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: D=0, Vm=0, size=0, M=0, cond=13, Vd=0
    let encoding: u32 = 0xDEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_14_condition_al_2624_eeb00840() {
    // Encoding: 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, Vd=0, cond=14, size=0
    let encoding: u32 = 0xEEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_cond_15_condition_nv_2624_feb00840() {
    // Encoding: 0xFEB00840
    // Test aarch32_VMOV_r_T2A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Vm=0, cond=15, size=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xFEB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_0_size_variant_0_2624_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, M=0, size=0, cond=0, Vd=0, Vm=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_1_size_variant_1_2624_0eb00940() {
    // Encoding: 0x0EB00940
    // Test aarch32_VMOV_r_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, D=0, size=1, M=0, Vm=0, Vd=0
    let encoding: u32 = 0x0EB00940;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_2_size_variant_2_2624_0eb00a40() {
    // Encoding: 0x0EB00A40
    // Test aarch32_VMOV_r_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, cond=0, D=0, M=0, Vm=0, size=2
    let encoding: u32 = 0x0EB00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_3_size_variant_3_2624_0eb00b40() {
    // Encoding: 0x0EB00B40
    // Test aarch32_VMOV_r_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, cond=0, size=3, Vd=0
    let encoding: u32 = 0x0EB00B40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_r_t2a2_a_invalid_0_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: size=0, M=0, cond=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_r_t2a2_a_invalid_1_a40_0eb00840() {
    // Encoding: 0x0EB00840
    // Test aarch32_VMOV_r_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: cond=0, M=0, Vm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0x0EB00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_d_0_min_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_d_1_max_a40_eef00840() {
    // Thumb encoding (32): 0xEEF00840
    // Test aarch32_VMOV_r_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, M=0, Vm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEF00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vd_0_min_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vm=0, size=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vd_1_poweroftwo_a40_eeb01840() {
    // Thumb encoding (32): 0xEEB01840
    // Test aarch32_VMOV_r_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, D=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB01840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_0_min_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_1_poweroftwo_a40_eeb00940() {
    // Thumb encoding (32): 0xEEB00940
    // Test aarch32_VMOV_r_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, size=1, Vd=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00940;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_2_poweroftwo_a40_eeb00a40() {
    // Thumb encoding (32): 0xEEB00A40
    // Test aarch32_VMOV_r_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, Vd=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_size_3_max_a40_eeb00b40() {
    // Thumb encoding (32): 0xEEB00B40
    // Test aarch32_VMOV_r_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, Vd=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00B40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_m_0_min_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vd=0, Vm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_m_1_max_a40_eeb00860() {
    // Thumb encoding (32): 0xEEB00860
    // Test aarch32_VMOV_r_T2A2_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, Vm=0, M=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vm_0_min_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, Vm=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_r_t2a2_a_field_vm_1_poweroftwo_a40_eeb00841() {
    // Thumb encoding (32): 0xEEB00841
    // Test aarch32_VMOV_r_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, size=0, Vm=1, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00841;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_0_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, size=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_1_a40_eef00840() {
    // Thumb encoding (32): 0xEEF00840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=1, Vd=0, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vm=0, D=1, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEF00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_2_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_3_a40_eeb01840() {
    // Thumb encoding (32): 0xEEB01840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=1, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vd=1, D=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB01840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_4_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: size=0, Vm=0, Vd=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_5_a40_eeb00940() {
    // Thumb encoding (32): 0xEEB00940
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=1, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, size=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00940;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_6_a40_eeb00a40() {
    // Thumb encoding (32): 0xEEB00A40
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=2, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=2, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_7_a40_eeb00b40() {
    // Thumb encoding (32): 0xEEB00B40
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=3, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, Vd=0, size=3, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00B40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_8_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, Vm=0, D=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_9_a40_eeb00860() {
    // Thumb encoding (32): 0xEEB00860
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=1, Vm=0
    // ISET: T32
    // Fields: M=1, D=0, Vd=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_10_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, size=0, Vd=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_r_t2a2_a_combo_11_a40_eeb00841() {
    // Thumb encoding (32): 0xEEB00841
    // Test aarch32_VMOV_r_T2A2_A field combination: D=0, Vd=0, size=0, M=0, Vm=1
    // ISET: T32
    // Fields: M=0, D=0, size=0, Vm=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00841;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_0_size_variant_0_2624_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_1_size_variant_1_2624_eeb00940() {
    // Thumb encoding (32): 0xEEB00940
    // Test aarch32_VMOV_r_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, Vd=0, Vm=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00940;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_2_size_variant_2_2624_eeb00a40() {
    // Thumb encoding (32): 0xEEB00A40
    // Test aarch32_VMOV_r_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmov_r_t2a2_a_special_size_3_size_variant_3_2624_eeb00b40() {
    // Thumb encoding (32): 0xEEB00B40
    // Test aarch32_VMOV_r_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Vd=0, D=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00B40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_r_t2a2_a_invalid_0_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: Vd=0, Vm=0, size=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_r_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_r_t2a2_a_invalid_1_a40_eeb00840() {
    // Thumb encoding (32): 0xEEB00840
    // Test aarch32_VMOV_r_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

// ============================================================================
// aarch32_VMOV_ss_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_0_min_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: op=0, Rt=0, Vm=0, M=0, cond=0, Rt2=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_1_poweroftwo_a10_1c400a10() {
    // Encoding: 0x1C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, op=0, Rt=0, Rt2=0, M=0, Vm=0
    let encoding: u32 = 0x1C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_2_poweroftwo_a10_2c400a10() {
    // Encoding: 0x2C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, op=0, Rt2=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x2C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_3_poweroftwo_a10_3c400a10() {
    // Encoding: 0x3C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rt2=0, op=0, cond=3, Rt=0, Vm=0
    let encoding: u32 = 0x3C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_4_poweroftwo_a10_4c400a10() {
    // Encoding: 0x4C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Rt=0, M=0, Vm=0, cond=4, Rt2=0
    let encoding: u32 = 0x4C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_5_poweroftwo_a10_5c400a10() {
    // Encoding: 0x5C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, M=0, cond=5, Vm=0, op=0, Rt2=0
    let encoding: u32 = 0x5C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_6_poweroftwo_a10_6c400a10() {
    // Encoding: 0x6C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, op=0, Rt2=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x6C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_7_poweroftwo_a10_7c400a10() {
    // Encoding: 0x7C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, op=0, Vm=0, Rt2=0, cond=7, Rt=0
    let encoding: u32 = 0x7C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_8_poweroftwo_a10_8c400a10() {
    // Encoding: 0x8C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Rt=0, cond=8, Rt2=0, M=0, Vm=0
    let encoding: u32 = 0x8C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_9_poweroftwo_a10_9c400a10() {
    // Encoding: 0x9C400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, op=0, Rt=0, Vm=0, Rt2=0, M=0
    let encoding: u32 = 0x9C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_10_poweroftwo_a10_ac400a10() {
    // Encoding: 0xAC400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rt=0, Vm=0, Rt2=0, op=0, M=0
    let encoding: u32 = 0xAC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_11_poweroftwo_a10_bc400a10() {
    // Encoding: 0xBC400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rt2=0, M=0, Vm=0, Rt=0, op=0
    let encoding: u32 = 0xBC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_12_poweroftwo_a10_cc400a10() {
    // Encoding: 0xCC400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, op=0, cond=12, Rt2=0, Rt=0, M=0
    let encoding: u32 = 0xCC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_13_poweroftwo_a10_dc400a10() {
    // Encoding: 0xDC400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rt2=0, M=0, Vm=0, op=0
    let encoding: u32 = 0xDC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_14_poweroftwo_a10_ec400a10() {
    // Encoding: 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, cond=14, Rt=0, op=0, M=0, Rt2=0
    let encoding: u32 = 0xEC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_cond_15_max_a10_fc400a10() {
    // Encoding: 0xFC400A10
    // Test aarch32_VMOV_ss_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, Vm=0, cond=15, M=0, op=0, Rt2=0
    let encoding: u32 = 0xFC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_op_0_min_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: Rt2=0, M=0, Rt=0, cond=0, op=0, Vm=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_op_1_max_a10_0c500a10() {
    // Encoding: 0x0C500A10
    // Test aarch32_VMOV_ss_T1A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: M=0, op=1, Rt2=0, Rt=0, Vm=0, cond=0
    let encoding: u32 = 0x0C500A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt2_0_min_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt2 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, op=0, M=0, Vm=0, Rt2=0, Rt=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt2_1_poweroftwo_a10_0c410a10() {
    // Encoding: 0x0C410A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=0, Rt2=1, op=0, Vm=0, Rt=0
    let encoding: u32 = 0x0C410A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt_0_min_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, M=0, op=0, Vm=0, cond=0, Rt2=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt_1_poweroftwo_a10_0c401a10() {
    // Encoding: 0x0C401A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, op=0, Rt2=0, Rt=1, M=0, cond=0
    let encoding: u32 = 0x0C401A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_m_0_min_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, Rt2=0, Rt=0, cond=0, op=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_m_1_max_a10_0c400a30() {
    // Encoding: 0x0C400A30
    // Test aarch32_VMOV_ss_T1A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: M=1, Rt=0, cond=0, Vm=0, op=0, Rt2=0
    let encoding: u32 = 0x0C400A30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_vm_0_min_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: op=0, Rt2=0, Vm=0, Rt=0, M=0, cond=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_vm_1_poweroftwo_a10_0c400a11() {
    // Encoding: 0x0C400A11
    // Test aarch32_VMOV_ss_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rt2=0, Vm=1, op=0, M=0
    let encoding: u32 = 0x0C400A11;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_0_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=0, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, M=0, Vm=0, cond=0, Rt2=0, op=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_1_a10_1c400a10() {
    // Encoding: 0x1C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=1, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Rt=0, cond=1, op=0, Rt2=0, Vm=0
    let encoding: u32 = 0x1C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_2_a10_2c400a10() {
    // Encoding: 0x2C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=2, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, cond=2, Rt2=0, op=0, Rt=0, Vm=0
    let encoding: u32 = 0x2C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_3_a10_3c400a10() {
    // Encoding: 0x3C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=3, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=3, op=0, M=0, Rt2=0, Rt=0, Vm=0
    let encoding: u32 = 0x3C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_4_a10_4c400a10() {
    // Encoding: 0x4C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=4, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, Rt2=0, op=0, cond=4, Rt=0
    let encoding: u32 = 0x4C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_5_a10_5c400a10() {
    // Encoding: 0x5C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=5, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt2=0, cond=5, Rt=0, M=0, op=0, Vm=0
    let encoding: u32 = 0x5C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_6_a10_6c400a10() {
    // Encoding: 0x6C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=6, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Rt=0, Rt2=0, Vm=0, op=0, cond=6
    let encoding: u32 = 0x6C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_7_a10_7c400a10() {
    // Encoding: 0x7C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=7, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, Rt2=0, Rt=0, M=0, cond=7, op=0
    let encoding: u32 = 0x7C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_8_a10_8c400a10() {
    // Encoding: 0x8C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=8, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, Vm=0, cond=8, op=0, Rt2=0, M=0
    let encoding: u32 = 0x8C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_9_a10_9c400a10() {
    // Encoding: 0x9C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=9, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=9, Rt=0, M=0, op=0, Vm=0, Rt2=0
    let encoding: u32 = 0x9C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_10_a10_ac400a10() {
    // Encoding: 0xAC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=10, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, M=0, Rt2=0, cond=10, Vm=0, op=0
    let encoding: u32 = 0xAC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_11_a10_bc400a10() {
    // Encoding: 0xBC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=11, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, Rt2=0, op=0, cond=11, M=0, Rt=0
    let encoding: u32 = 0xBC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_12_a10_cc400a10() {
    // Encoding: 0xCC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=12, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=12, M=0, Vm=0, op=0, Rt2=0, Rt=0
    let encoding: u32 = 0xCC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_13_a10_dc400a10() {
    // Encoding: 0xDC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=13, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, Vm=0, cond=13, Rt2=0, Rt=0, M=0
    let encoding: u32 = 0xDC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_14_a10_ec400a10() {
    // Encoding: 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=14, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: cond=14, M=0, Vm=0, Rt2=0, op=0, Rt=0
    let encoding: u32 = 0xEC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_15_a10_fc400a10() {
    // Encoding: 0xFC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=15, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, M=0, Rt2=0, cond=15, Vm=0, op=0
    let encoding: u32 = 0xFC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_16_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=0, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, M=0, Rt2=0, cond=0, Vm=0, Rt=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_17_a10_0c500a10() {
    // Encoding: 0x0C500A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=0, op=1, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, cond=0, Rt=0, Vm=0, op=1, Rt2=0
    let encoding: u32 = 0x0C500A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_18_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=0, op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: op=0, Rt2=0, cond=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_19_a10_0c410a10() {
    // Encoding: 0x0C410A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: cond=0, op=0, Rt2=1, Rt=0, M=0, Vm=0
    // ISET: A32
    // Fields: Rt=0, cond=0, Rt2=1, op=0, M=0, Vm=0
    let encoding: u32 = 0x0C410A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_0_condition_eq_2576_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: op=0, Rt2=0, M=0, Vm=0, cond=0, Rt=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_1_condition_ne_2576_1c400a10() {
    // Encoding: 0x1C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, Vm=0, M=0, cond=1, Rt2=0, op=0
    let encoding: u32 = 0x1C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_2_condition_cs_hs_2576_2c400a10() {
    // Encoding: 0x2C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt2=0, op=0, cond=2, Vm=0, M=0, Rt=0
    let encoding: u32 = 0x2C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_3_condition_cc_lo_2576_3c400a10() {
    // Encoding: 0x3C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: M=0, Vm=0, op=0, Rt=0, Rt2=0, cond=3
    let encoding: u32 = 0x3C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_4_condition_mi_2576_4c400a10() {
    // Encoding: 0x4C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rt2=0, op=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x4C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_5_condition_pl_2576_5c400a10() {
    // Encoding: 0x5C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: M=0, Vm=0, op=0, Rt=0, cond=5, Rt2=0
    let encoding: u32 = 0x5C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_6_condition_vs_2576_6c400a10() {
    // Encoding: 0x6C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: op=0, cond=6, Rt2=0, Rt=0, M=0, Vm=0
    let encoding: u32 = 0x6C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_7_condition_vc_2576_7c400a10() {
    // Encoding: 0x7C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt2=0, op=0, Vm=0, cond=7, M=0, Rt=0
    let encoding: u32 = 0x7C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_8_condition_hi_2576_8c400a10() {
    // Encoding: 0x8C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Vm=0, Rt=0, cond=8, Rt2=0, op=0, M=0
    let encoding: u32 = 0x8C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_9_condition_ls_2576_9c400a10() {
    // Encoding: 0x9C400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt2=0, M=0, Vm=0, Rt=0, cond=9, op=0
    let encoding: u32 = 0x9C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_10_condition_ge_2576_ac400a10() {
    // Encoding: 0xAC400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rt=0, Rt2=0, Vm=0, M=0, op=0
    let encoding: u32 = 0xAC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_11_condition_lt_2576_bc400a10() {
    // Encoding: 0xBC400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: M=0, Vm=0, Rt2=0, op=0, Rt=0, cond=11
    let encoding: u32 = 0xBC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_12_condition_gt_2576_cc400a10() {
    // Encoding: 0xCC400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, op=0, Rt=0, M=0, Vm=0, Rt2=0
    let encoding: u32 = 0xCC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_13_condition_le_2576_dc400a10() {
    // Encoding: 0xDC400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: op=0, M=0, cond=13, Vm=0, Rt2=0, Rt=0
    let encoding: u32 = 0xDC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_14_condition_al_2576_ec400a10() {
    // Encoding: 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Vm=0, Rt=0, M=0, Rt2=0, op=0, cond=14
    let encoding: u32 = 0xEC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_ss_t1a1_a_special_cond_15_condition_nv_2576_fc400a10() {
    // Encoding: 0xFC400A10
    // Test aarch32_VMOV_ss_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Vm=0, op=0, Rt2=0, cond=15, Rt=0, M=0
    let encoding: u32 = 0xFC400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_0_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(31) }
    // ISET: A32
    // Fields: Rt2=0, op=0, Rt=0, M=0, cond=0, Vm=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_1_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: op=0, Rt=0, Rt2=0, cond=0, M=0, Vm=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"to_arm_registers\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_2_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: A32
    // Fields: M=0, Vm=0, op=0, cond=0, Rt2=0, Rt=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_3_a10_0c400a10() {
    // Encoding: 0x0C400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt2=0, Vm=0, cond=0, M=0, Rt=0, op=0
    let encoding: u32 = 0x0C400A10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_op_0_min_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field op = 0 (Min)
    // ISET: T32
    // Fields: Rt2=0, op=0, M=0, Rt=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_op_1_max_a10_ec500a10() {
    // Thumb encoding (32): 0xEC500A10
    // Test aarch32_VMOV_ss_T1A1_A field op = 1 (Max)
    // ISET: T32
    // Fields: Rt2=0, Rt=0, op=1, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt2_0_min_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: op=0, M=0, Vm=0, Rt2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt2 16 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt2_1_poweroftwo_a10_ec410a10() {
    // Thumb encoding (32): 0xEC410A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, Vm=0, Rt=0, Rt2=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC410A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt_0_min_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rt2=0, Rt=0, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_rt_1_poweroftwo_a10_ec401a10() {
    // Thumb encoding (32): 0xEC401A10
    // Test aarch32_VMOV_ss_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Rt2=0, Vm=0, op=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC401A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_m_0_min_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field M = 0 (Min)
    // ISET: T32
    // Fields: op=0, Rt2=0, Rt=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_m_1_max_a10_ec400a30() {
    // Thumb encoding (32): 0xEC400A30
    // Test aarch32_VMOV_ss_T1A1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, Rt2=0, M=1, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_vm_0_min_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, op=0, Rt=0, Rt2=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_ss_t1a1_a_field_vm_1_poweroftwo_a10_ec400a11() {
    // Thumb encoding (32): 0xEC400A11
    // Test aarch32_VMOV_ss_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=1, Rt2=0, op=0, Rt=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_0_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, M=0, Rt2=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_1_a10_ec500a10() {
    // Thumb encoding (32): 0xEC500A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=1, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: op=1, Rt2=0, Vm=0, Rt=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC500A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_2_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Rt2=0, Rt=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_3_a10_ec410a10() {
    // Thumb encoding (32): 0xEC410A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=1, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt2=1, Rt=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC410A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_4_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, M=0, op=0, Vm=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_5_a10_ec401a10() {
    // Thumb encoding (32): 0xEC401A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=1, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt=1, Rt2=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC401A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_6_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, Rt2=0, M=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_7_a10_ec400a30() {
    // Thumb encoding (32): 0xEC400A30
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=1, Vm=0
    // ISET: T32
    // Fields: Vm=0, op=0, M=1, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_8_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=0
    // ISET: T32
    // Fields: Rt=0, M=0, Vm=0, op=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vm=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_9_a10_ec400a11() {
    // Thumb encoding (32): 0xEC400A11
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=0, Rt=0, M=0, Vm=1
    // ISET: T32
    // Fields: op=0, Vm=1, Rt=0, Rt2=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_10_a10_ec411a10() {
    // Thumb encoding (32): 0xEC411A10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=1, Rt=1, M=0, Vm=0
    // ISET: T32
    // Fields: Rt2=1, Rt=1, M=0, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC411A10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_vmov_ss_t1a1_a_combo_11_a10_ec4ffa10() {
    // Thumb encoding (32): 0xEC4FFA10
    // Test aarch32_VMOV_ss_T1A1_A field combination: op=0, Rt2=31, Rt=31, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Rt2=31, M=0, Rt=31, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC4FFA10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(31) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(31) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_0_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(31) }
    // ISET: T32
    // Fields: Vm=0, Rt2=0, op=0, Rt=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_1_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt2=0, op=0, Vm=0, Rt=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"to_arm_registers\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_2_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "to_arm_registers" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: T32
    // Fields: Rt2=0, M=0, Rt=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_ss_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_ss_t1a1_a_invalid_3_a10_ec400a10() {
    // Thumb encoding (32): 0xEC400A10
    // Test aarch32_VMOV_ss_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rt=0, Rt2=0, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEC400A10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VMOV_sr_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, opc2=0, Rt=0, opc1=0, U=0, N=0, Vn=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_1_poweroftwo_b10_1e100b10() {
    // Encoding: 0x1E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, U=0, opc2=0, Vn=0, opc1=0, cond=1, Rt=0
    let encoding: u32 = 0x1E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_2_poweroftwo_b10_2e100b10() {
    // Encoding: 0x2E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, N=0, opc1=0, Vn=0, U=0, opc2=0, Rt=0
    let encoding: u32 = 0x2E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_3_poweroftwo_b10_3e100b10() {
    // Encoding: 0x3E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    let encoding: u32 = 0x3E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_4_poweroftwo_b10_4e100b10() {
    // Encoding: 0x4E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, N=0, opc2=0, U=0, opc1=0, cond=4, Rt=0
    let encoding: u32 = 0x4E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_5_poweroftwo_b10_5e100b10() {
    // Encoding: 0x5E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: opc2=0, cond=5, U=0, opc1=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x5E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_6_poweroftwo_b10_6e100b10() {
    // Encoding: 0x6E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, U=0, Rt=0, N=0, opc2=0, opc1=0, cond=6
    let encoding: u32 = 0x6E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_7_poweroftwo_b10_7e100b10() {
    // Encoding: 0x7E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=0, N=0, cond=7, Vn=0, Rt=0, opc2=0, U=0
    let encoding: u32 = 0x7E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_8_poweroftwo_b10_8e100b10() {
    // Encoding: 0x8E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, N=0, opc2=0, opc1=0, U=0, Vn=0, Rt=0
    let encoding: u32 = 0x8E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_9_poweroftwo_b10_9e100b10() {
    // Encoding: 0x9E100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Rt=0, opc1=0, opc2=0, U=0, N=0, cond=9
    let encoding: u32 = 0x9E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_10_poweroftwo_b10_ae100b10() {
    // Encoding: 0xAE100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vn=0, Rt=0, N=0, opc2=0, cond=10, opc1=0
    let encoding: u32 = 0xAE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_11_poweroftwo_b10_be100b10() {
    // Encoding: 0xBE100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vn=0, cond=11, Rt=0, opc1=0, N=0, opc2=0
    let encoding: u32 = 0xBE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_12_poweroftwo_b10_ce100b10() {
    // Encoding: 0xCE100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, N=0, U=0, opc1=0, cond=12, opc2=0, Rt=0
    let encoding: u32 = 0xCE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_13_poweroftwo_b10_de100b10() {
    // Encoding: 0xDE100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, N=0, cond=13, opc2=0, U=0, opc1=0, Rt=0
    let encoding: u32 = 0xDE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_14_poweroftwo_b10_ee100b10() {
    // Encoding: 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, opc2=0, Vn=0, cond=14, opc1=0, U=0, Rt=0
    let encoding: u32 = 0xEE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_cond_15_max_b10_fe100b10() {
    // Encoding: 0xFE100B10
    // Test aarch32_VMOV_sr_T1A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: opc1=0, Rt=0, opc2=0, Vn=0, cond=15, U=0, N=0
    let encoding: u32 = 0xFE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_u_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, N=0, opc1=0, Rt=0, opc2=0, U=0, cond=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_u_1_max_b10_0e900b10() {
    // Encoding: 0x0E900B10
    // Test aarch32_VMOV_sr_T1A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: opc1=0, N=0, U=1, Vn=0, cond=0, opc2=0, Rt=0
    let encoding: u32 = 0x0E900B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc1_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field opc1 = 0 (Min)
    // ISET: A32
    // Fields: U=0, opc2=0, Rt=0, opc1=0, cond=0, Vn=0, N=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc1_1_poweroftwo_b10_0e300b10() {
    // Encoding: 0x0E300B10
    // Test aarch32_VMOV_sr_T1A1_A field opc1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=1, opc2=0, U=0, cond=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x0E300B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc1_3_max_b10_0e700b10() {
    // Encoding: 0x0E700B10
    // Test aarch32_VMOV_sr_T1A1_A field opc1 = 3 (Max)
    // ISET: A32
    // Fields: U=0, N=0, opc2=0, opc1=3, Vn=0, cond=0, Rt=0
    let encoding: u32 = 0x0E700B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_vn_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: opc2=0, Rt=0, U=0, opc1=0, Vn=0, N=0, cond=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_vn_1_poweroftwo_b10_0e110b10() {
    // Encoding: 0x0E110B10
    // Test aarch32_VMOV_sr_T1A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, opc1=0, Vn=1, Rt=0, opc2=0, U=0, N=0
    let encoding: u32 = 0x0E110B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_rt_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, opc1=0, opc2=0, cond=0, Rt=0, Vn=0, N=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_rt_1_poweroftwo_b10_0e101b10() {
    // Encoding: 0x0E101B10
    // Test aarch32_VMOV_sr_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, N=0, opc1=0, cond=0, opc2=0, Vn=0, Rt=1
    let encoding: u32 = 0x0E101B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_n_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, opc1=0, Rt=0, opc2=0, N=0, Vn=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_n_1_max_b10_0e100b90() {
    // Encoding: 0x0E100B90
    // Test aarch32_VMOV_sr_T1A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, cond=0, Vn=0, U=0, opc1=0, Rt=0, opc2=0
    let encoding: u32 = 0x0E100B90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc2_0_min_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field opc2 = 0 (Min)
    // ISET: A32
    // Fields: opc2=0, cond=0, U=0, opc1=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc2_1_poweroftwo_b10_0e100b30() {
    // Encoding: 0x0E100B30
    // Test aarch32_VMOV_sr_T1A1_A field opc2 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: opc1=0, cond=0, Rt=0, N=0, opc2=1, Vn=0, U=0
    let encoding: u32 = 0x0E100B30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc2_3_max_b10_0e100b70() {
    // Encoding: 0x0E100B70
    // Test aarch32_VMOV_sr_T1A1_A field opc2 = 3 (Max)
    // ISET: A32
    // Fields: U=0, Vn=0, cond=0, Rt=0, N=0, opc2=3, opc1=0
    let encoding: u32 = 0x0E100B70;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_0_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=0, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: N=0, Rt=0, opc2=0, Vn=0, cond=0, U=0, opc1=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_1_b10_1e100b10() {
    // Encoding: 0x1E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=1, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, opc1=0, opc2=0, cond=1, U=0
    let encoding: u32 = 0x1E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_2_b10_2e100b10() {
    // Encoding: 0x2E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=2, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Vn=0, Rt=0, opc1=0, N=0, opc2=0, U=0, cond=2
    let encoding: u32 = 0x2E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_3_b10_3e100b10() {
    // Encoding: 0x3E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=3, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: cond=3, U=0, opc1=0, opc2=0, Vn=0, N=0, Rt=0
    let encoding: u32 = 0x3E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_4_b10_4e100b10() {
    // Encoding: 0x4E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=4, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: N=0, opc2=0, opc1=0, cond=4, Vn=0, Rt=0, U=0
    let encoding: u32 = 0x4E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_5_b10_5e100b10() {
    // Encoding: 0x5E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=5, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Vn=0, cond=5, U=0, opc2=0, Rt=0, N=0, opc1=0
    let encoding: u32 = 0x5E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_6_b10_6e100b10() {
    // Encoding: 0x6E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=6, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: U=0, Vn=0, cond=6, N=0, opc2=0, Rt=0, opc1=0
    let encoding: u32 = 0x6E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_7_b10_7e100b10() {
    // Encoding: 0x7E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=7, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Vn=0, U=0, opc2=0, cond=7, opc1=0, Rt=0, N=0
    let encoding: u32 = 0x7E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_8_b10_8e100b10() {
    // Encoding: 0x8E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=8, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, N=0, cond=8, U=0, Vn=0, Rt=0, opc2=0
    let encoding: u32 = 0x8E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_9_b10_9e100b10() {
    // Encoding: 0x9E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=9, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: U=0, Rt=0, opc2=0, opc1=0, N=0, Vn=0, cond=9
    let encoding: u32 = 0x9E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_10_b10_ae100b10() {
    // Encoding: 0xAE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=10, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Vn=0, opc1=0, opc2=0, U=0, cond=10, N=0, Rt=0
    let encoding: u32 = 0xAE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_11_b10_be100b10() {
    // Encoding: 0xBE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=11, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: opc2=0, U=0, opc1=0, Rt=0, Vn=0, cond=11, N=0
    let encoding: u32 = 0xBE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_12_b10_ce100b10() {
    // Encoding: 0xCE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=12, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, Rt=0, N=0, opc2=0, U=0, Vn=0, cond=12
    let encoding: u32 = 0xCE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_13_b10_de100b10() {
    // Encoding: 0xDE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=13, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: cond=13, Rt=0, opc2=0, U=0, Vn=0, N=0, opc1=0
    let encoding: u32 = 0xDE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_14_b10_ee100b10() {
    // Encoding: 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=14, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: opc1=0, N=0, Vn=0, opc2=0, U=0, cond=14, Rt=0
    let encoding: u32 = 0xEE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_15_b10_fe100b10() {
    // Encoding: 0xFE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=15, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Rt=0, N=0, opc2=0, U=0, opc1=0, cond=15, Vn=0
    let encoding: u32 = 0xFE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_16_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=0, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: N=0, opc2=0, U=0, Vn=0, opc1=0, cond=0, Rt=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_17_b10_0e900b10() {
    // Encoding: 0x0E900B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=0, U=1, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: opc2=0, U=1, cond=0, Rt=0, Vn=0, N=0, opc1=0
    let encoding: u32 = 0x0E900B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=0 (minimum value)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_18_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=0, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: cond=0, Rt=0, opc1=0, U=0, N=0, opc2=0, Vn=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=1 (value 1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_19_b10_0e300b10() {
    // Encoding: 0x0E300B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: cond=0, U=0, opc1=1, Vn=0, Rt=0, N=0, opc2=0
    // ISET: A32
    // Fields: Vn=0, N=0, opc2=0, opc1=1, cond=0, U=0, Rt=0
    let encoding: u32 = 0x0E300B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_0_condition_eq_2832_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: opc1=0, opc2=0, U=0, cond=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_1_condition_ne_2832_1e100b10() {
    // Encoding: 0x1E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, N=0, U=0, cond=1, Vn=0, opc2=0, opc1=0
    let encoding: u32 = 0x1E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_2_condition_cs_hs_2832_2e100b10() {
    // Encoding: 0x2E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, U=0, opc2=0, opc1=0, Rt=0, N=0, Vn=0
    let encoding: u32 = 0x2E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_3_condition_cc_lo_2832_3e100b10() {
    // Encoding: 0x3E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: opc1=0, Vn=0, Rt=0, N=0, opc2=0, U=0, cond=3
    let encoding: u32 = 0x3E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_4_condition_mi_2832_4e100b10() {
    // Encoding: 0x4E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, N=0, Vn=0, opc2=0, opc1=0, U=0, Rt=0
    let encoding: u32 = 0x4E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_5_condition_pl_2832_5e100b10() {
    // Encoding: 0x5E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, Vn=0, N=0, opc1=0, opc2=0, cond=5, Rt=0
    let encoding: u32 = 0x5E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_6_condition_vs_2832_6e100b10() {
    // Encoding: 0x6E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: opc2=0, Rt=0, N=0, U=0, opc1=0, Vn=0, cond=6
    let encoding: u32 = 0x6E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_7_condition_vc_2832_7e100b10() {
    // Encoding: 0x7E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: N=0, Vn=0, Rt=0, opc2=0, cond=7, opc1=0, U=0
    let encoding: u32 = 0x7E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_8_condition_hi_2832_8e100b10() {
    // Encoding: 0x8E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: N=0, Rt=0, opc1=0, U=0, cond=8, Vn=0, opc2=0
    let encoding: u32 = 0x8E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_9_condition_ls_2832_9e100b10() {
    // Encoding: 0x9E100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Vn=0, opc2=0, N=0, opc1=0, Rt=0, cond=9, U=0
    let encoding: u32 = 0x9E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_10_condition_ge_2832_ae100b10() {
    // Encoding: 0xAE100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, Rt=0, opc1=0, opc2=0, Vn=0, cond=10, N=0
    let encoding: u32 = 0xAE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_11_condition_lt_2832_be100b10() {
    // Encoding: 0xBE100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    let encoding: u32 = 0xBE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_12_condition_gt_2832_ce100b10() {
    // Encoding: 0xCE100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: opc2=0, N=0, Vn=0, Rt=0, cond=12, U=0, opc1=0
    let encoding: u32 = 0xCE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_13_condition_le_2832_de100b10() {
    // Encoding: 0xDE100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, opc1=0, Rt=0, N=0, U=0, opc2=0, Vn=0
    let encoding: u32 = 0xDE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_14_condition_al_2832_ee100b10() {
    // Encoding: 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, Vn=0, Rt=0, opc1=0, cond=14, N=0, opc2=0
    let encoding: u32 = 0xEE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_sr_t1a1_a_special_cond_15_condition_nv_2832_fe100b10() {
    // Encoding: 0xFE100B10
    // Test aarch32_VMOV_sr_T1A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, opc1=0, Vn=0, Rt=0, N=0, opc2=0, U=0
    let encoding: u32 = 0xFE100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_0_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, Rt=0, opc1=0, N=0, cond=0, opc2=0, U=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_1_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: opc1=0, N=0, Rt=0, opc2=0, U=0, Vn=0, cond=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_2_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: U=0, cond=0, N=0, opc2=0, opc1=0, Rt=0, Vn=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_3_b10_0e100b10() {
    // Encoding: 0x0E100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vn=0, opc1=0, U=0, cond=0, Rt=0, N=0, opc2=0
    let encoding: u32 = 0x0E100B10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_u_0_min_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field U = 0 (Min)
    // ISET: T32
    // Fields: opc2=0, Rt=0, N=0, opc1=0, Vn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_u_1_max_b10_ee900b10() {
    // Thumb encoding (32): 0xEE900B10
    // Test aarch32_VMOV_sr_T1A1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, Rt=0, opc2=0, Vn=0, N=0, opc1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE900B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc1_0_min_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field opc1 = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Rt=0, opc1=0, U=0, opc2=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc1_1_poweroftwo_b10_ee300b10() {
    // Thumb encoding (32): 0xEE300B10
    // Test aarch32_VMOV_sr_T1A1_A field opc1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Vn=0, opc2=0, opc1=1, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE300B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc1 21 +: 2`
/// Requirement: FieldBoundary { field: "opc1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc1_3_max_b10_ee700b10() {
    // Thumb encoding (32): 0xEE700B10
    // Test aarch32_VMOV_sr_T1A1_A field opc1 = 3 (Max)
    // ISET: T32
    // Fields: opc1=3, U=0, opc2=0, Rt=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE700B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_vn_0_min_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, opc1=0, U=0, N=0, Vn=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_vn_1_poweroftwo_b10_ee110b10() {
    // Thumb encoding (32): 0xEE110B10
    // Test aarch32_VMOV_sr_T1A1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, opc2=0, Vn=1, opc1=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE110B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_rt_0_min_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Rt=0, opc1=0, N=0, opc2=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_rt_1_poweroftwo_b10_ee101b10() {
    // Thumb encoding (32): 0xEE101B10
    // Test aarch32_VMOV_sr_T1A1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: opc1=0, U=0, opc2=0, Rt=1, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE101B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_n_0_min_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field N = 0 (Min)
    // ISET: T32
    // Fields: N=0, opc2=0, Vn=0, Rt=0, U=0, opc1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_n_1_max_b10_ee100b90() {
    // Thumb encoding (32): 0xEE100B90
    // Test aarch32_VMOV_sr_T1A1_A field N = 1 (Max)
    // ISET: T32
    // Fields: U=0, Vn=0, Rt=0, N=1, opc1=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc2_0_min_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field opc2 = 0 (Min)
    // ISET: T32
    // Fields: opc2=0, U=0, Vn=0, Rt=0, opc1=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc2_1_poweroftwo_b10_ee100b30() {
    // Thumb encoding (32): 0xEE100B30
    // Test aarch32_VMOV_sr_T1A1_A field opc2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: opc1=0, Vn=0, Rt=0, opc2=1, N=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field opc2 5 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_field_opc2_3_max_b10_ee100b70() {
    // Thumb encoding (32): 0xEE100B70
    // Test aarch32_VMOV_sr_T1A1_A field opc2 = 3 (Max)
    // ISET: T32
    // Fields: Vn=0, opc1=0, N=0, Rt=0, opc2=3, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B70;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_0_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: U=0, N=0, Vn=0, opc1=0, Rt=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_1_b10_ee900b10() {
    // Thumb encoding (32): 0xEE900B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=1, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: U=1, N=0, opc2=0, Vn=0, Rt=0, opc1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE900B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=0 (minimum value)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_2_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: Rt=0, N=0, opc2=0, opc1=0, Vn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=1 (value 1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_3_b10_ee300b10() {
    // Thumb encoding (32): 0xEE300B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=1, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: opc1=1, Rt=0, U=0, opc2=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE300B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc1=3 (maximum value (3))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_4_b10_ee700b10() {
    // Thumb encoding (32): 0xEE700B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=3, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: opc2=0, U=0, opc1=3, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE700B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_5_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: Rt=0, opc2=0, N=0, Vn=0, opc1=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_6_b10_ee110b10() {
    // Thumb encoding (32): 0xEE110B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=1, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: Rt=0, U=0, opc2=0, opc1=0, Vn=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE110B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_7_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: U=0, N=0, opc2=0, Rt=0, opc1=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_8_b10_ee101b10() {
    // Thumb encoding (32): 0xEE101B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=1, N=0, opc2=0
    // ISET: T32
    // Fields: U=0, N=0, opc1=0, Vn=0, Rt=1, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE101B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// N=0 (minimum value)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_9_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: Rt=0, Vn=0, N=0, U=0, opc2=0, opc1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// N=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_10_b10_ee100b90() {
    // Thumb encoding (32): 0xEE100B90
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=1, opc2=0
    // ISET: T32
    // Fields: opc2=0, Rt=0, N=1, opc1=0, U=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=0 (minimum value)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_11_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=0
    // ISET: T32
    // Fields: N=0, U=0, opc1=0, Rt=0, opc2=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=1 (value 1)
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_12_b10_ee100b30() {
    // Thumb encoding (32): 0xEE100B30
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=1
    // ISET: T32
    // Fields: opc1=0, N=0, U=0, Rt=0, opc2=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=3 (maximum value (3))
#[test]
fn test_aarch32_vmov_sr_t1a1_a_combo_13_b10_ee100b70() {
    // Thumb encoding (32): 0xEE100B70
    // Test aarch32_VMOV_sr_T1A1_A field combination: U=0, opc1=0, Vn=0, Rt=0, N=0, opc2=3
    // ISET: T32
    // Fields: Vn=0, Rt=0, opc2=3, U=0, opc1=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B70;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_0_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: opc1=0, opc2=0, U=0, N=0, Vn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_1_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: U=0, N=0, opc2=0, opc1=0, Vn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_2_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: opc2=0, opc1=0, Vn=0, U=0, N=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_sr_T1A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_sr_t1a1_a_invalid_3_b10_ee100b10() {
    // Thumb encoding (32): 0xEE100B10
    // Test aarch32_VMOV_sr_T1A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: opc1=0, Vn=0, Rt=0, N=0, U=0, opc2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100B10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VMOV_h_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_0_min_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, op=0, cond=0, N=0, Rt=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_1_poweroftwo_910_1e000910() {
    // Encoding: 0x1E000910
    // Test aarch32_VMOV_h_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, cond=1, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x1E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_2_poweroftwo_910_2e000910() {
    // Encoding: 0x2E000910
    // Test aarch32_VMOV_h_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Rt=0, Vn=0, cond=2, op=0
    let encoding: u32 = 0x2E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_3_poweroftwo_910_3e000910() {
    // Encoding: 0x3E000910
    // Test aarch32_VMOV_h_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, cond=3, Rt=0, N=0, op=0
    let encoding: u32 = 0x3E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_4_poweroftwo_910_4e000910() {
    // Encoding: 0x4E000910
    // Test aarch32_VMOV_h_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, op=0, cond=4, Vn=0, N=0
    let encoding: u32 = 0x4E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_5_poweroftwo_910_5e000910() {
    // Encoding: 0x5E000910
    // Test aarch32_VMOV_h_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rt=0, N=0, op=0, Vn=0
    let encoding: u32 = 0x5E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_6_poweroftwo_910_6e000910() {
    // Encoding: 0x6E000910
    // Test aarch32_VMOV_h_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Vn=0, N=0, cond=6, Rt=0
    let encoding: u32 = 0x6E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_7_poweroftwo_910_7e000910() {
    // Encoding: 0x7E000910
    // Test aarch32_VMOV_h_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Vn=0, Rt=0, cond=7, N=0
    let encoding: u32 = 0x7E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_8_poweroftwo_910_8e000910() {
    // Encoding: 0x8E000910
    // Test aarch32_VMOV_h_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, cond=8, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x8E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_9_poweroftwo_910_9e000910() {
    // Encoding: 0x9E000910
    // Test aarch32_VMOV_h_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, op=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x9E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_10_poweroftwo_910_ae000910() {
    // Encoding: 0xAE000910
    // Test aarch32_VMOV_h_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Vn=0, Rt=0, op=0, N=0
    let encoding: u32 = 0xAE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_11_poweroftwo_910_be000910() {
    // Encoding: 0xBE000910
    // Test aarch32_VMOV_h_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, op=0, Vn=0, N=0, Rt=0
    let encoding: u32 = 0xBE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_12_poweroftwo_910_ce000910() {
    // Encoding: 0xCE000910
    // Test aarch32_VMOV_h_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, N=0, op=0, Vn=0, cond=12
    let encoding: u32 = 0xCE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_13_poweroftwo_910_de000910() {
    // Encoding: 0xDE000910
    // Test aarch32_VMOV_h_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, N=0, op=0, Rt=0, cond=13
    let encoding: u32 = 0xDE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_14_poweroftwo_910_ee000910() {
    // Encoding: 0xEE000910
    // Test aarch32_VMOV_h_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, cond=14, op=0
    let encoding: u32 = 0xEE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_h_a1_a_field_cond_15_max_910_fe000910() {
    // Encoding: 0xFE000910
    // Test aarch32_VMOV_h_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: op=0, Vn=0, Rt=0, cond=15, N=0
    let encoding: u32 = 0xFE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_h_a1_a_field_op_0_min_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Vn=0, cond=0, op=0, N=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_h_a1_a_field_op_1_max_910_0e100910() {
    // Encoding: 0x0E100910
    // Test aarch32_VMOV_h_A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: op=1, Vn=0, Rt=0, N=0, cond=0
    let encoding: u32 = 0x0E100910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_h_a1_a_field_vn_0_min_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, op=0, N=0, cond=0, Rt=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_h_a1_a_field_vn_1_poweroftwo_910_0e010910() {
    // Encoding: 0x0E010910
    // Test aarch32_VMOV_h_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=0, Vn=1, op=0, Rt=0
    let encoding: u32 = 0x0E010910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_h_a1_a_field_rt_0_min_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, op=0, Vn=0, N=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_h_a1_a_field_rt_1_poweroftwo_910_0e001910() {
    // Encoding: 0x0E001910
    // Test aarch32_VMOV_h_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Rt=1, cond=0, N=0, op=0
    let encoding: u32 = 0x0E001910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_h_a1_a_field_n_0_min_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, N=0, Vn=0, op=0, cond=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_h_a1_a_field_n_1_max_910_0e000990() {
    // Encoding: 0x0E000990
    // Test aarch32_VMOV_h_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, cond=0, Vn=0, Rt=0, op=0
    let encoding: u32 = 0x0E000990;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_0_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=0, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, Vn=0, N=0, Rt=0, cond=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_1_910_1e000910() {
    // Encoding: 0x1E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=1, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, cond=1, Rt=0, op=0, Vn=0
    let encoding: u32 = 0x1E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_2_910_2e000910() {
    // Encoding: 0x2E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=2, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, Rt=0, Vn=0, op=0, cond=2
    let encoding: u32 = 0x2E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_3_910_3e000910() {
    // Encoding: 0x3E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=3, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=3, op=0, Rt=0, N=0, Vn=0
    let encoding: u32 = 0x3E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_4_910_4e000910() {
    // Encoding: 0x4E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=4, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, N=0, cond=4, Rt=0, Vn=0
    let encoding: u32 = 0x4E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_5_910_5e000910() {
    // Encoding: 0x5E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=5, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Vn=0, Rt=0, cond=5, op=0, N=0
    let encoding: u32 = 0x5E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_6_910_6e000910() {
    // Encoding: 0x6E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=6, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=6, Rt=0, N=0, op=0, Vn=0
    let encoding: u32 = 0x6E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_7_910_7e000910() {
    // Encoding: 0x7E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=7, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=7, op=0, N=0, Vn=0, Rt=0
    let encoding: u32 = 0x7E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_8_910_8e000910() {
    // Encoding: 0x8E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=8, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=8, Rt=0, N=0, Vn=0, op=0
    let encoding: u32 = 0x8E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_9_910_9e000910() {
    // Encoding: 0x9E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=9, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, Rt=0, N=0, cond=9, Vn=0
    let encoding: u32 = 0x9E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_10_910_ae000910() {
    // Encoding: 0xAE000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=10, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, op=0, cond=10, Vn=0, N=0
    let encoding: u32 = 0xAE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_11_910_be000910() {
    // Encoding: 0xBE000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=11, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, Vn=0, N=0, cond=11, Rt=0
    let encoding: u32 = 0xBE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_12_910_ce000910() {
    // Encoding: 0xCE000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=12, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, cond=12, op=0, Rt=0, Vn=0
    let encoding: u32 = 0xCE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_13_910_de000910() {
    // Encoding: 0xDE000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=13, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, cond=13, Rt=0, Vn=0, N=0
    let encoding: u32 = 0xDE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_14_910_ee000910() {
    // Encoding: 0xEE000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=14, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=14, Vn=0, N=0, op=0, Rt=0
    let encoding: u32 = 0xEE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_15_910_fe000910() {
    // Encoding: 0xFE000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=15, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, N=0, cond=15, op=0, Vn=0
    let encoding: u32 = 0xFE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_h_a1_a_combo_16_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=0, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: cond=0, op=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_h_a1_a_combo_17_910_0e100910() {
    // Encoding: 0x0E100910
    // Test aarch32_VMOV_h_A1_A field combination: cond=0, op=1, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: Rt=0, N=0, Vn=0, op=1, cond=0
    let encoding: u32 = 0x0E100910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_h_a1_a_combo_18_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A field combination: cond=0, op=0, Vn=0, Rt=0, N=0
    // ISET: A32
    // Fields: op=0, Rt=0, N=0, Vn=0, cond=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_h_a1_a_combo_19_910_0e010910() {
    // Encoding: 0x0E010910
    // Test aarch32_VMOV_h_A1_A field combination: cond=0, op=0, Vn=1, Rt=0, N=0
    // ISET: A32
    // Fields: N=0, Vn=1, op=0, Rt=0, cond=0
    let encoding: u32 = 0x0E010910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_0_condition_eq_2320_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, op=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_1_condition_ne_2320_1e000910() {
    // Encoding: 0x1E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, N=0, Vn=0, Rt=0, op=0
    let encoding: u32 = 0x1E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_2_condition_cs_hs_2320_2e000910() {
    // Encoding: 0x2E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: N=0, Vn=0, Rt=0, cond=2, op=0
    let encoding: u32 = 0x2E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_3_condition_cc_lo_2320_3e000910() {
    // Encoding: 0x3E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: op=0, N=0, cond=3, Vn=0, Rt=0
    let encoding: u32 = 0x3E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_4_condition_mi_2320_4e000910() {
    // Encoding: 0x4E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: op=0, cond=4, N=0, Vn=0, Rt=0
    let encoding: u32 = 0x4E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_5_condition_pl_2320_5e000910() {
    // Encoding: 0x5E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rt=0, op=0, N=0, Vn=0
    let encoding: u32 = 0x5E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_6_condition_vs_2320_6e000910() {
    // Encoding: 0x6E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: op=0, Vn=0, cond=6, Rt=0, N=0
    let encoding: u32 = 0x6E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_7_condition_vc_2320_7e000910() {
    // Encoding: 0x7E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: op=0, Vn=0, N=0, cond=7, Rt=0
    let encoding: u32 = 0x7E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_8_condition_hi_2320_8e000910() {
    // Encoding: 0x8E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: op=0, Rt=0, cond=8, Vn=0, N=0
    let encoding: u32 = 0x8E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_9_condition_ls_2320_9e000910() {
    // Encoding: 0x9E000910
    // Test aarch32_VMOV_h_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, cond=9, Vn=0, N=0, op=0
    let encoding: u32 = 0x9E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_10_condition_ge_2320_ae000910() {
    // Encoding: 0xAE000910
    // Test aarch32_VMOV_h_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: N=0, op=0, Vn=0, cond=10, Rt=0
    let encoding: u32 = 0xAE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_11_condition_lt_2320_be000910() {
    // Encoding: 0xBE000910
    // Test aarch32_VMOV_h_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Vn=0, op=0, Rt=0, cond=11, N=0
    let encoding: u32 = 0xBE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_12_condition_gt_2320_ce000910() {
    // Encoding: 0xCE000910
    // Test aarch32_VMOV_h_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: N=0, Vn=0, Rt=0, op=0, cond=12
    let encoding: u32 = 0xCE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_13_condition_le_2320_de000910() {
    // Encoding: 0xDE000910
    // Test aarch32_VMOV_h_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, op=0, cond=13, N=0, Vn=0
    let encoding: u32 = 0xDE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_14_condition_al_2320_ee000910() {
    // Encoding: 0xEE000910
    // Test aarch32_VMOV_h_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Vn=0, Rt=0, N=0, cond=14, op=0
    let encoding: u32 = 0xEE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_h_a1_a_special_cond_15_condition_nv_2320_fe000910() {
    // Encoding: 0xFE000910
    // Test aarch32_VMOV_h_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Vn=0, cond=15, N=0, op=0, Rt=0
    let encoding: u32 = 0xFE000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_h_a1_a_invalid_0_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // ISET: A32
    // Fields: op=0, Rt=0, N=0, cond=0, Vn=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_h_a1_a_invalid_1_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, Rt=0, cond=0, op=0, N=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_a1_a_invalid_2_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0, Rt=0, op=0, N=0, Vn=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_a1_a_invalid_3_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, N=0, Rt=0, Vn=0, op=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_a1_a_invalid_4_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, op=0, Vn=0, Rt=0, N=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_a1_a_invalid_5_910_0e000910() {
    // Encoding: 0x0E000910
    // Test aarch32_VMOV_h_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, N=0, Rt=0, Vn=0, op=0
    let encoding: u32 = 0x0E000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_h_t1_a_field_op_0_min_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field op = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Rt=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field op 20 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_h_t1_a_field_op_1_max_910_ee100910() {
    // Thumb encoding (32): 0xEE100910
    // Test aarch32_VMOV_h_T1_A field op = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, Rt=0, op=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_h_t1_a_field_vn_0_min_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Rt=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_h_t1_a_field_vn_1_poweroftwo_910_ee010910() {
    // Thumb encoding (32): 0xEE010910
    // Test aarch32_VMOV_h_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, op=0, Vn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_vmov_h_t1_a_field_rt_0_min_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Vn=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_vmov_h_t1_a_field_rt_1_poweroftwo_910_ee001910() {
    // Thumb encoding (32): 0xEE001910
    // Test aarch32_VMOV_h_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, Rt=1, N=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_h_t1_a_field_n_0_min_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: op=0, N=0, Vn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_h_t1_a_field_n_1_max_910_ee000990() {
    // Thumb encoding (32): 0xEE000990
    // Test aarch32_VMOV_h_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: op=0, Rt=0, N=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000990;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_h_t1_a_combo_0_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: N=0, op=0, Rt=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_h_t1_a_combo_1_910_ee100910() {
    // Thumb encoding (32): 0xEE100910
    // Test aarch32_VMOV_h_T1_A field combination: op=1, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: Vn=0, op=1, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE100910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_h_t1_a_combo_2_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: N=0, Rt=0, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_h_t1_a_combo_3_910_ee010910() {
    // Thumb encoding (32): 0xEE010910
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=1, Rt=0, N=0
    // ISET: T32
    // Fields: Vn=1, Rt=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_vmov_h_t1_a_combo_4_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: op=0, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_vmov_h_t1_a_combo_5_910_ee001910() {
    // Thumb encoding (32): 0xEE001910
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=0, Rt=1, N=0
    // ISET: T32
    // Fields: op=0, N=0, Rt=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// N=0 (minimum value)
#[test]
fn test_aarch32_vmov_h_t1_a_combo_6_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=0, Rt=0, N=0
    // ISET: T32
    // Fields: Vn=0, N=0, op=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// N=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_h_t1_a_combo_7_910_ee000990() {
    // Thumb encoding (32): 0xEE000990
    // Test aarch32_VMOV_h_T1_A field combination: op=0, Vn=0, Rt=0, N=1
    // ISET: T32
    // Fields: Vn=0, N=1, Rt=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000990;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_h_t1_a_invalid_0_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // ISET: T32
    // Fields: N=0, op=0, Rt=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_h_t1_a_invalid_1_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, Vn=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_t1_a_invalid_2_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: op=0, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_t1_a_invalid_3_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Vn=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_t1_a_invalid_4_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: op=0, Vn=0, Rt=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_h_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_h_t1_a_invalid_5_910_ee000910() {
    // Thumb encoding (32): 0xEE000910
    // Test aarch32_VMOV_h_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: N=0, op=0, Vn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000910;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_VMOV_i_A Tests
// ============================================================================

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_i_0_min_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field i = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, imm4=0, D=0, imm3=0, Q=0, op=0, cmode=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_i_1_max_10_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T1A1_A field i = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, cmode=0, imm3=0, Q=0, i=1, D=0, op=0, imm4=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_d_0_min_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, imm3=0, Q=0, op=0, i=0, cmode=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_d_1_max_10_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Q=0, cmode=0, imm3=0, i=0, imm4=0, Vd=0, D=1, op=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_0_zero_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 0 (Zero)
    // ISET: A32
    // Fields: op=0, D=0, cmode=0, imm3=0, i=0, Vd=0, imm4=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_1_poweroftwo_10_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: i=0, Q=0, D=0, Vd=0, imm3=1, imm4=0, op=0, cmode=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_3_poweroftwominusone_10_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Vd=0, imm3=3, D=0, imm4=0, op=0, Q=0, i=0, cmode=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_7_max_10_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 7 (Max)
    // ISET: A32
    // Fields: D=0, i=0, imm3=7, Q=0, Vd=0, op=0, cmode=0, imm4=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_vd_0_min_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Q=0, i=0, imm4=0, D=0, Vd=0, op=0, cmode=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_vd_1_poweroftwo_10_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm3=0, Q=0, D=0, Vd=1, op=0, imm4=0, i=0, cmode=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_0_min_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field cmode = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, imm4=0, i=0, imm3=0, Q=0, cmode=0, D=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_1_poweroftwo_10_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T1A1_A field cmode = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm3=0, Q=0, D=0, cmode=1, i=0, imm4=0, Vd=0, op=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_7_poweroftwominusone_10_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T1A1_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm3=0, Q=0, op=0, Vd=0, imm4=0, i=0, D=0, cmode=7
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_15_max_10_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T1A1_A field cmode = 15 (Max)
    // ISET: A32
    // Fields: imm3=0, imm4=0, D=0, op=0, cmode=15, Vd=0, i=0, Q=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_q_0_min_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vd=0, Q=0, imm4=0, imm3=0, i=0, cmode=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_q_1_max_10_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T1A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: D=0, imm4=0, op=0, cmode=0, imm3=0, Q=1, i=0, Vd=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_op_0_min_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: i=0, Vd=0, imm3=0, Q=0, imm4=0, D=0, op=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_op_1_max_10_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T1A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: imm4=0, op=1, cmode=0, i=0, Vd=0, D=0, Q=0, imm3=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_0_zero_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: op=0, imm3=0, imm4=0, Vd=0, i=0, cmode=0, D=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_1_poweroftwo_10_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm3=0, D=0, Vd=0, cmode=0, op=0, i=0, Q=0, imm4=1
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_3_poweroftwominusone_10_f2800013() {
    // Encoding: 0xF2800013
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, imm3=0, op=0, Vd=0, cmode=0, i=0, Q=0, imm4=3
    let encoding: u32 = 0xF2800013;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_4_poweroftwo_10_f2800014() {
    // Encoding: 0xF2800014
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: i=0, D=0, imm3=0, Vd=0, imm4=4, cmode=0, Q=0, op=0
    let encoding: u32 = 0xF2800014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_7_poweroftwominusone_10_f2800017() {
    // Encoding: 0xF2800017
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cmode=0, imm3=0, Q=0, i=0, D=0, imm4=7, op=0, Vd=0
    let encoding: u32 = 0xF2800017;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_8_poweroftwo_10_f2800018() {
    // Encoding: 0xF2800018
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cmode=0, i=0, op=0, imm3=0, imm4=8, D=0, Q=0, Vd=0
    let encoding: u32 = 0xF2800018;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_15_max_10_f280001f() {
    // Encoding: 0xF280001F
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, i=0, cmode=0, imm4=15, imm3=0, op=0, D=0, Q=0
    let encoding: u32 = 0xF280001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_0_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Q=0, op=0, cmode=0, imm3=0, i=0, Vd=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_1_10_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, imm3=0, imm4=0, cmode=0, Q=0, i=1, D=0, Vd=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_2_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Q=0, cmode=0, D=0, Vd=0, imm4=0, op=0, imm3=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_3_10_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Q=0, imm4=0, i=0, cmode=0, D=1, op=0, Vd=0, imm3=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_4_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, imm4=0, op=0, i=0, Vd=0, cmode=0, Q=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_5_10_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Q=0, D=0, imm4=0, cmode=0, imm3=1, i=0, Vd=0, op=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_6_10_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, cmode=0, Vd=0, op=0, D=0, imm4=0, imm3=3, Q=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_7_10_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, D=0, op=0, imm4=0, imm3=7, Q=0, i=0, Vd=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_8_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, Vd=0, cmode=0, Q=0, op=0, imm3=0, imm4=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_9_10_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Vd=1, Q=0, imm3=0, op=0, i=0, cmode=0, D=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_10_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, imm3=0, Q=0, op=0, imm4=0, cmode=0, D=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_11_10_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Vd=0, Q=0, imm3=0, cmode=1, i=0, D=0, op=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_12_10_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=7, Vd=0, imm3=0, imm4=0, Q=0, op=0, i=0, D=0
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_13_10_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, imm4=0, cmode=15, Vd=0, i=0, Q=0, op=0, D=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_14_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, imm3=0, cmode=0, imm4=0, op=0, Q=0, D=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_15_10_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, Q=1, imm3=0, i=0, D=0, cmode=0, op=0, imm4=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_16_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, Q=0, i=0, D=0, op=0, imm4=0, cmode=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_17_10_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: A32
    // Fields: op=1, imm3=0, i=0, cmode=0, D=0, Q=0, imm4=0, Vd=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_18_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, op=0, imm3=0, Q=0, imm4=0, D=0, i=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_19_10_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: A32
    // Fields: op=0, imm4=1, Vd=0, i=0, cmode=0, imm3=0, Q=0, D=0
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t1a1_a_special_q_0_size_variant_0_16_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, i=0, imm3=0, op=0, Q=0, imm4=0, Vd=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_special_q_1_size_variant_1_16_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T1A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: i=0, D=0, imm3=0, cmode=0, Vd=0, Q=1, op=0, imm4=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t1a1_a_invalid_0_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: i=0, Vd=0, cmode=0, Q=0, op=0, D=0, imm3=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t1a1_a_invalid_1_10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, op=0, imm3=0, Vd=0, i=0, cmode=0, imm4=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_0_min_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, size=0, imm4H=0, Vd=0, cond=0, D=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_1_poweroftwo_800_1eb00800() {
    // Encoding: 0x1EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, D=0, cond=1, imm4H=0, Vd=0, size=0
    let encoding: u32 = 0x1EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_2_poweroftwo_800_2eb00800() {
    // Encoding: 0x2EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, cond=2, imm4H=0, D=0, size=0, imm4L=0
    let encoding: u32 = 0x2EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_3_poweroftwo_800_3eb00800() {
    // Encoding: 0x3EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, imm4L=0, cond=3, D=0, imm4H=0, Vd=0
    let encoding: u32 = 0x3EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_4_poweroftwo_800_4eb00800() {
    // Encoding: 0x4EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, imm4L=0, size=0, cond=4, imm4H=0, D=0
    let encoding: u32 = 0x4EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_5_poweroftwo_800_5eb00800() {
    // Encoding: 0x5EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm4H=0, Vd=0, size=0, imm4L=0, cond=5
    let encoding: u32 = 0x5EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_6_poweroftwo_800_6eb00800() {
    // Encoding: 0x6EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Vd=0, D=0, imm4H=0, size=0, imm4L=0
    let encoding: u32 = 0x6EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_7_poweroftwo_800_7eb00800() {
    // Encoding: 0x7EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, size=0, cond=7, Vd=0, imm4L=0, D=0
    let encoding: u32 = 0x7EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_8_poweroftwo_800_8eb00800() {
    // Encoding: 0x8EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, imm4H=0, size=0, cond=8, imm4L=0
    let encoding: u32 = 0x8EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_9_poweroftwo_800_9eb00800() {
    // Encoding: 0x9EB00800
    // Test aarch32_VMOV_i_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, D=0, imm4L=0, Vd=0, size=0, imm4H=0
    let encoding: u32 = 0x9EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_10_poweroftwo_800_aeb00800() {
    // Encoding: 0xAEB00800
    // Test aarch32_VMOV_i_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, size=0, D=0, cond=10, Vd=0, imm4L=0
    let encoding: u32 = 0xAEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_11_poweroftwo_800_beb00800() {
    // Encoding: 0xBEB00800
    // Test aarch32_VMOV_i_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, size=0, imm4H=0, D=0, Vd=0, imm4L=0
    let encoding: u32 = 0xBEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_12_poweroftwo_800_ceb00800() {
    // Encoding: 0xCEB00800
    // Test aarch32_VMOV_i_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, size=0, D=0, cond=12, imm4H=0, Vd=0
    let encoding: u32 = 0xCEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_13_poweroftwo_800_deb00800() {
    // Encoding: 0xDEB00800
    // Test aarch32_VMOV_i_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Vd=0, size=0, D=0, cond=13, imm4H=0
    let encoding: u32 = 0xDEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_14_poweroftwo_800_eeb00800() {
    // Encoding: 0xEEB00800
    // Test aarch32_VMOV_i_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, D=0, Vd=0, size=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xEEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmov_i_a2_a_field_cond_15_max_800_feb00800() {
    // Encoding: 0xFEB00800
    // Test aarch32_VMOV_i_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: D=0, imm4H=0, imm4L=0, cond=15, Vd=0, size=0
    let encoding: u32 = 0xFEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_a2_a_field_d_0_min_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, cond=0, imm4H=0, Vd=0, size=0, imm4L=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_a2_a_field_d_1_max_800_0ef00800() {
    // Encoding: 0x0EF00800
    // Test aarch32_VMOV_i_A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: imm4H=0, Vd=0, size=0, D=1, imm4L=0, cond=0
    let encoding: u32 = 0x0EF00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_0_zero_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: size=0, D=0, cond=0, imm4L=0, imm4H=0, Vd=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_1_poweroftwo_800_0eb10800() {
    // Encoding: 0x0EB10800
    // Test aarch32_VMOV_i_A2_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm4H=1, Vd=0, size=0, imm4L=0, cond=0
    let encoding: u32 = 0x0EB10800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_3_poweroftwominusone_800_0eb30800() {
    // Encoding: 0x0EB30800
    // Test aarch32_VMOV_i_A2_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4H=3, Vd=0, D=0, size=0, imm4L=0
    let encoding: u32 = 0x0EB30800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_4_poweroftwo_800_0eb40800() {
    // Encoding: 0x0EB40800
    // Test aarch32_VMOV_i_A2_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, imm4H=4, cond=0, Vd=0, imm4L=0, D=0
    let encoding: u32 = 0x0EB40800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_7_poweroftwominusone_800_0eb70800() {
    // Encoding: 0x0EB70800
    // Test aarch32_VMOV_i_A2_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Vd=0, size=0, D=0, imm4H=7, imm4L=0
    let encoding: u32 = 0x0EB70800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_8_poweroftwo_800_0eb80800() {
    // Encoding: 0x0EB80800
    // Test aarch32_VMOV_i_A2_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm4L=0, Vd=0, cond=0, imm4H=8, size=0
    let encoding: u32 = 0x0EB80800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4h_15_max_800_0ebf0800() {
    // Encoding: 0x0EBF0800
    // Test aarch32_VMOV_i_A2_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: cond=0, imm4L=0, D=0, imm4H=15, size=0, Vd=0
    let encoding: u32 = 0x0EBF0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_a2_a_field_vd_0_min_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, imm4H=0, cond=0, imm4L=0, size=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_a2_a_field_vd_1_poweroftwo_800_0eb01800() {
    // Encoding: 0x0EB01800
    // Test aarch32_VMOV_i_A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm4L=0, cond=0, size=0, imm4H=0, Vd=1
    let encoding: u32 = 0x0EB01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_a2_a_field_size_0_min_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, size=0, imm4L=0, cond=0, Vd=0, D=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_a2_a_field_size_1_poweroftwo_800_0eb00900() {
    // Encoding: 0x0EB00900
    // Test aarch32_VMOV_i_A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, imm4H=0, D=0, size=1, imm4L=0, cond=0
    let encoding: u32 = 0x0EB00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmov_i_a2_a_field_size_2_poweroftwo_800_0eb00a00() {
    // Encoding: 0x0EB00A00
    // Test aarch32_VMOV_i_A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, D=0, Vd=0, size=2, imm4H=0, imm4L=0
    let encoding: u32 = 0x0EB00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmov_i_a2_a_field_size_3_max_800_0eb00b00() {
    // Encoding: 0x0EB00B00
    // Test aarch32_VMOV_i_A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=0, D=0, size=3, Vd=0
    let encoding: u32 = 0x0EB00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_0_zero_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: Vd=0, imm4H=0, size=0, cond=0, imm4L=0, D=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_1_poweroftwo_800_0eb00801() {
    // Encoding: 0x0EB00801
    // Test aarch32_VMOV_i_A2_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, imm4L=1, Vd=0, D=0, cond=0, imm4H=0
    let encoding: u32 = 0x0EB00801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_3_poweroftwominusone_800_0eb00803() {
    // Encoding: 0x0EB00803
    // Test aarch32_VMOV_i_A2_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: size=0, D=0, cond=0, Vd=0, imm4H=0, imm4L=3
    let encoding: u32 = 0x0EB00803;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_4_poweroftwo_800_0eb00804() {
    // Encoding: 0x0EB00804
    // Test aarch32_VMOV_i_A2_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, D=0, imm4H=0, Vd=0, size=0, imm4L=4
    let encoding: u32 = 0x0EB00804;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_7_poweroftwominusone_800_0eb00807() {
    // Encoding: 0x0EB00807
    // Test aarch32_VMOV_i_A2_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=7, Vd=0, imm4H=0, cond=0, D=0, size=0
    let encoding: u32 = 0x0EB00807;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_8_poweroftwo_800_0eb00808() {
    // Encoding: 0x0EB00808
    // Test aarch32_VMOV_i_A2_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, cond=0, D=0, Vd=0, imm4H=0, imm4L=8
    let encoding: u32 = 0x0EB00808;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_a2_a_field_imm4l_15_max_800_0eb0080f() {
    // Encoding: 0x0EB0080F
    // Test aarch32_VMOV_i_A2_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, imm4H=0, cond=0, size=0, imm4L=15
    let encoding: u32 = 0x0EB0080F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_0_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=0, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=0, D=0, size=0, Vd=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_1_800_1eb00800() {
    // Encoding: 0x1EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=1, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, D=0, Vd=0, size=0, cond=1
    let encoding: u32 = 0x1EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_2_800_2eb00800() {
    // Encoding: 0x2EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=2, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: D=0, imm4L=0, cond=2, imm4H=0, Vd=0, size=0
    let encoding: u32 = 0x2EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_3_800_3eb00800() {
    // Encoding: 0x3EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=3, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: cond=3, imm4H=0, size=0, Vd=0, D=0, imm4L=0
    let encoding: u32 = 0x3EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_4_800_4eb00800() {
    // Encoding: 0x4EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=4, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, D=0, size=0, cond=4, imm4H=0, Vd=0
    let encoding: u32 = 0x4EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_5_800_5eb00800() {
    // Encoding: 0x5EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=5, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: D=0, imm4H=0, Vd=0, size=0, imm4L=0, cond=5
    let encoding: u32 = 0x5EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_6_800_6eb00800() {
    // Encoding: 0x6EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=6, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: cond=6, imm4L=0, D=0, imm4H=0, size=0, Vd=0
    let encoding: u32 = 0x6EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_7_800_7eb00800() {
    // Encoding: 0x7EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=7, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, Vd=0, size=0, D=0, imm4L=0, cond=7
    let encoding: u32 = 0x7EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_8_800_8eb00800() {
    // Encoding: 0x8EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=8, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: size=0, cond=8, imm4L=0, Vd=0, D=0, imm4H=0
    let encoding: u32 = 0x8EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_9_800_9eb00800() {
    // Encoding: 0x9EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=9, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: cond=9, D=0, size=0, imm4H=0, Vd=0, imm4L=0
    let encoding: u32 = 0x9EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_10_800_aeb00800() {
    // Encoding: 0xAEB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=10, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: cond=10, size=0, D=0, Vd=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xAEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_11_800_beb00800() {
    // Encoding: 0xBEB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=11, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: size=0, cond=11, D=0, imm4H=0, imm4L=0, Vd=0
    let encoding: u32 = 0xBEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_12_800_ceb00800() {
    // Encoding: 0xCEB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=12, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: cond=12, imm4L=0, size=0, D=0, imm4H=0, Vd=0
    let encoding: u32 = 0xCEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_13_800_deb00800() {
    // Encoding: 0xDEB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=13, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, size=0, imm4H=0, D=0, Vd=0, cond=13
    let encoding: u32 = 0xDEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_14_800_eeb00800() {
    // Encoding: 0xEEB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=14, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: Vd=0, size=0, imm4H=0, imm4L=0, cond=14, D=0
    let encoding: u32 = 0xEEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_15_800_feb00800() {
    // Encoding: 0xFEB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=15, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: D=0, imm4H=0, Vd=0, size=0, cond=15, imm4L=0
    let encoding: u32 = 0xFEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_a2_a_combo_16_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=0, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: Vd=0, imm4L=0, imm4H=0, size=0, cond=0, D=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_a2_a_combo_17_800_0ef00800() {
    // Encoding: 0x0EF00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=0, D=1, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, Vd=0, size=0, imm4L=0, D=1, cond=0
    let encoding: u32 = 0x0EF00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_a2_a_combo_18_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A field combination: cond=0, D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, size=0, cond=0, D=0, Vd=0, imm4L=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_a2_a_combo_19_800_0eb10800() {
    // Encoding: 0x0EB10800
    // Test aarch32_VMOV_i_A2_A field combination: cond=0, D=0, imm4H=1, Vd=0, size=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=1, cond=0, Vd=0, size=0, D=0, imm4L=0
    let encoding: u32 = 0x0EB10800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_0_condition_eq_2048_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Vd=0, imm4H=0, cond=0, imm4L=0, D=0, size=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_1_condition_ne_2048_1eb00800() {
    // Encoding: 0x1EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, cond=1, imm4L=0, imm4H=0
    let encoding: u32 = 0x1EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_2_condition_cs_hs_2048_2eb00800() {
    // Encoding: 0x2EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Vd=0, imm4H=0, cond=2, D=0, size=0, imm4L=0
    let encoding: u32 = 0x2EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_3_condition_cc_lo_2048_3eb00800() {
    // Encoding: 0x3EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Vd=0, imm4L=0, size=0, cond=3, D=0, imm4H=0
    let encoding: u32 = 0x3EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_4_condition_mi_2048_4eb00800() {
    // Encoding: 0x4EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Vd=0, imm4L=0, imm4H=0, size=0, D=0
    let encoding: u32 = 0x4EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_5_condition_pl_2048_5eb00800() {
    // Encoding: 0x5EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: size=0, imm4H=0, cond=5, Vd=0, imm4L=0, D=0
    let encoding: u32 = 0x5EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_6_condition_vs_2048_6eb00800() {
    // Encoding: 0x6EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, D=0, imm4L=0, Vd=0, size=0, imm4H=0
    let encoding: u32 = 0x6EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_7_condition_vc_2048_7eb00800() {
    // Encoding: 0x7EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: D=0, imm4H=0, size=0, cond=7, Vd=0, imm4L=0
    let encoding: u32 = 0x7EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_8_condition_hi_2048_8eb00800() {
    // Encoding: 0x8EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Vd=0, imm4H=0, imm4L=0, D=0, size=0
    let encoding: u32 = 0x8EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_9_condition_ls_2048_9eb00800() {
    // Encoding: 0x9EB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Vd=0, imm4H=0, imm4L=0, size=0, cond=9, D=0
    let encoding: u32 = 0x9EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_10_condition_ge_2048_aeb00800() {
    // Encoding: 0xAEB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: D=0, size=0, imm4H=0, cond=10, imm4L=0, Vd=0
    let encoding: u32 = 0xAEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_11_condition_lt_2048_beb00800() {
    // Encoding: 0xBEB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: size=0, Vd=0, imm4L=0, cond=11, D=0, imm4H=0
    let encoding: u32 = 0xBEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_12_condition_gt_2048_ceb00800() {
    // Encoding: 0xCEB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: size=0, imm4L=0, cond=12, imm4H=0, D=0, Vd=0
    let encoding: u32 = 0xCEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_13_condition_le_2048_deb00800() {
    // Encoding: 0xDEB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Vd=0, size=0, imm4L=0, D=0, imm4H=0, cond=13
    let encoding: u32 = 0xDEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_14_condition_al_2048_eeb00800() {
    // Encoding: 0xEEB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: size=0, imm4H=0, cond=14, D=0, Vd=0, imm4L=0
    let encoding: u32 = 0xEEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmov_i_a2_a_special_cond_15_condition_nv_2048_feb00800() {
    // Encoding: 0xFEB00800
    // Test aarch32_VMOV_i_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4L=0, D=0, imm4H=0, Vd=0, size=0, cond=15
    let encoding: u32 = 0xFEB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_a2_a_special_size_0_size_variant_0_2048_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm4H=0, D=0, size=0, Vd=0, imm4L=0, cond=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_a2_a_special_size_1_size_variant_1_2048_0eb00900() {
    // Encoding: 0x0EB00900
    // Test aarch32_VMOV_i_A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: imm4H=0, Vd=0, size=1, cond=0, imm4L=0, D=0
    let encoding: u32 = 0x0EB00900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmov_i_a2_a_special_size_2_size_variant_2_2048_0eb00a00() {
    // Encoding: 0x0EB00A00
    // Test aarch32_VMOV_i_A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: cond=0, D=0, size=2, imm4H=0, Vd=0, imm4L=0
    let encoding: u32 = 0x0EB00A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmov_i_a2_a_special_size_3_size_variant_3_2048_0eb00b00() {
    // Encoding: 0x0EB00B00
    // Test aarch32_VMOV_i_A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, size=3, imm4L=0, cond=0, D=0, imm4H=0
    let encoding: u32 = 0x0EB00B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_a2_a_invalid_0_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: size=0, cond=0, imm4H=0, D=0, Vd=0, imm4L=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_a2_a_invalid_1_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: imm4L=0, cond=0, imm4H=0, Vd=0, size=0, D=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_a2_a_invalid_2_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: imm4H=0, D=0, Vd=0, cond=0, size=0, imm4L=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_a2_a_invalid_3_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, size=0, imm4L=0, cond=0, D=0, imm4H=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }) } }, rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_i_a2_a_invalid_4_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0, Vd=0, D=0, size=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_i_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_i_a2_a_invalid_5_800_0eb00800() {
    // Encoding: 0x0EB00800
    // Test aarch32_VMOV_i_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, cond=0, Vd=0, size=0, D=0
    let encoding: u32 = 0x0EB00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_i_0_min_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field i = 0 (Min)
    // ISET: A32
    // Fields: D=0, Q=0, op=0, imm4=0, imm3=0, i=0, cmode=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_i_1_max_810_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T3A3_A field i = 1 (Max)
    // ISET: A32
    // Fields: imm4=0, D=0, i=1, Vd=0, Q=0, op=0, cmode=0, imm3=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_d_0_min_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, imm4=0, op=0, Q=0, imm3=0, i=0, cmode=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_d_1_max_810_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T3A3_A field D = 1 (Max)
    // ISET: A32
    // Fields: Q=0, Vd=0, imm4=0, op=0, imm3=0, i=0, cmode=0, D=1
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_0_zero_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 0 (Zero)
    // ISET: A32
    // Fields: imm4=0, imm3=0, cmode=0, Vd=0, op=0, Q=0, i=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_1_poweroftwo_810_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, imm4=0, i=0, D=0, cmode=0, imm3=1, op=0, Q=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_3_poweroftwominusone_810_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: i=0, cmode=0, Q=0, op=0, imm3=3, imm4=0, Vd=0, D=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_7_max_810_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 7 (Max)
    // ISET: A32
    // Fields: imm4=0, Vd=0, i=0, Q=0, cmode=0, op=0, imm3=7, D=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_vd_0_min_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: i=0, imm4=0, D=0, Vd=0, imm3=0, op=0, cmode=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_vd_1_poweroftwo_810_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, imm4=0, i=0, imm3=0, op=0, Vd=1, cmode=0, D=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_0_min_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field cmode = 0 (Min)
    // ISET: A32
    // Fields: imm3=0, cmode=0, Vd=0, i=0, D=0, imm4=0, Q=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_1_poweroftwo_810_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T3A3_A field cmode = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cmode=1, op=0, i=0, Q=0, Vd=0, D=0, imm3=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_7_poweroftwominusone_810_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T3A3_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cmode=7, Vd=0, op=0, imm4=0, imm3=0, D=0, i=0, Q=0
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_15_max_810_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T3A3_A field cmode = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, i=0, imm4=0, imm3=0, D=0, op=0, Q=0, cmode=15
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_q_0_min_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field Q = 0 (Min)
    // ISET: A32
    // Fields: cmode=0, D=0, Q=0, i=0, imm3=0, op=0, Vd=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_q_1_max_810_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T3A3_A field Q = 1 (Max)
    // ISET: A32
    // Fields: imm4=0, Q=1, D=0, i=0, cmode=0, op=0, Vd=0, imm3=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_op_0_min_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field op = 0 (Min)
    // ISET: A32
    // Fields: imm4=0, op=0, imm3=0, D=0, i=0, Vd=0, cmode=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_op_1_max_810_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T3A3_A field op = 1 (Max)
    // ISET: A32
    // Fields: D=0, cmode=0, i=0, Q=0, op=1, imm3=0, imm4=0, Vd=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_0_zero_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: Vd=0, D=0, cmode=0, imm3=0, op=0, Q=0, i=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_1_poweroftwo_810_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: i=0, cmode=0, Q=0, op=0, imm3=0, D=0, Vd=0, imm4=1
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_3_poweroftwominusone_810_f2800013() {
    // Encoding: 0xF2800013
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cmode=0, i=0, op=0, D=0, Vd=0, imm3=0, Q=0, imm4=3
    let encoding: u32 = 0xF2800013;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_4_poweroftwo_810_f2800014() {
    // Encoding: 0xF2800014
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, op=0, i=0, D=0, imm3=0, Vd=0, cmode=0, imm4=4
    let encoding: u32 = 0xF2800014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_7_poweroftwominusone_810_f2800017() {
    // Encoding: 0xF2800017
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: op=0, imm4=7, i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0
    let encoding: u32 = 0xF2800017;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_8_poweroftwo_810_f2800018() {
    // Encoding: 0xF2800018
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cmode=0, i=0, D=0, imm4=8, imm3=0, op=0, Vd=0, Q=0
    let encoding: u32 = 0xF2800018;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_15_max_810_f280001f() {
    // Encoding: 0xF280001F
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: op=0, imm3=0, D=0, Vd=0, imm4=15, i=0, cmode=0, Q=0
    let encoding: u32 = 0xF280001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_0_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, imm4=0, D=0, imm3=0, Vd=0, i=0, op=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_1_810_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, cmode=0, imm4=0, Q=0, D=0, i=1, Vd=0, op=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_2_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, cmode=0, Vd=0, Q=0, imm3=0, D=0, i=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_3_810_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, D=1, Q=0, Vd=0, cmode=0, op=0, imm4=0, imm3=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_4_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, Q=0, D=0, imm3=0, cmode=0, Vd=0, imm4=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_5_810_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, imm3=1, cmode=0, Q=0, op=0, D=0, i=0, Vd=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_6_810_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=3, i=0, op=0, Q=0, imm4=0, D=0, cmode=0, Vd=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_7_810_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, Q=0, Vd=0, cmode=0, imm4=0, op=0, imm3=7, i=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_8_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, Q=0, D=0, imm4=0, cmode=0, Vd=0, imm3=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_9_810_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Q=0, op=0, Vd=1, i=0, cmode=0, imm3=0, D=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_10_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, cmode=0, i=0, op=0, D=0, imm3=0, imm4=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_11_810_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Q=0, Vd=0, imm4=0, D=0, op=0, imm3=0, cmode=1, i=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_12_810_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, i=0, cmode=7, imm3=0, imm4=0, Q=0, D=0, op=0
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_13_810_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, imm3=0, i=0, cmode=15, Q=0, op=0, imm4=0, Vd=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_14_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, Vd=0, D=0, Q=0, op=0, cmode=0, imm3=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_15_810_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, op=0, imm4=0, D=0, Q=1, imm3=0, i=0, Vd=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_16_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, cmode=0, Vd=0, imm4=0, op=0, Q=0, D=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_17_810_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: A32
    // Fields: Q=0, Vd=0, op=1, imm3=0, cmode=0, D=0, i=0, imm4=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_18_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, D=0, cmode=0, Vd=0, Q=0, i=0, imm4=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_19_810_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: A32
    // Fields: D=0, Vd=0, i=0, Q=0, imm4=1, cmode=0, imm3=0, op=0
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t3a3_a_special_q_0_size_variant_0_2064_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: cmode=0, op=0, D=0, Vd=0, imm4=0, i=0, Q=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_special_q_1_size_variant_1_2064_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T3A3_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, imm4=0, i=0, op=0, Q=1, D=0, imm3=0, cmode=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t3a3_a_invalid_0_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: imm4=0, Q=0, op=0, D=0, imm3=0, Vd=0, i=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t3a3_a_invalid_1_810_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: cmode=0, imm3=0, Vd=0, imm4=0, i=0, op=0, Q=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_i_0_min_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field i = 0 (Min)
    // ISET: A32
    // Fields: i=0, Q=0, imm4=0, Vd=0, imm3=0, cmode=0, op=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_i_1_max_c10_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T4A4_A field i = 1 (Max)
    // ISET: A32
    // Fields: imm3=0, Q=0, Vd=0, op=0, cmode=0, imm4=0, D=0, i=1
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_d_0_min_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field D = 0 (Min)
    // ISET: A32
    // Fields: cmode=0, imm3=0, Vd=0, imm4=0, D=0, i=0, op=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_d_1_max_c10_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T4A4_A field D = 1 (Max)
    // ISET: A32
    // Fields: imm3=0, Vd=0, op=0, D=1, Q=0, cmode=0, i=0, imm4=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_0_zero_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 0 (Zero)
    // ISET: A32
    // Fields: Q=0, op=0, i=0, cmode=0, imm4=0, Vd=0, D=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_1_poweroftwo_c10_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, Vd=0, Q=0, op=0, imm3=1, i=0, cmode=0, D=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_3_poweroftwominusone_c10_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: i=0, Vd=0, Q=0, imm3=3, D=0, imm4=0, cmode=0, op=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_7_max_c10_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 7 (Max)
    // ISET: A32
    // Fields: Q=0, imm3=7, op=0, D=0, cmode=0, i=0, Vd=0, imm4=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_vd_0_min_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vd=0, D=0, cmode=0, imm4=0, i=0, Q=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_vd_1_poweroftwo_c10_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T4A4_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, Q=0, i=0, imm3=0, op=0, imm4=0, D=0, cmode=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_0_min_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field cmode = 0 (Min)
    // ISET: A32
    // Fields: D=0, i=0, imm3=0, Vd=0, cmode=0, imm4=0, Q=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_1_poweroftwo_c10_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T4A4_A field cmode = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, imm3=0, Q=0, i=0, op=0, imm4=0, cmode=1, D=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_7_poweroftwominusone_c10_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T4A4_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cmode=7, Q=0, op=0, i=0, D=0, imm3=0, Vd=0
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_15_max_c10_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T4A4_A field cmode = 15 (Max)
    // ISET: A32
    // Fields: i=0, imm4=0, D=0, imm3=0, cmode=15, op=0, Vd=0, Q=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_q_0_min_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field Q = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, imm3=0, i=0, imm4=0, D=0, Q=0, cmode=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_q_1_max_c10_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T4A4_A field Q = 1 (Max)
    // ISET: A32
    // Fields: i=0, D=0, Vd=0, cmode=0, op=0, Q=1, imm3=0, imm4=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_op_0_min_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field op = 0 (Min)
    // ISET: A32
    // Fields: imm4=0, cmode=0, D=0, op=0, Vd=0, imm3=0, Q=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_op_1_max_c10_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T4A4_A field op = 1 (Max)
    // ISET: A32
    // Fields: Q=0, cmode=0, op=1, imm4=0, i=0, imm3=0, D=0, Vd=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_0_zero_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: Q=0, imm4=0, imm3=0, cmode=0, D=0, i=0, op=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_1_poweroftwo_c10_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Vd=0, i=0, D=0, cmode=0, imm4=1, imm3=0, Q=0
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_3_poweroftwominusone_c10_f2800013() {
    // Encoding: 0xF2800013
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: i=0, cmode=0, op=0, imm4=3, Q=0, imm3=0, D=0, Vd=0
    let encoding: u32 = 0xF2800013;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_4_poweroftwo_c10_f2800014() {
    // Encoding: 0xF2800014
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, op=0, Vd=0, i=0, imm3=0, cmode=0, D=0, imm4=4
    let encoding: u32 = 0xF2800014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_7_poweroftwominusone_c10_f2800017() {
    // Encoding: 0xF2800017
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Q=0, i=0, Vd=0, imm4=7, D=0, op=0, imm3=0, cmode=0
    let encoding: u32 = 0xF2800017;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_8_poweroftwo_c10_f2800018() {
    // Encoding: 0xF2800018
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cmode=0, Vd=0, op=0, imm3=0, imm4=8, Q=0, D=0, i=0
    let encoding: u32 = 0xF2800018;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_15_max_c10_f280001f() {
    // Encoding: 0xF280001F
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: i=0, imm4=15, D=0, op=0, imm3=0, Vd=0, cmode=0, Q=0
    let encoding: u32 = 0xF280001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_0_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, i=0, cmode=0, imm4=0, D=0, Q=0, Vd=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_1_c10_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, D=0, Vd=0, imm3=0, op=0, imm4=0, i=1, Q=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_2_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, i=0, D=0, Q=0, imm3=0, Vd=0, cmode=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_3_c10_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, imm4=0, op=0, i=0, Q=0, Vd=0, D=1, cmode=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_4_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Q=0, op=0, Vd=0, i=0, D=0, imm3=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_5_c10_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, imm3=1, Q=0, Vd=0, op=0, i=0, D=0, imm4=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_6_c10_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, Q=0, imm3=3, i=0, imm4=0, D=0, op=0, Vd=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_7_c10_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, i=0, cmode=0, imm3=7, imm4=0, D=0, Vd=0, Q=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_8_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Q=0, cmode=0, imm3=0, i=0, op=0, D=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_9_c10_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, Q=0, cmode=0, Vd=1, D=0, i=0, op=0, imm4=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_10_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, D=0, op=0, imm3=0, Q=0, imm4=0, i=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_11_c10_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, i=0, Q=0, imm3=0, imm4=0, Vd=0, cmode=1, op=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_12_c10_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, Vd=0, cmode=7, imm3=0, op=0, Q=0, imm4=0, D=0
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_13_c10_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, imm3=0, D=0, i=0, Vd=0, cmode=15, Q=0, imm4=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_14_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, Q=0, i=0, cmode=0, op=0, imm4=0, Vd=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_15_c10_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, cmode=0, Vd=0, imm4=0, Q=1, i=0, op=0, D=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_16_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, Q=0, cmode=0, op=0, imm4=0, Vd=0, i=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_17_c10_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: A32
    // Fields: Q=0, i=0, imm3=0, Vd=0, op=1, D=0, imm4=0, cmode=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_18_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, imm4=0, op=0, D=0, i=0, imm3=0, Q=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_19_c10_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: A32
    // Fields: Q=0, D=0, imm3=0, cmode=0, op=0, imm4=1, i=0, Vd=0
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t4a4_a_special_q_0_size_variant_0_3088_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: cmode=0, Vd=0, i=0, D=0, op=0, imm4=0, imm3=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_special_q_1_size_variant_1_3088_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T4A4_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Q=1, imm3=0, i=0, D=0, Vd=0, cmode=0, imm4=0, op=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t4a4_a_invalid_0_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: i=0, imm3=0, cmode=0, imm4=0, Q=0, Vd=0, op=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t4a4_a_invalid_1_c10_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T4A4_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: imm3=0, imm4=0, Q=0, Vd=0, op=0, cmode=0, i=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_i_0_min_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field i = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, i=0, op=0, imm4=0, cmode=0, Q=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field i 24 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_i_1_max_e30_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T5A5_A field i = 1 (Max)
    // ISET: A32
    // Fields: op=0, imm4=0, imm3=0, D=0, Q=0, i=1, cmode=0, Vd=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_d_0_min_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field D = 0 (Min)
    // ISET: A32
    // Fields: imm3=0, Vd=0, Q=0, cmode=0, i=0, D=0, imm4=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_d_1_max_e30_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T5A5_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=1, op=0, imm3=0, Q=0, imm4=0, cmode=0, i=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_0_zero_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 0 (Zero)
    // ISET: A32
    // Fields: op=0, i=0, D=0, cmode=0, Q=0, imm3=0, imm4=0, Vd=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_1_poweroftwo_e30_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, cmode=0, Q=0, i=0, op=0, imm3=1, imm4=0
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_3_poweroftwominusone_e30_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: D=0, imm4=0, Vd=0, imm3=3, i=0, cmode=0, Q=0, op=0
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_7_max_e30_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 7 (Max)
    // ISET: A32
    // Fields: Q=0, imm4=0, Vd=0, cmode=0, i=0, imm3=7, D=0, op=0
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_vd_0_min_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: i=0, imm4=0, imm3=0, Vd=0, op=0, cmode=0, Q=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_vd_1_poweroftwo_e30_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T5A5_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, op=0, cmode=0, Vd=1, i=0, D=0, imm4=0, imm3=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_0_min_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field cmode = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, i=0, imm3=0, D=0, Q=0, cmode=0, op=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_1_poweroftwo_e30_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T5A5_A field cmode = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, Vd=0, D=0, op=0, i=0, cmode=1, imm4=0, imm3=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_7_poweroftwominusone_e30_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T5A5_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, op=0, imm3=0, i=0, Q=0, D=0, Vd=0, cmode=7
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_15_max_e30_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T5A5_A field cmode = 15 (Max)
    // ISET: A32
    // Fields: i=0, op=0, Vd=0, Q=0, cmode=15, imm3=0, D=0, imm4=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_q_0_min_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field Q = 0 (Min)
    // ISET: A32
    // Fields: imm4=0, cmode=0, Vd=0, Q=0, op=0, i=0, D=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_q_1_max_e30_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T5A5_A field Q = 1 (Max)
    // ISET: A32
    // Fields: i=0, D=0, imm3=0, Q=1, Vd=0, cmode=0, imm4=0, op=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_op_0_min_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field op = 0 (Min)
    // ISET: A32
    // Fields: imm4=0, op=0, Vd=0, i=0, cmode=0, D=0, Q=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_op_1_max_e30_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T5A5_A field op = 1 (Max)
    // ISET: A32
    // Fields: imm3=0, D=0, cmode=0, Vd=0, Q=0, op=1, imm4=0, i=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_0_zero_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: Vd=0, Q=0, cmode=0, imm4=0, D=0, op=0, i=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_1_poweroftwo_e30_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, imm4=1, cmode=0, op=0, i=0, imm3=0, Vd=0, Q=0
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_3_poweroftwominusone_e30_f2800013() {
    // Encoding: 0xF2800013
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=3, imm3=0, Q=0, cmode=0, op=0, D=0, Vd=0, i=0
    let encoding: u32 = 0xF2800013;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_4_poweroftwo_e30_f2800014() {
    // Encoding: 0xF2800014
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, i=0, D=0, Vd=0, imm4=4, imm3=0, Q=0, cmode=0
    let encoding: u32 = 0xF2800014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_7_poweroftwominusone_e30_f2800017() {
    // Encoding: 0xF2800017
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Q=0, D=0, imm3=0, Vd=0, cmode=0, i=0, op=0, imm4=7
    let encoding: u32 = 0xF2800017;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_8_poweroftwo_e30_f2800018() {
    // Encoding: 0xF2800018
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, imm4=8, op=0, D=0, cmode=0, imm3=0, i=0, Q=0
    let encoding: u32 = 0xF2800018;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_15_max_e30_f280001f() {
    // Encoding: 0xF280001F
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: D=0, i=0, cmode=0, Vd=0, op=0, imm3=0, Q=0, imm4=15
    let encoding: u32 = 0xF280001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_0_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, Vd=0, i=0, imm3=0, op=0, imm4=0, cmode=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_1_e30_f3800010() {
    // Encoding: 0xF3800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, D=0, i=1, cmode=0, op=0, imm4=0, Q=0, Vd=0
    let encoding: u32 = 0xF3800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_2_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, imm4=0, Vd=0, op=0, i=0, D=0, cmode=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_3_e30_f2c00010() {
    // Encoding: 0xF2C00010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: i=0, Q=0, cmode=0, D=1, Vd=0, op=0, imm4=0, imm3=0
    let encoding: u32 = 0xF2C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_4_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Q=0, imm3=0, i=0, op=0, D=0, Vd=0, imm4=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_5_e30_f2810010() {
    // Encoding: 0xF2810010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, cmode=0, i=0, Q=0, op=0, Vd=0, imm4=0, imm3=1
    let encoding: u32 = 0xF2810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_6_e30_f2830010() {
    // Encoding: 0xF2830010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, Vd=0, Q=0, i=0, imm4=0, cmode=0, op=0, imm3=3
    let encoding: u32 = 0xF2830010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_7_e30_f2870010() {
    // Encoding: 0xF2870010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Q=0, D=0, op=0, cmode=0, Vd=0, i=0, imm4=0, imm3=7
    let encoding: u32 = 0xF2870010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_8_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, cmode=0, Q=0, i=0, Vd=0, imm3=0, op=0, D=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_9_e30_f2801010() {
    // Encoding: 0xF2801010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm3=0, cmode=0, Vd=1, op=0, Q=0, i=0, D=0, imm4=0
    let encoding: u32 = 0xF2801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_10_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=0, D=0, Q=0, Vd=0, imm3=0, imm4=0, i=0, op=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_11_e30_f2800110() {
    // Encoding: 0xF2800110
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: imm4=0, Vd=0, imm3=0, cmode=1, op=0, Q=0, i=0, D=0
    let encoding: u32 = 0xF2800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_12_e30_f2800710() {
    // Encoding: 0xF2800710
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, imm3=0, cmode=7, imm4=0, i=0, op=0, D=0, Q=0
    let encoding: u32 = 0xF2800710;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_13_e30_f2800f10() {
    // Encoding: 0xF2800F10
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: cmode=15, imm4=0, i=0, Vd=0, D=0, imm3=0, op=0, Q=0
    let encoding: u32 = 0xF2800F10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_14_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, imm4=0, Q=0, Vd=0, imm3=0, op=0, cmode=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_15_e30_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: A32
    // Fields: D=0, imm4=0, Q=1, cmode=0, i=0, imm3=0, Vd=0, op=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_16_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: Vd=0, Q=0, D=0, op=0, imm3=0, cmode=0, i=0, imm4=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_17_e30_f2800030() {
    // Encoding: 0xF2800030
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: A32
    // Fields: D=0, Vd=0, imm3=0, cmode=0, op=1, Q=0, imm4=0, i=0
    let encoding: u32 = 0xF2800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_18_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: A32
    // Fields: op=0, imm4=0, Vd=0, i=0, imm3=0, Q=0, D=0, cmode=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_19_e30_f2800011() {
    // Encoding: 0xF2800011
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: A32
    // Fields: imm3=0, Vd=0, imm4=1, D=0, i=0, op=0, cmode=0, Q=0
    let encoding: u32 = 0xF2800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t5a5_a_special_q_0_size_variant_0_3632_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, Q=0, cmode=0, op=0, imm4=0, i=0, D=0, imm3=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_special_q_1_size_variant_1_3632_f2800050() {
    // Encoding: 0xF2800050
    // Test aarch32_VMOV_i_T5A5_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, Q=1, D=0, op=0, imm3=0, cmode=0, i=0, imm4=0
    let encoding: u32 = 0xF2800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t5a5_a_invalid_0_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: i=0, D=0, op=0, imm4=0, imm3=0, cmode=0, Vd=0, Q=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t5a5_a_invalid_1_e30_f2800010() {
    // Encoding: 0xF2800010
    // Test aarch32_VMOV_i_T5A5_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: imm3=0, cmode=0, Vd=0, D=0, Q=0, op=0, imm4=0, i=0
    let encoding: u32 = 0xF2800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for A32 encoding 0x{:08X}", encoding);
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_i_0_min_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field i = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, op=0, D=0, imm3=0, i=0, imm4=0, cmode=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_i_1_max_10_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T1A1_A field i = 1 (Max)
    // ISET: T32
    // Fields: op=0, D=0, cmode=0, imm4=0, Vd=0, imm3=0, Q=0, i=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_d_0_min_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: i=0, Vd=0, D=0, op=0, Q=0, imm4=0, cmode=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_d_1_max_10_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, imm3=0, i=0, op=0, Q=0, Vd=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_0_zero_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: cmode=0, imm4=0, Vd=0, imm3=0, i=0, D=0, op=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_1_poweroftwo_10_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=1, op=0, D=0, cmode=0, Q=0, imm4=0, Vd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_3_poweroftwominusone_10_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Q=0, i=0, Vd=0, op=0, cmode=0, D=0, imm3=3, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm3_7_max_10_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T1A1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm3=7, imm4=0, i=0, Q=0, D=0, cmode=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_vd_0_min_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: op=0, D=0, Q=0, Vd=0, cmode=0, i=0, imm4=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_vd_1_poweroftwo_10_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: cmode=0, D=0, imm3=0, i=0, op=0, Vd=1, Q=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_0_min_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field cmode = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Q=0, op=0, i=0, imm3=0, D=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_1_poweroftwo_10_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T1A1_A field cmode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, imm3=0, D=0, cmode=1, imm4=0, Vd=0, op=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_7_poweroftwominusone_10_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T1A1_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Q=0, imm3=0, i=0, cmode=7, Vd=0, op=0, imm4=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_cmode_15_max_10_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T1A1_A field cmode = 15 (Max)
    // ISET: T32
    // Fields: Q=0, i=0, Vd=0, cmode=15, D=0, imm3=0, imm4=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_q_0_min_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: op=0, cmode=0, Vd=0, imm4=0, D=0, Q=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_q_1_max_10_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T1A1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, imm3=0, i=0, Vd=0, op=0, imm4=0, cmode=0, Q=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_op_0_min_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field op = 0 (Min)
    // ISET: T32
    // Fields: D=0, cmode=0, imm4=0, Q=0, i=0, Vd=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_op_1_max_10_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T1A1_A field op = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, cmode=0, op=1, i=0, Q=0, D=0, imm3=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_0_zero_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: imm4=0, imm3=0, D=0, cmode=0, Q=0, op=0, i=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_1_poweroftwo_10_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, op=0, i=0, Vd=0, cmode=0, D=0, Q=0, imm4=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_3_poweroftwominusone_10_ef800013() {
    // Thumb encoding (32): 0xEF800013
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: op=0, cmode=0, i=0, D=0, Vd=0, Q=0, imm4=3, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800013;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_4_poweroftwo_10_ef800014() {
    // Thumb encoding (32): 0xEF800014
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, cmode=0, D=0, Q=0, imm4=4, imm3=0, i=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800014;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_7_poweroftwominusone_10_ef800017() {
    // Thumb encoding (32): 0xEF800017
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, imm4=7, Q=0, cmode=0, i=0, op=0, D=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800017;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_8_poweroftwo_10_ef800018() {
    // Thumb encoding (32): 0xEF800018
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, D=0, cmode=0, i=0, Q=0, op=0, Vd=0, imm4=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800018;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t1a1_a_field_imm4_15_max_10_ef80001f() {
    // Thumb encoding (32): 0xEF80001F
    // Test aarch32_VMOV_i_T1A1_A field imm4 = 15 (Max)
    // ISET: T32
    // Fields: imm4=15, Q=0, Vd=0, i=0, cmode=0, D=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF80001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_0_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=0, imm3=0, imm4=0, Q=0, D=0, i=0, cmode=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_1_10_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, imm4=0, D=0, i=1, cmode=0, op=0, Vd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_2_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, cmode=0, op=0, imm4=0, D=0, Q=0, i=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_3_10_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, cmode=0, imm4=0, op=0, imm3=0, D=1, Q=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_4_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, op=0, i=0, Vd=0, D=0, imm3=0, cmode=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_5_10_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, cmode=0, imm4=0, imm3=1, Q=0, Vd=0, i=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_6_10_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=3, Q=0, cmode=0, imm4=0, D=0, Vd=0, op=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_7_10_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=0, imm3=7, Vd=0, op=0, Q=0, i=0, D=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_8_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, i=0, D=0, imm3=0, Vd=0, cmode=0, op=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_9_10_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, Q=0, Vd=1, imm3=0, op=0, D=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_10_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, op=0, cmode=0, Vd=0, Q=0, imm4=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_11_10_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=1, D=0, i=0, Q=0, Vd=0, op=0, imm3=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_12_10_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, i=0, op=0, imm4=0, Vd=0, imm3=0, cmode=7, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_13_10_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, Q=0, op=0, Vd=0, imm3=0, imm4=0, D=0, cmode=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_14_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, Vd=0, i=0, imm3=0, Q=0, op=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_15_10_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, cmode=0, op=0, Q=1, Vd=0, i=0, D=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_16_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: op=0, Vd=0, D=0, imm4=0, imm3=0, i=0, Q=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_17_10_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: T32
    // Fields: i=0, Vd=0, op=1, D=0, imm3=0, cmode=0, imm4=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_18_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, D=0, op=0, Q=0, Vd=0, imm3=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t1a1_a_combo_19_10_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T1A1_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: T32
    // Fields: imm4=1, imm3=0, Vd=0, Q=0, cmode=0, op=0, D=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t1a1_a_special_q_0_size_variant_0_16_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: cmode=0, Q=0, D=0, i=0, Vd=0, op=0, imm4=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t1a1_a_special_q_1_size_variant_1_16_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T1A1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: cmode=0, i=0, imm4=0, op=0, Q=1, imm3=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t1a1_a_invalid_0_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: cmode=0, Q=0, imm3=0, imm4=0, Vd=0, op=0, i=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t1a1_a_invalid_1_10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: op=0, i=0, D=0, imm3=0, cmode=0, Vd=0, imm4=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t2_a_field_d_0_min_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field D = 0 (Min)
    // ISET: T32
    // Fields: imm4H=0, size=0, Vd=0, imm4L=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t2_a_field_d_1_max_800_eef00800() {
    // Thumb encoding (32): 0xEEF00800
    // Test aarch32_VMOV_i_T2_A field D = 1 (Max)
    // ISET: T32
    // Fields: imm4H=0, D=1, Vd=0, size=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEF00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_0_zero_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field imm4H = 0 (Zero)
    // ISET: T32
    // Fields: imm4H=0, Vd=0, size=0, D=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_1_poweroftwo_800_eeb10800() {
    // Thumb encoding (32): 0xEEB10800
    // Test aarch32_VMOV_i_T2_A field imm4H = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4L=0, size=0, Vd=0, D=0, imm4H=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB10800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_3_poweroftwominusone_800_eeb30800() {
    // Thumb encoding (32): 0xEEB30800
    // Test aarch32_VMOV_i_T2_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, imm4L=0, D=0, size=0, imm4H=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB30800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_4_poweroftwo_800_eeb40800() {
    // Thumb encoding (32): 0xEEB40800
    // Test aarch32_VMOV_i_T2_A field imm4H = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4L=0, size=0, D=0, imm4H=4, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB40800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_7_poweroftwominusone_800_eeb70800() {
    // Thumb encoding (32): 0xEEB70800
    // Test aarch32_VMOV_i_T2_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, size=0, imm4L=0, D=0, imm4H=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB70800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_8_poweroftwo_800_eeb80800() {
    // Thumb encoding (32): 0xEEB80800
    // Test aarch32_VMOV_i_T2_A field imm4H = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, imm4L=0, imm4H=8, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB80800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4H 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4h_15_max_800_eebf0800() {
    // Thumb encoding (32): 0xEEBF0800
    // Test aarch32_VMOV_i_T2_A field imm4H = 15 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, imm4H=15, size=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEBF0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t2_a_field_vd_0_min_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: imm4H=0, imm4L=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t2_a_field_vd_1_poweroftwo_800_eeb01800() {
    // Thumb encoding (32): 0xEEB01800
    // Test aarch32_VMOV_i_T2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, size=0, imm4H=0, D=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB01800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t2_a_field_size_0_min_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, imm4L=0, imm4H=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t2_a_field_size_1_poweroftwo_800_eeb00900() {
    // Thumb encoding (32): 0xEEB00900
    // Test aarch32_VMOV_i_T2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4H=0, Vd=0, imm4L=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmov_i_t2_a_field_size_2_poweroftwo_800_eeb00a00() {
    // Thumb encoding (32): 0xEEB00A00
    // Test aarch32_VMOV_i_T2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, imm4L=0, size=2, D=0, imm4H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmov_i_t2_a_field_size_3_max_800_eeb00b00() {
    // Thumb encoding (32): 0xEEB00B00
    // Test aarch32_VMOV_i_T2_A field size = 3 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, imm4H=0, imm4L=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_0_zero_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field imm4L = 0 (Zero)
    // ISET: T32
    // Fields: imm4H=0, Vd=0, D=0, imm4L=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_1_poweroftwo_800_eeb00801() {
    // Thumb encoding (32): 0xEEB00801
    // Test aarch32_VMOV_i_T2_A field imm4L = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4H=0, size=0, imm4L=1, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_3_poweroftwominusone_800_eeb00803() {
    // Thumb encoding (32): 0xEEB00803
    // Test aarch32_VMOV_i_T2_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: size=0, imm4L=3, Vd=0, imm4H=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_4_poweroftwo_800_eeb00804() {
    // Thumb encoding (32): 0xEEB00804
    // Test aarch32_VMOV_i_T2_A field imm4L = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, imm4L=4, Vd=0, imm4H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_7_poweroftwominusone_800_eeb00807() {
    // Thumb encoding (32): 0xEEB00807
    // Test aarch32_VMOV_i_T2_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: size=0, Vd=0, imm4L=7, imm4H=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_8_poweroftwo_800_eeb00808() {
    // Thumb encoding (32): 0xEEB00808
    // Test aarch32_VMOV_i_T2_A field imm4L = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, imm4L=8, imm4H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t2_a_field_imm4l_15_max_800_eeb0080f() {
    // Thumb encoding (32): 0xEEB0080F
    // Test aarch32_VMOV_i_T2_A field imm4L = 15 (Max)
    // ISET: T32
    // Fields: Vd=0, imm4H=0, size=0, imm4L=15, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB0080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_0_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: Vd=0, imm4L=0, size=0, D=0, imm4H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_1_800_eef00800() {
    // Thumb encoding (32): 0xEEF00800
    // Test aarch32_VMOV_i_T2_A field combination: D=1, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: imm4H=0, imm4L=0, D=1, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEF00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_2_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: D=0, Vd=0, imm4H=0, size=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_3_800_eeb10800() {
    // Thumb encoding (32): 0xEEB10800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=1, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, imm4L=0, imm4H=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB10800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_4_800_eeb30800() {
    // Thumb encoding (32): 0xEEB30800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=3, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: Vd=0, imm4H=3, D=0, size=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB30800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_5_800_eeb40800() {
    // Thumb encoding (32): 0xEEB40800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=4, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, imm4L=0, imm4H=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB40800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=7 (immediate midpoint (7))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_6_800_eeb70800() {
    // Thumb encoding (32): 0xEEB70800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=7, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, imm4H=7, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB70800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_7_800_eeb80800() {
    // Thumb encoding (32): 0xEEB80800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=8, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: imm4H=8, Vd=0, size=0, D=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB80800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4H=15 (maximum immediate (15))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_8_800_eebf0800() {
    // Thumb encoding (32): 0xEEBF0800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=15, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: imm4L=0, D=0, imm4H=15, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEBF0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_9_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: imm4H=0, size=0, D=0, Vd=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_10_800_eeb01800() {
    // Thumb encoding (32): 0xEEB01800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=1, size=0, imm4L=0
    // ISET: T32
    // Fields: imm4L=0, imm4H=0, Vd=1, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB01800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_11_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: imm4L=0, imm4H=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_12_800_eeb00900() {
    // Thumb encoding (32): 0xEEB00900
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=1, imm4L=0
    // ISET: T32
    // Fields: D=0, size=1, imm4L=0, imm4H=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_13_800_eeb00a00() {
    // Thumb encoding (32): 0xEEB00A00
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=2, imm4L=0
    // ISET: T32
    // Fields: D=0, imm4H=0, Vd=0, size=2, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_14_800_eeb00b00() {
    // Thumb encoding (32): 0xEEB00B00
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=3, imm4L=0
    // ISET: T32
    // Fields: D=0, size=3, imm4L=0, imm4H=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4L=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_15_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=0
    // ISET: T32
    // Fields: D=0, Vd=0, imm4L=0, imm4H=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4L=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_16_800_eeb00801() {
    // Thumb encoding (32): 0xEEB00801
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=1
    // ISET: T32
    // Fields: imm4H=0, D=0, Vd=0, size=0, imm4L=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4L=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_vmov_i_t2_a_combo_17_800_eeb00803() {
    // Thumb encoding (32): 0xEEB00803
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=3
    // ISET: T32
    // Fields: size=0, imm4H=0, Vd=0, imm4L=3, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4L=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_18_800_eeb00804() {
    // Thumb encoding (32): 0xEEB00804
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=4
    // ISET: T32
    // Fields: D=0, imm4L=4, Vd=0, imm4H=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4L=7 (immediate midpoint (7))
#[test]
fn test_aarch32_vmov_i_t2_a_combo_19_800_eeb00807() {
    // Thumb encoding (32): 0xEEB00807
    // Test aarch32_VMOV_i_T2_A field combination: D=0, imm4H=0, Vd=0, size=0, imm4L=7
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, imm4H=0, imm4L=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t2_a_special_size_0_size_variant_0_2048_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, imm4L=0, Vd=0, imm4H=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t2_a_special_size_1_size_variant_1_2048_eeb00900() {
    // Thumb encoding (32): 0xEEB00900
    // Test aarch32_VMOV_i_T2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, size=1, Vd=0, imm4H=0, imm4L=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmov_i_t2_a_special_size_2_size_variant_2_2048_eeb00a00() {
    // Thumb encoding (32): 0xEEB00A00
    // Test aarch32_VMOV_i_T2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, imm4H=0, imm4L=0, D=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmov_i_t2_a_special_size_3_size_variant_3_2048_eeb00b00() {
    // Thumb encoding (32): 0xEEB00B00
    // Test aarch32_VMOV_i_T2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: D=0, size=3, imm4L=0, Vd=0, imm4H=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t2_a_invalid_0_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: D=0, size=0, imm4L=0, imm4H=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t2_a_invalid_1_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, D=0, imm4H=0, imm4L=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t2_a_invalid_2_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: imm4H=0, D=0, Vd=0, imm4L=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t2_a_invalid_3_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm4L=0, D=0, imm4H=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_i_t2_a_invalid_4_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: imm4H=0, Vd=0, D=0, imm4L=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmov_i_t2_a_invalid_5_800_eeb00800() {
    // Thumb encoding (32): 0xEEB00800
    // Test aarch32_VMOV_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm4L=0, D=0, Vd=0, imm4H=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEEB00800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_i_0_min_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field i = 0 (Min)
    // ISET: T32
    // Fields: op=0, Q=0, cmode=0, D=0, i=0, imm3=0, Vd=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_i_1_max_810_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T3A3_A field i = 1 (Max)
    // ISET: T32
    // Fields: D=0, Q=0, op=0, imm3=0, cmode=0, imm4=0, Vd=0, i=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_d_0_min_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field D = 0 (Min)
    // ISET: T32
    // Fields: Q=0, op=0, i=0, D=0, imm4=0, imm3=0, Vd=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_d_1_max_810_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T3A3_A field D = 1 (Max)
    // ISET: T32
    // Fields: op=0, imm3=0, D=1, i=0, Q=0, Vd=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_0_zero_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: cmode=0, D=0, Vd=0, Q=0, imm3=0, imm4=0, i=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_1_poweroftwo_810_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, cmode=0, D=0, op=0, imm3=1, imm4=0, i=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_3_poweroftwominusone_810_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Vd=0, Q=0, cmode=0, i=0, D=0, imm4=0, op=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm3_7_max_810_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T3A3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: D=0, Q=0, op=0, Vd=0, imm4=0, cmode=0, i=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_vd_0_min_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, imm4=0, imm3=0, op=0, cmode=0, Q=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_vd_1_poweroftwo_810_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T3A3_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Vd=1, cmode=0, Q=0, D=0, imm4=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_0_min_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field cmode = 0 (Min)
    // ISET: T32
    // Fields: Q=0, i=0, D=0, imm4=0, Vd=0, imm3=0, cmode=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_1_poweroftwo_810_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T3A3_A field cmode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, op=0, D=0, imm3=0, cmode=1, Q=0, imm4=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_7_poweroftwominusone_810_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T3A3_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, Vd=0, imm3=0, imm4=0, Q=0, i=0, op=0, cmode=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_cmode_15_max_810_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T3A3_A field cmode = 15 (Max)
    // ISET: T32
    // Fields: Vd=0, D=0, cmode=15, Q=0, imm4=0, imm3=0, op=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_q_0_min_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Q=0, D=0, op=0, imm3=0, Vd=0, cmode=0, imm4=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_q_1_max_810_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T3A3_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, cmode=0, imm4=0, imm3=0, i=0, Q=1, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_op_0_min_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field op = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Q=0, imm3=0, D=0, op=0, cmode=0, i=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_op_1_max_810_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T3A3_A field op = 1 (Max)
    // ISET: T32
    // Fields: D=0, Q=0, Vd=0, cmode=0, imm4=0, imm3=0, op=1, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_0_zero_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: D=0, imm4=0, op=0, imm3=0, Vd=0, Q=0, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_1_poweroftwo_810_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=1, Vd=0, Q=0, imm3=0, i=0, D=0, cmode=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_3_poweroftwominusone_810_ef800013() {
    // Thumb encoding (32): 0xEF800013
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=3, i=0, cmode=0, Q=0, imm3=0, Vd=0, op=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800013;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_4_poweroftwo_810_ef800014() {
    // Thumb encoding (32): 0xEF800014
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, cmode=0, imm4=4, D=0, i=0, imm3=0, Q=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800014;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_7_poweroftwominusone_810_ef800017() {
    // Thumb encoding (32): 0xEF800017
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: D=0, op=0, i=0, Vd=0, imm3=0, Q=0, imm4=7, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800017;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_8_poweroftwo_810_ef800018() {
    // Thumb encoding (32): 0xEF800018
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: cmode=0, op=0, i=0, Q=0, imm4=8, imm3=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800018;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t3a3_a_field_imm4_15_max_810_ef80001f() {
    // Thumb encoding (32): 0xEF80001F
    // Test aarch32_VMOV_i_T3A3_A field imm4 = 15 (Max)
    // ISET: T32
    // Fields: i=0, Q=0, D=0, Vd=0, cmode=0, imm3=0, op=0, imm4=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF80001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_0_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, Vd=0, D=0, Q=0, imm4=0, op=0, cmode=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_1_810_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=0, op=0, D=0, cmode=0, i=1, imm4=0, Q=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_2_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, i=0, imm4=0, Vd=0, cmode=0, Q=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_3_810_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, cmode=0, Q=0, imm4=0, Vd=0, op=0, D=1, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_4_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=0, op=0, D=0, Q=0, imm4=0, imm3=0, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_5_810_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, Vd=0, Q=0, imm3=1, imm4=0, op=0, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_6_810_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, Vd=0, D=0, imm3=3, cmode=0, imm4=0, Q=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_7_810_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, imm3=7, Vd=0, Q=0, op=0, D=0, cmode=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_8_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=0, Q=0, i=0, imm4=0, D=0, cmode=0, imm3=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_9_810_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=1, cmode=0, i=0, D=0, imm3=0, imm4=0, Q=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_10_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, Q=0, imm3=0, D=0, i=0, Vd=0, cmode=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_11_810_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, op=0, Vd=0, i=0, imm3=0, cmode=1, imm4=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_12_810_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, Vd=0, Q=0, imm3=0, cmode=7, imm4=0, op=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_13_810_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, imm3=0, cmode=15, D=0, Q=0, i=0, op=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_14_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, Q=0, imm4=0, op=0, i=0, cmode=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_15_810_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, op=0, D=0, imm3=0, Q=1, cmode=0, Vd=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_16_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, op=0, Vd=0, D=0, imm4=0, imm3=0, cmode=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_17_810_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: T32
    // Fields: Q=0, i=0, cmode=0, D=0, imm3=0, imm4=0, op=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_18_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: op=0, cmode=0, Q=0, imm3=0, Vd=0, imm4=0, D=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t3a3_a_combo_19_810_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T3A3_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: T32
    // Fields: D=0, cmode=0, Vd=0, imm4=1, Q=0, op=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t3a3_a_special_q_0_size_variant_0_2064_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Vd=0, Q=0, i=0, imm3=0, imm4=0, cmode=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t3a3_a_special_q_1_size_variant_1_2064_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T3A3_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm4=0, op=0, imm3=0, Vd=0, D=0, cmode=0, Q=1, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t3a3_a_invalid_0_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: imm4=0, op=0, cmode=0, Q=0, D=0, imm3=0, Vd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t3a3_a_invalid_1_810_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T3A3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm4=0, D=0, i=0, op=0, Q=0, imm3=0, cmode=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_i_0_min_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field i = 0 (Min)
    // ISET: T32
    // Fields: cmode=0, i=0, Vd=0, D=0, imm3=0, Q=0, op=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_i_1_max_c10_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T4A4_A field i = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, D=0, cmode=0, imm4=0, i=1, Q=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_d_0_min_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field D = 0 (Min)
    // ISET: T32
    // Fields: Q=0, cmode=0, i=0, Vd=0, imm4=0, op=0, D=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_d_1_max_c10_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T4A4_A field D = 1 (Max)
    // ISET: T32
    // Fields: op=0, cmode=0, i=0, imm3=0, Vd=0, Q=0, imm4=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_0_zero_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, op=0, Vd=0, cmode=0, imm4=0, i=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_1_poweroftwo_c10_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, Q=0, Vd=0, i=0, cmode=0, op=0, imm3=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_3_poweroftwominusone_c10_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: op=0, imm3=3, cmode=0, Q=0, Vd=0, i=0, D=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm3_7_max_c10_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T4A4_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, op=0, imm3=7, Q=0, Vd=0, D=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_vd_0_min_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: i=0, Vd=0, Q=0, imm3=0, cmode=0, imm4=0, D=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_vd_1_poweroftwo_c10_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T4A4_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, cmode=0, Q=0, Vd=1, imm3=0, op=0, i=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_0_min_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field cmode = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm3=0, Vd=0, cmode=0, op=0, imm4=0, Q=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_1_poweroftwo_c10_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T4A4_A field cmode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, cmode=1, i=0, imm4=0, D=0, imm3=0, op=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_7_poweroftwominusone_c10_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T4A4_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm4=0, imm3=0, cmode=7, D=0, Vd=0, Q=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_cmode_15_max_c10_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T4A4_A field cmode = 15 (Max)
    // ISET: T32
    // Fields: imm4=0, imm3=0, op=0, D=0, Vd=0, cmode=15, Q=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_q_0_min_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field Q = 0 (Min)
    // ISET: T32
    // Fields: cmode=0, D=0, imm3=0, imm4=0, Q=0, Vd=0, op=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_q_1_max_c10_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T4A4_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, i=0, imm4=0, cmode=0, imm3=0, Q=1, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_op_0_min_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field op = 0 (Min)
    // ISET: T32
    // Fields: i=0, Q=0, imm4=0, Vd=0, op=0, imm3=0, cmode=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_op_1_max_c10_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T4A4_A field op = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, Q=0, imm4=0, Vd=0, i=0, cmode=0, D=0, op=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_0_zero_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: imm4=0, D=0, Vd=0, op=0, Q=0, imm3=0, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_1_poweroftwo_c10_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, op=0, cmode=0, D=0, Vd=0, Q=0, imm4=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_3_poweroftwominusone_c10_ef800013() {
    // Thumb encoding (32): 0xEF800013
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Q=0, imm3=0, D=0, Vd=0, op=0, imm4=3, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800013;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_4_poweroftwo_c10_ef800014() {
    // Thumb encoding (32): 0xEF800014
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm4=4, Vd=0, cmode=0, i=0, D=0, Q=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800014;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_7_poweroftwominusone_c10_ef800017() {
    // Thumb encoding (32): 0xEF800017
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=7, Vd=0, op=0, Q=0, D=0, imm3=0, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800017;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_8_poweroftwo_c10_ef800018() {
    // Thumb encoding (32): 0xEF800018
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, op=0, imm3=0, i=0, Vd=0, imm4=8, Q=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800018;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t4a4_a_field_imm4_15_max_c10_ef80001f() {
    // Thumb encoding (32): 0xEF80001F
    // Test aarch32_VMOV_i_T4A4_A field imm4 = 15 (Max)
    // ISET: T32
    // Fields: Vd=0, Q=0, op=0, D=0, imm3=0, imm4=15, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF80001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_0_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, D=0, imm3=0, cmode=0, Vd=0, op=0, Q=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_1_c10_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, Vd=0, imm3=0, D=0, cmode=0, i=1, imm4=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_2_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, Vd=0, D=0, imm3=0, i=0, cmode=0, op=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_3_c10_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, cmode=0, imm3=0, Vd=0, D=1, Q=0, op=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_4_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, i=0, D=0, Vd=0, Q=0, op=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_5_c10_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, op=0, Vd=0, cmode=0, imm4=0, D=0, imm3=1, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_6_c10_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, Vd=0, op=0, imm3=3, cmode=0, Q=0, imm4=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_7_c10_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: op=0, imm3=7, cmode=0, i=0, Q=0, imm4=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_8_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, op=0, Q=0, D=0, Vd=0, cmode=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_9_c10_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, Vd=1, imm3=0, imm4=0, op=0, i=0, cmode=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_10_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, Q=0, Vd=0, cmode=0, op=0, D=0, i=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_11_c10_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, Vd=0, op=0, cmode=1, imm4=0, D=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_12_c10_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, cmode=7, i=0, Vd=0, imm3=0, D=0, op=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_13_c10_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: op=0, Q=0, D=0, imm3=0, Vd=0, cmode=15, imm4=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_14_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=0, Q=0, Vd=0, op=0, i=0, imm4=0, D=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_15_c10_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: T32
    // Fields: Q=1, i=0, imm3=0, D=0, Vd=0, op=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_16_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=0, i=0, op=0, imm4=0, Vd=0, imm3=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_17_c10_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: T32
    // Fields: imm3=0, i=0, op=1, cmode=0, imm4=0, Vd=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_18_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, Q=0, cmode=0, i=0, D=0, Vd=0, op=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t4a4_a_combo_19_c10_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T4A4_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: T32
    // Fields: Q=0, imm3=0, D=0, op=0, Vd=0, cmode=0, i=0, imm4=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t4a4_a_special_q_0_size_variant_0_3088_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: Q=0, imm3=0, cmode=0, i=0, Vd=0, D=0, imm4=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t4a4_a_special_q_1_size_variant_1_3088_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T4A4_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: op=0, Vd=0, imm3=0, Q=1, D=0, imm4=0, i=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t4a4_a_invalid_0_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, op=0, Q=0, imm4=0, Vd=0, i=0, imm3=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t4a4_a_invalid_1_c10_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T4A4_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm4=0, i=0, Vd=0, Q=0, D=0, imm3=0, cmode=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_i_0_min_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field i = 0 (Min)
    // ISET: T32
    // Fields: i=0, Q=0, Vd=0, imm4=0, D=0, imm3=0, op=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field i 28 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_i_1_max_e30_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T5A5_A field i = 1 (Max)
    // ISET: T32
    // Fields: op=0, i=1, Vd=0, imm3=0, imm4=0, cmode=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_d_0_min_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field D = 0 (Min)
    // ISET: T32
    // Fields: Q=0, op=0, imm4=0, cmode=0, i=0, Vd=0, imm3=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_d_1_max_e30_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T5A5_A field D = 1 (Max)
    // ISET: T32
    // Fields: i=0, D=1, imm4=0, imm3=0, Vd=0, Q=0, op=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_0_zero_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: op=0, D=0, cmode=0, Q=0, imm4=0, i=0, Vd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_1_poweroftwo_e30_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, imm3=1, Q=0, cmode=0, op=0, imm4=0, D=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_3_poweroftwominusone_e30_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=3, D=0, Vd=0, cmode=0, Q=0, imm4=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm3_7_max_e30_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T5A5_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm4=0, D=0, i=0, Vd=0, Q=0, cmode=0, imm3=7, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_vd_0_min_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Q=0, D=0, op=0, cmode=0, imm4=0, imm3=0, Vd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_vd_1_poweroftwo_e30_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T5A5_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm3=0, i=0, Q=0, cmode=0, Vd=1, D=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_0_min_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field cmode = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vd=0, imm3=0, imm4=0, D=0, cmode=0, Q=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_1_poweroftwo_e30_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T5A5_A field cmode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, imm3=0, i=0, imm4=0, Vd=0, op=0, cmode=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_7_poweroftwominusone_e30_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T5A5_A field cmode = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Vd=0, imm4=0, op=0, imm3=0, D=0, cmode=7, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field cmode 8 +: 4`
/// Requirement: FieldBoundary { field: "cmode", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_cmode_15_max_e30_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T5A5_A field cmode = 15 (Max)
    // ISET: T32
    // Fields: i=0, op=0, Vd=0, Q=0, D=0, imm3=0, imm4=0, cmode=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_q_0_min_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Q=0, D=0, i=0, imm4=0, Vd=0, op=0, cmode=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_q_1_max_e30_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T5A5_A field Q = 1 (Max)
    // ISET: T32
    // Fields: op=0, D=0, imm4=0, imm3=0, cmode=0, i=0, Vd=0, Q=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_op_0_min_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field op = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm3=0, op=0, cmode=0, Q=0, D=0, imm4=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field op 5 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_op_1_max_e30_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T5A5_A field op = 1 (Max)
    // ISET: T32
    // Fields: D=0, imm4=0, Vd=0, cmode=0, op=1, Q=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_0_zero_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: D=0, imm3=0, imm4=0, op=0, i=0, Vd=0, cmode=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_1_poweroftwo_e30_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, D=0, imm4=1, cmode=0, Vd=0, Q=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_3_poweroftwominusone_e30_ef800013() {
    // Thumb encoding (32): 0xEF800013
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: cmode=0, imm4=3, op=0, i=0, Q=0, Vd=0, imm3=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800013;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_4_poweroftwo_e30_ef800014() {
    // Thumb encoding (32): 0xEF800014
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, cmode=0, Q=0, D=0, imm4=4, Vd=0, op=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800014;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_7_poweroftwominusone_e30_ef800017() {
    // Thumb encoding (32): 0xEF800017
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: op=0, D=0, imm3=0, i=0, Vd=0, Q=0, imm4=7, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800017;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_8_poweroftwo_e30_ef800018() {
    // Thumb encoding (32): 0xEF800018
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, imm4=8, cmode=0, op=0, D=0, imm3=0, i=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800018;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_vmov_i_t5a5_a_field_imm4_15_max_e30_ef80001f() {
    // Thumb encoding (32): 0xEF80001F
    // Test aarch32_VMOV_i_T5A5_A field imm4 = 15 (Max)
    // ISET: T32
    // Fields: op=0, imm4=15, D=0, imm3=0, Vd=0, Q=0, cmode=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF80001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_0_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, op=0, i=0, Vd=0, D=0, imm3=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_1_e30_ff800010() {
    // Thumb encoding (32): 0xFF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=1, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm4=0, cmode=0, i=1, Q=0, Vd=0, D=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_2_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=0, Q=0, imm4=0, cmode=0, Vd=0, D=0, i=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_3_e30_efc00010() {
    // Thumb encoding (32): 0xEFC00010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=1, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: op=0, D=1, imm4=0, cmode=0, Q=0, i=0, Vd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_4_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=0, cmode=0, D=0, imm4=0, op=0, imm3=0, i=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_5_e30_ef810010() {
    // Thumb encoding (32): 0xEF810010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=1, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=0, D=0, Vd=0, op=0, imm3=1, imm4=0, i=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_6_e30_ef830010() {
    // Thumb encoding (32): 0xEF830010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=3, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, cmode=0, imm4=0, Q=0, D=0, op=0, Vd=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF830010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_7_e30_ef870010() {
    // Thumb encoding (32): 0xEF870010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=7, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: imm3=7, D=0, i=0, Vd=0, Q=0, op=0, imm4=0, cmode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF870010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_8_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Q=0, imm3=0, cmode=0, i=0, Vd=0, op=0, imm4=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_9_e30_ef801010() {
    // Thumb encoding (32): 0xEF801010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=1, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: Vd=1, op=0, Q=0, D=0, cmode=0, imm3=0, i=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_10_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=0, imm4=0, i=0, Vd=0, D=0, op=0, Q=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=1 (value 1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_11_e30_ef800110() {
    // Thumb encoding (32): 0xEF800110
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=1, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=1, imm4=0, Vd=0, imm3=0, Q=0, D=0, op=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=7 (midpoint (7))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_12_e30_ef800710() {
    // Thumb encoding (32): 0xEF800710
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=7, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: op=0, Vd=0, D=0, imm3=0, imm4=0, Q=0, i=0, cmode=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800710;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cmode=15 (maximum value (15))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_13_e30_ef800f10() {
    // Thumb encoding (32): 0xEF800F10
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=15, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, op=0, imm3=0, Vd=0, Q=0, D=0, imm4=0, cmode=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800F10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_14_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: D=0, cmode=0, Vd=0, imm4=0, Q=0, imm3=0, i=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_15_e30_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=1, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, D=0, Vd=0, cmode=0, Q=1, imm4=0, op=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_16_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: i=0, imm4=0, Q=0, op=0, imm3=0, cmode=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_17_e30_ef800030() {
    // Thumb encoding (32): 0xEF800030
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=1, imm4=0
    // ISET: T32
    // Fields: D=0, op=1, imm3=0, Vd=0, i=0, cmode=0, Q=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_18_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=0
    // ISET: T32
    // Fields: cmode=0, Q=0, Vd=0, imm4=0, D=0, imm3=0, i=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_aarch32_vmov_i_t5a5_a_combo_19_e30_ef800011() {
    // Thumb encoding (32): 0xEF800011
    // Test aarch32_VMOV_i_T5A5_A field combination: i=0, D=0, imm3=0, Vd=0, cmode=0, Q=0, op=0, imm4=1
    // ISET: T32
    // Fields: D=0, imm3=0, i=0, op=0, imm4=1, Vd=0, cmode=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmov_i_t5a5_a_special_q_0_size_variant_0_3632_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, i=0, imm3=0, cmode=0, op=0, imm4=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmov_i_t5a5_a_special_q_1_size_variant_1_3632_ef800050() {
    // Thumb encoding (32): 0xEF800050
    // Test aarch32_VMOV_i_T5A5_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: op=0, D=0, i=0, imm4=0, imm3=0, Q=1, cmode=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t5a5_a_invalid_0_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: i=0, cmode=0, Q=0, imm4=0, D=0, imm3=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmov_i_t5a5_a_invalid_1_e30_ef800010() {
    // Thumb encoding (32): 0xEF800010
    // Test aarch32_VMOV_i_T5A5_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm3=0, imm4=0, op=0, Q=0, i=0, D=0, cmode=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_0_f2802830() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802830
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802830;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x5A, "X16 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_0_f2802830() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802830
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802830;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x5A, "X16 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_1_f2800030() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x0, "X16 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_1_f2800030() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x0, "X16 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_2_f2800430() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x0, "X16 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_2_f2800430() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x0, "X16 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_3_f2bffc30() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_3_f2bffc30() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_4_f2fffc30() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_4_f2fffc30() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_5_f2800430() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_5_f2800430() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_6_f2800430() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFF, "X16 should be 0xFFFFFFFFFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_6_f2800430() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFF, "X16 should be 0xFFFFFFFFFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_7_f2800430() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_7_f2800430() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0x7FFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_8_f2800430() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x7FFFFFFE, "X16 should be 0x000000007FFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_8_f2800430() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x7FFFFFFE, "X16 should be 0x000000007FFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_9_f2800430() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_9_f2800430() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_10_f2800430() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_10_f2800430() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800430
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800430;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_32_rd31_sp_f280283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmov_i_t1a1_a_add_oracle_64_rd31_sp_f280283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMOV_i_T1A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t1a1_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_0_f2802830() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802830
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802830;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x5A, "X16 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_0_f2802830() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802830
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802830;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x5A, "X16 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_1_f2800830() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800830
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800830;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_1_f2800830() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800830
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800830;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_2_f2800c30() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_2_f2800c30() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_3_f2bffc30() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_3_f2bffc30() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_4_f2fffc30() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_4_f2fffc30() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_5_f2800c30() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_5_f2800c30() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0xFFFFFFFFFFFFFFFC");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_6_f2800c30() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_6_f2800c30() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_7_f2800c30() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_7_f2800c30() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x7FFFFFFFFFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_8_f2800c30() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x7FFFFFFC, "X16 should be 0x000000007FFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_8_f2800c30() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x7FFFFFFC, "X16 should be 0x000000007FFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_9_f2800c30() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_9_f2800c30() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0xFFFFFFFFFFFFFFFC");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_10_f2800c30() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_10_f2800c30() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_32_rd31_sp_f280283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmov_i_t3a3_a_add_oracle_64_rd31_sp_f280283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMOV_i_T3A3_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t3a3_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_0_f2802c30() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x59, "X16 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_0_f2802c30() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x59, "X16 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_1_f2800c30() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_1_f2800c30() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_2_f2800c30() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_2_f2800c30() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFE, "X16 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_3_f2bffc30() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_3_f2bffc30() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_4_f2fffc30() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_4_f2fffc30() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_5_f2800c30() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_5_f2800c30() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0xFFFFFFFFFFFFFFFC");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_6_f2800c30() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_6_f2800c30() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_7_f2800c30() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_7_f2800c30() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x7FFFFFFFFFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_8_f2800c30() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x7FFFFFFC, "X16 should be 0x000000007FFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_8_f2800c30() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0x7FFFFFFC, "X16 should be 0x000000007FFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_9_f2800c30() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_9_f2800c30() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0xFFFFFFFFFFFFFFFC");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_10_f2800c30() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_10_f2800c30() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFC, "X16 should be 0x00000000FFFFFFFC");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_32_rd31_sp_f2802c3f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmov_i_t4a4_a_add_oracle_64_rd31_sp_f2802c3f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMOV_i_T4A4_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t4a4_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_0_f2802e30() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFF5, "X16 should be 0xFFFFFFFFFFFFFFF5");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_0_f2802e30() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFF5, "X16 should be 0xFFFFFFFFFFFFFFF5");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_1_f2800e30() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_1_f2800e30() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_2_f2800e30() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_2_f2800e30() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_3_f2bffe30() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_3_f2bffe30() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFF001, "X16 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_4_f2fffe30() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_4_f2fffe30() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFF001000, "X16 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_5_f2800e30() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_5_f2800e30() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_6_f2800e30() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_6_f2800e30() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_7_f2800e30() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_7_f2800e30() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_8_f2800e30() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_8_f2800e30() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_9_f2800e30() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_9_f2800e30() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_10_f2800e30() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_10_f2800e30() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 16), 0xFFFFFFFD, "X16 should be 0xFFFFFFFFFFFFFFFD");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_32_rd31_sp_f2802e3f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802E3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmov_i_t5a5_a_add_oracle_64_rd31_sp_f2802e3f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802E3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMOV_i_T5A5_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmov_i_t5a5_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

