//! A32 simd mul tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_VMLA_i_A Tests
// ============================================================================

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field op 24 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_op_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vn=0, op=0, D=0, Vm=0, size=0, Q=0, M=0, N=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field op 24 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_op_1_max_900_f3000900() {
    // Encoding: 0xF3000900
    // Test aarch32_VMLA_i_T1A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, D=0, Vd=0, size=0, N=0, M=0, Q=0, Vm=0, op=1
    let encoding: u32 = 0xF3000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_d_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, op=0, N=0, Vn=0, M=0, Vm=0, Q=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_d_1_max_900_f2400900() {
    // Encoding: 0xF2400900
    // Test aarch32_VMLA_i_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vm=0, D=1, op=0, Q=0, Vn=0, M=0, N=0, Vd=0
    let encoding: u32 = 0xF2400900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, op=0, M=0, Q=0, N=0, size=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_1_poweroftwo_900_f2100900() {
    // Encoding: 0xF2100900
    // Test aarch32_VMLA_i_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, size=1, Vn=0, Vd=0, D=0, M=0, op=0, N=0, Q=0
    let encoding: u32 = 0xF2100900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_2_poweroftwo_900_f2200900() {
    // Encoding: 0xF2200900
    // Test aarch32_VMLA_i_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Q=0, Vn=0, op=0, N=0, M=0, Vm=0, size=2, D=0
    let encoding: u32 = 0xF2200900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_3_max_900_f2300900() {
    // Encoding: 0xF2300900
    // Test aarch32_VMLA_i_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: N=0, Q=0, size=3, Vd=0, M=0, D=0, Vm=0, Vn=0, op=0
    let encoding: u32 = 0xF2300900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vn_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: M=0, size=0, Vm=0, Q=0, N=0, Vd=0, op=0, Vn=0, D=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vn_1_poweroftwo_900_f2010900() {
    // Encoding: 0xF2010900
    // Test aarch32_VMLA_i_T1A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, Vd=0, Vn=1, size=0, N=0, op=0, Q=0
    let encoding: u32 = 0xF2010900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vd_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, N=0, Vn=0, op=0, D=0, Q=0, size=0, M=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vd_1_poweroftwo_900_f2001900() {
    // Encoding: 0xF2001900
    // Test aarch32_VMLA_i_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, op=0, D=0, Vm=0, N=0, Q=0, Vd=1, M=0, size=0
    let encoding: u32 = 0xF2001900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_n_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, M=0, size=0, N=0, Vm=0, Q=0, Vd=0, op=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_n_1_max_900_f2000980() {
    // Encoding: 0xF2000980
    // Test aarch32_VMLA_i_T1A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, op=0, Vd=0, Vn=0, D=0, Vm=0, Q=0, size=0, M=0
    let encoding: u32 = 0xF2000980;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_q_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: N=0, M=0, Vm=0, D=0, Vn=0, Vd=0, size=0, Q=0, op=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_q_1_max_900_f2000940() {
    // Encoding: 0xF2000940
    // Test aarch32_VMLA_i_T1A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: op=0, size=0, Q=1, Vd=0, Vm=0, Vn=0, N=0, D=0, M=0
    let encoding: u32 = 0xF2000940;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_m_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, N=0, Vn=0, M=0, Q=0, op=0, Vm=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_m_1_max_900_f2000920() {
    // Encoding: 0xF2000920
    // Test aarch32_VMLA_i_T1A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: N=0, Vm=0, Q=0, Vd=0, D=0, op=0, Vn=0, size=0, M=1
    let encoding: u32 = 0xF2000920;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vm_0_min_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: op=0, D=0, Vn=0, M=0, N=0, Q=0, size=0, Vd=0, Vm=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vm_1_poweroftwo_900_f2000901() {
    // Encoding: 0xF2000901
    // Test aarch32_VMLA_i_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, op=0, Vd=0, N=0, Vn=0, size=0, M=0, Vm=1, Q=0
    let encoding: u32 = 0xF2000901;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmla_i_t1a1_a_combo_0_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A field combination: op=0, D=0, size=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Q=0, Vd=0, M=0, D=0, Vm=0, Vn=0, N=0, op=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_0_size_variant_0_2304_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, size=0, M=0, N=0, op=0, Vd=0, Vm=0, Vn=0, Q=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_1_size_variant_1_2304_f2100900() {
    // Encoding: 0xF2100900
    // Test aarch32_VMLA_i_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vn=0, Q=0, op=0, M=0, D=0, size=1, Vd=0, N=0, Vm=0
    let encoding: u32 = 0xF2100900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_2_size_variant_2_2304_f2200900() {
    // Encoding: 0xF2200900
    // Test aarch32_VMLA_i_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, M=0, Q=0, D=0, op=0, Vn=0, size=2, Vm=0, N=0
    let encoding: u32 = 0xF2200900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_3_size_variant_3_2304_f2300900() {
    // Encoding: 0xF2300900
    // Test aarch32_VMLA_i_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, M=0, Vd=0, Q=0, op=0, D=0, Vn=0, N=0, Vm=0
    let encoding: u32 = 0xF2300900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_q_0_size_variant_0_2304_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Q=0, Vn=0, M=0, size=0, op=0, Vd=0, Vm=0, N=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_q_1_size_variant_1_2304_f2000940() {
    // Encoding: 0xF2000940
    // Test aarch32_VMLA_i_T1A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: N=0, Vd=0, M=0, size=0, Vm=0, D=0, Q=1, Vn=0, op=0
    let encoding: u32 = 0xF2000940;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_0_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: A32
    // Fields: D=0, Vd=0, Vm=0, M=0, op=0, Vn=0, N=0, size=0, Q=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_1_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, D=0, size=0, Vm=0, op=0, Vd=0, N=0, Q=0, Vn=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_2_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: Vn=0, Q=0, size=0, Vm=0, op=0, D=0, M=0, Vd=0, N=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_3_900_f2000900() {
    // Encoding: 0xF2000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, N=0, Vm=0, op=0, D=0, size=0, Vd=0, Vn=0, M=0
    let encoding: u32 = 0xF2000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field op 28 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_op_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field op = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, N=0, M=0, Vm=0, Vd=0, Q=0, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field op 28 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_op_1_max_900_ff000900() {
    // Thumb encoding (32): 0xFF000900
    // Test aarch32_VMLA_i_T1A1_A field op = 1 (Max)
    // ISET: T32
    // Fields: M=0, Vm=0, Q=0, D=0, Vd=0, op=1, size=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_d_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, D=0, Q=0, size=0, Vm=0, op=0, N=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_d_1_max_900_ef400900() {
    // Thumb encoding (32): 0xEF400900
    // Test aarch32_VMLA_i_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: op=0, size=0, Vn=0, Q=0, D=1, Vd=0, N=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF400900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, D=0, op=0, size=0, Vn=0, M=0, Vd=0, Q=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_1_poweroftwo_900_ef100900() {
    // Thumb encoding (32): 0xEF100900
    // Test aarch32_VMLA_i_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Vm=0, size=1, D=0, Q=0, N=0, M=0, Vn=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_2_poweroftwo_900_ef200900() {
    // Thumb encoding (32): 0xEF200900
    // Test aarch32_VMLA_i_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, Q=0, size=2, Vd=0, Vn=0, N=0, D=0, M=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_size_3_max_900_ef300900() {
    // Thumb encoding (32): 0xEF300900
    // Test aarch32_VMLA_i_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Vm=0, op=0, Vn=0, M=0, Vd=0, N=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vn_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, op=0, size=0, Vm=0, Vn=0, N=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vn_1_poweroftwo_900_ef010900() {
    // Thumb encoding (32): 0xEF010900
    // Test aarch32_VMLA_i_T1A1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, D=0, size=0, Vd=0, Q=0, Vm=0, N=0, Vn=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF010900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vd_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: op=0, D=0, M=0, N=0, Vn=0, size=0, Vd=0, Q=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vd_1_poweroftwo_900_ef001900() {
    // Thumb encoding (32): 0xEF001900
    // Test aarch32_VMLA_i_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, size=0, N=0, M=0, D=0, Vm=0, op=0, Q=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF001900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_n_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field N = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, N=0, Vn=0, D=0, op=0, M=0, Vm=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_n_1_max_900_ef000980() {
    // Thumb encoding (32): 0xEF000980
    // Test aarch32_VMLA_i_T1A1_A field N = 1 (Max)
    // ISET: T32
    // Fields: size=0, Q=0, Vm=0, N=1, Vd=0, op=0, D=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000980;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_q_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: op=0, D=0, size=0, Vn=0, Vm=0, Q=0, M=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_q_1_max_900_ef000940() {
    // Thumb encoding (32): 0xEF000940
    // Test aarch32_VMLA_i_T1A1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: size=0, M=0, Vd=0, N=0, Q=1, Vm=0, D=0, Vn=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000940;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_m_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, op=0, Vm=0, Q=0, Vd=0, D=0, size=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_m_1_max_900_ef000920() {
    // Thumb encoding (32): 0xEF000920
    // Test aarch32_VMLA_i_T1A1_A field M = 1 (Max)
    // ISET: T32
    // Fields: size=0, Q=0, M=1, Vd=0, D=0, Vm=0, Vn=0, N=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000920;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vm_0_min_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: N=0, op=0, Vm=0, Vn=0, Vd=0, M=0, size=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t1a1_a_field_vm_1_poweroftwo_900_ef000901() {
    // Thumb encoding (32): 0xEF000901
    // Test aarch32_VMLA_i_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, Q=0, M=0, N=0, op=0, Vn=0, D=0, Vm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000901;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmla_i_t1a1_a_combo_0_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A field combination: op=0, D=0, size=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: size=0, M=0, Vn=0, Vm=0, op=0, Vd=0, Q=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_0_size_variant_0_2304_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vn=0, N=0, Vm=0, op=0, D=0, Q=0, size=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_1_size_variant_1_2304_ef100900() {
    // Thumb encoding (32): 0xEF100900
    // Test aarch32_VMLA_i_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: M=0, Vm=0, Vn=0, op=0, size=1, D=0, Vd=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_2_size_variant_2_2304_ef200900() {
    // Thumb encoding (32): 0xEF200900
    // Test aarch32_VMLA_i_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: op=0, Q=0, D=0, Vm=0, Vd=0, M=0, Vn=0, N=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_size_3_size_variant_3_2304_ef300900() {
    // Thumb encoding (32): 0xEF300900
    // Test aarch32_VMLA_i_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, D=0, Vd=0, Q=0, Vm=0, op=0, Vn=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_q_0_size_variant_0_2304_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: op=0, size=0, N=0, D=0, Vm=0, M=0, Vd=0, Vn=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_i_t1a1_a_special_q_1_size_variant_1_2304_ef000940() {
    // Thumb encoding (32): 0xEF000940
    // Test aarch32_VMLA_i_T1A1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: op=0, size=0, N=0, Vn=0, D=0, Vm=0, Vd=0, Q=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000940;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_0_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // ISET: T32
    // Fields: N=0, Q=0, D=0, op=0, Vn=0, Vd=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_1_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: op=0, D=0, Vd=0, M=0, Vn=0, N=0, size=0, Vm=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_2_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Q=0, Vm=0, N=0, Vn=0, M=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t1a1_a_invalid_3_900_ef000900() {
    // Thumb encoding (32): 0xEF000900
    // Test aarch32_VMLA_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: N=0, Q=0, size=0, Vd=0, Vm=0, Vn=0, M=0, op=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_vmla_i_t1a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_vmla_i_t1a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_vmla_i_t1a1_a_t32_oracle_0_ff000900() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xFF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_vmla_i_t1a1_a_t32_oracle_1_ff000900() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_vmla_i_t1a1_a_t32_oracle_2_ff000900() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_VMLA_i_T1A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_vmla_i_t1a1_a_t32_oracle_3_ff000900() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xFF000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

// ============================================================================
// aarch32_VMLA_i_A Tests
// ============================================================================

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_u_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: D=0, N=0, Vn=0, Vm=0, size=0, U=0, op=0, M=0, Vd=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_u_1_max_800_f3800800() {
    // Encoding: 0xF3800800
    // Test aarch32_VMLA_i_T2A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: D=0, U=1, M=0, Vn=0, Vm=0, N=0, size=0, op=0, Vd=0
    let encoding: u32 = 0xF3800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_d_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vn=0, D=0, op=0, M=0, Vm=0, N=0, Vd=0, U=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_d_1_max_800_f2c00800() {
    // Encoding: 0xF2C00800
    // Test aarch32_VMLA_i_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: op=0, M=0, Vn=0, Vm=0, U=0, size=0, D=1, N=0, Vd=0
    let encoding: u32 = 0xF2C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, U=0, N=0, Vd=0, Vm=0, size=0, M=0, D=0, op=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_1_poweroftwo_800_f2900800() {
    // Encoding: 0xF2900800
    // Test aarch32_VMLA_i_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, op=0, U=0, Vm=0, Vn=0, size=1, N=0, M=0
    let encoding: u32 = 0xF2900800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_2_poweroftwo_800_f2a00800() {
    // Encoding: 0xF2A00800
    // Test aarch32_VMLA_i_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, op=0, N=0, M=0, U=0, Vd=0, D=0, Vm=0, Vn=0
    let encoding: u32 = 0xF2A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_3_max_800_f2b00800() {
    // Encoding: 0xF2B00800
    // Test aarch32_VMLA_i_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: U=0, D=0, Vd=0, Vm=0, size=3, M=0, op=0, Vn=0, N=0
    let encoding: u32 = 0xF2B00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vn_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, U=0, Vn=0, size=0, op=0, D=0, M=0, Vm=0, N=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vn_1_poweroftwo_800_f2810800() {
    // Encoding: 0xF2810800
    // Test aarch32_VMLA_i_T2A2_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, size=0, D=0, op=0, Vn=1, Vd=0, U=0, N=0, M=0
    let encoding: u32 = 0xF2810800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vd_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: M=0, N=0, Vd=0, Vm=0, op=0, size=0, D=0, U=0, Vn=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vd_1_poweroftwo_800_f2801800() {
    // Encoding: 0xF2801800
    // Test aarch32_VMLA_i_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, D=0, op=0, Vd=1, M=0, Vn=0, Vm=0, size=0, N=0
    let encoding: u32 = 0xF2801800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_op_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field op = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Vm=0, size=0, N=0, op=0, D=0, U=0, Vd=0, M=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_op_1_max_800_f2800a00() {
    // Encoding: 0xF2800A00
    // Test aarch32_VMLA_i_T2A2_A field op = 1 (Max)
    // ISET: A32
    // Fields: M=0, N=0, size=0, Vm=0, op=1, U=0, D=0, Vd=0, Vn=0
    let encoding: u32 = 0xF2800A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_n_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field N = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, U=0, Vm=0, N=0, Vd=0, Vn=0, op=0, M=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_n_1_max_800_f2800880() {
    // Encoding: 0xF2800880
    // Test aarch32_VMLA_i_T2A2_A field N = 1 (Max)
    // ISET: A32
    // Fields: U=0, Vd=0, Vm=0, N=1, M=0, op=0, Vn=0, D=0, size=0
    let encoding: u32 = 0xF2800880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_m_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, Vm=0, N=0, op=0, U=0, Vn=0, Vd=0, M=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_m_1_max_800_f2800820() {
    // Encoding: 0xF2800820
    // Test aarch32_VMLA_i_T2A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: U=0, Vm=0, D=0, size=0, Vn=0, op=0, M=1, Vd=0, N=0
    let encoding: u32 = 0xF2800820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vm_0_min_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vd=0, op=0, U=0, Vm=0, D=0, N=0, size=0, Vn=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vm_1_poweroftwo_800_f2800801() {
    // Encoding: 0xF2800801
    // Test aarch32_VMLA_i_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, D=0, Vn=0, Vd=0, U=0, size=0, M=0, Vm=1, N=0
    let encoding: u32 = 0xF2800801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmla_i_t2a2_a_combo_0_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, op=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, Vd=0, Vn=0, op=0, size=0, U=0, N=0, M=0, Vm=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_0_size_variant_0_2048_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Vn=0, M=0, Vd=0, op=0, size=0, U=0, N=0, Vm=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_1_size_variant_1_2048_f2900800() {
    // Encoding: 0xF2900800
    // Test aarch32_VMLA_i_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: U=0, M=0, op=0, N=0, Vm=0, D=0, Vn=0, Vd=0, size=1
    let encoding: u32 = 0xF2900800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_2_size_variant_2_2048_f2a00800() {
    // Encoding: 0xF2A00800
    // Test aarch32_VMLA_i_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, D=0, M=0, op=0, U=0, Vd=0, Vm=0, N=0, Vn=0
    let encoding: u32 = 0xF2A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_3_size_variant_3_2048_f2b00800() {
    // Encoding: 0xF2B00800
    // Test aarch32_VMLA_i_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: U=0, Vd=0, op=0, M=0, size=3, D=0, Vm=0, Vn=0, N=0
    let encoding: u32 = 0xF2B00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t2a2_a_invalid_0_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: U=0, size=0, D=0, Vd=0, Vn=0, Vm=0, M=0, N=0, op=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t2a2_a_invalid_1_800_f2800800() {
    // Encoding: 0xF2800800
    // Test aarch32_VMLA_i_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: op=0, Vm=0, D=0, size=0, Vn=0, M=0, Vd=0, N=0, U=0
    let encoding: u32 = 0xF2800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_u_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field U = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, size=0, Vm=0, Vd=0, U=0, op=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_u_1_max_800_ff800800() {
    // Thumb encoding (32): 0xFF800800
    // Test aarch32_VMLA_i_T2A2_A field U = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, U=1, D=0, op=0, size=0, Vd=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_d_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, U=0, Vn=0, op=0, N=0, D=0, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_d_1_max_800_efc00800() {
    // Thumb encoding (32): 0xEFC00800
    // Test aarch32_VMLA_i_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, op=0, size=0, M=0, Vm=0, Vn=0, N=0, U=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, U=0, N=0, op=0, Vn=0, Vm=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_1_poweroftwo_800_ef900800() {
    // Thumb encoding (32): 0xEF900800
    // Test aarch32_VMLA_i_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, Vd=0, op=0, Vn=0, size=1, D=0, U=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_2_poweroftwo_800_efa00800() {
    // Thumb encoding (32): 0xEFA00800
    // Test aarch32_VMLA_i_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=2, Vn=0, op=0, U=0, Vm=0, M=0, N=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_size_3_max_800_efb00800() {
    // Thumb encoding (32): 0xEFB00800
    // Test aarch32_VMLA_i_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: M=0, Vn=0, Vm=0, Vd=0, N=0, D=0, op=0, U=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vn_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: op=0, N=0, Vd=0, U=0, D=0, M=0, Vm=0, size=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vn_1_poweroftwo_800_ef810800() {
    // Thumb encoding (32): 0xEF810800
    // Test aarch32_VMLA_i_T2A2_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, Vm=0, Vd=0, U=0, N=0, size=0, Vn=1, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vd_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: U=0, D=0, Vd=0, M=0, N=0, size=0, Vm=0, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vd_1_poweroftwo_800_ef801800() {
    // Thumb encoding (32): 0xEF801800
    // Test aarch32_VMLA_i_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, M=0, Vm=0, Vd=1, size=0, op=0, U=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_op_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field op = 0 (Min)
    // ISET: T32
    // Fields: size=0, N=0, U=0, Vn=0, Vm=0, D=0, op=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_op_1_max_800_ef800a00() {
    // Thumb encoding (32): 0xEF800A00
    // Test aarch32_VMLA_i_T2A2_A field op = 1 (Max)
    // ISET: T32
    // Fields: U=0, D=0, M=0, Vm=0, Vn=0, N=0, Vd=0, size=0, op=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_n_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field N = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, op=0, N=0, M=0, U=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_n_1_max_800_ef800880() {
    // Thumb encoding (32): 0xEF800880
    // Test aarch32_VMLA_i_T2A2_A field N = 1 (Max)
    // ISET: T32
    // Fields: M=0, D=0, Vd=0, op=0, size=0, Vm=0, U=0, N=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_m_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field M = 0 (Min)
    // ISET: T32
    // Fields: op=0, N=0, Vn=0, U=0, Vd=0, M=0, D=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_m_1_max_800_ef800820() {
    // Thumb encoding (32): 0xEF800820
    // Test aarch32_VMLA_i_T2A2_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, op=0, N=0, U=0, D=0, Vd=0, M=1, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vm_0_min_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, N=0, Vn=0, Vd=0, op=0, U=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_i_t2a2_a_field_vm_1_poweroftwo_800_ef800801() {
    // Thumb encoding (32): 0xEF800801
    // Test aarch32_VMLA_i_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, M=0, Vm=1, N=0, D=0, size=0, op=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmla_i_t2a2_a_combo_0_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, op=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vn=0, Vm=0, U=0, D=0, op=0, N=0, size=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_0_size_variant_0_2048_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: U=0, Vn=0, M=0, Vm=0, op=0, size=0, Vd=0, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_1_size_variant_1_2048_ef900800() {
    // Thumb encoding (32): 0xEF900800
    // Test aarch32_VMLA_i_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: M=0, Vn=0, op=0, N=0, D=0, Vm=0, size=1, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_2_size_variant_2_2048_efa00800() {
    // Thumb encoding (32): 0xEFA00800
    // Test aarch32_VMLA_i_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: N=0, U=0, D=0, size=2, op=0, Vm=0, M=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_i_t2a2_a_special_size_3_size_variant_3_2048_efb00800() {
    // Thumb encoding (32): 0xEFB00800
    // Test aarch32_VMLA_i_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vm=0, Vn=0, M=0, Vd=0, size=3, D=0, U=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t2a2_a_invalid_0_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vn=0, op=0, size=0, Vm=0, N=0, M=0, D=0, U=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_i_t2a2_a_invalid_1_800_ef800800() {
    // Thumb encoding (32): 0xEF800800
    // Test aarch32_VMLA_i_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, Vn=0, U=0, N=0, Vm=0, op=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_0_f2802820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_0_f2802820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_1_f2800820() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_1_f2800820() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_2_f2800c20() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_2_f2800c20() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_3_f2bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_3_f2bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_4_f2fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_4_f2fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_5_f2800c20() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_5_f2800c20() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_6_f2800c20() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_6_f2800c20() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_7_f2800c20() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_7_f2800c20() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_8_f2800c20() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_8_f2800c20() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_9_f2800c20() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_9_f2800c20() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_10_f2800c20() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_10_f2800c20() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_32_rd31_sp_f280283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_add_oracle_64_rd31_sp_f280283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_0_f2802820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_0_f2802820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_1_f2800820() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_1_f2800820() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_2_f2800c20() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_2_f2800c20() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_3_f2bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_3_f2bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_4_f2fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_4_f2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_5_f2800c20() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_5_f2800c20() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_6_f2800c20() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_6_f2800c20() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_7_f2800c20() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_7_f2800c20() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_8_f2800c20() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_8_f2800c20() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_9_f2800c20() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_9_f2800c20() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_10_f2800c20() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_10_f2800c20() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_32_rd31_zr_f280283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_adds_oracle_64_rd31_zr_f280283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_0_f2802820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_0_f2802820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_1_f2800820() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_1_f2800820() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_2_f2800c20() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_2_f2800c20() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_3_f2bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_3_f2bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_4_f2fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_4_f2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_5_f2800c20() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_5_f2800c20() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_6_f2800c20() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_6_f2800c20() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_7_f2800c20() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_7_f2800c20() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_8_f2800c20() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_8_f2800c20() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_9_f2800c20() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_9_f2800c20() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_10_f2800c20() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_10_f2800c20() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_32_rd31_sp_f280283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_sub_oracle_64_rd31_sp_f280283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_0_f2802820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_0_f2802820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_1_f2800820() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_1_f2800820() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_2_f2800c20() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_2_f2800c20() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_3_f2bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_3_f2bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_4_f2fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_4_f2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_5_f2800c20() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_5_f2800c20() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_6_f2800c20() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_6_f2800c20() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_7_f2800c20() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_7_f2800c20() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_8_f2800c20() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_8_f2800c20() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_9_f2800c20() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_9_f2800c20() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_10_f2800c20() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_10_f2800c20() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_32_rd31_zr_f280283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmla_i_t2a2_a_subs_oracle_64_rd31_zr_f280283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMLA_i_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_i_t2a2_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMUL_s_A Tests
// ============================================================================

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Q 24 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_s_a1_a_field_q_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: F=0, size=0, Vn=0, D=0, N=0, Vd=0, Vm=0, Q=0, M=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Q 24 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_s_a1_a_field_q_1_max_840_f3800840() {
    // Encoding: 0xF3800840
    // Test aarch32_VMUL_s_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: Q=1, D=0, Vd=0, Vn=0, size=0, F=0, N=0, Vm=0, M=0
    let encoding: u32 = 0xF3800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_a1_a_field_d_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: F=0, Vd=0, Q=0, Vm=0, D=0, size=0, N=0, M=0, Vn=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_a1_a_field_d_1_max_840_f2c00840() {
    // Encoding: 0xF2C00840
    // Test aarch32_VMUL_s_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, Q=0, F=0, Vd=0, Vm=0, M=0, N=0, Vn=0, D=1
    let encoding: u32 = 0xF2C00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_s_a1_a_field_size_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, F=0, Vn=0, N=0, M=0, Vd=0, Q=0, Vm=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_s_a1_a_field_size_1_poweroftwo_840_f2900840() {
    // Encoding: 0xF2900840
    // Test aarch32_VMUL_s_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, F=0, Vm=0, Vn=0, D=0, size=1, Vd=0, M=0, N=0
    let encoding: u32 = 0xF2900840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_s_a1_a_field_size_2_poweroftwo_840_f2a00840() {
    // Encoding: 0xF2A00840
    // Test aarch32_VMUL_s_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, D=0, F=0, Vd=0, N=0, M=0, Q=0, Vm=0, Vn=0
    let encoding: u32 = 0xF2A00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_s_a1_a_field_size_3_max_840_f2b00840() {
    // Encoding: 0xF2B00840
    // Test aarch32_VMUL_s_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Q=0, N=0, F=0, D=0, size=3, Vm=0, M=0, Vn=0, Vd=0
    let encoding: u32 = 0xF2B00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_a1_a_field_vn_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: F=0, N=0, size=0, D=0, Vm=0, Vn=0, M=0, Q=0, Vd=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_a1_a_field_vn_1_poweroftwo_840_f2810840() {
    // Encoding: 0xF2810840
    // Test aarch32_VMUL_s_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vn=1, M=0, Vd=0, Q=0, F=0, N=0, Vm=0, size=0
    let encoding: u32 = 0xF2810840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_a1_a_field_vd_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: F=0, D=0, Vn=0, Q=0, Vd=0, size=0, N=0, M=0, Vm=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_a1_a_field_vd_1_poweroftwo_840_f2801840() {
    // Encoding: 0xF2801840
    // Test aarch32_VMUL_s_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, F=0, D=0, N=0, size=0, Vd=1, Q=0, M=0, Vn=0
    let encoding: u32 = 0xF2801840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_a1_a_field_f_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field F = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, F=0, M=0, N=0, D=0, size=0, Vn=0, Q=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_a1_a_field_f_1_max_840_f2800940() {
    // Encoding: 0xF2800940
    // Test aarch32_VMUL_s_A1_A field F = 1 (Max)
    // ISET: A32
    // Fields: D=0, Q=0, Vn=0, F=1, Vd=0, size=0, Vm=0, N=0, M=0
    let encoding: u32 = 0xF2800940;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_a1_a_field_n_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: D=0, N=0, Vd=0, Vn=0, M=0, Q=0, F=0, size=0, Vm=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_a1_a_field_n_1_max_840_f28008c0() {
    // Encoding: 0xF28008C0
    // Test aarch32_VMUL_s_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, M=0, D=0, Vm=0, Q=0, size=0, Vd=0, F=0, N=1
    let encoding: u32 = 0xF28008C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_a1_a_field_m_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: N=0, D=0, F=0, M=0, Vd=0, size=0, Vn=0, Vm=0, Q=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_a1_a_field_m_1_max_840_f2800860() {
    // Encoding: 0xF2800860
    // Test aarch32_VMUL_s_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, Vn=0, N=0, size=0, Q=0, F=0, Vm=0, M=1
    let encoding: u32 = 0xF2800860;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_a1_a_field_vm_0_min_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vn=0, M=0, D=0, F=0, Vm=0, Q=0, N=0, size=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_a1_a_field_vm_1_poweroftwo_840_f2800841() {
    // Encoding: 0xF2800841
    // Test aarch32_VMUL_s_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Q=0, Vm=1, M=0, Vd=0, F=0, D=0, Vn=0, size=0
    let encoding: u32 = 0xF2800841;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmul_s_a1_a_combo_0_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A field combination: Q=0, D=0, size=0, Vn=0, Vd=0, F=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, F=0, Q=0, N=0, size=0, Vd=0, Vm=0, M=0, Vn=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_s_a1_a_special_q_0_size_variant_0_2112_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Q=0, size=0, M=0, N=0, F=0, Vd=0, Vn=0, Vm=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_s_a1_a_special_q_1_size_variant_1_2112_f3800840() {
    // Encoding: 0xF3800840
    // Test aarch32_VMUL_s_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: M=0, F=0, Q=1, size=0, Vn=0, Vd=0, D=0, N=0, Vm=0
    let encoding: u32 = 0xF3800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_s_a1_a_special_size_0_size_variant_0_2112_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Q=0, F=0, size=0, Vd=0, N=0, Vm=0, M=0, Vn=0, D=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_s_a1_a_special_size_1_size_variant_1_2112_f2900840() {
    // Encoding: 0xF2900840
    // Test aarch32_VMUL_s_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: F=0, Vd=0, Vm=0, D=0, size=1, M=0, Q=0, N=0, Vn=0
    let encoding: u32 = 0xF2900840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_s_a1_a_special_size_2_size_variant_2_2112_f2a00840() {
    // Encoding: 0xF2A00840
    // Test aarch32_VMUL_s_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vd=0, N=0, Vm=0, Vn=0, Q=0, M=0, D=0, F=0, size=2
    let encoding: u32 = 0xF2A00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_s_a1_a_special_size_3_size_variant_3_2112_f2b00840() {
    // Encoding: 0xF2B00840
    // Test aarch32_VMUL_s_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: N=0, D=0, Vd=0, Vn=0, M=0, Vm=0, F=0, size=3, Q=0
    let encoding: u32 = 0xF2B00840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_a1_a_invalid_0_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: size=0, M=0, Vm=0, D=0, N=0, Q=0, Vd=0, Vn=0, F=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_a1_a_invalid_1_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Q=0, Vn=0, N=0, Vd=0, D=0, Vm=0, F=0, size=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_a1_a_invalid_2_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: Vm=0, size=0, Q=0, Vn=0, D=0, M=0, F=0, N=0, Vd=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_a1_a_invalid_3_840_f2800840() {
    // Encoding: 0xF2800840
    // Test aarch32_VMUL_s_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, size=0, M=0, F=0, Vd=0, N=0, Vm=0, D=0, Vn=0
    let encoding: u32 = 0xF2800840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Q 28 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_s_t1_a_field_q_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, Vd=0, Vn=0, size=0, D=0, N=0, Vm=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Q 28 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_s_t1_a_field_q_1_max_840_ff800840() {
    // Thumb encoding (32): 0xFF800840
    // Test aarch32_VMUL_s_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, F=0, M=0, Q=1, D=0, size=0, Vd=0, Vm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t1_a_field_d_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vd=0, F=0, Q=0, Vn=0, D=0, Vm=0, N=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t1_a_field_d_1_max_840_efc00840() {
    // Thumb encoding (32): 0xEFC00840
    // Test aarch32_VMUL_s_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, Vn=0, Q=0, N=0, F=0, Vd=0, D=1, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_s_t1_a_field_size_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Q=0, Vn=0, M=0, size=0, F=0, Vm=0, Vd=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_s_t1_a_field_size_1_poweroftwo_840_ef900840() {
    // Thumb encoding (32): 0xEF900840
    // Test aarch32_VMUL_s_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, Vm=0, Q=0, F=0, N=0, D=0, Vd=0, M=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_s_t1_a_field_size_2_poweroftwo_840_efa00840() {
    // Thumb encoding (32): 0xEFA00840
    // Test aarch32_VMUL_s_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vn=0, F=0, N=0, size=2, Vm=0, M=0, Q=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_s_t1_a_field_size_3_max_840_efb00840() {
    // Thumb encoding (32): 0xEFB00840
    // Test aarch32_VMUL_s_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vm=0, D=0, size=3, Vn=0, N=0, Q=0, F=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t1_a_field_vn_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, size=0, D=0, N=0, Vd=0, Q=0, Vm=0, F=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t1_a_field_vn_1_poweroftwo_840_ef810840() {
    // Thumb encoding (32): 0xEF810840
    // Test aarch32_VMUL_s_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Vm=0, M=0, Q=0, N=0, F=0, D=0, Vn=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t1_a_field_vd_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, N=0, Q=0, Vn=0, Vm=0, size=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t1_a_field_vd_1_poweroftwo_840_ef801840() {
    // Thumb encoding (32): 0xEF801840
    // Test aarch32_VMUL_s_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: F=0, D=0, Vn=0, Vd=1, M=0, size=0, N=0, Vm=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t1_a_field_f_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field F = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, Q=0, size=0, Vn=0, F=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t1_a_field_f_1_max_840_ef800940() {
    // Thumb encoding (32): 0xEF800940
    // Test aarch32_VMUL_s_T1_A field F = 1 (Max)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, Vn=0, Vd=0, Q=0, F=1, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800940;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t1_a_field_n_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, size=0, Vd=0, M=0, Q=0, N=0, Vn=0, D=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t1_a_field_n_1_max_840_ef8008c0() {
    // Thumb encoding (32): 0xEF8008C0
    // Test aarch32_VMUL_s_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, Q=0, D=0, Vm=0, size=0, M=0, N=1, Vd=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF8008C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t1_a_field_m_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Q=0, F=0, N=0, D=0, M=0, Vm=0, Vn=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t1_a_field_m_1_max_840_ef800860() {
    // Thumb encoding (32): 0xEF800860
    // Test aarch32_VMUL_s_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, Vn=0, N=0, Q=0, Vd=0, D=0, M=1, size=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t1_a_field_vm_0_min_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vn=0, N=0, Q=0, M=0, F=0, D=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t1_a_field_vm_1_poweroftwo_840_ef800841() {
    // Thumb encoding (32): 0xEF800841
    // Test aarch32_VMUL_s_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: F=0, D=0, Q=0, size=0, N=0, Vn=0, Vd=0, M=0, Vm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800841;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmul_s_t1_a_combo_0_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A field combination: Q=0, D=0, size=0, Vn=0, Vd=0, F=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: size=0, M=0, Vd=0, F=0, Vm=0, Q=0, D=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_s_t1_a_special_q_0_size_variant_0_2112_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: F=0, Vd=0, M=0, Vm=0, N=0, D=0, size=0, Vn=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_s_t1_a_special_q_1_size_variant_1_2112_ff800840() {
    // Thumb encoding (32): 0xFF800840
    // Test aarch32_VMUL_s_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Vd=0, F=0, Vn=0, size=0, Q=1, M=0, Vm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_s_t1_a_special_size_0_size_variant_0_2112_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: M=0, Vd=0, N=0, Q=0, D=0, size=0, F=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_s_t1_a_special_size_1_size_variant_1_2112_ef900840() {
    // Thumb encoding (32): 0xEF900840
    // Test aarch32_VMUL_s_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: M=0, N=0, Q=0, Vd=0, Vm=0, Vn=0, F=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_s_t1_a_special_size_2_size_variant_2_2112_efa00840() {
    // Thumb encoding (32): 0xEFA00840
    // Test aarch32_VMUL_s_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, M=0, Vd=0, Vm=0, Vn=0, Q=0, F=0, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_s_t1_a_special_size_3_size_variant_3_2112_efb00840() {
    // Thumb encoding (32): 0xEFB00840
    // Test aarch32_VMUL_s_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, size=3, D=0, Q=0, Vn=0, M=0, Vm=0, N=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_s_t1_a_invalid_0_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: N=0, Q=0, Vm=0, size=0, Vn=0, M=0, Vd=0, F=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_s_t1_a_invalid_1_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vn=0, F=0, size=0, M=0, Vd=0, Vm=0, Q=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t1_a_invalid_2_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: Vm=0, D=0, F=0, Q=0, size=0, Vn=0, N=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t1_a_invalid_3_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, size=0, D=0, M=0, N=0, Vn=0, Vd=0, F=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t1_a_invalid_4_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: M=0, D=0, Vn=0, N=0, Vm=0, Vd=0, size=0, F=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_s_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t1_a_invalid_5_840_ef800840() {
    // Thumb encoding (32): 0xEF800840
    // Test aarch32_VMUL_s_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vn=0, Q=0, F=0, M=0, Vd=0, N=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_0_f2802860() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_0_f2802860() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_1_f2800860() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_1_f2800860() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_2_f2800c60() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_2_f2800c60() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_3_f2bffc60() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_3_f2bffc60() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_4_f2fffc60() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_4_f2fffc60() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_5_f2800c60() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_5_f2800c60() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_6_f2800c60() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_6_f2800c60() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_7_f2800c60() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_7_f2800c60() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_8_f2800c60() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_8_f2800c60() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_9_f2800c60() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_9_f2800c60() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_10_f2800c60() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_10_f2800c60() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_32_rd31_sp_f280287f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmul_s_a1_a_add_oracle_64_rd31_sp_f280287f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_0_f2802860() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_0_f2802860() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_1_f2800860() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_1_f2800860() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_2_f2800c60() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_2_f2800c60() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_3_f2bffc60() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_3_f2bffc60() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_4_f2fffc60() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_4_f2fffc60() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_5_f2800c60() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_5_f2800c60() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_6_f2800c60() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_6_f2800c60() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_7_f2800c60() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_7_f2800c60() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_8_f2800c60() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_8_f2800c60() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_9_f2800c60() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_9_f2800c60() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_10_f2800c60() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_10_f2800c60() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_32_rd31_zr_f280287f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmul_s_a1_a_adds_oracle_64_rd31_zr_f280287f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_0_f2802860() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_0_f2802860() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_1_f2800860() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_1_f2800860() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_2_f2800c60() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_2_f2800c60() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_3_f2bffc60() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_3_f2bffc60() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_4_f2fffc60() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_4_f2fffc60() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_5_f2800c60() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_5_f2800c60() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_6_f2800c60() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_6_f2800c60() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_7_f2800c60() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_7_f2800c60() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_8_f2800c60() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_8_f2800c60() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_9_f2800c60() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_9_f2800c60() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_10_f2800c60() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_10_f2800c60() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_32_rd31_sp_f280287f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmul_s_a1_a_sub_oracle_64_rd31_sp_f280287f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_0_f2802860() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_0_f2802860() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_1_f2800860() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_1_f2800860() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_2_f2800c60() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_2_f2800c60() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_3_f2bffc60() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_3_f2bffc60() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_4_f2fffc60() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_4_f2fffc60() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_5_f2800c60() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_5_f2800c60() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_6_f2800c60() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_6_f2800c60() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_7_f2800c60() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_7_f2800c60() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_8_f2800c60() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_8_f2800c60() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_9_f2800c60() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_9_f2800c60() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_10_f2800c60() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_10_f2800c60() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_32_rd31_zr_f280287f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmul_s_a1_a_subs_oracle_64_rd31_zr_f280287f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMUL_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_a1_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMUL_f_A Tests
// ============================================================================

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_a1_a_field_d_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, sz=0, Q=0, Vd=0, M=0, N=0, Vm=0, D=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_a1_a_field_d_1_max_d10_f3400d10() {
    // Encoding: 0xF3400D10
    // Test aarch32_VMUL_f_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, D=1, Vm=0, N=0, Q=0, Vd=0, sz=0, M=0
    let encoding: u32 = 0xF3400D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_f_a1_a_field_sz_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field sz = 0 (Min)
    // ISET: A32
    // Fields: sz=0, M=0, Vd=0, Vn=0, Vm=0, D=0, Q=0, N=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_f_a1_a_field_sz_1_max_d10_f3100d10() {
    // Encoding: 0xF3100D10
    // Test aarch32_VMUL_f_A1_A field sz = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, Vm=0, Q=0, sz=1, D=0, M=0, N=0, Vd=0
    let encoding: u32 = 0xF3100D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_a1_a_field_vn_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, sz=0, Vn=0, N=0, M=0, Q=0, Vd=0, D=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_a1_a_field_vn_1_poweroftwo_d10_f3010d10() {
    // Encoding: 0xF3010D10
    // Test aarch32_VMUL_f_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Q=0, Vm=0, D=0, Vd=0, sz=0, Vn=1, M=0
    let encoding: u32 = 0xF3010D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_a1_a_field_vd_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, Vn=0, Q=0, D=0, sz=0, M=0, N=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_a1_a_field_vd_1_poweroftwo_d10_f3001d10() {
    // Encoding: 0xF3001D10
    // Test aarch32_VMUL_f_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, Vn=0, D=0, M=0, Vm=0, N=0, Q=0, sz=0
    let encoding: u32 = 0xF3001D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_a1_a_field_n_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: N=0, M=0, D=0, Vd=0, sz=0, Vm=0, Q=0, Vn=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_a1_a_field_n_1_max_d10_f3000d90() {
    // Encoding: 0xF3000D90
    // Test aarch32_VMUL_f_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vn=0, N=1, Vd=0, sz=0, Vm=0, M=0, Q=0
    let encoding: u32 = 0xF3000D90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_f_a1_a_field_q_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: Q=0, D=0, N=0, Vd=0, Vm=0, sz=0, M=0, Vn=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_f_a1_a_field_q_1_max_d10_f3000d50() {
    // Encoding: 0xF3000D50
    // Test aarch32_VMUL_f_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: M=0, N=0, sz=0, Q=1, Vn=0, Vd=0, D=0, Vm=0
    let encoding: u32 = 0xF3000D50;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_a1_a_field_m_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: N=0, sz=0, Q=0, D=0, Vn=0, Vm=0, Vd=0, M=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_a1_a_field_m_1_max_d10_f3000d30() {
    // Encoding: 0xF3000D30
    // Test aarch32_VMUL_f_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, Vn=0, Vd=0, N=0, Q=0, D=0, sz=0, M=1
    let encoding: u32 = 0xF3000D30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_a1_a_field_vm_0_min_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Vd=0, Q=0, D=0, N=0, Vm=0, M=0, sz=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_a1_a_field_vm_1_poweroftwo_d10_f3000d11() {
    // Encoding: 0xF3000D11
    // Test aarch32_VMUL_f_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, Q=0, M=0, Vm=1, Vn=0, Vd=0, N=0, D=0
    let encoding: u32 = 0xF3000D11;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmul_f_a1_a_combo_0_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A field combination: D=0, sz=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: N=0, Q=0, M=0, Vm=0, Vn=0, Vd=0, D=0, sz=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_f_a1_a_special_sz_0_size_variant_0_3344_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A special value sz = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vn=0, N=0, sz=0, Vd=0, M=0, Vm=0, D=0, Q=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_f_a1_a_special_sz_1_size_variant_1_3344_f3100d10() {
    // Encoding: 0xF3100D10
    // Test aarch32_VMUL_f_A1_A special value sz = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vm=0, Vd=0, M=0, N=0, Vn=0, sz=1, Q=0, D=0
    let encoding: u32 = 0xF3100D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_f_a1_a_special_q_0_size_variant_0_3344_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, Q=0, sz=0, Vd=0, Vn=0, D=0, M=0, N=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_f_a1_a_special_q_1_size_variant_1_3344_f3000d50() {
    // Encoding: 0xF3000D50
    // Test aarch32_VMUL_f_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: N=0, sz=0, Vm=0, D=0, Vn=0, Vd=0, M=0, Q=1
    let encoding: u32 = 0xF3000D50;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a1_a_invalid_0_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: sz=0, D=0, Vn=0, Vd=0, Vm=0, M=0, N=0, Q=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a1_a_invalid_1_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, D=0, M=0, sz=0, Vm=0, Vd=0, Q=0, Vn=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a1_a_invalid_2_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }
    // ISET: A32
    // Fields: Q=0, N=0, D=0, Vd=0, Vn=0, M=0, Vm=0, sz=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a1_a_invalid_3_d10_f3000d10() {
    // Encoding: 0xF3000D10
    // Test aarch32_VMUL_f_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, sz=0, M=0, Vn=0, D=0, Vm=0, Vd=0, N=0
    let encoding: u32 = 0xF3000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, size=0, cond=0, Vn=0, D=0, Vd=0, N=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_1_poweroftwo_800_1e200800() {
    // Encoding: 0x1E200800
    // Test aarch32_VMUL_f_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Vn=0, Vd=0, M=0, D=0, Vm=0, size=0, cond=1
    let encoding: u32 = 0x1E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_2_poweroftwo_800_2e200800() {
    // Encoding: 0x2E200800
    // Test aarch32_VMUL_f_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, cond=2, D=0, Vm=0, Vn=0, size=0, M=0, N=0
    let encoding: u32 = 0x2E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_3_poweroftwo_800_3e200800() {
    // Encoding: 0x3E200800
    // Test aarch32_VMUL_f_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Vd=0, cond=3, N=0, D=0, M=0, Vn=0, size=0
    let encoding: u32 = 0x3E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_4_poweroftwo_800_4e200800() {
    // Encoding: 0x4E200800
    // Test aarch32_VMUL_f_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, D=0, N=0, size=0, M=0, Vn=0, Vd=0, Vm=0
    let encoding: u32 = 0x4E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_5_poweroftwo_800_5e200800() {
    // Encoding: 0x5E200800
    // Test aarch32_VMUL_f_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, N=0, Vm=0, M=0, cond=5, size=0, Vn=0
    let encoding: u32 = 0x5E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_6_poweroftwo_800_6e200800() {
    // Encoding: 0x6E200800
    // Test aarch32_VMUL_f_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, cond=6, Vn=0, size=0, Vd=0, N=0, Vm=0
    let encoding: u32 = 0x6E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_7_poweroftwo_800_7e200800() {
    // Encoding: 0x7E200800
    // Test aarch32_VMUL_f_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=7, Vm=0, M=0, Vn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0x7E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_8_poweroftwo_800_8e200800() {
    // Encoding: 0x8E200800
    // Test aarch32_VMUL_f_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vm=0, Vn=0, cond=8, size=0, Vd=0, M=0, N=0
    let encoding: u32 = 0x8E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_9_poweroftwo_800_9e200800() {
    // Encoding: 0x9E200800
    // Test aarch32_VMUL_f_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, Vn=0, Vm=0, cond=9, N=0, D=0, M=0
    let encoding: u32 = 0x9E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_10_poweroftwo_800_ae200800() {
    // Encoding: 0xAE200800
    // Test aarch32_VMUL_f_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, M=0, cond=10, Vd=0, Vm=0, D=0, N=0, size=0
    let encoding: u32 = 0xAE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_11_poweroftwo_800_be200800() {
    // Encoding: 0xBE200800
    // Test aarch32_VMUL_f_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, M=0, N=0, D=0, Vm=0, Vn=0, size=0, Vd=0
    let encoding: u32 = 0xBE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_12_poweroftwo_800_ce200800() {
    // Encoding: 0xCE200800
    // Test aarch32_VMUL_f_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, M=0, size=0, D=0, Vm=0, N=0, Vn=0, Vd=0
    let encoding: u32 = 0xCE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_13_poweroftwo_800_de200800() {
    // Encoding: 0xDE200800
    // Test aarch32_VMUL_f_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, M=0, D=0, Vd=0, size=0, Vm=0, Vn=0, N=0
    let encoding: u32 = 0xDE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_14_poweroftwo_800_ee200800() {
    // Encoding: 0xEE200800
    // Test aarch32_VMUL_f_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, N=0, Vm=0, Vn=0, D=0, size=0, M=0, Vd=0
    let encoding: u32 = 0xEE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmul_f_a2_a_field_cond_15_max_800_fe200800() {
    // Encoding: 0xFE200800
    // Test aarch32_VMUL_f_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, Vn=0, size=0, D=0, cond=15, N=0
    let encoding: u32 = 0xFE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_a2_a_field_d_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, size=0, M=0, cond=0, N=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_a2_a_field_d_1_max_800_0e600800() {
    // Encoding: 0x0E600800
    // Test aarch32_VMUL_f_A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, size=0, N=0, Vm=0, D=1, cond=0, M=0, Vd=0
    let encoding: u32 = 0x0E600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_a2_a_field_vn_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: N=0, Vm=0, M=0, cond=0, Vn=0, D=0, Vd=0, size=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_a2_a_field_vn_1_poweroftwo_800_0e210800() {
    // Encoding: 0x0E210800
    // Test aarch32_VMUL_f_A2_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, cond=0, D=0, N=0, M=0, Vd=0, Vm=0, Vn=1
    let encoding: u32 = 0x0E210800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_a2_a_field_vd_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, N=0, cond=0, Vn=0, size=0, Vm=0, D=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_a2_a_field_vd_1_poweroftwo_800_0e201800() {
    // Encoding: 0x0E201800
    // Test aarch32_VMUL_f_A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, M=0, Vm=0, size=0, Vn=0, Vd=1, D=0, cond=0
    let encoding: u32 = 0x0E201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_f_a2_a_field_size_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Vm=0, D=0, size=0, Vn=0, N=0, M=0, Vd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_f_a2_a_field_size_1_poweroftwo_800_0e200900() {
    // Encoding: 0x0E200900
    // Test aarch32_VMUL_f_A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, M=0, Vd=0, N=0, D=0, cond=0, Vm=0, size=1
    let encoding: u32 = 0x0E200900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_f_a2_a_field_size_2_poweroftwo_800_0e200a00() {
    // Encoding: 0x0E200A00
    // Test aarch32_VMUL_f_A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, D=0, Vd=0, Vn=0, N=0, Vm=0, cond=0, size=2
    let encoding: u32 = 0x0E200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_f_a2_a_field_size_3_max_800_0e200b00() {
    // Encoding: 0x0E200B00
    // Test aarch32_VMUL_f_A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: N=0, Vd=0, Vm=0, D=0, size=3, M=0, Vn=0, cond=0
    let encoding: u32 = 0x0E200B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_a2_a_field_n_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field N = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vn=0, Vm=0, N=0, cond=0, size=0, Vd=0, D=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_a2_a_field_n_1_max_800_0e200880() {
    // Encoding: 0x0E200880
    // Test aarch32_VMUL_f_A2_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, N=1, M=0, D=0, Vn=0, size=0, Vm=0, cond=0
    let encoding: u32 = 0x0E200880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_a2_a_field_m_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vm=0, M=0, D=0, N=0, cond=0, Vd=0, Vn=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_a2_a_field_m_1_max_800_0e200820() {
    // Encoding: 0x0E200820
    // Test aarch32_VMUL_f_A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, Vn=0, N=0, size=0, M=1, cond=0, Vm=0
    let encoding: u32 = 0x0E200820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_a2_a_field_vm_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, N=0, M=0, Vd=0, Vn=0, cond=0, Vm=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_a2_a_field_vm_1_poweroftwo_800_0e200801() {
    // Encoding: 0x0E200801
    // Test aarch32_VMUL_f_A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, size=0, D=0, N=0, Vd=0, M=0, cond=0, Vn=0
    let encoding: u32 = 0x0E200801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmul_f_a2_a_combo_0_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A field combination: cond=0, D=0, Vn=0, Vd=0, size=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, Vm=0, Vn=0, cond=0, size=0, Vd=0, M=0, N=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_0_condition_eq_2048_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Vn=0, size=0, N=0, cond=0, D=0, Vd=0, Vm=0, M=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_1_condition_ne_2048_1e200800() {
    // Encoding: 0x1E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: N=0, cond=1, Vd=0, M=0, Vn=0, size=0, Vm=0, D=0
    let encoding: u32 = 0x1E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_2_condition_cs_hs_2048_2e200800() {
    // Encoding: 0x2E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Vd=0, cond=2, M=0, D=0, Vn=0, size=0, Vm=0, N=0
    let encoding: u32 = 0x2E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_3_condition_cc_lo_2048_3e200800() {
    // Encoding: 0x3E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Vd=0, D=0, cond=3, size=0, N=0, Vm=0, Vn=0, M=0
    let encoding: u32 = 0x3E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_4_condition_mi_2048_4e200800() {
    // Encoding: 0x4E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, D=0, Vm=0, Vd=0, N=0, size=0, M=0, Vn=0
    let encoding: u32 = 0x4E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_5_condition_pl_2048_5e200800() {
    // Encoding: 0x5E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Vd=0, cond=5, size=0, N=0, Vm=0, Vn=0, M=0, D=0
    let encoding: u32 = 0x5E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_6_condition_vs_2048_6e200800() {
    // Encoding: 0x6E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: D=0, Vd=0, Vm=0, Vn=0, size=0, cond=6, N=0, M=0
    let encoding: u32 = 0x6E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_7_condition_vc_2048_7e200800() {
    // Encoding: 0x7E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: size=0, M=0, N=0, Vd=0, Vm=0, Vn=0, D=0, cond=7
    let encoding: u32 = 0x7E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_8_condition_hi_2048_8e200800() {
    // Encoding: 0x8E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: M=0, D=0, size=0, cond=8, Vm=0, Vn=0, Vd=0, N=0
    let encoding: u32 = 0x8E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_9_condition_ls_2048_9e200800() {
    // Encoding: 0x9E200800
    // Test aarch32_VMUL_f_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: D=0, Vn=0, cond=9, Vd=0, size=0, N=0, M=0, Vm=0
    let encoding: u32 = 0x9E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_10_condition_ge_2048_ae200800() {
    // Encoding: 0xAE200800
    // Test aarch32_VMUL_f_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, size=0, Vd=0, D=0, Vm=0, N=0, Vn=0, M=0
    let encoding: u32 = 0xAE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_11_condition_lt_2048_be200800() {
    // Encoding: 0xBE200800
    // Test aarch32_VMUL_f_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Vd=0, size=0, Vn=0, D=0, N=0, M=0, cond=11, Vm=0
    let encoding: u32 = 0xBE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_12_condition_gt_2048_ce200800() {
    // Encoding: 0xCE200800
    // Test aarch32_VMUL_f_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, D=0, N=0, size=0, Vd=0, M=0, Vn=0, Vm=0
    let encoding: u32 = 0xCE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_13_condition_le_2048_de200800() {
    // Encoding: 0xDE200800
    // Test aarch32_VMUL_f_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: N=0, M=0, D=0, cond=13, size=0, Vm=0, Vd=0, Vn=0
    let encoding: u32 = 0xDE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_14_condition_al_2048_ee200800() {
    // Encoding: 0xEE200800
    // Test aarch32_VMUL_f_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: M=0, Vm=0, cond=14, D=0, Vn=0, N=0, Vd=0, size=0
    let encoding: u32 = 0xEE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmul_f_a2_a_special_cond_15_condition_nv_2048_fe200800() {
    // Encoding: 0xFE200800
    // Test aarch32_VMUL_f_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Vm=0, M=0, cond=15, D=0, Vn=0, N=0, Vd=0, size=0
    let encoding: u32 = 0xFE200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_f_a2_a_special_size_0_size_variant_0_2048_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, M=0, size=0, N=0, cond=0, Vn=0, Vm=0, Vd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_f_a2_a_special_size_1_size_variant_1_2048_0e200900() {
    // Encoding: 0x0E200900
    // Test aarch32_VMUL_f_A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vn=0, N=0, M=0, Vm=0, cond=0, D=0, Vd=0, size=1
    let encoding: u32 = 0x0E200900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_f_a2_a_special_size_2_size_variant_2_2048_0e200a00() {
    // Encoding: 0x0E200A00
    // Test aarch32_VMUL_f_A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vn=0, Vd=0, N=0, Vm=0, D=0, size=2, M=0, cond=0
    let encoding: u32 = 0x0E200A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_f_a2_a_special_size_3_size_variant_3_2048_0e200b00() {
    // Encoding: 0x0E200B00
    // Test aarch32_VMUL_f_A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Vm=0, Vn=0, size=3, Vd=0, cond=0, N=0, M=0
    let encoding: u32 = 0x0E200B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a2_a_invalid_0_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: size=0, N=0, cond=0, Vm=0, D=0, M=0, Vn=0, Vd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a2_a_invalid_1_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, cond=0, Vd=0, D=0, Vm=0, Vn=0, N=0, M=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a2_a_invalid_2_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: cond=0, Vn=0, size=0, N=0, D=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_a2_a_invalid_3_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: cond=0, Vd=0, M=0, Vn=0, N=0, Vm=0, D=0, size=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }) } }, rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_f_a2_a_invalid_4_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, Vn=0, N=0, cond=0, size=0, Vd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_f_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_f_a2_a_invalid_5_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch32_VMUL_f_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: N=0, Vd=0, D=0, Vm=0, Vn=0, size=0, cond=0, M=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_t1_a_field_d_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vn=0, Vd=0, sz=0, Q=0, M=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_t1_a_field_d_1_max_d10_ff400d10() {
    // Thumb encoding (32): 0xFF400D10
    // Test aarch32_VMUL_f_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, Q=0, D=1, N=0, sz=0, Vm=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF400D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_f_t1_a_field_sz_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field sz = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, sz=0, Vn=0, N=0, Vm=0, Q=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_f_t1_a_field_sz_1_max_d10_ff100d10() {
    // Thumb encoding (32): 0xFF100D10
    // Test aarch32_VMUL_f_T1_A field sz = 1 (Max)
    // ISET: T32
    // Fields: M=0, Q=0, sz=1, N=0, D=0, Vn=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_t1_a_field_vn_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: D=0, N=0, Q=0, Vm=0, Vn=0, M=0, sz=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_t1_a_field_vn_1_poweroftwo_d10_ff010d10() {
    // Thumb encoding (32): 0xFF010D10
    // Test aarch32_VMUL_f_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, sz=0, N=0, D=0, M=0, Vd=0, Vn=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF010D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_t1_a_field_vd_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, D=0, sz=0, Q=0, M=0, N=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_t1_a_field_vd_1_poweroftwo_d10_ff001d10() {
    // Thumb encoding (32): 0xFF001D10
    // Test aarch32_VMUL_f_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sz=0, N=0, D=0, Q=0, Vd=1, Vn=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF001D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_t1_a_field_n_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: sz=0, Vd=0, N=0, D=0, Q=0, M=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_t1_a_field_n_1_max_d10_ff000d90() {
    // Thumb encoding (32): 0xFF000D90
    // Test aarch32_VMUL_f_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vn=0, Q=0, N=1, M=0, sz=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_f_t1_a_field_q_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, sz=0, M=0, Q=0, N=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_f_t1_a_field_q_1_max_d10_ff000d50() {
    // Thumb encoding (32): 0xFF000D50
    // Test aarch32_VMUL_f_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: N=0, sz=0, Vd=0, M=0, D=0, Vn=0, Vm=0, Q=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D50;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_t1_a_field_m_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vn=0, Vm=0, sz=0, N=0, M=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_t1_a_field_m_1_max_d10_ff000d30() {
    // Thumb encoding (32): 0xFF000D30
    // Test aarch32_VMUL_f_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, Q=0, sz=0, Vn=0, Vd=0, N=0, M=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_t1_a_field_vm_0_min_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vn=0, Vd=0, Vm=0, sz=0, N=0, Q=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_t1_a_field_vm_1_poweroftwo_d10_ff000d11() {
    // Thumb encoding (32): 0xFF000D11
    // Test aarch32_VMUL_f_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, Vd=0, M=0, Vm=1, D=0, Vn=0, N=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmul_f_t1_a_combo_0_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A field combination: D=0, sz=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: sz=0, Q=0, M=0, D=0, Vd=0, Vn=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_f_t1_a_special_sz_0_size_variant_0_3344_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A special value sz = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vm=0, M=0, N=0, sz=0, Q=0, Vd=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_f_t1_a_special_sz_1_size_variant_1_3344_ff100d10() {
    // Thumb encoding (32): 0xFF100D10
    // Test aarch32_VMUL_f_T1_A special value sz = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, sz=1, Q=0, M=0, D=0, Vn=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_f_t1_a_special_q_0_size_variant_0_3344_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: M=0, D=0, Vd=0, Q=0, Vn=0, N=0, sz=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_f_t1_a_special_q_1_size_variant_1_3344_ff000d50() {
    // Thumb encoding (32): 0xFF000D50
    // Test aarch32_VMUL_f_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: sz=0, Vd=0, Q=1, D=0, M=0, Vm=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D50;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_f_t1_a_invalid_0_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, Q=0, sz=0, Vm=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_f_t1_a_invalid_1_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, Vm=0, N=0, Vd=0, M=0, Q=0, sz=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t1_a_invalid_2_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: Vd=0, D=0, N=0, M=0, Vm=0, sz=0, Q=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t1_a_invalid_3_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Q=0, sz=0, Vm=0, D=0, N=0, Vn=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t1_a_invalid_4_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }
    // ISET: T32
    // Fields: Vn=0, N=0, D=0, Vd=0, Vm=0, Q=0, M=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t1_a_invalid_5_d10_ff000d10() {
    // Thumb encoding (32): 0xFF000D10
    // Test aarch32_VMUL_f_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: sz=0, D=0, Vm=0, Vd=0, N=0, Q=0, M=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_t2_a_field_d_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vn=0, Vd=0, N=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_t2_a_field_d_1_max_800_ee600800() {
    // Thumb encoding (32): 0xEE600800
    // Test aarch32_VMUL_f_T2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, Vn=0, size=0, D=1, Vd=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE600800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_t2_a_field_vn_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vm=0, N=0, D=0, Vn=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_t2_a_field_vn_1_poweroftwo_800_ee210800() {
    // Thumb encoding (32): 0xEE210800
    // Test aarch32_VMUL_f_T2_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=1, Vm=0, D=0, N=0, Vd=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE210800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_t2_a_field_vd_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, N=0, M=0, Vm=0, Vd=0, Vn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_t2_a_field_vd_1_poweroftwo_800_ee201800() {
    // Thumb encoding (32): 0xEE201800
    // Test aarch32_VMUL_f_T2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, D=0, Vn=0, Vd=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE201800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_f_t2_a_field_size_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field size = 0 (Min)
    // ISET: T32
    // Fields: N=0, Vm=0, size=0, M=0, Vn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_f_t2_a_field_size_1_poweroftwo_800_ee200900() {
    // Thumb encoding (32): 0xEE200900
    // Test aarch32_VMUL_f_T2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, Vd=0, Vm=0, N=0, D=0, size=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_f_t2_a_field_size_2_poweroftwo_800_ee200a00() {
    // Thumb encoding (32): 0xEE200A00
    // Test aarch32_VMUL_f_T2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, Vn=0, N=0, Vm=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_f_t2_a_field_size_3_max_800_ee200b00() {
    // Thumb encoding (32): 0xEE200B00
    // Test aarch32_VMUL_f_T2_A field size = 3 (Max)
    // ISET: T32
    // Fields: N=0, D=0, Vn=0, size=3, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_t2_a_field_n_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field N = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, size=0, M=0, Vm=0, D=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_t2_a_field_n_1_max_800_ee200880() {
    // Thumb encoding (32): 0xEE200880
    // Test aarch32_VMUL_f_T2_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, Vn=0, Vd=0, N=1, size=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_f_t2_a_field_m_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Vn=0, Vm=0, size=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_f_t2_a_field_m_1_max_800_ee200820() {
    // Thumb encoding (32): 0xEE200820
    // Test aarch32_VMUL_f_T2_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, N=0, Vn=0, size=0, Vm=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_f_t2_a_field_vm_0_min_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, N=0, Vd=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_f_t2_a_field_vm_1_poweroftwo_800_ee200801() {
    // Thumb encoding (32): 0xEE200801
    // Test aarch32_VMUL_f_T2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=1, M=0, Vd=0, D=0, size=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmul_f_t2_a_combo_0_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A field combination: D=0, Vn=0, Vd=0, size=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, Vn=0, size=0, N=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_f_t2_a_special_size_0_size_variant_0_2048_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, Vm=0, M=0, D=0, size=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_f_t2_a_special_size_1_size_variant_1_2048_ee200900() {
    // Thumb encoding (32): 0xEE200900
    // Test aarch32_VMUL_f_T2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: M=0, Vd=0, Vm=0, D=0, Vn=0, size=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_f_t2_a_special_size_2_size_variant_2_2048_ee200a00() {
    // Thumb encoding (32): 0xEE200A00
    // Test aarch32_VMUL_f_T2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vn=0, N=0, M=0, Vm=0, D=0, size=2, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_f_t2_a_special_size_3_size_variant_3_2048_ee200b00() {
    // Thumb encoding (32): 0xEE200B00
    // Test aarch32_VMUL_f_T2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, M=0, Vn=0, Vm=0, size=3, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_f_t2_a_invalid_0_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: Vn=0, M=0, Vm=0, D=0, N=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_f_t2_a_invalid_1_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, size=0, Vn=0, N=0, M=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t2_a_invalid_2_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: Vd=0, N=0, Vm=0, size=0, D=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t2_a_invalid_3_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, N=0, M=0, Vm=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t2_a_invalid_4_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: Vn=0, Vd=0, Vm=0, M=0, D=0, size=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_f_t2_a_invalid_5_800_ee200800() {
    // Thumb encoding (32): 0xEE200800
    // Test aarch32_VMUL_f_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: N=0, M=0, size=0, Vm=0, D=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_VMUL_f_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_vmul_f_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

// ============================================================================
// aarch32_VMUL_i_A Tests
// ============================================================================

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_a2_a_field_u_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: size=0, M=0, N=0, U=0, op=0, Vn=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_a2_a_field_u_1_max_c00_f3800c00() {
    // Encoding: 0xF3800C00
    // Test aarch32_VMUL_i_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: D=0, U=1, op=0, Vd=0, size=0, Vn=0, M=0, Vm=0, N=0
    let encoding: u32 = 0xF3800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_a2_a_field_d_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, size=0, M=0, op=0, U=0, N=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_a2_a_field_d_1_max_c00_f2c00c00() {
    // Encoding: 0xF2C00C00
    // Test aarch32_VMUL_i_A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, size=0, op=0, D=1, N=0, U=0, Vd=0, Vm=0, M=0
    let encoding: u32 = 0xF2C00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_i_a2_a_field_size_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, op=0, Vm=0, size=0, U=0, Vn=0, N=0, M=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_i_a2_a_field_size_1_poweroftwo_c00_f2900c00() {
    // Encoding: 0xF2900C00
    // Test aarch32_VMUL_i_A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, op=0, Vm=0, M=0, Vd=0, N=0, U=0, Vn=0, size=1
    let encoding: u32 = 0xF2900C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_i_a2_a_field_size_2_poweroftwo_c00_f2a00c00() {
    // Encoding: 0xF2A00C00
    // Test aarch32_VMUL_i_A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, N=0, Vn=0, M=0, Vm=0, op=0, U=0, size=2, Vd=0
    let encoding: u32 = 0xF2A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_i_a2_a_field_size_3_max_c00_f2b00c00() {
    // Encoding: 0xF2B00C00
    // Test aarch32_VMUL_i_A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: N=0, D=0, size=3, op=0, Vn=0, Vm=0, M=0, Vd=0, U=0
    let encoding: u32 = 0xF2B00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_a2_a_field_vn_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, op=0, size=0, D=0, M=0, U=0, N=0, Vn=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_a2_a_field_vn_1_poweroftwo_c00_f2810c00() {
    // Encoding: 0xF2810C00
    // Test aarch32_VMUL_i_A2_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, size=0, U=0, N=0, M=0, op=0, D=0, Vn=1, Vd=0
    let encoding: u32 = 0xF2810C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_a2_a_field_vd_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vm=0, U=0, Vn=0, op=0, D=0, Vd=0, M=0, N=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_a2_a_field_vd_1_poweroftwo_c00_f2801c00() {
    // Encoding: 0xF2801C00
    // Test aarch32_VMUL_i_A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Vm=0, size=0, op=0, N=0, D=0, Vd=1, M=0, U=0
    let encoding: u32 = 0xF2801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_a2_a_field_op_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field op = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, U=0, op=0, size=0, Vn=0, Vm=0, N=0, M=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_a2_a_field_op_1_max_c00_f2800e00() {
    // Encoding: 0xF2800E00
    // Test aarch32_VMUL_i_A2_A field op = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, Vm=0, size=0, M=0, D=0, U=0, op=1, Vn=0, N=0
    let encoding: u32 = 0xF2800E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_a2_a_field_n_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field N = 0 (Min)
    // ISET: A32
    // Fields: U=0, op=0, N=0, Vn=0, Vm=0, M=0, size=0, Vd=0, D=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_a2_a_field_n_1_max_c00_f2800c80() {
    // Encoding: 0xF2800C80
    // Test aarch32_VMUL_i_A2_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, D=0, Vn=0, op=0, Vm=0, U=0, size=0, Vd=0, M=0
    let encoding: u32 = 0xF2800C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_a2_a_field_m_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: N=0, Vn=0, op=0, M=0, U=0, D=0, Vd=0, Vm=0, size=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_a2_a_field_m_1_max_c00_f2800c20() {
    // Encoding: 0xF2800C20
    // Test aarch32_VMUL_i_A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, size=0, N=0, Vm=0, Vn=0, M=1, U=0, op=0, D=0
    let encoding: u32 = 0xF2800C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_a2_a_field_vm_0_min_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: size=0, M=0, D=0, Vm=0, N=0, Vn=0, U=0, Vd=0, op=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_a2_a_field_vm_1_poweroftwo_c00_f2800c01() {
    // Encoding: 0xF2800C01
    // Test aarch32_VMUL_i_A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, Vm=1, U=0, M=0, size=0, N=0, op=0, Vn=0
    let encoding: u32 = 0xF2800C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmul_i_a2_a_combo_0_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, op=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vd=0, size=0, Vn=0, op=0, N=0, Vm=0, M=0, D=0, U=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_i_a2_a_special_size_0_size_variant_0_3072_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: U=0, op=0, Vm=0, Vn=0, D=0, Vd=0, N=0, size=0, M=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_i_a2_a_special_size_1_size_variant_1_3072_f2900c00() {
    // Encoding: 0xF2900C00
    // Test aarch32_VMUL_i_A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, M=0, op=0, Vd=0, N=0, U=0, Vm=0, Vn=0, size=1
    let encoding: u32 = 0xF2900C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_i_a2_a_special_size_2_size_variant_2_3072_f2a00c00() {
    // Encoding: 0xF2A00C00
    // Test aarch32_VMUL_i_A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: M=0, size=2, U=0, Vd=0, op=0, Vm=0, N=0, Vn=0, D=0
    let encoding: u32 = 0xF2A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_i_a2_a_special_size_3_size_variant_3_3072_f2b00c00() {
    // Encoding: 0xF2B00C00
    // Test aarch32_VMUL_i_A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, U=0, op=0, Vm=0, size=3, N=0, M=0, Vd=0, Vn=0
    let encoding: u32 = 0xF2B00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_a2_a_invalid_0_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, true]) }
    // ISET: A32
    // Fields: size=0, N=0, Vd=0, op=0, M=0, D=0, Vn=0, U=0, Vm=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_a2_a_invalid_1_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, op=0, M=0, U=0, N=0, Vn=0, Vm=0, D=0, size=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveBit128PMULLExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveBit128PMULLExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_a2_a_invalid_2_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveBit128PMULLExt" }, args: [] } }
    // ISET: A32
    // Fields: U=0, D=0, Vn=0, M=0, N=0, op=0, Vm=0, size=0, Vd=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_a2_a_invalid_3_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, op=0, Vn=0, N=0, U=0, D=0, Vm=0, size=0, M=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_a2_a_invalid_4_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vn=0, op=0, D=0, N=0, Vd=0, U=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_a2_a_invalid_5_c00_f2800c00() {
    // Encoding: 0xF2800C00
    // Test aarch32_VMUL_i_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, D=0, U=0, Vn=0, op=0, M=0, Vd=0, N=0, Vm=0
    let encoding: u32 = 0xF2800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t2_a_field_u_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field U = 0 (Min)
    // ISET: T32
    // Fields: N=0, size=0, Vn=0, U=0, Vd=0, Vm=0, M=0, op=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t2_a_field_u_1_max_c00_ff800c00() {
    // Thumb encoding (32): 0xFF800C00
    // Test aarch32_VMUL_i_T2_A field U = 1 (Max)
    // ISET: T32
    // Fields: N=0, Vn=0, D=0, M=0, U=1, size=0, op=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t2_a_field_d_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vn=0, Vd=0, N=0, M=0, U=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t2_a_field_d_1_max_c00_efc00c00() {
    // Thumb encoding (32): 0xEFC00C00
    // Test aarch32_VMUL_i_T2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, op=0, D=1, Vd=0, Vm=0, U=0, size=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_i_t2_a_field_size_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field size = 0 (Min)
    // ISET: T32
    // Fields: U=0, M=0, size=0, op=0, Vn=0, D=0, Vd=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_i_t2_a_field_size_1_poweroftwo_c00_ef900c00() {
    // Thumb encoding (32): 0xEF900C00
    // Test aarch32_VMUL_i_T2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, op=0, size=1, D=0, U=0, N=0, M=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_i_t2_a_field_size_2_poweroftwo_c00_efa00c00() {
    // Thumb encoding (32): 0xEFA00C00
    // Test aarch32_VMUL_i_T2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, size=2, Vm=0, M=0, Vn=0, N=0, D=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_i_t2_a_field_size_3_max_c00_efb00c00() {
    // Thumb encoding (32): 0xEFB00C00
    // Test aarch32_VMUL_i_T2_A field size = 3 (Max)
    // ISET: T32
    // Fields: op=0, N=0, size=3, Vm=0, Vd=0, U=0, Vn=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t2_a_field_vn_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vd=0, M=0, D=0, Vm=0, N=0, Vn=0, size=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t2_a_field_vn_1_poweroftwo_c00_ef810c00() {
    // Thumb encoding (32): 0xEF810C00
    // Test aarch32_VMUL_i_T2_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, op=0, size=0, Vn=1, M=0, Vm=0, N=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t2_a_field_vd_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, D=0, M=0, N=0, size=0, Vd=0, U=0, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t2_a_field_vd_1_poweroftwo_c00_ef801c00() {
    // Thumb encoding (32): 0xEF801C00
    // Test aarch32_VMUL_i_T2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Vm=0, N=0, D=0, size=0, Vd=1, Vn=0, op=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t2_a_field_op_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field op = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vn=0, size=0, M=0, Vd=0, D=0, N=0, U=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field op 9 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t2_a_field_op_1_max_c00_ef800e00() {
    // Thumb encoding (32): 0xEF800E00
    // Test aarch32_VMUL_i_T2_A field op = 1 (Max)
    // ISET: T32
    // Fields: op=1, D=0, N=0, size=0, U=0, M=0, Vd=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t2_a_field_n_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field N = 0 (Min)
    // ISET: T32
    // Fields: D=0, op=0, Vn=0, U=0, M=0, Vm=0, size=0, N=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t2_a_field_n_1_max_c00_ef800c80() {
    // Thumb encoding (32): 0xEF800C80
    // Test aarch32_VMUL_i_T2_A field N = 1 (Max)
    // ISET: T32
    // Fields: N=1, U=0, M=0, Vm=0, op=0, size=0, D=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t2_a_field_m_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field M = 0 (Min)
    // ISET: T32
    // Fields: size=0, N=0, D=0, U=0, Vn=0, M=0, op=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t2_a_field_m_1_max_c00_ef800c20() {
    // Thumb encoding (32): 0xEF800C20
    // Test aarch32_VMUL_i_T2_A field M = 1 (Max)
    // ISET: T32
    // Fields: U=0, Vm=0, D=0, size=0, Vd=0, Vn=0, N=0, M=1, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t2_a_field_vm_0_min_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vn=0, op=0, N=0, U=0, D=0, Vd=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t2_a_field_vm_1_poweroftwo_c00_ef800c01() {
    // Thumb encoding (32): 0xEF800C01
    // Test aarch32_VMUL_i_T2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vm=1, Vd=0, op=0, M=0, U=0, N=0, size=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmul_i_t2_a_combo_0_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, op=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: op=0, Vm=0, N=0, size=0, U=0, Vn=0, Vd=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_i_t2_a_special_size_0_size_variant_0_3072_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, op=0, D=0, Vm=0, U=0, M=0, N=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_i_t2_a_special_size_1_size_variant_1_3072_ef900c00() {
    // Thumb encoding (32): 0xEF900C00
    // Test aarch32_VMUL_i_T2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: op=0, D=0, U=0, N=0, Vn=0, Vd=0, M=0, Vm=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_i_t2_a_special_size_2_size_variant_2_3072_efa00c00() {
    // Thumb encoding (32): 0xEFA00C00
    // Test aarch32_VMUL_i_T2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, op=0, D=0, U=0, M=0, Vd=0, Vm=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_i_t2_a_special_size_3_size_variant_3_3072_efb00c00() {
    // Thumb encoding (32): 0xEFB00C00
    // Test aarch32_VMUL_i_T2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vn=0, D=0, size=3, M=0, U=0, Vm=0, op=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_0_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, true]) }
    // ISET: T32
    // Fields: Vd=0, N=0, D=0, size=0, Vm=0, M=0, op=0, Vn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_1_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, M=0, size=0, D=0, op=0, N=0, Vd=0, U=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_2_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vn=0, N=0, size=0, M=0, D=0, U=0, Vm=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_3_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Vm=0, U=0, D=0, Vn=0, N=0, size=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveBit128PMULLExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveBit128PMULLExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_4_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveBit128PMULLExt" }, args: [] } }
    // ISET: T32
    // Fields: U=0, Vn=0, size=0, N=0, M=0, D=0, op=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_5_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: N=0, D=0, Vm=0, op=0, Vd=0, size=0, Vn=0, U=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_6_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, size=0, Vn=0, Vm=0, op=0, M=0, Vd=0, U=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t2_a_invalid_7_c00_ef800c00() {
    // Thumb encoding (32): 0xEF800C00
    // Test aarch32_VMUL_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: U=0, N=0, op=0, M=0, Vm=0, Vn=0, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_0_f2802c20() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_0_f2802c20() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_1_f2800c20() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_1_f2800c20() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_2_f2800c20() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_2_f2800c20() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_3_f2bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_3_f2bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_4_f2fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_4_f2fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_5_f2800c20() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_5_f2800c20() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_6_f2800c20() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_6_f2800c20() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_7_f2800c20() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_7_f2800c20() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_8_f2800c20() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_8_f2800c20() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_9_f2800c20() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_9_f2800c20() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_10_f2800c20() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_10_f2800c20() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_32_rd31_sp_f2802c3f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmul_i_a2_a_add_oracle_64_rd31_sp_f2802c3f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_0_f2802c20() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_0_f2802c20() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_1_f2800c20() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_1_f2800c20() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_2_f2800c20() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_2_f2800c20() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_3_f2bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_3_f2bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_4_f2fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_4_f2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_5_f2800c20() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_5_f2800c20() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_6_f2800c20() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_6_f2800c20() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_7_f2800c20() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_7_f2800c20() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_8_f2800c20() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_8_f2800c20() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_9_f2800c20() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_9_f2800c20() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_10_f2800c20() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_10_f2800c20() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_32_rd31_zr_f2802c3f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmul_i_a2_a_adds_oracle_64_rd31_zr_f2802c3f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_0_f2802c20() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_0_f2802c20() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_1_f2800c20() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_1_f2800c20() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_2_f2800c20() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_2_f2800c20() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_3_f2bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_3_f2bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_4_f2fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_4_f2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_5_f2800c20() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_5_f2800c20() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_6_f2800c20() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_6_f2800c20() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_7_f2800c20() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_7_f2800c20() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_8_f2800c20() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_8_f2800c20() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_9_f2800c20() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_9_f2800c20() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_10_f2800c20() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_10_f2800c20() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_32_rd31_sp_f2802c3f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmul_i_a2_a_sub_oracle_64_rd31_sp_f2802c3f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_0_f2802c20() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_0_f2802c20() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x59, "X0 should be 0x0000000000000059");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_1_f2800c20() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_1_f2800c20() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_2_f2800c20() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_2_f2800c20() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_3_f2bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_3_f2bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_4_f2fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_4_f2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_5_f2800c20() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_5_f2800c20() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_6_f2800c20() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_6_f2800c20() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_7_f2800c20() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_7_f2800c20() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x7FFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_8_f2800c20() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_8_f2800c20() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFC,
        "X0 should be 0x000000007FFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_9_f2800c20() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_9_f2800c20() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0xFFFFFFFFFFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_10_f2800c20() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_10_f2800c20() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFC,
        "X0 should be 0x00000000FFFFFFFC"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_32_rd31_zr_f2802c3f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmul_i_a2_a_subs_oracle_64_rd31_zr_f2802c3f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF2802C3F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802C3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMUL_i_A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_a2_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMLA_f_A Tests
// ============================================================================

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a1_a_field_d_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: N=0, op=0, sz=0, Vd=0, M=0, Q=0, Vn=0, Vm=0, D=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a1_a_field_d_1_max_d10_f2400d10() {
    // Encoding: 0xF2400D10
    // Test aarch32_VMLA_f_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, Vn=0, M=0, Vd=0, op=0, sz=0, D=1, Q=0, N=0
    let encoding: u32 = 0xF2400D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field op 21 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a1_a_field_op_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vd=0, M=0, sz=0, Q=0, Vm=0, D=0, Vn=0, N=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field op 21 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a1_a_field_op_1_max_d10_f2200d10() {
    // Encoding: 0xF2200D10
    // Test aarch32_VMLA_f_A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: sz=0, op=1, Vn=0, N=0, Vd=0, M=0, Vm=0, Q=0, D=0
    let encoding: u32 = 0xF2200D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_f_a1_a_field_sz_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field sz = 0 (Min)
    // ISET: A32
    // Fields: N=0, Q=0, Vn=0, M=0, Vd=0, op=0, sz=0, Vm=0, D=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_f_a1_a_field_sz_1_max_d10_f2100d10() {
    // Encoding: 0xF2100D10
    // Test aarch32_VMLA_f_A1_A field sz = 1 (Max)
    // ISET: A32
    // Fields: sz=1, D=0, M=0, N=0, op=0, Q=0, Vn=0, Vd=0, Vm=0
    let encoding: u32 = 0xF2100D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_a1_a_field_vn_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vd=0, M=0, op=0, Vn=0, D=0, N=0, Vm=0, sz=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_a1_a_field_vn_1_poweroftwo_d10_f2010d10() {
    // Encoding: 0xF2010D10
    // Test aarch32_VMLA_f_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, M=0, op=0, Vn=1, N=0, sz=0, D=0, Vm=0, Q=0
    let encoding: u32 = 0xF2010D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_a1_a_field_vd_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vn=0, sz=0, D=0, Vm=0, Vd=0, N=0, op=0, M=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_a1_a_field_vd_1_poweroftwo_d10_f2001d10() {
    // Encoding: 0xF2001D10
    // Test aarch32_VMLA_f_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, op=0, Q=0, N=0, sz=0, Vn=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF2001D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a1_a_field_n_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: N=0, M=0, D=0, Q=0, op=0, Vn=0, sz=0, Vd=0, Vm=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a1_a_field_n_1_max_d10_f2000d90() {
    // Encoding: 0xF2000D90
    // Test aarch32_VMLA_f_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Q=0, Vd=0, Vm=0, sz=0, D=0, op=0, Vn=0, M=0, N=1
    let encoding: u32 = 0xF2000D90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_f_a1_a_field_q_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vm=0, M=0, Vd=0, N=0, Vn=0, D=0, sz=0, Q=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_f_a1_a_field_q_1_max_d10_f2000d50() {
    // Encoding: 0xF2000D50
    // Test aarch32_VMLA_f_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: sz=0, op=0, Vn=0, D=0, M=0, Vm=0, N=0, Q=1, Vd=0
    let encoding: u32 = 0xF2000D50;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a1_a_field_m_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vd=0, M=0, Vm=0, N=0, Q=0, D=0, sz=0, Vn=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a1_a_field_m_1_max_d10_f2000d30() {
    // Encoding: 0xF2000D30
    // Test aarch32_VMLA_f_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: N=0, M=1, Vm=0, Vd=0, sz=0, D=0, op=0, Vn=0, Q=0
    let encoding: u32 = 0xF2000D30;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_a1_a_field_vm_0_min_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Q=0, N=0, Vn=0, Vd=0, Vm=0, op=0, M=0, sz=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_a1_a_field_vm_1_poweroftwo_d10_f2000d11() {
    // Encoding: 0xF2000D11
    // Test aarch32_VMLA_f_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, op=0, Vn=0, sz=0, M=0, D=0, Vm=1, Q=0, N=0
    let encoding: u32 = 0xF2000D11;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmla_f_a1_a_combo_0_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A field combination: D=0, op=0, sz=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vd=0, op=0, N=0, Vn=0, sz=0, Q=0, D=0, Vm=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_f_a1_a_special_sz_0_size_variant_0_3344_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A special value sz = 0 (Size variant 0)
    // ISET: A32
    // Fields: M=0, Vd=0, D=0, Vm=0, Vn=0, op=0, sz=0, N=0, Q=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_f_a1_a_special_sz_1_size_variant_1_3344_f2100d10() {
    // Encoding: 0xF2100D10
    // Test aarch32_VMLA_f_A1_A special value sz = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vm=0, Vd=0, Q=0, M=0, op=0, N=0, D=0, sz=1, Vn=0
    let encoding: u32 = 0xF2100D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_f_a1_a_special_q_0_size_variant_0_3344_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: M=0, op=0, Vd=0, sz=0, N=0, Q=0, Vn=0, Vm=0, D=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_f_a1_a_special_q_1_size_variant_1_3344_f2000d50() {
    // Encoding: 0xF2000D50
    // Test aarch32_VMLA_f_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vm=0, op=0, sz=0, Vn=0, N=0, Q=1, M=0, D=0, Vd=0
    let encoding: u32 = 0xF2000D50;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a1_a_invalid_0_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: op=0, Vd=0, Vn=0, N=0, Q=0, D=0, M=0, sz=0, Vm=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a1_a_invalid_1_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vm=0, Vn=0, Q=0, M=0, D=0, sz=0, op=0, N=0, Vd=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a1_a_invalid_2_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }
    // ISET: A32
    // Fields: N=0, M=0, Vm=0, sz=0, Vn=0, Vd=0, D=0, Q=0, op=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a1_a_invalid_3_d10_f2000d10() {
    // Encoding: 0xF2000D10
    // Test aarch32_VMLA_f_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, Vn=0, D=0, sz=0, M=0, op=0, Vd=0, Q=0, Vm=0
    let encoding: u32 = 0xF2000D10;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, cond=0, D=0, op=0, Vm=0, Vn=0, N=0, size=0, M=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_1_poweroftwo_800_1e000800() {
    // Encoding: 0x1E000800
    // Test aarch32_VMLA_f_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, Vd=0, Vn=0, Vm=0, cond=1, size=0, N=0, op=0
    let encoding: u32 = 0x1E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_2_poweroftwo_800_2e000800() {
    // Encoding: 0x2E000800
    // Test aarch32_VMLA_f_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=2, N=0, D=0, Vd=0, Vn=0, size=0, op=0, Vm=0
    let encoding: u32 = 0x2E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_3_poweroftwo_800_3e000800() {
    // Encoding: 0x3E000800
    // Test aarch32_VMLA_f_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Vm=0, cond=3, op=0, D=0, Vn=0, size=0, Vd=0, M=0
    let encoding: u32 = 0x3E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_4_poweroftwo_800_4e000800() {
    // Encoding: 0x4E000800
    // Test aarch32_VMLA_f_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=4, Vd=0, Vm=0, size=0, N=0, op=0, M=0, Vn=0
    let encoding: u32 = 0x4E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_5_poweroftwo_800_5e000800() {
    // Encoding: 0x5E000800
    // Test aarch32_VMLA_f_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vn=0, Vm=0, op=0, size=0, Vd=0, cond=5, D=0, N=0
    let encoding: u32 = 0x5E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_6_poweroftwo_800_6e000800() {
    // Encoding: 0x6E000800
    // Test aarch32_VMLA_f_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Vn=0, D=0, cond=6, size=0, M=0, op=0, N=0, Vm=0
    let encoding: u32 = 0x6E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_7_poweroftwo_800_7e000800() {
    // Encoding: 0x7E000800
    // Test aarch32_VMLA_f_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, N=0, cond=7, op=0, M=0, size=0, Vn=0, Vm=0
    let encoding: u32 = 0x7E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_8_poweroftwo_800_8e000800() {
    // Encoding: 0x8E000800
    // Test aarch32_VMLA_f_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=0, Vn=0, op=0, M=0, cond=8, size=0, N=0
    let encoding: u32 = 0x8E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_9_poweroftwo_800_9e000800() {
    // Encoding: 0x9E000800
    // Test aarch32_VMLA_f_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, N=0, M=0, Vm=0, Vn=0, cond=9, op=0, Vd=0, size=0
    let encoding: u32 = 0x9E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_10_poweroftwo_800_ae000800() {
    // Encoding: 0xAE000800
    // Test aarch32_VMLA_f_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, N=0, Vd=0, cond=10, M=0, Vn=0, D=0, op=0, Vm=0
    let encoding: u32 = 0xAE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_11_poweroftwo_800_be000800() {
    // Encoding: 0xBE000800
    // Test aarch32_VMLA_f_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, N=0, Vm=0, op=0, cond=11, Vn=0, D=0
    let encoding: u32 = 0xBE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_12_poweroftwo_800_ce000800() {
    // Encoding: 0xCE000800
    // Test aarch32_VMLA_f_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, D=0, op=0, cond=12, size=0, Vd=0, Vn=0, Vm=0, N=0
    let encoding: u32 = 0xCE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_13_poweroftwo_800_de000800() {
    // Encoding: 0xDE000800
    // Test aarch32_VMLA_f_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, D=0, op=0, M=0, size=0, Vm=0, Vn=0, N=0, Vd=0
    let encoding: u32 = 0xDE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_14_poweroftwo_800_ee000800() {
    // Encoding: 0xEE000800
    // Test aarch32_VMLA_f_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=14, size=0, Vd=0, M=0, op=0, Vm=0, N=0, Vn=0
    let encoding: u32 = 0xEE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_vmla_f_a2_a_field_cond_15_max_800_fe000800() {
    // Encoding: 0xFE000800
    // Test aarch32_VMLA_f_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Vd=0, Vn=0, size=0, D=0, N=0, Vm=0, cond=15, op=0, M=0
    let encoding: u32 = 0xFE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a2_a_field_d_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, Vm=0, cond=0, size=0, M=0, Vd=0, N=0, op=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a2_a_field_d_1_max_800_0e400800() {
    // Encoding: 0x0E400800
    // Test aarch32_VMLA_f_A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, size=0, N=0, Vn=0, M=0, Vm=0, cond=0, D=1, op=0
    let encoding: u32 = 0x0E400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_a2_a_field_vn_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: N=0, size=0, Vn=0, op=0, cond=0, M=0, Vd=0, Vm=0, D=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_a2_a_field_vn_1_poweroftwo_800_0e010800() {
    // Encoding: 0x0E010800
    // Test aarch32_VMLA_f_A2_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, size=0, Vd=0, M=0, D=0, Vn=1, op=0, Vm=0, N=0
    let encoding: u32 = 0x0E010800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_a2_a_field_vd_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, N=0, Vd=0, Vn=0, M=0, op=0, cond=0, Vm=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_a2_a_field_vd_1_poweroftwo_800_0e001800() {
    // Encoding: 0x0E001800
    // Test aarch32_VMLA_f_A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, M=0, Vn=0, size=0, Vm=0, Vd=1, op=0, cond=0, D=0
    let encoding: u32 = 0x0E001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_f_a2_a_field_size_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vn=0, cond=0, op=0, size=0, N=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_f_a2_a_field_size_1_poweroftwo_800_0e000900() {
    // Encoding: 0x0E000900
    // Test aarch32_VMLA_f_A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, D=0, op=0, size=1, cond=0, Vm=0, N=0, Vn=0, Vd=0
    let encoding: u32 = 0x0E000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_f_a2_a_field_size_2_poweroftwo_800_0e000a00() {
    // Encoding: 0x0E000A00
    // Test aarch32_VMLA_f_A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, cond=0, Vd=0, Vn=0, M=0, Vm=0, op=0, size=2, N=0
    let encoding: u32 = 0x0E000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_f_a2_a_field_size_3_max_800_0e000b00() {
    // Encoding: 0x0E000B00
    // Test aarch32_VMLA_f_A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vn=0, op=0, D=0, M=0, N=0, Vd=0, size=3, cond=0, Vm=0
    let encoding: u32 = 0x0E000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a2_a_field_n_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field N = 0 (Min)
    // ISET: A32
    // Fields: size=0, M=0, Vd=0, cond=0, D=0, N=0, op=0, Vm=0, Vn=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a2_a_field_n_1_max_800_0e000880() {
    // Encoding: 0x0E000880
    // Test aarch32_VMLA_f_A2_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, M=0, Vn=0, size=0, Vm=0, D=0, op=0, Vd=0, cond=0
    let encoding: u32 = 0x0E000880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field op 6 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a2_a_field_op_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field op = 0 (Min)
    // ISET: A32
    // Fields: cond=0, size=0, op=0, N=0, Vn=0, Vm=0, M=0, Vd=0, D=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field op 6 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a2_a_field_op_1_max_800_0e000840() {
    // Encoding: 0x0E000840
    // Test aarch32_VMLA_f_A2_A field op = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, cond=0, size=0, N=0, Vd=0, D=0, Vm=0, op=1, M=0
    let encoding: u32 = 0x0E000840;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_a2_a_field_m_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, op=0, size=0, N=0, Vn=0, M=0, Vm=0, D=0, cond=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_a2_a_field_m_1_max_800_0e000820() {
    // Encoding: 0x0E000820
    // Test aarch32_VMLA_f_A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: M=1, Vm=0, Vn=0, D=0, cond=0, Vd=0, N=0, size=0, op=0
    let encoding: u32 = 0x0E000820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_a2_a_field_vm_0_min_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: N=0, op=0, M=0, Vm=0, Vn=0, D=0, size=0, Vd=0, cond=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_a2_a_field_vm_1_poweroftwo_800_0e000801() {
    // Encoding: 0x0E000801
    // Test aarch32_VMLA_f_A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vm=1, N=0, Vn=0, M=0, op=0, Vd=0, size=0, cond=0
    let encoding: u32 = 0x0E000801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_vmla_f_a2_a_combo_0_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A field combination: cond=0, D=0, Vn=0, Vd=0, size=0, N=0, op=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, N=0, Vm=0, op=0, Vn=0, cond=0, D=0, Vd=0, size=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_0_condition_eq_2048_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Vn=0, D=0, M=0, Vm=0, Vd=0, size=0, op=0, cond=0, N=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_1_condition_ne_2048_1e000800() {
    // Encoding: 0x1E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Vn=0, M=0, Vm=0, N=0, op=0, cond=1, Vd=0, D=0, size=0
    let encoding: u32 = 0x1E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_2_condition_cs_hs_2048_2e000800() {
    // Encoding: 0x2E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, size=0, op=0, Vm=0, Vn=0, D=0, N=0, M=0, Vd=0
    let encoding: u32 = 0x2E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_3_condition_cc_lo_2048_3e000800() {
    // Encoding: 0x3E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: N=0, Vn=0, Vm=0, Vd=0, op=0, size=0, cond=3, M=0, D=0
    let encoding: u32 = 0x3E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_4_condition_mi_2048_4e000800() {
    // Encoding: 0x4E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: D=0, size=0, cond=4, Vd=0, op=0, N=0, M=0, Vn=0, Vm=0
    let encoding: u32 = 0x4E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_5_condition_pl_2048_5e000800() {
    // Encoding: 0x5E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Vd=0, D=0, N=0, op=0, Vm=0, Vn=0, size=0, cond=5, M=0
    let encoding: u32 = 0x5E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_6_condition_vs_2048_6e000800() {
    // Encoding: 0x6E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: N=0, D=0, size=0, Vn=0, Vm=0, M=0, cond=6, op=0, Vd=0
    let encoding: u32 = 0x6E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_7_condition_vc_2048_7e000800() {
    // Encoding: 0x7E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Vd=0, Vn=0, M=0, op=0, size=0, N=0, D=0, cond=7, Vm=0
    let encoding: u32 = 0x7E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_8_condition_hi_2048_8e000800() {
    // Encoding: 0x8E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Vm=0, Vn=0, cond=8, op=0, M=0, Vd=0, N=0, D=0, size=0
    let encoding: u32 = 0x8E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_9_condition_ls_2048_9e000800() {
    // Encoding: 0x9E000800
    // Test aarch32_VMLA_f_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Vn=0, op=0, size=0, Vd=0, M=0, Vm=0, cond=9, N=0, D=0
    let encoding: u32 = 0x9E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_10_condition_ge_2048_ae000800() {
    // Encoding: 0xAE000800
    // Test aarch32_VMLA_f_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: size=0, Vn=0, N=0, cond=10, op=0, M=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xAE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_11_condition_lt_2048_be000800() {
    // Encoding: 0xBE000800
    // Test aarch32_VMLA_f_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Vd=0, D=0, Vm=0, op=0, M=0, Vn=0, N=0, size=0, cond=11
    let encoding: u32 = 0xBE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_12_condition_gt_2048_ce000800() {
    // Encoding: 0xCE000800
    // Test aarch32_VMLA_f_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, op=0, Vd=0, M=0, Vn=0, Vm=0, N=0, D=0, size=0
    let encoding: u32 = 0xCE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_13_condition_le_2048_de000800() {
    // Encoding: 0xDE000800
    // Test aarch32_VMLA_f_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Vm=0, Vn=0, op=0, Vd=0, N=0, M=0, size=0, D=0, cond=13
    let encoding: u32 = 0xDE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_14_condition_al_2048_ee000800() {
    // Encoding: 0xEE000800
    // Test aarch32_VMLA_f_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Vm=0, Vn=0, N=0, D=0, Vd=0, size=0, M=0, cond=14, op=0
    let encoding: u32 = 0xEE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_vmla_f_a2_a_special_cond_15_condition_nv_2048_fe000800() {
    // Encoding: 0xFE000800
    // Test aarch32_VMLA_f_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: D=0, cond=15, N=0, Vm=0, op=0, size=0, Vn=0, M=0, Vd=0
    let encoding: u32 = 0xFE000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_f_a2_a_special_size_0_size_variant_0_2048_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, D=0, N=0, op=0, Vn=0, Vd=0, cond=0, size=0, M=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_f_a2_a_special_size_1_size_variant_1_2048_0e000900() {
    // Encoding: 0x0E000900
    // Test aarch32_VMLA_f_A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, Vm=0, op=0, M=0, N=0, Vd=0, Vn=0, size=1, D=0
    let encoding: u32 = 0x0E000900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_f_a2_a_special_size_2_size_variant_2_2048_0e000a00() {
    // Encoding: 0x0E000A00
    // Test aarch32_VMLA_f_A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vn=0, Vm=0, N=0, size=2, op=0, cond=0, Vd=0, M=0, D=0
    let encoding: u32 = 0x0E000A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_f_a2_a_special_size_3_size_variant_3_2048_0e000b00() {
    // Encoding: 0x0E000B00
    // Test aarch32_VMLA_f_A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: M=0, Vn=0, Vd=0, N=0, Vm=0, D=0, size=3, cond=0, op=0
    let encoding: u32 = 0x0E000B00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a2_a_invalid_0_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vd=0, op=0, Vm=0, Vn=0, N=0, cond=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a2_a_invalid_1_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, Vm=0, M=0, Vd=0, cond=0, size=0, op=0, N=0, D=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }) } }, rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_f_a2_a_invalid_2_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }) } }, rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: Vn=0, N=0, size=0, M=0, Vm=0, op=0, cond=0, D=0, Vd=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_f_a2_a_invalid_3_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Vm=0, M=0, N=0, D=0, Vd=0, op=0, Vn=0, size=0, cond=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a2_a_invalid_4_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: M=0, size=0, N=0, Vn=0, op=0, Vm=0, D=0, cond=0, Vd=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_a2_a_invalid_5_800_0e000800() {
    // Encoding: 0x0E000800
    // Test aarch32_VMLA_f_A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: cond=0, M=0, N=0, Vn=0, op=0, D=0, Vd=0, size=0, Vm=0
    let encoding: u32 = 0x0E000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t1_a_field_d_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, op=0, sz=0, Q=0, Vn=0, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t1_a_field_d_1_max_d10_ef400d10() {
    // Thumb encoding (32): 0xEF400D10
    // Test aarch32_VMLA_f_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, M=0, N=0, D=1, sz=0, Vn=0, Q=0, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF400D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field op 21 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t1_a_field_op_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field op = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vn=0, sz=0, D=0, M=0, N=0, Vm=0, Q=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field op 21 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t1_a_field_op_1_max_d10_ef200d10() {
    // Thumb encoding (32): 0xEF200D10
    // Test aarch32_VMLA_f_T1_A field op = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, D=0, Vm=0, Vd=0, op=1, M=0, sz=0, Q=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_f_t1_a_field_sz_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field sz = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, Vd=0, D=0, sz=0, N=0, op=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field sz 20 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_f_t1_a_field_sz_1_max_d10_ef100d10() {
    // Thumb encoding (32): 0xEF100D10
    // Test aarch32_VMLA_f_T1_A field sz = 1 (Max)
    // ISET: T32
    // Fields: sz=1, N=0, Vd=0, op=0, Vm=0, D=0, Vn=0, M=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_t1_a_field_vn_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, sz=0, Q=0, Vm=0, D=0, op=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_t1_a_field_vn_1_poweroftwo_d10_ef010d10() {
    // Thumb encoding (32): 0xEF010D10
    // Test aarch32_VMLA_f_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=0, op=0, Q=0, Vn=1, D=0, sz=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF010D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_t1_a_field_vd_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, op=0, N=0, sz=0, Vn=0, M=0, Q=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_t1_a_field_vd_1_poweroftwo_d10_ef001d10() {
    // Thumb encoding (32): 0xEF001D10
    // Test aarch32_VMLA_f_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, D=0, op=0, Q=0, Vd=1, N=0, sz=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF001D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t1_a_field_n_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vn=0, Vd=0, sz=0, Q=0, M=0, Vm=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t1_a_field_n_1_max_d10_ef000d90() {
    // Thumb encoding (32): 0xEF000D90
    // Test aarch32_VMLA_f_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: sz=0, Q=0, D=0, Vn=0, M=0, Vm=0, N=1, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_f_t1_a_field_q_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: D=0, N=0, Q=0, sz=0, Vn=0, M=0, Vm=0, op=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_f_t1_a_field_q_1_max_d10_ef000d50() {
    // Thumb encoding (32): 0xEF000D50
    // Test aarch32_VMLA_f_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, N=0, M=0, op=0, Vd=0, Vn=0, Q=1, sz=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D50;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t1_a_field_m_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: op=0, D=0, M=0, N=0, sz=0, Vd=0, Vn=0, Vm=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t1_a_field_m_1_max_d10_ef000d30() {
    // Thumb encoding (32): 0xEF000D30
    // Test aarch32_VMLA_f_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: op=0, Vn=0, Vm=0, N=0, Q=0, sz=0, D=0, M=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_t1_a_field_vm_0_min_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, D=0, Q=0, M=0, sz=0, op=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_t1_a_field_vm_1_poweroftwo_d10_ef000d11() {
    // Thumb encoding (32): 0xEF000D11
    // Test aarch32_VMLA_f_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Q=0, M=0, op=0, Vm=1, Vd=0, N=0, sz=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D11;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmla_f_t1_a_combo_0_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A field combination: D=0, op=0, sz=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vn=0, Vm=0, op=0, Vd=0, M=0, N=0, sz=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_f_t1_a_special_sz_0_size_variant_0_3344_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A special value sz = 0 (Size variant 0)
    // ISET: T32
    // Fields: sz=0, op=0, M=0, Vn=0, Vd=0, N=0, Q=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_f_t1_a_special_sz_1_size_variant_1_3344_ef100d10() {
    // Thumb encoding (32): 0xEF100D10
    // Test aarch32_VMLA_f_T1_A special value sz = 1 (Size variant 1)
    // ISET: T32
    // Fields: Q=0, op=0, Vn=0, M=0, Vm=0, N=0, Vd=0, D=0, sz=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_f_t1_a_special_q_0_size_variant_0_3344_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vm=0, sz=0, Q=0, D=0, op=0, Vn=0, N=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_f_t1_a_special_q_1_size_variant_1_3344_ef000d50() {
    // Thumb encoding (32): 0xEF000D50
    // Test aarch32_VMLA_f_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: op=0, D=0, N=0, M=0, Vm=0, sz=0, Vn=0, Q=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D50;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t1_a_invalid_0_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: D=0, M=0, op=0, Vn=0, Q=0, Vm=0, N=0, sz=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t1_a_invalid_1_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: op=0, D=0, N=0, Vd=0, Vn=0, Q=0, sz=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t1_a_invalid_2_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } }
    // ISET: T32
    // Fields: op=0, Vm=0, N=0, D=0, Q=0, Vn=0, M=0, Vd=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t1_a_invalid_3_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Q=0, M=0, Vd=0, D=0, N=0, op=0, sz=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_f_t1_a_invalid_4_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: op=0, Vm=0, sz=0, Vd=0, D=0, Vn=0, N=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_f_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_f_t1_a_invalid_5_d10_ef000d10() {
    // Thumb encoding (32): 0xEF000D10
    // Test aarch32_VMLA_f_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Q=0, Vn=0, Vd=0, Vm=0, sz=0, D=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000D10;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t2_a_field_d_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field D = 0 (Min)
    // ISET: T32
    // Fields: M=0, N=0, Vn=0, op=0, size=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t2_a_field_d_1_max_800_ee400800() {
    // Thumb encoding (32): 0xEE400800
    // Test aarch32_VMLA_f_T2_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, op=0, Vn=0, Vm=0, N=0, M=0, size=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_t2_a_field_vn_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vn=0, D=0, size=0, N=0, op=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_t2_a_field_vn_1_poweroftwo_800_ee010800() {
    // Thumb encoding (32): 0xEE010800
    // Test aarch32_VMLA_f_T2_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, op=0, M=0, D=0, Vm=0, Vd=0, Vn=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_t2_a_field_vd_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Vm=0, size=0, M=0, N=0, D=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_t2_a_field_vd_1_poweroftwo_800_ee001800() {
    // Thumb encoding (32): 0xEE001800
    // Test aarch32_VMLA_f_T2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, M=0, Vm=0, op=0, D=0, Vn=0, Vd=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE001800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_f_t2_a_field_size_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, N=0, D=0, op=0, Vm=0, Vn=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_f_t2_a_field_size_1_poweroftwo_800_ee000900() {
    // Thumb encoding (32): 0xEE000900
    // Test aarch32_VMLA_f_T2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, M=0, op=0, Vm=0, D=0, size=1, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_f_t2_a_field_size_2_poweroftwo_800_ee000a00() {
    // Thumb encoding (32): 0xEE000A00
    // Test aarch32_VMLA_f_T2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, M=0, N=0, Vd=0, size=2, Vn=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size 8 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_f_t2_a_field_size_3_max_800_ee000b00() {
    // Thumb encoding (32): 0xEE000B00
    // Test aarch32_VMLA_f_T2_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vm=0, size=3, op=0, D=0, Vd=0, N=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t2_a_field_n_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field N = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vn=0, size=0, N=0, op=0, Vd=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t2_a_field_n_1_max_800_ee000880() {
    // Thumb encoding (32): 0xEE000880
    // Test aarch32_VMLA_f_T2_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, op=0, N=1, Vn=0, M=0, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field op 6 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t2_a_field_op_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field op = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, Vn=0, op=0, Vm=0, size=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field op 6 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t2_a_field_op_1_max_800_ee000840() {
    // Thumb encoding (32): 0xEE000840
    // Test aarch32_VMLA_f_T2_A field op = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, Vd=0, D=0, M=0, Vm=0, op=1, size=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_f_t2_a_field_m_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, op=0, D=0, Vm=0, size=0, Vn=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_f_t2_a_field_m_1_max_800_ee000820() {
    // Thumb encoding (32): 0xEE000820
    // Test aarch32_VMLA_f_T2_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Vm=0, M=1, D=0, size=0, op=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_f_t2_a_field_vm_0_min_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: N=0, M=0, Vm=0, Vd=0, Vn=0, size=0, D=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_f_t2_a_field_vm_1_poweroftwo_800_ee000801() {
    // Thumb encoding (32): 0xEE000801
    // Test aarch32_VMLA_f_T2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vn=0, M=0, Vd=0, op=0, size=0, Vm=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_vmla_f_t2_a_combo_0_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A field combination: D=0, Vn=0, Vd=0, size=0, N=0, op=0, M=0, Vm=0
    // ISET: T32
    // Fields: D=0, M=0, Vn=0, N=0, op=0, Vm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_f_t2_a_special_size_0_size_variant_0_2048_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, D=0, Vn=0, size=0, M=0, op=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_f_t2_a_special_size_1_size_variant_1_2048_ee000900() {
    // Thumb encoding (32): 0xEE000900
    // Test aarch32_VMLA_f_T2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: N=0, M=0, size=1, op=0, D=0, Vn=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_f_t2_a_special_size_2_size_variant_2_2048_ee000a00() {
    // Thumb encoding (32): 0xEE000A00
    // Test aarch32_VMLA_f_T2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, size=2, Vn=0, N=0, Vd=0, op=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_f_t2_a_special_size_3_size_variant_3_2048_ee000b00() {
    // Thumb encoding (32): 0xEE000B00
    // Test aarch32_VMLA_f_T2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: op=0, N=0, D=0, Vd=0, size=3, Vm=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000B00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t2_a_invalid_0_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: D=0, Vn=0, size=0, N=0, op=0, Vm=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t2_a_invalid_1_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, Vd=0, N=0, M=0, Vm=0, op=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_f_t2_a_invalid_2_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: N=0, Vd=0, D=0, Vn=0, Vm=0, op=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_f_t2_a_invalid_3_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Vn=0, size=0, Vd=0, D=0, N=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Len\" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: \"FPSCR\" }), field: \"Stride\" } } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t2_a_invalid_4_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Ne, lhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Len" }, rhs: Binary { op: Or, lhs: LitBits([false, false, false]), rhs: Member { base: Var(QualifiedIdentifier { qualifier: Any, name: "FPSCR" }), field: "Stride" } } }, rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: M=0, Vd=0, N=0, size=0, Vn=0, op=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_f_t2_a_invalid_5_800_ee000800() {
    // Thumb encoding (32): 0xEE000800
    // Test aarch32_VMLA_f_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, Vd=0, N=0, size=0, M=0, op=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEE000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0x92401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0x92403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0x92407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // Encoding: 0x92400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // Encoding: 0x9240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x12001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x12003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_vmla_f_a1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // Encoding: 0x12000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_0_0_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_0_ff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_0_aaaaaaaa_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_0_55555555_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_0_ffffffff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_1_0_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_1_ff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_1_aaaaaaaa_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAA, "R0 should be 0x000000AA");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_1_55555555_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55, "R0 should be 0x00000055");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_1_ffffffff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_2_0_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_2_ff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_2_aaaaaaaa_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_2_55555555_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_2_ffffffff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_3_0_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_3_ff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_3_aaaaaaaa_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA000000, "R0 should be 0x0A000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_3_55555555_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5000000, "R0 should be 0x05000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_3_ffffffff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_4_0_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_4_ff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_4_aaaaaaaa_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_4_55555555_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_f_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_f_a1_a_a32_logical_imm_4_ffffffff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_VMLA_s_A Tests
// ============================================================================

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Q 24 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_s_a1_a_field_q_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, N=0, size=0, F=0, D=0, Vn=0, Vm=0, M=0, Q=0, op=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Q 24 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_s_a1_a_field_q_1_max_40_f3800040() {
    // Encoding: 0xF3800040
    // Test aarch32_VMLA_s_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: N=0, Vn=0, size=0, Vm=0, M=0, F=0, op=0, Vd=0, D=0, Q=1
    let encoding: u32 = 0xF3800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_a1_a_field_d_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Q=0, Vn=0, op=0, F=0, M=0, size=0, D=0, Vd=0, N=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_a1_a_field_d_1_max_40_f2c00040() {
    // Encoding: 0xF2C00040
    // Test aarch32_VMLA_s_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, op=0, Vd=0, M=0, F=0, Vm=0, Q=0, Vn=0, N=0, D=1
    let encoding: u32 = 0xF2C00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_s_a1_a_field_size_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, op=0, F=0, M=0, Vn=0, Q=0, D=0, N=0, Vm=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_s_a1_a_field_size_1_poweroftwo_40_f2900040() {
    // Encoding: 0xF2900040
    // Test aarch32_VMLA_s_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, op=0, size=1, D=0, Vm=0, Q=0, M=0, Vd=0, N=0, F=0
    let encoding: u32 = 0xF2900040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_s_a1_a_field_size_2_poweroftwo_40_f2a00040() {
    // Encoding: 0xF2A00040
    // Test aarch32_VMLA_s_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, op=0, D=0, size=2, Vm=0, Q=0, Vd=0, M=0, F=0, N=0
    let encoding: u32 = 0xF2A00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_s_a1_a_field_size_3_max_40_f2b00040() {
    // Encoding: 0xF2B00040
    // Test aarch32_VMLA_s_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: F=0, Q=0, Vn=0, Vd=0, D=0, Vm=0, op=0, size=3, N=0, M=0
    let encoding: u32 = 0xF2B00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_a1_a_field_vn_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: F=0, Vm=0, op=0, D=0, Vd=0, Q=0, M=0, size=0, N=0, Vn=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_a1_a_field_vn_1_poweroftwo_40_f2810040() {
    // Encoding: 0xF2810040
    // Test aarch32_VMLA_s_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vn=1, F=0, Q=0, N=0, Vd=0, op=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF2810040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_a1_a_field_vd_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: size=0, Q=0, Vn=0, Vd=0, F=0, Vm=0, D=0, N=0, M=0, op=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_a1_a_field_vd_1_poweroftwo_40_f2801040() {
    // Encoding: 0xF2801040
    // Test aarch32_VMLA_s_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: F=0, D=0, op=0, M=0, N=0, Vm=0, size=0, Q=0, Vn=0, Vd=1
    let encoding: u32 = 0xF2801040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_a1_a_field_op_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, op=0, Q=0, F=0, N=0, M=0, Vd=0, size=0, Vm=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_a1_a_field_op_1_max_40_f2800440() {
    // Encoding: 0xF2800440
    // Test aarch32_VMLA_s_A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vn=0, N=0, M=0, Vm=0, Vd=0, op=1, D=0, F=0, Q=0
    let encoding: u32 = 0xF2800440;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_a1_a_field_f_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field F = 0 (Min)
    // ISET: A32
    // Fields: N=0, F=0, Vn=0, op=0, size=0, Q=0, M=0, Vm=0, Vd=0, D=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_a1_a_field_f_1_max_40_f2800140() {
    // Encoding: 0xF2800140
    // Test aarch32_VMLA_s_A1_A field F = 1 (Max)
    // ISET: A32
    // Fields: D=0, size=0, F=1, Vd=0, M=0, N=0, Q=0, Vm=0, Vn=0, op=0
    let encoding: u32 = 0xF2800140;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_a1_a_field_n_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, Vn=0, N=0, F=0, M=0, Vm=0, size=0, Q=0, op=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_a1_a_field_n_1_max_40_f28000c0() {
    // Encoding: 0xF28000C0
    // Test aarch32_VMLA_s_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, op=0, size=0, F=0, M=0, Vd=0, Q=0, Vn=0, D=0, Vm=0
    let encoding: u32 = 0xF28000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_a1_a_field_m_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, op=0, Vn=0, Q=0, Vm=0, N=0, F=0, M=0, D=0, size=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_a1_a_field_m_1_max_40_f2800060() {
    // Encoding: 0xF2800060
    // Test aarch32_VMLA_s_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, op=0, size=0, Vd=0, Q=0, D=0, Vm=0, M=1, N=0, F=0
    let encoding: u32 = 0xF2800060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_a1_a_field_vm_0_min_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: M=0, D=0, Q=0, size=0, Vd=0, op=0, Vm=0, N=0, F=0, Vn=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_a1_a_field_vm_1_poweroftwo_40_f2800041() {
    // Encoding: 0xF2800041
    // Test aarch32_VMLA_s_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: F=0, D=0, Vd=0, op=0, Vm=1, Vn=0, size=0, N=0, M=0, Q=0
    let encoding: u32 = 0xF2800041;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmla_s_a1_a_combo_0_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A field combination: Q=0, D=0, size=0, Vn=0, Vd=0, op=0, F=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vd=0, F=0, Q=0, N=0, Vm=0, Vn=0, M=0, D=0, op=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_s_a1_a_special_q_0_size_variant_0_64_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Vd=0, N=0, F=0, op=0, M=0, size=0, Vm=0, Vn=0, Q=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_s_a1_a_special_q_1_size_variant_1_64_f3800040() {
    // Encoding: 0xF3800040
    // Test aarch32_VMLA_s_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, Vm=0, op=0, M=0, Vd=0, F=0, Q=1, N=0, size=0, Vn=0
    let encoding: u32 = 0xF3800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_s_a1_a_special_size_0_size_variant_0_64_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: F=0, Vd=0, Vn=0, Q=0, size=0, D=0, op=0, M=0, N=0, Vm=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_s_a1_a_special_size_1_size_variant_1_64_f2900040() {
    // Encoding: 0xF2900040
    // Test aarch32_VMLA_s_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, Vn=0, Vd=0, Q=0, M=0, F=0, op=0, size=1, N=0, Vm=0
    let encoding: u32 = 0xF2900040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_s_a1_a_special_size_2_size_variant_2_64_f2a00040() {
    // Encoding: 0xF2A00040
    // Test aarch32_VMLA_s_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, Q=0, D=0, Vn=0, op=0, N=0, M=0, F=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2A00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_s_a1_a_special_size_3_size_variant_3_64_f2b00040() {
    // Encoding: 0xF2B00040
    // Test aarch32_VMLA_s_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Q=0, size=3, op=0, Vd=0, F=0, N=0, Vm=0, Vn=0, M=0, D=0
    let encoding: u32 = 0xF2B00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_a1_a_invalid_0_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: A32
    // Fields: D=0, Vn=0, Q=0, size=0, op=0, N=0, Vd=0, F=0, M=0, Vm=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_a1_a_invalid_1_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: F=0, Q=0, size=0, M=0, Vd=0, op=0, N=0, Vn=0, D=0, Vm=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_a1_a_invalid_2_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: Vn=0, Q=0, Vd=0, op=0, M=0, Vm=0, size=0, F=0, D=0, N=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_a1_a_invalid_3_40_f2800040() {
    // Encoding: 0xF2800040
    // Test aarch32_VMLA_s_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, F=0, Q=0, Vm=0, size=0, D=0, M=0, Vn=0, op=0, Vd=0
    let encoding: u32 = 0xF2800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Q 28 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_s_t1_a_field_q_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, F=0, Vn=0, Vd=0, op=0, size=0, D=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Q 28 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_s_t1_a_field_q_1_max_40_ff800040() {
    // Thumb encoding (32): 0xFF800040
    // Test aarch32_VMLA_s_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: F=0, Vn=0, Q=1, size=0, D=0, Vm=0, N=0, Vd=0, op=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t1_a_field_d_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vn=0, Q=0, Vd=0, N=0, F=0, M=0, size=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t1_a_field_d_1_max_40_efc00040() {
    // Thumb encoding (32): 0xEFC00040
    // Test aarch32_VMLA_s_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, op=0, M=0, D=1, Vd=0, Vm=0, size=0, N=0, Q=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_s_t1_a_field_size_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: F=0, M=0, Q=0, Vn=0, size=0, op=0, Vd=0, D=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_s_t1_a_field_size_1_poweroftwo_40_ef900040() {
    // Thumb encoding (32): 0xEF900040
    // Test aarch32_VMLA_s_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, Vn=0, op=0, Q=0, M=0, Vm=0, D=0, Vd=0, N=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_s_t1_a_field_size_2_poweroftwo_40_efa00040() {
    // Thumb encoding (32): 0xEFA00040
    // Test aarch32_VMLA_s_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, N=0, op=0, M=0, size=2, Vn=0, D=0, Q=0, Vm=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_s_t1_a_field_size_3_max_40_efb00040() {
    // Thumb encoding (32): 0xEFB00040
    // Test aarch32_VMLA_s_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, D=0, Q=0, F=0, Vn=0, op=0, N=0, Vm=0, M=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t1_a_field_vn_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Q=0, M=0, N=0, D=0, F=0, op=0, size=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t1_a_field_vn_1_poweroftwo_40_ef810040() {
    // Thumb encoding (32): 0xEF810040
    // Test aarch32_VMLA_s_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: F=0, Vm=0, Q=0, op=0, N=0, D=0, Vn=1, Vd=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t1_a_field_vd_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, op=0, Vm=0, F=0, Vd=0, N=0, Q=0, size=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t1_a_field_vd_1_poweroftwo_40_ef801040() {
    // Thumb encoding (32): 0xEF801040
    // Test aarch32_VMLA_s_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, Vn=0, N=0, M=0, Vm=0, size=0, Q=0, D=0, F=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t1_a_field_op_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field op = 0 (Min)
    // ISET: T32
    // Fields: op=0, M=0, F=0, D=0, Vd=0, N=0, Vm=0, Q=0, size=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t1_a_field_op_1_max_40_ef800440() {
    // Thumb encoding (32): 0xEF800440
    // Test aarch32_VMLA_s_T1_A field op = 1 (Max)
    // ISET: T32
    // Fields: op=1, M=0, Vm=0, F=0, size=0, Vd=0, Vn=0, Q=0, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800440;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t1_a_field_f_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field F = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, N=0, F=0, D=0, M=0, Q=0, size=0, Vn=0, op=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field F 8 +: 1`
/// Requirement: FieldBoundary { field: "F", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t1_a_field_f_1_max_40_ef800140() {
    // Thumb encoding (32): 0xEF800140
    // Test aarch32_VMLA_s_T1_A field F = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, Q=0, N=0, D=0, Vn=0, M=0, size=0, op=0, F=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800140;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t1_a_field_n_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, M=0, Q=0, D=0, size=0, Vd=0, F=0, Vn=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t1_a_field_n_1_max_40_ef8000c0() {
    // Thumb encoding (32): 0xEF8000C0
    // Test aarch32_VMLA_s_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, Vn=0, op=0, M=0, D=0, Vm=0, F=0, N=1, Q=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF8000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t1_a_field_m_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vd=0, Vn=0, D=0, Q=0, size=0, Vm=0, F=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t1_a_field_m_1_max_40_ef800060() {
    // Thumb encoding (32): 0xEF800060
    // Test aarch32_VMLA_s_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, D=0, Q=0, size=0, F=0, Vd=0, Vm=0, Vn=0, M=1, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t1_a_field_vm_0_min_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Q=0, Vn=0, size=0, D=0, op=0, N=0, M=0, Vd=0, Vm=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t1_a_field_vm_1_poweroftwo_40_ef800041() {
    // Thumb encoding (32): 0xEF800041
    // Test aarch32_VMLA_s_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, size=0, Vm=1, F=0, D=0, N=0, Vd=0, Q=0, Vn=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800041;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch32_vmla_s_t1_a_combo_0_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A field combination: Q=0, D=0, size=0, Vn=0, Vd=0, op=0, F=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, Q=0, size=0, D=0, M=0, Vn=0, Vm=0, op=0, N=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_s_t1_a_special_q_0_size_variant_0_64_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, size=0, F=0, Vd=0, Vn=0, Q=0, op=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_s_t1_a_special_q_1_size_variant_1_64_ff800040() {
    // Thumb encoding (32): 0xFF800040
    // Test aarch32_VMLA_s_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: F=0, size=0, Vm=0, Vd=0, Q=1, Vn=0, op=0, N=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_s_t1_a_special_size_0_size_variant_0_64_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: M=0, N=0, Vm=0, Q=0, size=0, D=0, Vd=0, op=0, Vn=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_s_t1_a_special_size_1_size_variant_1_64_ef900040() {
    // Thumb encoding (32): 0xEF900040
    // Test aarch32_VMLA_s_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: N=0, F=0, D=0, Q=0, Vd=0, M=0, size=1, Vn=0, op=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_s_t1_a_special_size_2_size_variant_2_64_efa00040() {
    // Thumb encoding (32): 0xEFA00040
    // Test aarch32_VMLA_s_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, Q=0, size=2, D=0, N=0, M=0, op=0, Vm=0, Vn=0, F=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_s_t1_a_special_size_3_size_variant_3_64_efb00040() {
    // Thumb encoding (32): 0xEFB00040
    // Test aarch32_VMLA_s_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, Q=0, op=0, D=0, M=0, F=0, Vn=0, Vd=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } } } } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t1_a_invalid_0_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } } } } } }
    // ISET: T32
    // Fields: op=0, D=0, N=0, Vn=0, Vd=0, Vm=0, Q=0, F=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t1_a_invalid_1_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, op=0, Vm=0, size=0, M=0, Q=0, Vn=0, N=0, F=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"F\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_s_t1_a_invalid_2_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "F" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: Vn=0, Vd=0, D=0, F=0, N=0, Q=0, op=0, size=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_vmla_s_t1_a_invalid_3_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vn=0, op=0, F=0, Q=0, N=0, Vm=0, D=0, size=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t1_a_invalid_4_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: Vm=0, N=0, op=0, F=0, Vd=0, D=0, size=0, Vn=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_s_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t1_a_invalid_5_40_ef800040() {
    // Thumb encoding (32): 0xEF800040
    // Test aarch32_VMLA_s_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, op=0, F=0, Vm=0, Q=0, M=0, Vn=0, N=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_0_f2802860() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_0_f2802860() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_1_f2800060() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_1_f2800060() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_2_f2800460() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_2_f2800460() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_3_f2bffc60() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_3_f2bffc60() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_4_f2fffc60() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_4_f2fffc60() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_5_f2800460() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_5_f2800460() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_6_f2800460() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_6_f2800460() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_7_f2800460() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_7_f2800460() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_8_f2800460() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_8_f2800460() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_9_f2800460() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_9_f2800460() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_10_f2800460() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_10_f2800460() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_32_rd31_sp_f280287f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmla_s_a1_a_add_oracle_64_rd31_sp_f280287f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_0_f2802860() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_0_f2802860() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_1_f2800060() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_1_f2800060() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_2_f2800460() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_2_f2800460() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_3_f2bffc60() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_3_f2bffc60() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_4_f2fffc60() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_4_f2fffc60() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_5_f2800460() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_5_f2800460() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_6_f2800460() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_6_f2800460() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_7_f2800460() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_7_f2800460() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_8_f2800460() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_8_f2800460() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_9_f2800460() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_9_f2800460() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_10_f2800460() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_10_f2800460() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_32_rd31_zr_f280287f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmla_s_a1_a_adds_oracle_64_rd31_zr_f280287f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_0_f2802860() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_0_f2802860() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_1_f2800060() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_1_f2800060() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_2_f2800460() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_2_f2800460() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_3_f2bffc60() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_3_f2bffc60() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_4_f2fffc60() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_4_f2fffc60() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_5_f2800460() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_5_f2800460() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_6_f2800460() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_6_f2800460() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_7_f2800460() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_7_f2800460() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_8_f2800460() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_8_f2800460() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_9_f2800460() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_9_f2800460() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_10_f2800460() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_10_f2800460() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_32_rd31_sp_f280287f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmla_s_a1_a_sub_oracle_64_rd31_sp_f280287f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_0_f2802860() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_0_f2802860() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802860
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802860;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_1_f2800060() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_1_f2800060() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800060
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_2_f2800460() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_2_f2800460() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_3_f2bffc60() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_3_f2bffc60() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_4_f2fffc60() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_4_f2fffc60() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFC60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFC60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_5_f2800460() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_5_f2800460() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_6_f2800460() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_6_f2800460() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_7_f2800460() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_7_f2800460() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_8_f2800460() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_8_f2800460() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_9_f2800460() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_9_f2800460() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_10_f2800460() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_10_f2800460() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800460
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800460;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_32_rd31_zr_f280287f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmla_s_a1_a_subs_oracle_64_rd31_zr_f280287f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF280287F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF280287F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMLA_s_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_a1_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMUL_s_A Tests
// ============================================================================

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_u_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, U=0, Vd=0, N=0, size=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_u_1_max_a40_f3800a40() {
    // Encoding: 0xF3800A40
    // Test aarch32_VMUL_s_T2A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: N=0, size=0, Vn=0, Vd=0, U=1, Vm=0, M=0, D=0
    let encoding: u32 = 0xF3800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_d_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vn=0, Vd=0, N=0, M=0, Vm=0, size=0, U=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_d_1_max_a40_f2c00a40() {
    // Encoding: 0xF2C00A40
    // Test aarch32_VMUL_s_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, N=0, D=1, Vn=0, size=0, U=0
    let encoding: u32 = 0xF2C00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vn=0, Vm=0, Vd=0, size=0, U=0, N=0, D=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_1_poweroftwo_a40_f2900a40() {
    // Encoding: 0xF2900A40
    // Test aarch32_VMUL_s_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vn=0, Vm=0, D=0, Vd=0, N=0, U=0, size=1
    let encoding: u32 = 0xF2900A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_2_poweroftwo_a40_f2a00a40() {
    // Encoding: 0xF2A00A40
    // Test aarch32_VMUL_s_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, Vn=0, U=0, N=0, Vm=0, Vd=0, M=0, D=0
    let encoding: u32 = 0xF2A00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_3_max_a40_f2b00a40() {
    // Encoding: 0xF2B00A40
    // Test aarch32_VMUL_s_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vm=0, U=0, Vn=0, D=0, size=3, Vd=0, N=0, M=0
    let encoding: u32 = 0xF2B00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vn_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, D=0, M=0, Vd=0, U=0, Vn=0, size=0, N=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vn_1_poweroftwo_a40_f2810a40() {
    // Encoding: 0xF2810A40
    // Test aarch32_VMUL_s_T2A2_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, M=0, Vd=0, Vm=0, D=0, U=0, Vn=1, size=0
    let encoding: u32 = 0xF2810A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vd_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, N=0, M=0, D=0, U=0, Vn=0, Vm=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vd_1_poweroftwo_a40_f2801a40() {
    // Encoding: 0xF2801A40
    // Test aarch32_VMUL_s_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=0, U=0, M=0, Vd=1, Vn=0, N=0, Vm=0
    let encoding: u32 = 0xF2801A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_n_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field N = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, U=0, Vd=0, N=0, size=0, Vn=0, D=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_n_1_max_a40_f2800ac0() {
    // Encoding: 0xF2800AC0
    // Test aarch32_VMUL_s_T2A2_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, N=1, Vd=0, D=0, M=0, Vm=0, size=0, U=0
    let encoding: u32 = 0xF2800AC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_m_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, U=0, Vn=0, D=0, M=0, Vm=0, N=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_m_1_max_a40_f2800a60() {
    // Encoding: 0xF2800A60
    // Test aarch32_VMUL_s_T2A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, Vd=0, N=0, M=1, size=0, U=0, D=0, Vn=0
    let encoding: u32 = 0xF2800A60;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vm_0_min_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: M=0, size=0, D=0, U=0, Vm=0, Vd=0, N=0, Vn=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vm_1_poweroftwo_a40_f2800a41() {
    // Encoding: 0xF2800A41
    // Test aarch32_VMUL_s_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vn=0, M=0, Vm=1, U=0, Vd=0, N=0, size=0
    let encoding: u32 = 0xF2800A41;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmul_s_t2a2_a_combo_0_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vm=0, D=0, Vd=0, N=0, Vn=0, U=0, M=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_0_size_variant_0_2624_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, M=0, U=0, size=0, Vn=0, Vd=0, N=0, Vm=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_1_size_variant_1_2624_f2900a40() {
    // Encoding: 0xF2900A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: N=0, Vn=0, size=1, D=0, Vd=0, M=0, Vm=0, U=0
    let encoding: u32 = 0xF2900A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_2_size_variant_2_2624_f2a00a40() {
    // Encoding: 0xF2A00A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vn=0, N=0, M=0, Vm=0, size=2, U=0, D=0, Vd=0
    let encoding: u32 = 0xF2A00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_3_size_variant_3_2624_f2b00a40() {
    // Encoding: 0xF2B00A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, N=0, D=0, M=0, Vm=0, Vd=0, Vn=0, U=0
    let encoding: u32 = 0xF2B00A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t2a2_a_invalid_0_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: M=0, Vd=0, U=0, D=0, Vn=0, N=0, Vm=0, size=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t2a2_a_invalid_1_a40_f2800a40() {
    // Encoding: 0xF2800A40
    // Test aarch32_VMUL_s_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, size=0, D=0, Vd=0, M=0, N=0, Vm=0, U=0
    let encoding: u32 = 0xF2800A40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_u_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field U = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, D=0, M=0, Vn=0, Vd=0, size=0, N=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_u_1_max_a40_ff800a40() {
    // Thumb encoding (32): 0xFF800A40
    // Test aarch32_VMUL_s_T2A2_A field U = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vd=0, U=1, Vn=0, M=0, N=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_d_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Vn=0, M=0, N=0, Vm=0, U=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_d_1_max_a40_efc00a40() {
    // Thumb encoding (32): 0xEFC00A40
    // Test aarch32_VMUL_s_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: U=0, M=0, Vn=0, D=1, size=0, N=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: N=0, U=0, Vd=0, Vn=0, M=0, size=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_1_poweroftwo_a40_ef900a40() {
    // Thumb encoding (32): 0xEF900A40
    // Test aarch32_VMUL_s_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Vd=0, N=0, Vn=0, Vm=0, D=0, size=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_2_poweroftwo_a40_efa00a40() {
    // Thumb encoding (32): 0xEFA00A40
    // Test aarch32_VMUL_s_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, N=0, Vd=0, M=0, Vn=0, Vm=0, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_size_3_max_a40_efb00a40() {
    // Thumb encoding (32): 0xEFB00A40
    // Test aarch32_VMUL_s_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: N=0, D=0, U=0, size=3, Vn=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vn_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vn=0, U=0, size=0, M=0, Vd=0, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vn_1_poweroftwo_a40_ef810a40() {
    // Thumb encoding (32): 0xEF810A40
    // Test aarch32_VMUL_s_T2A2_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vn=1, M=0, Vd=0, U=0, D=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vd_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vn=0, Vd=0, D=0, size=0, N=0, M=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vd_1_poweroftwo_a40_ef801a40() {
    // Thumb encoding (32): 0xEF801A40
    // Test aarch32_VMUL_s_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, M=0, U=0, Vm=0, N=0, size=0, Vn=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_n_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field N = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vm=0, U=0, M=0, Vn=0, N=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_n_1_max_a40_ef800ac0() {
    // Thumb encoding (32): 0xEF800AC0
    // Test aarch32_VMUL_s_T2A2_A field N = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vm=0, M=0, N=1, Vd=0, U=0, size=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800AC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_m_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field M = 0 (Min)
    // ISET: T32
    // Fields: U=0, Vm=0, N=0, Vd=0, size=0, M=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_m_1_max_a40_ef800a60() {
    // Thumb encoding (32): 0xEF800A60
    // Test aarch32_VMUL_s_T2A2_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Vn=0, size=0, U=0, Vm=0, D=0, M=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vm_0_min_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: N=0, M=0, size=0, U=0, Vn=0, Vm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_s_t2a2_a_field_vm_1_poweroftwo_a40_ef800a41() {
    // Thumb encoding (32): 0xEF800A41
    // Test aarch32_VMUL_s_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, M=0, Vn=0, size=0, U=0, D=0, Vm=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A41;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmul_s_t2a2_a_combo_0_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vn=0, M=0, N=0, Vm=0, D=0, size=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_0_size_variant_0_2624_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Vn=0, size=0, Vd=0, U=0, M=0, Vm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_1_size_variant_1_2624_ef900a40() {
    // Thumb encoding (32): 0xEF900A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, N=0, Vm=0, D=0, U=0, M=0, size=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_2_size_variant_2_2624_efa00a40() {
    // Thumb encoding (32): 0xEFA00A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vn=0, Vd=0, N=0, M=0, U=0, Vm=0, size=2, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_s_t2a2_a_special_size_3_size_variant_3_2624_efb00a40() {
    // Thumb encoding (32): 0xEFB00A40
    // Test aarch32_VMUL_s_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, D=0, M=0, N=0, Vm=0, U=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t2a2_a_invalid_0_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, N=0, Vn=0, Vd=0, Vm=0, size=0, U=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_s_t2a2_a_invalid_1_a40_ef800a40() {
    // Thumb encoding (32): 0xEF800A40
    // Test aarch32_VMUL_s_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, N=0, size=0, Vn=0, M=0, Vd=0, D=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800A40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_0_f2802a60() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_0_f2802a60() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_1_f2800a60() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_1_f2800a60() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_2_f2800e60() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_2_f2800e60() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_3_f2bffe60() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_3_f2bffe60() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_4_f2fffe60() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_4_f2fffe60() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_5_f2800e60() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_5_f2800e60() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_6_f2800e60() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_6_f2800e60() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_7_f2800e60() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_7_f2800e60() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_8_f2800e60() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_8_f2800e60() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_9_f2800e60() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_9_f2800e60() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_10_f2800e60() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_10_f2800e60() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_32_rd31_sp_f2802a7f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_add_oracle_64_rd31_sp_f2802a7f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_0_f2802a60() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_0_f2802a60() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_1_f2800a60() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_1_f2800a60() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_2_f2800e60() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_2_f2800e60() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_3_f2bffe60() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_3_f2bffe60() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_4_f2fffe60() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_4_f2fffe60() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_5_f2800e60() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_5_f2800e60() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_6_f2800e60() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_6_f2800e60() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_7_f2800e60() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_7_f2800e60() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_8_f2800e60() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_8_f2800e60() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_9_f2800e60() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_9_f2800e60() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_10_f2800e60() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_10_f2800e60() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_32_rd31_zr_f2802a7f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_adds_oracle_64_rd31_zr_f2802a7f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_0_f2802a60() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_0_f2802a60() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_1_f2800a60() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_1_f2800a60() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_2_f2800e60() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_2_f2800e60() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_3_f2bffe60() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_3_f2bffe60() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_4_f2fffe60() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_4_f2fffe60() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_5_f2800e60() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_5_f2800e60() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_6_f2800e60() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_6_f2800e60() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_7_f2800e60() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_7_f2800e60() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_8_f2800e60() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_8_f2800e60() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_9_f2800e60() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_9_f2800e60() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_10_f2800e60() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_10_f2800e60() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_32_rd31_sp_f2802a7f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_sub_oracle_64_rd31_sp_f2802a7f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_0_f2802a60() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_0_f2802a60() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF6,
        "X0 should be 0xFFFFFFFFFFFFFFF6"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_1_f2800a60() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_1_f2800a60() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800A60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800A60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_2_f2800e60() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_2_f2800e60() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_3_f2bffe60() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_3_f2bffe60() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_4_f2fffe60() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_4_f2fffe60() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_5_f2800e60() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_5_f2800e60() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_6_f2800e60() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_6_f2800e60() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_7_f2800e60() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_7_f2800e60() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_8_f2800e60() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_8_f2800e60() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_9_f2800e60() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_9_f2800e60() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_10_f2800e60() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_10_f2800e60() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFD,
        "X0 should be 0xFFFFFFFFFFFFFFFD"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_32_rd31_zr_f2802a7f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmul_s_t2a2_a_subs_oracle_64_rd31_zr_f2802a7f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF2802A7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802A7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMUL_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_s_t2a2_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMLA_s_A Tests
// ============================================================================

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_u_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, N=0, U=0, op=0, Vn=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field U 24 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_u_1_max_640_f3800240() {
    // Encoding: 0xF3800240
    // Test aarch32_VMLA_s_T2A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: M=0, U=1, D=0, N=0, Vn=0, Vd=0, size=0, op=0, Vm=0
    let encoding: u32 = 0xF3800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_d_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, size=0, M=0, D=0, Vm=0, U=0, op=0, N=0, Vd=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_d_1_max_640_f2c00240() {
    // Encoding: 0xF2C00240
    // Test aarch32_VMLA_s_T2A2_A field D = 1 (Max)
    // ISET: A32
    // Fields: M=0, Vm=0, U=0, Vd=0, N=0, D=1, size=0, op=0, Vn=0
    let encoding: u32 = 0xF2C00240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field size = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vm=0, N=0, M=0, Vd=0, D=0, Vn=0, size=0, U=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_1_poweroftwo_640_f2900240() {
    // Encoding: 0xF2900240
    // Test aarch32_VMLA_s_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, U=0, N=0, size=1, D=0, Vd=0, Vn=0, M=0, op=0
    let encoding: u32 = 0xF2900240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_2_poweroftwo_640_f2a00240() {
    // Encoding: 0xF2A00240
    // Test aarch32_VMLA_s_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, N=0, U=0, M=0, Vn=0, op=0, D=0, Vm=0, size=2
    let encoding: u32 = 0xF2A00240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_3_max_640_f2b00240() {
    // Encoding: 0xF2B00240
    // Test aarch32_VMLA_s_T2A2_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vm=0, op=0, M=0, D=0, size=3, N=0, U=0, Vn=0, Vd=0
    let encoding: u32 = 0xF2B00240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vn_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, N=0, Vn=0, size=0, op=0, U=0, Vd=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vn_1_poweroftwo_640_f2810240() {
    // Encoding: 0xF2810240
    // Test aarch32_VMLA_s_T2A2_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, size=0, N=0, Vd=0, U=0, D=0, op=0, M=0, Vn=1
    let encoding: u32 = 0xF2810240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vd_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vn=0, Vd=0, op=0, size=0, U=0, N=0, D=0, Vm=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vd_1_poweroftwo_640_f2801240() {
    // Encoding: 0xF2801240
    // Test aarch32_VMLA_s_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=1, Vn=0, op=0, U=0, Vm=0, N=0, D=0, M=0
    let encoding: u32 = 0xF2801240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_op_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field op = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, Vd=0, N=0, size=0, M=0, op=0, U=0, Vm=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_op_1_max_640_f2800640() {
    // Encoding: 0xF2800640
    // Test aarch32_VMLA_s_T2A2_A field op = 1 (Max)
    // ISET: A32
    // Fields: U=0, op=1, N=0, size=0, M=0, Vn=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2800640;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_n_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field N = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vn=0, Vd=0, U=0, op=0, D=0, size=0, N=0, Vm=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_n_1_max_640_f28002c0() {
    // Encoding: 0xF28002C0
    // Test aarch32_VMLA_s_T2A2_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, Vm=0, size=0, op=0, Vn=0, U=0, Vd=0, M=0, D=0
    let encoding: u32 = 0xF28002C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_m_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vm=0, size=0, M=0, Vn=0, D=0, op=0, U=0, N=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_m_1_max_640_f2800260() {
    // Encoding: 0xF2800260
    // Test aarch32_VMLA_s_T2A2_A field M = 1 (Max)
    // ISET: A32
    // Fields: U=0, size=0, Vn=0, op=0, M=1, N=0, Vd=0, Vm=0, D=0
    let encoding: u32 = 0xF2800260;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vm_0_min_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: U=0, N=0, Vm=0, op=0, M=0, Vn=0, Vd=0, D=0, size=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vm_1_poweroftwo_640_f2800241() {
    // Encoding: 0xF2800241
    // Test aarch32_VMLA_s_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Vn=0, size=0, Vd=0, M=0, N=0, D=0, Vm=1, op=0
    let encoding: u32 = 0xF2800241;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmla_s_t2a2_a_combo_0_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, op=0, N=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vn=0, N=0, Vd=0, U=0, Vm=0, op=0, size=0, D=0, M=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_0_size_variant_0_1600_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: N=0, Vm=0, M=0, U=0, Vd=0, size=0, op=0, Vn=0, D=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_1_size_variant_1_1600_f2900240() {
    // Encoding: 0xF2900240
    // Test aarch32_VMLA_s_T2A2_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: size=1, M=0, N=0, U=0, op=0, Vm=0, D=0, Vn=0, Vd=0
    let encoding: u32 = 0xF2900240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_2_size_variant_2_1600_f2a00240() {
    // Encoding: 0xF2A00240
    // Test aarch32_VMLA_s_T2A2_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: U=0, Vn=0, M=0, Vd=0, D=0, op=0, N=0, size=2, Vm=0
    let encoding: u32 = 0xF2A00240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_3_size_variant_3_1600_f2b00240() {
    // Encoding: 0xF2B00240
    // Test aarch32_VMLA_s_T2A2_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vn=0, D=0, Vm=0, N=0, size=3, M=0, U=0, Vd=0, op=0
    let encoding: u32 = 0xF2B00240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t2a2_a_invalid_0_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: size=0, N=0, M=0, Vn=0, op=0, U=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t2a2_a_invalid_1_640_f2800240() {
    // Encoding: 0xF2800240
    // Test aarch32_VMLA_s_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: op=0, Vm=0, Vd=0, Vn=0, U=0, N=0, size=0, M=0, D=0
    let encoding: u32 = 0xF2800240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_u_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, Vm=0, size=0, Vd=0, N=0, D=0, op=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field U 28 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_u_1_max_640_ff800240() {
    // Thumb encoding (32): 0xFF800240
    // Test aarch32_VMLA_s_T2A2_A field U = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, size=0, Vn=0, Vd=0, op=0, N=0, U=1, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_d_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, D=0, op=0, U=0, M=0, size=0, Vm=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_d_1_max_640_efc00240() {
    // Thumb encoding (32): 0xEFC00240
    // Test aarch32_VMLA_s_T2A2_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, M=0, U=0, op=0, N=0, Vm=0, size=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFC00240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field size = 0 (Min)
    // ISET: T32
    // Fields: M=0, op=0, Vd=0, U=0, size=0, Vm=0, D=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_1_poweroftwo_640_ef900240() {
    // Thumb encoding (32): 0xEF900240
    // Test aarch32_VMLA_s_T2A2_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, op=0, Vn=0, U=0, M=0, size=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_2_poweroftwo_640_efa00240() {
    // Thumb encoding (32): 0xEFA00240
    // Test aarch32_VMLA_s_T2A2_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, size=2, op=0, D=0, M=0, Vd=0, Vm=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_size_3_max_640_efb00240() {
    // Thumb encoding (32): 0xEFB00240
    // Test aarch32_VMLA_s_T2A2_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Vm=0, Vn=0, M=0, U=0, op=0, N=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vn_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, size=0, M=0, U=0, D=0, Vm=0, N=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vn_1_poweroftwo_640_ef810240() {
    // Thumb encoding (32): 0xEF810240
    // Test aarch32_VMLA_s_T2A2_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=1, D=0, Vd=0, size=0, op=0, N=0, M=0, U=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF810240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vd_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vd=0, N=0, D=0, Vn=0, Vm=0, U=0, size=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vd_1_poweroftwo_640_ef801240() {
    // Thumb encoding (32): 0xEF801240
    // Test aarch32_VMLA_s_T2A2_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, M=0, size=0, Vd=1, U=0, Vn=0, op=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF801240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_op_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field op = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, op=0, Vn=0, N=0, U=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field op 10 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_op_1_max_640_ef800640() {
    // Thumb encoding (32): 0xEF800640
    // Test aarch32_VMLA_s_T2A2_A field op = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vn=0, Vm=0, D=0, U=0, op=1, Vd=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800640;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_n_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field N = 0 (Min)
    // ISET: T32
    // Fields: N=0, Vn=0, Vd=0, U=0, D=0, op=0, M=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_n_1_max_640_ef8002c0() {
    // Thumb encoding (32): 0xEF8002C0
    // Test aarch32_VMLA_s_T2A2_A field N = 1 (Max)
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, Vm=0, Vn=0, N=1, U=0, op=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF8002C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_m_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field M = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vm=0, D=0, U=0, Vd=0, N=0, op=0, M=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_m_1_max_640_ef800260() {
    // Thumb encoding (32): 0xEF800260
    // Test aarch32_VMLA_s_T2A2_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, U=0, size=0, op=0, Vm=0, Vd=0, N=0, Vn=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800260;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vm_0_min_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, op=0, M=0, D=0, Vd=0, Vm=0, U=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmla_s_t2a2_a_field_vm_1_poweroftwo_640_ef800241() {
    // Thumb encoding (32): 0xEF800241
    // Test aarch32_VMLA_s_T2A2_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, size=0, Vm=1, D=0, Vn=0, op=0, M=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800241;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_vmla_s_t2a2_a_combo_0_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A field combination: U=0, D=0, size=0, Vn=0, Vd=0, op=0, N=0, M=0, Vm=0
    // ISET: T32
    // Fields: size=0, Vn=0, M=0, U=0, D=0, N=0, op=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_0_size_variant_0_1600_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: M=0, D=0, Vn=0, Vm=0, op=0, N=0, size=0, Vd=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_1_size_variant_1_1600_ef900240() {
    // Thumb encoding (32): 0xEF900240
    // Test aarch32_VMLA_s_T2A2_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: N=0, U=0, Vd=0, D=0, M=0, size=1, op=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF900240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_2_size_variant_2_1600_efa00240() {
    // Thumb encoding (32): 0xEFA00240
    // Test aarch32_VMLA_s_T2A2_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, M=0, N=0, Vd=0, D=0, Vn=0, U=0, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFA00240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmla_s_t2a2_a_special_size_3_size_variant_3_1600_efb00240() {
    // Thumb encoding (32): 0xEFB00240
    // Test aarch32_VMLA_s_T2A2_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vm=0, U=0, Vd=0, size=3, op=0, D=0, Vn=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEFB00240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t2a2_a_invalid_0_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, U=0, size=0, Vn=0, N=0, M=0, Vm=0, Vd=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmla_s_t2a2_a_invalid_1_640_ef800240() {
    // Thumb encoding (32): 0xEF800240
    // Test aarch32_VMLA_s_T2A2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, D=0, size=0, op=0, N=0, M=0, U=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF800240;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_0_f2802e60() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_0_f2802e60() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_1_f2800660() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_1_f2800660() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_2_f2800660() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_2_f2800660() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_3_f2bffe60() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_3_f2bffe60() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_4_f2fffe60() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_4_f2fffe60() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_5_f2800660() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_5_f2800660() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_6_f2800660() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_6_f2800660() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_7_f2800660() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_7_f2800660() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_8_f2800660() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_8_f2800660() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_9_f2800660() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_9_f2800660() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_10_f2800660() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_10_f2800660() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_32_rd31_sp_f2802e7f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_add_oracle_64_rd31_sp_f2802e7f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_0_f2802e60() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_0_f2802e60() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_1_f2800660() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_1_f2800660() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_2_f2800660() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_2_f2800660() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_3_f2bffe60() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_3_f2bffe60() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_4_f2fffe60() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_4_f2fffe60() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_5_f2800660() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_5_f2800660() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_6_f2800660() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_6_f2800660() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_7_f2800660() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_7_f2800660() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_8_f2800660() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_8_f2800660() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_9_f2800660() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_9_f2800660() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_10_f2800660() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_10_f2800660() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_32_rd31_zr_f2802e7f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_adds_oracle_64_rd31_zr_f2802e7f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_0_f2802e60() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_0_f2802e60() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_1_f2800660() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_1_f2800660() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_2_f2800660() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_2_f2800660() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_3_f2bffe60() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_3_f2bffe60() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_4_f2fffe60() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_4_f2fffe60() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_5_f2800660() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_5_f2800660() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_6_f2800660() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_6_f2800660() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_7_f2800660() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_7_f2800660() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_8_f2800660() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_8_f2800660() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_9_f2800660() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_9_f2800660() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_10_f2800660() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_10_f2800660() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_32_rd31_sp_f2802e7f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_sub_oracle_64_rd31_sp_f2802e7f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_0_f2802e60() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_0_f2802e60() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xF2802E60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFF5,
        "X0 should be 0xFFFFFFFFFFFFFFF5"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_1_f2800660() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_1_f2800660() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_2_f2800660() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_2_f2800660() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_3_f2bffe60() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_3_f2bffe60() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xF2BFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2BFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_4_f2fffe60() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_4_f2fffe60() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xF2FFFE60
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2FFFE60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_5_f2800660() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_5_f2800660() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_6_f2800660() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_6_f2800660() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_7_f2800660() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_7_f2800660() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_8_f2800660() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_8_f2800660() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_9_f2800660() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_9_f2800660() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_10_f2800660() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_10_f2800660() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xF2800660
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2800660;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_32_rd31_zr_f2802e7f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_vmla_s_t2a2_a_subs_oracle_64_rd31_zr_f2802e7f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xF2802E7F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2802E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_0_0_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_0_64_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_0_7fffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_0_80000000_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_0_ffffffff_f281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0xF281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_1_0_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_1_64_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_1_7fffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_1_80000000_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_1_ffffffff_f28100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0xF28100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF28100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_2_0_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_2_64_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_2_7fffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_2_80000000_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_2_ffffffff_f2810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0xF2810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_3_0_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_3_64_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_3_7fffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_3_80000000_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_3_ffffffff_f281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0xF281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_4_0_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_4_64_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_4_7fffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_4_80000000_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_VMLA_s_T2A2_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmla_s_t2a2_a_a32_add_sub_imm_4_ffffffff_f2810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0xF2810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_VMUL_i_A Tests
// ============================================================================

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field op 24 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_op_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field op = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vn=0, Q=0, Vm=0, M=0, D=0, Vd=0, size=0, N=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field op 24 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_op_1_max_910_f3000910() {
    // Encoding: 0xF3000910
    // Test aarch32_VMUL_i_T1A1_A field op = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, size=0, D=0, M=0, N=0, op=1, Q=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_d_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vm=0, Vd=0, size=0, Q=0, M=0, D=0, Vn=0, N=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_d_1_max_910_f2400910() {
    // Encoding: 0xF2400910
    // Test aarch32_VMUL_i_T1A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: N=0, M=0, Vn=0, D=1, Vm=0, Q=0, size=0, Vd=0, op=0
    let encoding: u32 = 0xF2400910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, Q=0, D=0, size=0, Vn=0, op=0, Vd=0, N=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_1_poweroftwo_910_f2100910() {
    // Encoding: 0xF2100910
    // Test aarch32_VMUL_i_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Q=0, Vd=0, op=0, N=0, M=0, Vm=0, size=1, D=0
    let encoding: u32 = 0xF2100910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_2_poweroftwo_910_f2200910() {
    // Encoding: 0xF2200910
    // Test aarch32_VMUL_i_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: op=0, Vn=0, Vd=0, N=0, Vm=0, size=2, Q=0, M=0, D=0
    let encoding: u32 = 0xF2200910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_3_max_910_f2300910() {
    // Encoding: 0xF2300910
    // Test aarch32_VMUL_i_T1A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: Vn=0, N=0, Vd=0, D=0, M=0, size=3, Q=0, op=0, Vm=0
    let encoding: u32 = 0xF2300910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vn_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: op=0, Vm=0, M=0, Vd=0, D=0, size=0, Q=0, Vn=0, N=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vn_1_poweroftwo_910_f2010910() {
    // Encoding: 0xF2010910
    // Test aarch32_VMUL_i_T1A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, op=0, N=0, size=0, D=0, M=0, Vn=1, Q=0, Vd=0
    let encoding: u32 = 0xF2010910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vd_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Q=0, M=0, op=0, Vd=0, size=0, D=0, Vn=0, N=0, Vm=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vd_1_poweroftwo_910_f2001910() {
    // Encoding: 0xF2001910
    // Test aarch32_VMUL_i_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, M=0, Vn=0, Vd=1, Vm=0, size=0, Q=0, op=0, D=0
    let encoding: u32 = 0xF2001910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_n_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Q=0, M=0, N=0, Vd=0, op=0, Vm=0, size=0, D=0, Vn=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_n_1_max_910_f2000990() {
    // Encoding: 0xF2000990
    // Test aarch32_VMUL_i_T1A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: op=0, M=0, Vn=0, Vm=0, Vd=0, Q=0, D=0, size=0, N=1
    let encoding: u32 = 0xF2000990;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_q_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: M=0, size=0, Q=0, D=0, Vd=0, N=0, op=0, Vn=0, Vm=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_q_1_max_910_f2000950() {
    // Encoding: 0xF2000950
    // Test aarch32_VMUL_i_T1A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, op=0, Vn=0, size=0, Q=1, Vd=0, N=0
    let encoding: u32 = 0xF2000950;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_m_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: M=0, Q=0, Vm=0, Vd=0, Vn=0, D=0, N=0, op=0, size=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_m_1_max_910_f2000930() {
    // Encoding: 0xF2000930
    // Test aarch32_VMUL_i_T1A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, N=0, D=0, size=0, op=0, Q=0, M=1, Vm=0, Vd=0
    let encoding: u32 = 0xF2000930;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vm_0_min_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: N=0, size=0, Vm=0, Vn=0, Vd=0, D=0, op=0, Q=0, M=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vm_1_poweroftwo_910_f2000911() {
    // Encoding: 0xF2000911
    // Test aarch32_VMUL_i_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, N=0, M=0, D=0, Vm=1, size=0, Vn=0, Vd=0, op=0
    let encoding: u32 = 0xF2000911;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmul_i_t1a1_a_combo_0_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A field combination: op=0, D=0, size=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: Q=0, N=0, Vd=0, M=0, Vm=0, D=0, size=0, op=0, Vn=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_0_size_variant_0_2320_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: N=0, op=0, size=0, M=0, Vd=0, Q=0, Vn=0, D=0, Vm=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_1_size_variant_1_2320_f2100910() {
    // Encoding: 0xF2100910
    // Test aarch32_VMUL_i_T1A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, size=1, Vd=0, Vn=0, N=0, Q=0, Vm=0, M=0, op=0
    let encoding: u32 = 0xF2100910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_2_size_variant_2_2320_f2200910() {
    // Encoding: 0xF2200910
    // Test aarch32_VMUL_i_T1A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vn=0, Q=0, Vd=0, N=0, size=2, M=0, op=0, D=0, Vm=0
    let encoding: u32 = 0xF2200910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_3_size_variant_3_2320_f2300910() {
    // Encoding: 0xF2300910
    // Test aarch32_VMUL_i_T1A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: op=0, Vn=0, N=0, Q=0, D=0, size=3, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF2300910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_q_0_size_variant_0_2320_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, Vn=0, M=0, Vm=0, Vd=0, Q=0, op=0, N=0, D=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_q_1_size_variant_1_2320_f2000950() {
    // Encoding: 0xF2000950
    // Test aarch32_VMUL_i_T1A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: D=0, Q=1, op=0, Vn=0, M=0, Vm=0, N=0, Vd=0, size=0
    let encoding: u32 = 0xF2000950;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "op" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"op\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_0_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "op" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) } } }
    // ISET: A32
    // Fields: Vn=0, N=0, size=0, Vd=0, op=0, M=0, D=0, Q=0, Vm=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_1_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Q=0, N=0, D=0, size=0, Vm=0, Vn=0, Vd=0, op=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_2_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: A32
    // Fields: Vn=0, Q=0, D=0, Vd=0, M=0, size=0, op=0, Vm=0, N=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_3_910_f2000910() {
    // Encoding: 0xF2000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, op=0, D=0, size=0, Vn=0, N=0, M=0, Vm=0, Q=0
    let encoding: u32 = 0xF2000910;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field op 28 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_op_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field op = 0 (Min)
    // ISET: T32
    // Fields: M=0, Q=0, size=0, Vm=0, Vd=0, D=0, Vn=0, N=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field op 28 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_op_1_max_910_ff000910() {
    // Thumb encoding (32): 0xFF000910
    // Test aarch32_VMUL_i_T1A1_A field op = 1 (Max)
    // ISET: T32
    // Fields: N=0, Q=0, D=0, M=0, Vn=0, Vm=0, Vd=0, size=0, op=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_d_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, op=0, M=0, size=0, D=0, N=0, Q=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_d_1_max_910_ef400910() {
    // Thumb encoding (32): 0xEF400910
    // Test aarch32_VMUL_i_T1A1_A field D = 1 (Max)
    // ISET: T32
    // Fields: M=0, Vd=0, Q=0, N=0, size=0, D=1, Vn=0, Vm=0, op=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF400910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, op=0, Vm=0, M=0, size=0, D=0, Q=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_1_poweroftwo_910_ef100910() {
    // Thumb encoding (32): 0xEF100910
    // Test aarch32_VMUL_i_T1A1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, Vm=0, D=0, M=0, size=1, Vd=0, Q=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_2_poweroftwo_910_ef200910() {
    // Thumb encoding (32): 0xEF200910
    // Test aarch32_VMUL_i_T1A1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: op=0, Vm=0, M=0, Q=0, Vd=0, N=0, D=0, Vn=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size 20 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_size_3_max_910_ef300910() {
    // Thumb encoding (32): 0xEF300910
    // Test aarch32_VMUL_i_T1A1_A field size = 3 (Max)
    // ISET: T32
    // Fields: M=0, Vm=0, Q=0, N=0, Vd=0, D=0, op=0, size=3, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vn_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, M=0, N=0, Vn=0, D=0, Vd=0, size=0, op=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vn_1_poweroftwo_910_ef010910() {
    // Thumb encoding (32): 0xEF010910
    // Test aarch32_VMUL_i_T1A1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=1, op=0, Vd=0, Q=0, N=0, M=0, D=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF010910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vd_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, N=0, size=0, op=0, Q=0, Vn=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vd_1_poweroftwo_910_ef001910() {
    // Thumb encoding (32): 0xEF001910
    // Test aarch32_VMUL_i_T1A1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vd=1, Q=0, D=0, size=0, op=0, Vn=0, Vm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF001910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_n_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, op=0, M=0, Vm=0, N=0, size=0, D=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_n_1_max_910_ef000990() {
    // Thumb encoding (32): 0xEF000990
    // Test aarch32_VMUL_i_T1A1_A field N = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vn=0, M=0, Vm=0, op=0, size=0, Vd=0, N=1, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000990;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_q_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: op=0, Vn=0, Vm=0, M=0, N=0, D=0, size=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_q_1_max_910_ef000950() {
    // Thumb encoding (32): 0xEF000950
    // Test aarch32_VMUL_i_T1A1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, Q=1, Vn=0, op=0, N=0, M=0, size=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000950;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_m_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field M = 0 (Min)
    // ISET: T32
    // Fields: N=0, size=0, D=0, Vd=0, Vm=0, M=0, Q=0, op=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_m_1_max_910_ef000930() {
    // Thumb encoding (32): 0xEF000930
    // Test aarch32_VMUL_i_T1A1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, op=0, size=0, Q=0, Vm=0, D=0, N=0, Vd=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000930;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vm_0_min_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: op=0, size=0, Vd=0, Q=0, Vm=0, M=0, N=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_vmul_i_t1a1_a_field_vm_1_poweroftwo_910_ef000911() {
    // Thumb encoding (32): 0xEF000911
    // Test aarch32_VMUL_i_T1A1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Vn=0, M=0, Q=0, op=0, Vm=1, D=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000911;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch32_vmul_i_t1a1_a_combo_0_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A field combination: op=0, D=0, size=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Q=0, Vn=0, Vd=0, M=0, size=0, Vm=0, D=0, op=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_0_size_variant_0_2320_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Q=0, N=0, Vm=0, Vd=0, M=0, op=0, Vn=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_1_size_variant_1_2320_ef100910() {
    // Thumb encoding (32): 0xEF100910
    // Test aarch32_VMUL_i_T1A1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Q=0, Vd=0, N=0, M=0, op=0, Vm=0, size=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_2_size_variant_2_2320_ef200910() {
    // Thumb encoding (32): 0xEF200910
    // Test aarch32_VMUL_i_T1A1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, Vd=0, Vm=0, N=0, D=0, M=0, op=0, Vn=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_size_3_size_variant_3_2320_ef300910() {
    // Thumb encoding (32): 0xEF300910
    // Test aarch32_VMUL_i_T1A1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: N=0, D=0, Vm=0, Vd=0, Vn=0, size=3, op=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_q_0_size_variant_0_2320_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: N=0, Vd=0, op=0, Vn=0, Vm=0, Q=0, D=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_vmul_i_t1a1_a_special_q_1_size_variant_1_2320_ef000950() {
    // Thumb encoding (32): 0xEF000950
    // Test aarch32_VMUL_i_T1A1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, op=0, Vm=0, size=0, Vn=0, M=0, Vd=0, Q=1, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000950;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "op" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"op\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_0_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "op" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) } } }
    // ISET: T32
    // Fields: Vm=0, Vn=0, N=0, Q=0, D=0, op=0, size=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_1_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, D=0, op=0, N=0, Vm=0, M=0, size=0, Q=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_2_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: Vd=0, M=0, size=0, Vm=0, op=0, N=0, Vn=0, Q=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_vmul_i_t1a1_a_invalid_3_910_ef000910() {
    // Thumb encoding (32): 0xEF000910
    // Test aarch32_VMUL_i_T1A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Q=0, size=0, op=0, Vd=0, D=0, N=0, M=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000910;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0x92401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0x92403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0x92407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // Encoding: 0x92400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // Encoding: 0x9240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x12001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x12003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_vmul_i_t1a1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // Encoding: 0x12000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_0_0_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_0_ff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_0_aaaaaaaa_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_0_55555555_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_0_ffffffff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_1_0_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_1_ff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_1_aaaaaaaa_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAA, "R0 should be 0x000000AA");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_1_55555555_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55, "R0 should be 0x00000055");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_1_ffffffff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_2_0_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_2_ff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_2_aaaaaaaa_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_2_55555555_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_2_ffffffff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_3_0_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_3_ff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_3_aaaaaaaa_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA000000, "R0 should be 0x0A000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_3_55555555_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5000000, "R0 should be 0x05000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_3_ffffffff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_4_0_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_4_ff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_4_aaaaaaaa_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_4_55555555_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_VMUL_i_T1A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_vmul_i_t1a1_a_a32_logical_imm_4_ffffffff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}
