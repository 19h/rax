//! A32 misc other tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_TSB_A Tests
// ============================================================================

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_0_min_12_03200012() {
    // Encoding: 0x03200012
    // Test aarch32_TSB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_1_poweroftwo_12_13200012() {
    // Encoding: 0x13200012
    // Test aarch32_TSB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_2_poweroftwo_12_23200012() {
    // Encoding: 0x23200012
    // Test aarch32_TSB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_3_poweroftwo_12_33200012() {
    // Encoding: 0x33200012
    // Test aarch32_TSB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_4_poweroftwo_12_43200012() {
    // Encoding: 0x43200012
    // Test aarch32_TSB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_5_poweroftwo_12_53200012() {
    // Encoding: 0x53200012
    // Test aarch32_TSB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_6_poweroftwo_12_63200012() {
    // Encoding: 0x63200012
    // Test aarch32_TSB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_7_poweroftwo_12_73200012() {
    // Encoding: 0x73200012
    // Test aarch32_TSB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_8_poweroftwo_12_83200012() {
    // Encoding: 0x83200012
    // Test aarch32_TSB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_9_poweroftwo_12_93200012() {
    // Encoding: 0x93200012
    // Test aarch32_TSB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_10_poweroftwo_12_a3200012() {
    // Encoding: 0xA3200012
    // Test aarch32_TSB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_11_poweroftwo_12_b3200012() {
    // Encoding: 0xB3200012
    // Test aarch32_TSB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_12_poweroftwo_12_c3200012() {
    // Encoding: 0xC3200012
    // Test aarch32_TSB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_13_poweroftwo_12_d3200012() {
    // Encoding: 0xD3200012
    // Test aarch32_TSB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_14_poweroftwo_12_e3200012() {
    // Encoding: 0xE3200012
    // Test aarch32_TSB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_tsb_a1_a_field_cond_15_max_12_f3200012() {
    // Encoding: 0xF3200012
    // Test aarch32_TSB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_tsb_a1_a_combo_0_12_03200012() {
    // Encoding: 0x03200012
    // Test aarch32_TSB_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_tsb_a1_a_special_cond_0_condition_eq_18_03200012() {
    // Encoding: 0x03200012
    // Test aarch32_TSB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_tsb_a1_a_special_cond_1_condition_ne_18_13200012() {
    // Encoding: 0x13200012
    // Test aarch32_TSB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_tsb_a1_a_special_cond_2_condition_cs_hs_18_23200012() {
    // Encoding: 0x23200012
    // Test aarch32_TSB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_tsb_a1_a_special_cond_3_condition_cc_lo_18_33200012() {
    // Encoding: 0x33200012
    // Test aarch32_TSB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_tsb_a1_a_special_cond_4_condition_mi_18_43200012() {
    // Encoding: 0x43200012
    // Test aarch32_TSB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_tsb_a1_a_special_cond_5_condition_pl_18_53200012() {
    // Encoding: 0x53200012
    // Test aarch32_TSB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_tsb_a1_a_special_cond_6_condition_vs_18_63200012() {
    // Encoding: 0x63200012
    // Test aarch32_TSB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_tsb_a1_a_special_cond_7_condition_vc_18_73200012() {
    // Encoding: 0x73200012
    // Test aarch32_TSB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_tsb_a1_a_special_cond_8_condition_hi_18_83200012() {
    // Encoding: 0x83200012
    // Test aarch32_TSB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_tsb_a1_a_special_cond_9_condition_ls_18_93200012() {
    // Encoding: 0x93200012
    // Test aarch32_TSB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_tsb_a1_a_special_cond_10_condition_ge_18_a3200012() {
    // Encoding: 0xA3200012
    // Test aarch32_TSB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_tsb_a1_a_special_cond_11_condition_lt_18_b3200012() {
    // Encoding: 0xB3200012
    // Test aarch32_TSB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_tsb_a1_a_special_cond_12_condition_gt_18_c3200012() {
    // Encoding: 0xC3200012
    // Test aarch32_TSB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_tsb_a1_a_special_cond_13_condition_le_18_d3200012() {
    // Encoding: 0xD3200012
    // Test aarch32_TSB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_tsb_a1_a_special_cond_14_condition_al_18_e3200012() {
    // Encoding: 0xE3200012
    // Test aarch32_TSB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_tsb_a1_a_special_cond_15_condition_nv_18_f3200012() {
    // Encoding: 0xF3200012
    // Test aarch32_TSB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_tsb_a1_a_invalid_0_12_03200012() {
    // Encoding: 0x03200012
    // Test aarch32_TSB_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_tsb_a1_a_invalid_1_12_03200012() {
    // Encoding: 0x03200012
    // Test aarch32_TSB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200012;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_TSB_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_tsb_t1_a_basic_encoding_f3a08012() {
    // Thumb encoding (32): 0xF3A08012
    // Test aarch32_TSB_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_TSB_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_tsb_t1_a_invalid_0_8012_f3a08012() {
    // Thumb encoding (32): 0xF3A08012
    // Test aarch32_TSB_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08012;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_TSB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_tsb_t1_a_invalid_1_8012_f3a08012() {
    // Thumb encoding (32): 0xF3A08012
    // Test aarch32_TSB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08012;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_TSB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_tsb_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

// ============================================================================
// aarch32_RFE_AS Tests
// ============================================================================

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rfe_a1_as_field_p_0_min_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS field P = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, U=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_rfe_a1_as_field_p_1_max_0_f9100000() {
    // Encoding: 0xF9100000
    // Test aarch32_RFE_A1_AS field P = 1 (Max)
    // ISET: A32
    // Fields: U=0, Rn=0, P=1, W=0
    let encoding: u32 = 0xF9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rfe_a1_as_field_u_0_min_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, U=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_rfe_a1_as_field_u_1_max_0_f8900000() {
    // Encoding: 0xF8900000
    // Test aarch32_RFE_A1_AS field U = 1 (Max)
    // ISET: A32
    // Fields: P=0, U=1, Rn=0, W=0
    let encoding: u32 = 0xF8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rfe_a1_as_field_w_0_min_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS field W = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, U=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_rfe_a1_as_field_w_1_max_0_f8300000() {
    // Encoding: 0xF8300000
    // Test aarch32_RFE_A1_AS field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, U=0, Rn=0, P=0
    let encoding: u32 = 0xF8300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rfe_a1_as_field_rn_0_min_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, P=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rfe_a1_as_field_rn_1_poweroftwo_0_f8110000() {
    // Encoding: 0xF8110000
    // Test aarch32_RFE_A1_AS field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=1, W=0, P=0
    let encoding: u32 = 0xF8110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_rfe_a1_as_combo_0_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS field combination: P=0, U=0, W=0, Rn=0
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, W=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_a1_as_invalid_0_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, W=0, P=0, U=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_a1_as_invalid_1_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_RFE_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, W=0, U=0, Rn=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rfe_t1_as_field_w_0_min_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS field W = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_rfe_t1_as_field_w_1_max_0_e8300000() {
    // Thumb encoding (32): 0xE8300000
    // Test aarch32_RFE_T1_AS field W = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, W=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rfe_t1_as_field_rn_0_min_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rfe_t1_as_field_rn_1_poweroftwo_0_e8110000() {
    // Thumb encoding (32): 0xE8110000
    // Test aarch32_RFE_T1_AS field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_rfe_t1_as_combo_0_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS field combination: W=0, Rn=0
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t1_as_invalid_0_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t1_as_invalid_1_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t1_as_invalid_2_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS invalid encoding: Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t1_as_invalid_3_0_e8100000() {
    // Thumb encoding (32): 0xE8100000
    // Test aarch32_RFE_T1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rfe_t2_as_field_w_0_min_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_rfe_t2_as_field_w_1_max_0_e9b00000() {
    // Thumb encoding (32): 0xE9B00000
    // Test aarch32_RFE_T2_AS field W = 1 (Max)
    // ISET: T32
    // Fields: W=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rfe_t2_as_field_rn_0_min_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS field Rn = 0 (Min)
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rfe_t2_as_field_rn_1_poweroftwo_0_e9910000() {
    // Thumb encoding (32): 0xE9910000
    // Test aarch32_RFE_T2_AS field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_rfe_t2_as_combo_0_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS field combination: W=0, Rn=0
    // ISET: T32
    // Fields: Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t2_as_invalid_0_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t2_as_invalid_1_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t2_as_invalid_2_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS invalid encoding: Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t2_as_invalid_3_0_e9900000() {
    // Thumb encoding (32): 0xE9900000
    // Test aarch32_RFE_T2_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_rfe_a1_as_exception_0_f8100000() {
    // Test aarch32_RFE_A1_AS exception: Undefined
    // Encoding: 0xF8100000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_RFE_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_a1_as_exception_1_f8100000() {
    // Test aarch32_RFE_A1_AS exception: Unpredictable
    // Encoding: 0xF8100000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_rfe_t1_as_exception_0_e8100000() {
    // Test aarch32_RFE_T1_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_RFE_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t1_as_exception_1_e8100000() {
    // Test aarch32_RFE_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_rfe_t2_as_exception_0_e9900000() {
    // Test aarch32_RFE_T2_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_RFE_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rfe_t2_as_exception_1_e9900000() {
    // Test aarch32_RFE_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_USADA8_A Tests
// ============================================================================

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_0_min_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, Rd=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_1_poweroftwo_10_17800010() {
    // Encoding: 0x17800010
    // Test aarch32_USADA8_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=0, Rn=0, cond=1
    let encoding: u32 = 0x17800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_2_poweroftwo_10_27800010() {
    // Encoding: 0x27800010
    // Test aarch32_USADA8_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0x27800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_3_poweroftwo_10_37800010() {
    // Encoding: 0x37800010
    // Test aarch32_USADA8_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=3, Ra=0, Rm=0
    let encoding: u32 = 0x37800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_4_poweroftwo_10_47800010() {
    // Encoding: 0x47800010
    // Test aarch32_USADA8_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x47800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_5_poweroftwo_10_57800010() {
    // Encoding: 0x57800010
    // Test aarch32_USADA8_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0, cond=5
    let encoding: u32 = 0x57800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_6_poweroftwo_10_67800010() {
    // Encoding: 0x67800010
    // Test aarch32_USADA8_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=6, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x67800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_7_poweroftwo_10_77800010() {
    // Encoding: 0x77800010
    // Test aarch32_USADA8_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, Ra=0, cond=7
    let encoding: u32 = 0x77800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_8_poweroftwo_10_87800010() {
    // Encoding: 0x87800010
    // Test aarch32_USADA8_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=8, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x87800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_9_poweroftwo_10_97800010() {
    // Encoding: 0x97800010
    // Test aarch32_USADA8_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rn=0, Rd=0, cond=9, Rm=0
    let encoding: u32 = 0x97800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_10_poweroftwo_10_a7800010() {
    // Encoding: 0xA7800010
    // Test aarch32_USADA8_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=0, Rn=0, cond=10
    let encoding: u32 = 0xA7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_11_poweroftwo_10_b7800010() {
    // Encoding: 0xB7800010
    // Test aarch32_USADA8_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0xB7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_12_poweroftwo_10_c7800010() {
    // Encoding: 0xC7800010
    // Test aarch32_USADA8_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0, cond=12
    let encoding: u32 = 0xC7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_13_poweroftwo_10_d7800010() {
    // Encoding: 0xD7800010
    // Test aarch32_USADA8_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rd=0, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0xD7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_14_poweroftwo_10_e7800010() {
    // Encoding: 0xE7800010
    // Test aarch32_USADA8_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=14, Ra=0, Rn=0, Rd=0
    let encoding: u32 = 0xE7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_usada8_a1_a_field_cond_15_max_10_f7800010() {
    // Encoding: 0xF7800010
    // Test aarch32_USADA8_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=15, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0xF7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_a1_a_field_rd_0_min_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Ra=0, Rn=0, Rd=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_a1_a_field_rd_1_poweroftwo_10_07810010() {
    // Encoding: 0x07810010
    // Test aarch32_USADA8_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=0, Rd=1, Rm=0, Rn=0
    let encoding: u32 = 0x07810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_a1_a_field_ra_0_min_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Ra=0, Rm=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_a1_a_field_ra_1_poweroftwo_10_07801010() {
    // Encoding: 0x07801010
    // Test aarch32_USADA8_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Ra=1, Rn=0, Rm=0
    let encoding: u32 = 0x07801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_a1_a_field_rm_0_min_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_a1_a_field_rm_1_poweroftwo_10_07800110() {
    // Encoding: 0x07800110
    // Test aarch32_USADA8_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=1, Rn=0, cond=0, Ra=0
    let encoding: u32 = 0x07800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_a1_a_field_rn_0_min_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_a1_a_field_rn_1_poweroftwo_10_07800011() {
    // Encoding: 0x07800011
    // Test aarch32_USADA8_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Ra=0, Rm=0, Rn=1, Rd=0
    let encoding: u32 = 0x07800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_usada8_a1_a_combo_0_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Ra=0, Rd=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_usada8_a1_a_special_cond_0_condition_eq_16_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Ra=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_usada8_a1_a_special_cond_1_condition_ne_16_17800010() {
    // Encoding: 0x17800010
    // Test aarch32_USADA8_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rm=0, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0x17800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_usada8_a1_a_special_cond_2_condition_cs_hs_16_27800010() {
    // Encoding: 0x27800010
    // Test aarch32_USADA8_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rm=0, Rd=0, Ra=0
    let encoding: u32 = 0x27800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_usada8_a1_a_special_cond_3_condition_cc_lo_16_37800010() {
    // Encoding: 0x37800010
    // Test aarch32_USADA8_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rn=0, Rm=0, cond=3
    let encoding: u32 = 0x37800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_usada8_a1_a_special_cond_4_condition_mi_16_47800010() {
    // Encoding: 0x47800010
    // Test aarch32_USADA8_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Ra=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x47800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_usada8_a1_a_special_cond_5_condition_pl_16_57800010() {
    // Encoding: 0x57800010
    // Test aarch32_USADA8_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0, cond=5
    let encoding: u32 = 0x57800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_usada8_a1_a_special_cond_6_condition_vs_16_67800010() {
    // Encoding: 0x67800010
    // Test aarch32_USADA8_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=6, Rm=0, Ra=0
    let encoding: u32 = 0x67800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_usada8_a1_a_special_cond_7_condition_vc_16_77800010() {
    // Encoding: 0x77800010
    // Test aarch32_USADA8_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Ra=0, Rm=0, cond=7, Rd=0, Rn=0
    let encoding: u32 = 0x77800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_usada8_a1_a_special_cond_8_condition_hi_16_87800010() {
    // Encoding: 0x87800010
    // Test aarch32_USADA8_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, cond=8, Rn=0, Rd=0, Ra=0
    let encoding: u32 = 0x87800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_usada8_a1_a_special_cond_9_condition_ls_16_97800010() {
    // Encoding: 0x97800010
    // Test aarch32_USADA8_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Ra=0, Rn=0, Rm=0, Rd=0, cond=9
    let encoding: u32 = 0x97800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_usada8_a1_a_special_cond_10_condition_ge_16_a7800010() {
    // Encoding: 0xA7800010
    // Test aarch32_USADA8_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Ra=0, cond=10, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0xA7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_usada8_a1_a_special_cond_11_condition_lt_16_b7800010() {
    // Encoding: 0xB7800010
    // Test aarch32_USADA8_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rm=0, Rn=0, Rd=0, Ra=0
    let encoding: u32 = 0xB7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_usada8_a1_a_special_cond_12_condition_gt_16_c7800010() {
    // Encoding: 0xC7800010
    // Test aarch32_USADA8_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, cond=12, Ra=0, Rm=0, Rd=0
    let encoding: u32 = 0xC7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_usada8_a1_a_special_cond_13_condition_le_16_d7800010() {
    // Encoding: 0xD7800010
    // Test aarch32_USADA8_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rd=0, Rn=0, cond=13
    let encoding: u32 = 0xD7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_usada8_a1_a_special_cond_14_condition_al_16_e7800010() {
    // Encoding: 0xE7800010
    // Test aarch32_USADA8_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xE7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_usada8_a1_a_special_cond_15_condition_nv_16_f7800010() {
    // Encoding: 0xF7800010
    // Test aarch32_USADA8_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xF7800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usada8_a1_a_invalid_0_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USADA8_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usada8_a1_a_invalid_1_10_07800010() {
    // Encoding: 0x07800010
    // Test aarch32_USADA8_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, Rd=0, Ra=0
    let encoding: u32 = 0x07800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_t1_a_field_rn_0_min_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_t1_a_field_rn_1_poweroftwo_0_fb710000() {
    // Thumb encoding (32): 0xFB710000
    // Test aarch32_USADA8_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Ra=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_t1_a_field_ra_0_min_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_t1_a_field_ra_1_poweroftwo_0_fb701000() {
    // Thumb encoding (32): 0xFB701000
    // Test aarch32_USADA8_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=1, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB701000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_t1_a_field_rd_0_min_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_t1_a_field_rd_1_poweroftwo_0_fb700100() {
    // Thumb encoding (32): 0xFB700100
    // Test aarch32_USADA8_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Ra=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usada8_t1_a_field_rm_0_min_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Ra=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usada8_t1_a_field_rm_1_poweroftwo_0_fb700001() {
    // Thumb encoding (32): 0xFB700001
    // Test aarch32_USADA8_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_usada8_t1_a_combo_0_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A field combination: Rn=0, Ra=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Ra=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usada8_t1_a_invalid_0_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_USADA8_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usada8_t1_a_invalid_1_0_fb700000() {
    // Thumb encoding (32): 0xFB700000
    // Test aarch32_USADA8_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB700000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_ADR_A Tests
// ============================================================================

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_adr_a1_a_field_cond_0_min_0_028f0000() {
    // Encoding: 0x028F0000
    // Test aarch32_ADR_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=0
    let encoding: u32 = 0x028F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_adr_a1_a_field_cond_1_poweroftwo_0_128f0000() {
    // Encoding: 0x128F0000
    // Test aarch32_ADR_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=1
    let encoding: u32 = 0x128F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_adr_a1_a_field_cond_2_poweroftwo_0_228f0000() {
    // Encoding: 0x228F0000
    // Test aarch32_ADR_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rd=0, imm12=0
    let encoding: u32 = 0x228F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_adr_a1_a_field_cond_3_poweroftwo_0_328f0000() {
    // Encoding: 0x328F0000
    // Test aarch32_ADR_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=3
    let encoding: u32 = 0x328F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_adr_a1_a_field_cond_4_poweroftwo_0_428f0000() {
    // Encoding: 0x428F0000
    // Test aarch32_ADR_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=4, Rd=0
    let encoding: u32 = 0x428F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_adr_a1_a_field_cond_5_poweroftwo_0_528f0000() {
    // Encoding: 0x528F0000
    // Test aarch32_ADR_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=5, Rd=0
    let encoding: u32 = 0x528F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_adr_a1_a_field_cond_6_poweroftwo_0_628f0000() {
    // Encoding: 0x628F0000
    // Test aarch32_ADR_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=6
    let encoding: u32 = 0x628F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_adr_a1_a_field_cond_7_poweroftwo_0_728f0000() {
    // Encoding: 0x728F0000
    // Test aarch32_ADR_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, imm12=0
    let encoding: u32 = 0x728F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_adr_a1_a_field_cond_8_poweroftwo_0_828f0000() {
    // Encoding: 0x828F0000
    // Test aarch32_ADR_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, imm12=0
    let encoding: u32 = 0x828F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_adr_a1_a_field_cond_9_poweroftwo_0_928f0000() {
    // Encoding: 0x928F0000
    // Test aarch32_ADR_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, imm12=0, Rd=0
    let encoding: u32 = 0x928F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_adr_a1_a_field_cond_10_poweroftwo_0_a28f0000() {
    // Encoding: 0xA28F0000
    // Test aarch32_ADR_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, imm12=0
    let encoding: u32 = 0xA28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_adr_a1_a_field_cond_11_poweroftwo_0_b28f0000() {
    // Encoding: 0xB28F0000
    // Test aarch32_ADR_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=11
    let encoding: u32 = 0xB28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_adr_a1_a_field_cond_12_poweroftwo_0_c28f0000() {
    // Encoding: 0xC28F0000
    // Test aarch32_ADR_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=12
    let encoding: u32 = 0xC28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_adr_a1_a_field_cond_13_poweroftwo_0_d28f0000() {
    // Encoding: 0xD28F0000
    // Test aarch32_ADR_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=13, Rd=0
    let encoding: u32 = 0xD28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_adr_a1_a_field_cond_14_poweroftwo_0_e28f0000() {
    // Encoding: 0xE28F0000
    // Test aarch32_ADR_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=14
    let encoding: u32 = 0xE28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_adr_a1_a_field_cond_15_max_0_f28f0000() {
    // Encoding: 0xF28F0000
    // Test aarch32_ADR_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm12=0, Rd=0
    let encoding: u32 = 0xF28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adr_a1_a_field_rd_0_min_0_028f0000() {
    // Encoding: 0x028F0000
    // Test aarch32_ADR_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x028F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adr_a1_a_field_rd_1_poweroftwo_0_028f1000() {
    // Encoding: 0x028F1000
    // Test aarch32_ADR_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, Rd=1
    let encoding: u32 = 0x028F1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_a1_a_field_imm12_0_zero_0_028f0000() {
    // Encoding: 0x028F0000
    // Test aarch32_ADR_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x028F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_a1_a_field_imm12_1_poweroftwo_0_028f0001() {
    // Encoding: 0x028F0001
    // Test aarch32_ADR_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=1, cond=0
    let encoding: u32 = 0x028F0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adr_a1_a_field_imm12_3_poweroftwominusone_0_028f0003() {
    // Encoding: 0x028F0003
    // Test aarch32_ADR_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=3, cond=0
    let encoding: u32 = 0x028F0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_4_poweroftwo_0_028f0004() {
    // Encoding: 0x028F0004
    // Test aarch32_ADR_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=4
    let encoding: u32 = 0x028F0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adr_a1_a_field_imm12_7_poweroftwominusone_0_028f0007() {
    // Encoding: 0x028F0007
    // Test aarch32_ADR_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=7, cond=0
    let encoding: u32 = 0x028F0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_8_poweroftwo_0_028f0008() {
    // Encoding: 0x028F0008
    // Test aarch32_ADR_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=8
    let encoding: u32 = 0x028F0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adr_a1_a_field_imm12_15_poweroftwominusone_0_028f000f() {
    // Encoding: 0x028F000F
    // Test aarch32_ADR_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=15
    let encoding: u32 = 0x028F000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_16_poweroftwo_0_028f0010() {
    // Encoding: 0x028F0010
    // Test aarch32_ADR_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=16
    let encoding: u32 = 0x028F0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adr_a1_a_field_imm12_31_poweroftwominusone_0_028f001f() {
    // Encoding: 0x028F001F
    // Test aarch32_ADR_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, cond=0, Rd=0
    let encoding: u32 = 0x028F001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_32_poweroftwo_0_028f0020() {
    // Encoding: 0x028F0020
    // Test aarch32_ADR_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=32
    let encoding: u32 = 0x028F0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adr_a1_a_field_imm12_63_poweroftwominusone_0_028f003f() {
    // Encoding: 0x028F003F
    // Test aarch32_ADR_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, Rd=0, cond=0
    let encoding: u32 = 0x028F003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_64_poweroftwo_0_028f0040() {
    // Encoding: 0x028F0040
    // Test aarch32_ADR_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=64, Rd=0
    let encoding: u32 = 0x028F0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_adr_a1_a_field_imm12_127_poweroftwominusone_0_028f007f() {
    // Encoding: 0x028F007F
    // Test aarch32_ADR_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=127, Rd=0
    let encoding: u32 = 0x028F007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_128_poweroftwo_0_028f0080() {
    // Encoding: 0x028F0080
    // Test aarch32_ADR_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=128
    let encoding: u32 = 0x028F0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_adr_a1_a_field_imm12_255_poweroftwominusone_0_028f00ff() {
    // Encoding: 0x028F00FF
    // Test aarch32_ADR_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=255, cond=0
    let encoding: u32 = 0x028F00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_256_poweroftwo_0_028f0100() {
    // Encoding: 0x028F0100
    // Test aarch32_ADR_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=256
    let encoding: u32 = 0x028F0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_adr_a1_a_field_imm12_511_poweroftwominusone_0_028f01ff() {
    // Encoding: 0x028F01FF
    // Test aarch32_ADR_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=511, cond=0
    let encoding: u32 = 0x028F01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_512_poweroftwo_0_028f0200() {
    // Encoding: 0x028F0200
    // Test aarch32_ADR_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=512
    let encoding: u32 = 0x028F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_adr_a1_a_field_imm12_1023_poweroftwominusone_0_028f03ff() {
    // Encoding: 0x028F03FF
    // Test aarch32_ADR_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=1023, cond=0
    let encoding: u32 = 0x028F03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_1024_poweroftwo_0_028f0400() {
    // Encoding: 0x028F0400
    // Test aarch32_ADR_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, cond=0, Rd=0
    let encoding: u32 = 0x028F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_2047_poweroftwominusone_0_028f07ff() {
    // Encoding: 0x028F07FF
    // Test aarch32_ADR_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=2047
    let encoding: u32 = 0x028F07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_2048_poweroftwo_0_028f0800() {
    // Encoding: 0x028F0800
    // Test aarch32_ADR_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=2048, cond=0
    let encoding: u32 = 0x028F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_adr_a1_a_field_imm12_4095_max_0_028f0fff() {
    // Encoding: 0x028F0FFF
    // Test aarch32_ADR_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, cond=0, Rd=0
    let encoding: u32 = 0x028F0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_adr_a1_a_combo_0_0_028f0000() {
    // Encoding: 0x028F0000
    // Test aarch32_ADR_A1_A field combination: cond=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x028F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_adr_a1_a_special_cond_0_condition_eq_0_028f0000() {
    // Encoding: 0x028F0000
    // Test aarch32_ADR_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm12=0, Rd=0
    let encoding: u32 = 0x028F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_adr_a1_a_special_cond_1_condition_ne_0_128f0000() {
    // Encoding: 0x128F0000
    // Test aarch32_ADR_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, imm12=0
    let encoding: u32 = 0x128F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_adr_a1_a_special_cond_2_condition_cs_hs_0_228f0000() {
    // Encoding: 0x228F0000
    // Test aarch32_ADR_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=2
    let encoding: u32 = 0x228F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_adr_a1_a_special_cond_3_condition_cc_lo_0_328f0000() {
    // Encoding: 0x328F0000
    // Test aarch32_ADR_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, cond=3, imm12=0
    let encoding: u32 = 0x328F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_adr_a1_a_special_cond_4_condition_mi_0_428f0000() {
    // Encoding: 0x428F0000
    // Test aarch32_ADR_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm12=0, Rd=0
    let encoding: u32 = 0x428F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_adr_a1_a_special_cond_5_condition_pl_0_528f0000() {
    // Encoding: 0x528F0000
    // Test aarch32_ADR_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, cond=5, imm12=0
    let encoding: u32 = 0x528F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_adr_a1_a_special_cond_6_condition_vs_0_628f0000() {
    // Encoding: 0x628F0000
    // Test aarch32_ADR_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, cond=6, imm12=0
    let encoding: u32 = 0x628F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_adr_a1_a_special_cond_7_condition_vc_0_728f0000() {
    // Encoding: 0x728F0000
    // Test aarch32_ADR_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rd=0, imm12=0
    let encoding: u32 = 0x728F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_adr_a1_a_special_cond_8_condition_hi_0_828f0000() {
    // Encoding: 0x828F0000
    // Test aarch32_ADR_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm12=0, cond=8, Rd=0
    let encoding: u32 = 0x828F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_adr_a1_a_special_cond_9_condition_ls_0_928f0000() {
    // Encoding: 0x928F0000
    // Test aarch32_ADR_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rd=0, imm12=0
    let encoding: u32 = 0x928F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_adr_a1_a_special_cond_10_condition_ge_0_a28f0000() {
    // Encoding: 0xA28F0000
    // Test aarch32_ADR_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, imm12=0
    let encoding: u32 = 0xA28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_adr_a1_a_special_cond_11_condition_lt_0_b28f0000() {
    // Encoding: 0xB28F0000
    // Test aarch32_ADR_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=11
    let encoding: u32 = 0xB28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_adr_a1_a_special_cond_12_condition_gt_0_c28f0000() {
    // Encoding: 0xC28F0000
    // Test aarch32_ADR_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, imm12=0, Rd=0
    let encoding: u32 = 0xC28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_adr_a1_a_special_cond_13_condition_le_0_d28f0000() {
    // Encoding: 0xD28F0000
    // Test aarch32_ADR_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, imm12=0
    let encoding: u32 = 0xD28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_adr_a1_a_special_cond_14_condition_al_0_e28f0000() {
    // Encoding: 0xE28F0000
    // Test aarch32_ADR_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, imm12=0, Rd=0
    let encoding: u32 = 0xE28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_adr_a1_a_special_cond_15_condition_nv_0_f28f0000() {
    // Encoding: 0xF28F0000
    // Test aarch32_ADR_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, cond=15, imm12=0
    let encoding: u32 = 0xF28F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_adr_a2_a_field_cond_0_min_0_024f0000() {
    // Encoding: 0x024F0000
    // Test aarch32_ADR_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=0
    let encoding: u32 = 0x024F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_adr_a2_a_field_cond_1_poweroftwo_0_124f0000() {
    // Encoding: 0x124F0000
    // Test aarch32_ADR_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=1
    let encoding: u32 = 0x124F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_adr_a2_a_field_cond_2_poweroftwo_0_224f0000() {
    // Encoding: 0x224F0000
    // Test aarch32_ADR_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm12=0, Rd=0
    let encoding: u32 = 0x224F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_adr_a2_a_field_cond_3_poweroftwo_0_324f0000() {
    // Encoding: 0x324F0000
    // Test aarch32_ADR_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=3, Rd=0
    let encoding: u32 = 0x324F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_adr_a2_a_field_cond_4_poweroftwo_0_424f0000() {
    // Encoding: 0x424F0000
    // Test aarch32_ADR_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=4, Rd=0
    let encoding: u32 = 0x424F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_adr_a2_a_field_cond_5_poweroftwo_0_524f0000() {
    // Encoding: 0x524F0000
    // Test aarch32_ADR_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=5
    let encoding: u32 = 0x524F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_adr_a2_a_field_cond_6_poweroftwo_0_624f0000() {
    // Encoding: 0x624F0000
    // Test aarch32_ADR_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=6, Rd=0
    let encoding: u32 = 0x624F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_adr_a2_a_field_cond_7_poweroftwo_0_724f0000() {
    // Encoding: 0x724F0000
    // Test aarch32_ADR_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, imm12=0
    let encoding: u32 = 0x724F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_adr_a2_a_field_cond_8_poweroftwo_0_824f0000() {
    // Encoding: 0x824F0000
    // Test aarch32_ADR_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=8
    let encoding: u32 = 0x824F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_adr_a2_a_field_cond_9_poweroftwo_0_924f0000() {
    // Encoding: 0x924F0000
    // Test aarch32_ADR_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=9
    let encoding: u32 = 0x924F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_adr_a2_a_field_cond_10_poweroftwo_0_a24f0000() {
    // Encoding: 0xA24F0000
    // Test aarch32_ADR_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=10, Rd=0
    let encoding: u32 = 0xA24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_adr_a2_a_field_cond_11_poweroftwo_0_b24f0000() {
    // Encoding: 0xB24F0000
    // Test aarch32_ADR_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=11
    let encoding: u32 = 0xB24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_adr_a2_a_field_cond_12_poweroftwo_0_c24f0000() {
    // Encoding: 0xC24F0000
    // Test aarch32_ADR_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rd=0, imm12=0
    let encoding: u32 = 0xC24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_adr_a2_a_field_cond_13_poweroftwo_0_d24f0000() {
    // Encoding: 0xD24F0000
    // Test aarch32_ADR_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rd=0, imm12=0
    let encoding: u32 = 0xD24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_adr_a2_a_field_cond_14_poweroftwo_0_e24f0000() {
    // Encoding: 0xE24F0000
    // Test aarch32_ADR_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=14
    let encoding: u32 = 0xE24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_adr_a2_a_field_cond_15_max_0_f24f0000() {
    // Encoding: 0xF24F0000
    // Test aarch32_ADR_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=15
    let encoding: u32 = 0xF24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adr_a2_a_field_rd_0_min_0_024f0000() {
    // Encoding: 0x024F0000
    // Test aarch32_ADR_A2_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x024F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adr_a2_a_field_rd_1_poweroftwo_0_024f1000() {
    // Encoding: 0x024F1000
    // Test aarch32_ADR_A2_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, imm12=0
    let encoding: u32 = 0x024F1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_a2_a_field_imm12_0_zero_0_024f0000() {
    // Encoding: 0x024F0000
    // Test aarch32_ADR_A2_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rd=0
    let encoding: u32 = 0x024F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_a2_a_field_imm12_1_poweroftwo_0_024f0001() {
    // Encoding: 0x024F0001
    // Test aarch32_ADR_A2_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=1, Rd=0
    let encoding: u32 = 0x024F0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adr_a2_a_field_imm12_3_poweroftwominusone_0_024f0003() {
    // Encoding: 0x024F0003
    // Test aarch32_ADR_A2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=3, cond=0
    let encoding: u32 = 0x024F0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_4_poweroftwo_0_024f0004() {
    // Encoding: 0x024F0004
    // Test aarch32_ADR_A2_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=4
    let encoding: u32 = 0x024F0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adr_a2_a_field_imm12_7_poweroftwominusone_0_024f0007() {
    // Encoding: 0x024F0007
    // Test aarch32_ADR_A2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=7, cond=0
    let encoding: u32 = 0x024F0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_8_poweroftwo_0_024f0008() {
    // Encoding: 0x024F0008
    // Test aarch32_ADR_A2_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=8
    let encoding: u32 = 0x024F0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adr_a2_a_field_imm12_15_poweroftwominusone_0_024f000f() {
    // Encoding: 0x024F000F
    // Test aarch32_ADR_A2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=15, Rd=0, cond=0
    let encoding: u32 = 0x024F000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_16_poweroftwo_0_024f0010() {
    // Encoding: 0x024F0010
    // Test aarch32_ADR_A2_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=16
    let encoding: u32 = 0x024F0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adr_a2_a_field_imm12_31_poweroftwominusone_0_024f001f() {
    // Encoding: 0x024F001F
    // Test aarch32_ADR_A2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=31
    let encoding: u32 = 0x024F001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_32_poweroftwo_0_024f0020() {
    // Encoding: 0x024F0020
    // Test aarch32_ADR_A2_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=32
    let encoding: u32 = 0x024F0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adr_a2_a_field_imm12_63_poweroftwominusone_0_024f003f() {
    // Encoding: 0x024F003F
    // Test aarch32_ADR_A2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=63
    let encoding: u32 = 0x024F003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_64_poweroftwo_0_024f0040() {
    // Encoding: 0x024F0040
    // Test aarch32_ADR_A2_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=64, cond=0
    let encoding: u32 = 0x024F0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_adr_a2_a_field_imm12_127_poweroftwominusone_0_024f007f() {
    // Encoding: 0x024F007F
    // Test aarch32_ADR_A2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, cond=0, Rd=0
    let encoding: u32 = 0x024F007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_128_poweroftwo_0_024f0080() {
    // Encoding: 0x024F0080
    // Test aarch32_ADR_A2_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=128, cond=0
    let encoding: u32 = 0x024F0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_adr_a2_a_field_imm12_255_poweroftwominusone_0_024f00ff() {
    // Encoding: 0x024F00FF
    // Test aarch32_ADR_A2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=255, cond=0, Rd=0
    let encoding: u32 = 0x024F00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_256_poweroftwo_0_024f0100() {
    // Encoding: 0x024F0100
    // Test aarch32_ADR_A2_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=256, cond=0
    let encoding: u32 = 0x024F0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_adr_a2_a_field_imm12_511_poweroftwominusone_0_024f01ff() {
    // Encoding: 0x024F01FF
    // Test aarch32_ADR_A2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=511, Rd=0
    let encoding: u32 = 0x024F01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_512_poweroftwo_0_024f0200() {
    // Encoding: 0x024F0200
    // Test aarch32_ADR_A2_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=512, cond=0
    let encoding: u32 = 0x024F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_adr_a2_a_field_imm12_1023_poweroftwominusone_0_024f03ff() {
    // Encoding: 0x024F03FF
    // Test aarch32_ADR_A2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=1023
    let encoding: u32 = 0x024F03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_1024_poweroftwo_0_024f0400() {
    // Encoding: 0x024F0400
    // Test aarch32_ADR_A2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=1024, cond=0
    let encoding: u32 = 0x024F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_2047_poweroftwominusone_0_024f07ff() {
    // Encoding: 0x024F07FF
    // Test aarch32_ADR_A2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=2047, Rd=0, cond=0
    let encoding: u32 = 0x024F07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_2048_poweroftwo_0_024f0800() {
    // Encoding: 0x024F0800
    // Test aarch32_ADR_A2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=2048
    let encoding: u32 = 0x024F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_adr_a2_a_field_imm12_4095_max_0_024f0fff() {
    // Encoding: 0x024F0FFF
    // Test aarch32_ADR_A2_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, cond=0, Rd=0
    let encoding: u32 = 0x024F0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_adr_a2_a_combo_0_0_024f0000() {
    // Encoding: 0x024F0000
    // Test aarch32_ADR_A2_A field combination: cond=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=0
    let encoding: u32 = 0x024F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_adr_a2_a_special_cond_0_condition_eq_0_024f0000() {
    // Encoding: 0x024F0000
    // Test aarch32_ADR_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm12=0, Rd=0
    let encoding: u32 = 0x024F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_adr_a2_a_special_cond_1_condition_ne_0_124f0000() {
    // Encoding: 0x124F0000
    // Test aarch32_ADR_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, imm12=0
    let encoding: u32 = 0x124F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_adr_a2_a_special_cond_2_condition_cs_hs_0_224f0000() {
    // Encoding: 0x224F0000
    // Test aarch32_ADR_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, cond=2, Rd=0
    let encoding: u32 = 0x224F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_adr_a2_a_special_cond_3_condition_cc_lo_0_324f0000() {
    // Encoding: 0x324F0000
    // Test aarch32_ADR_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm12=0, Rd=0
    let encoding: u32 = 0x324F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_adr_a2_a_special_cond_4_condition_mi_0_424f0000() {
    // Encoding: 0x424F0000
    // Test aarch32_ADR_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, imm12=0
    let encoding: u32 = 0x424F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_adr_a2_a_special_cond_5_condition_pl_0_524f0000() {
    // Encoding: 0x524F0000
    // Test aarch32_ADR_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=5
    let encoding: u32 = 0x524F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_adr_a2_a_special_cond_6_condition_vs_0_624f0000() {
    // Encoding: 0x624F0000
    // Test aarch32_ADR_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, imm12=0
    let encoding: u32 = 0x624F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_adr_a2_a_special_cond_7_condition_vc_0_724f0000() {
    // Encoding: 0x724F0000
    // Test aarch32_ADR_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rd=0, imm12=0
    let encoding: u32 = 0x724F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_adr_a2_a_special_cond_8_condition_hi_0_824f0000() {
    // Encoding: 0x824F0000
    // Test aarch32_ADR_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm12=0, Rd=0
    let encoding: u32 = 0x824F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_adr_a2_a_special_cond_9_condition_ls_0_924f0000() {
    // Encoding: 0x924F0000
    // Test aarch32_ADR_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rd=0, imm12=0
    let encoding: u32 = 0x924F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_adr_a2_a_special_cond_10_condition_ge_0_a24f0000() {
    // Encoding: 0xA24F0000
    // Test aarch32_ADR_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, imm12=0
    let encoding: u32 = 0xA24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_adr_a2_a_special_cond_11_condition_lt_0_b24f0000() {
    // Encoding: 0xB24F0000
    // Test aarch32_ADR_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, cond=11, imm12=0
    let encoding: u32 = 0xB24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_adr_a2_a_special_cond_12_condition_gt_0_c24f0000() {
    // Encoding: 0xC24F0000
    // Test aarch32_ADR_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=12
    let encoding: u32 = 0xC24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_adr_a2_a_special_cond_13_condition_le_0_d24f0000() {
    // Encoding: 0xD24F0000
    // Test aarch32_ADR_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm12=0, cond=13, Rd=0
    let encoding: u32 = 0xD24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_adr_a2_a_special_cond_14_condition_al_0_e24f0000() {
    // Encoding: 0xE24F0000
    // Test aarch32_ADR_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=14
    let encoding: u32 = 0xE24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_adr_a2_a_special_cond_15_condition_nv_0_f24f0000() {
    // Encoding: 0xF24F0000
    // Test aarch32_ADR_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, imm12=0
    let encoding: u32 = 0xF24F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field Rd 24 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adr_t1_a_field_rd_0_min_0_a0000000() {
    // Thumb encoding (32): 0xA0000000
    // Test aarch32_ADR_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field Rd 24 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adr_t1_a_field_rd_1_poweroftwo_0_a1000000() {
    // Thumb encoding (32): 0xA1000000
    // Test aarch32_ADR_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_t1_a_field_imm8_0_zero_0_a0000000() {
    // Thumb encoding (32): 0xA0000000
    // Test aarch32_ADR_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_t1_a_field_imm8_1_poweroftwo_0_a0010000() {
    // Thumb encoding (32): 0xA0010000
    // Test aarch32_ADR_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adr_t1_a_field_imm8_3_poweroftwominusone_0_a0030000() {
    // Thumb encoding (32): 0xA0030000
    // Test aarch32_ADR_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_4_poweroftwo_0_a0040000() {
    // Thumb encoding (32): 0xA0040000
    // Test aarch32_ADR_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adr_t1_a_field_imm8_7_poweroftwominusone_0_a0070000() {
    // Thumb encoding (32): 0xA0070000
    // Test aarch32_ADR_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_8_poweroftwo_0_a0080000() {
    // Thumb encoding (32): 0xA0080000
    // Test aarch32_ADR_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adr_t1_a_field_imm8_15_poweroftwominusone_0_a00f0000() {
    // Thumb encoding (32): 0xA00F0000
    // Test aarch32_ADR_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA00F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_16_poweroftwo_0_a0100000() {
    // Thumb encoding (32): 0xA0100000
    // Test aarch32_ADR_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adr_t1_a_field_imm8_31_poweroftwominusone_0_a01f0000() {
    // Thumb encoding (32): 0xA01F0000
    // Test aarch32_ADR_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA01F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_32_poweroftwo_0_a0200000() {
    // Thumb encoding (32): 0xA0200000
    // Test aarch32_ADR_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adr_t1_a_field_imm8_63_poweroftwominusone_0_a03f0000() {
    // Thumb encoding (32): 0xA03F0000
    // Test aarch32_ADR_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA03F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_64_poweroftwo_0_a0400000() {
    // Thumb encoding (32): 0xA0400000
    // Test aarch32_ADR_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_127_poweroftwominusone_0_a07f0000() {
    // Thumb encoding (32): 0xA07F0000
    // Test aarch32_ADR_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA07F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_128_poweroftwo_0_a0800000() {
    // Thumb encoding (32): 0xA0800000
    // Test aarch32_ADR_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_adr_t1_a_field_imm8_255_max_0_a0ff0000() {
    // Thumb encoding (32): 0xA0FF0000
    // Test aarch32_ADR_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_adr_t1_a_combo_0_0_a0000000() {
    // Thumb encoding (32): 0xA0000000
    // Test aarch32_ADR_T1_A field combination: Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adr_t2_a_field_i_0_min_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, imm8=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_adr_t2_a_field_i_1_max_0_f6af0000() {
    // Thumb encoding (32): 0xF6AF0000
    // Test aarch32_ADR_T2_A field i = 1 (Max)
    // ISET: T32
    // Fields: i=1, imm8=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF6AF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_t2_a_field_imm3_0_zero_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_t2_a_field_imm3_1_poweroftwo_0_f2af1000() {
    // Thumb encoding (32): 0xF2AF1000
    // Test aarch32_ADR_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=1, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_adr_t2_a_field_imm3_3_poweroftwominusone_0_f2af3000() {
    // Thumb encoding (32): 0xF2AF3000
    // Test aarch32_ADR_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=0, imm3=3, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_adr_t2_a_field_imm3_7_max_0_f2af7000() {
    // Thumb encoding (32): 0xF2AF7000
    // Test aarch32_ADR_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm3=7, imm8=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adr_t2_a_field_rd_0_min_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, i=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adr_t2_a_field_rd_1_poweroftwo_0_f2af0100() {
    // Thumb encoding (32): 0xF2AF0100
    // Test aarch32_ADR_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=1, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_t2_a_field_imm8_0_zero_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_t2_a_field_imm8_1_poweroftwo_0_f2af0001() {
    // Thumb encoding (32): 0xF2AF0001
    // Test aarch32_ADR_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adr_t2_a_field_imm8_3_poweroftwominusone_0_f2af0003() {
    // Thumb encoding (32): 0xF2AF0003
    // Test aarch32_ADR_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=3, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_4_poweroftwo_0_f2af0004() {
    // Thumb encoding (32): 0xF2AF0004
    // Test aarch32_ADR_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adr_t2_a_field_imm8_7_poweroftwominusone_0_f2af0007() {
    // Thumb encoding (32): 0xF2AF0007
    // Test aarch32_ADR_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_8_poweroftwo_0_f2af0008() {
    // Thumb encoding (32): 0xF2AF0008
    // Test aarch32_ADR_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adr_t2_a_field_imm8_15_poweroftwominusone_0_f2af000f() {
    // Thumb encoding (32): 0xF2AF000F
    // Test aarch32_ADR_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rd=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_16_poweroftwo_0_f2af0010() {
    // Thumb encoding (32): 0xF2AF0010
    // Test aarch32_ADR_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=16, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adr_t2_a_field_imm8_31_poweroftwominusone_0_f2af001f() {
    // Thumb encoding (32): 0xF2AF001F
    // Test aarch32_ADR_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rd=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_32_poweroftwo_0_f2af0020() {
    // Thumb encoding (32): 0xF2AF0020
    // Test aarch32_ADR_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adr_t2_a_field_imm8_63_poweroftwominusone_0_f2af003f() {
    // Thumb encoding (32): 0xF2AF003F
    // Test aarch32_ADR_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, imm8=63, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_64_poweroftwo_0_f2af0040() {
    // Thumb encoding (32): 0xF2AF0040
    // Test aarch32_ADR_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=64, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_127_poweroftwominusone_0_f2af007f() {
    // Thumb encoding (32): 0xF2AF007F
    // Test aarch32_ADR_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, imm8=127, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_128_poweroftwo_0_f2af0080() {
    // Thumb encoding (32): 0xF2AF0080
    // Test aarch32_ADR_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_adr_t2_a_field_imm8_255_max_0_f2af00ff() {
    // Thumb encoding (32): 0xF2AF00FF
    // Test aarch32_ADR_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rd=0, imm8=255, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_adr_t2_a_combo_0_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A field combination: i=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adr_t2_a_invalid_0_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADR_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adr_t2_a_invalid_1_0_f2af0000() {
    // Thumb encoding (32): 0xF2AF0000
    // Test aarch32_ADR_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, i=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AF0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adr_t3_a_field_i_0_min_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_adr_t3_a_field_i_1_max_0_f60f0000() {
    // Thumb encoding (32): 0xF60F0000
    // Test aarch32_ADR_T3_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, i=1, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF60F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_t3_a_field_imm3_0_zero_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_t3_a_field_imm3_1_poweroftwo_0_f20f1000() {
    // Thumb encoding (32): 0xF20F1000
    // Test aarch32_ADR_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rd=0, i=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_adr_t3_a_field_imm3_3_poweroftwominusone_0_f20f3000() {
    // Thumb encoding (32): 0xF20F3000
    // Test aarch32_ADR_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=3, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_adr_t3_a_field_imm3_7_max_0_f20f7000() {
    // Thumb encoding (32): 0xF20F7000
    // Test aarch32_ADR_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm8=0, Rd=0, i=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adr_t3_a_field_rd_0_min_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm8=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adr_t3_a_field_rd_1_poweroftwo_0_f20f0100() {
    // Thumb encoding (32): 0xF20F0100
    // Test aarch32_ADR_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm8=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adr_t3_a_field_imm8_0_zero_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adr_t3_a_field_imm8_1_poweroftwo_0_f20f0001() {
    // Thumb encoding (32): 0xF20F0001
    // Test aarch32_ADR_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adr_t3_a_field_imm8_3_poweroftwominusone_0_f20f0003() {
    // Thumb encoding (32): 0xF20F0003
    // Test aarch32_ADR_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_4_poweroftwo_0_f20f0004() {
    // Thumb encoding (32): 0xF20F0004
    // Test aarch32_ADR_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=4, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adr_t3_a_field_imm8_7_poweroftwominusone_0_f20f0007() {
    // Thumb encoding (32): 0xF20F0007
    // Test aarch32_ADR_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, imm8=7, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_8_poweroftwo_0_f20f0008() {
    // Thumb encoding (32): 0xF20F0008
    // Test aarch32_ADR_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=8, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adr_t3_a_field_imm8_15_poweroftwominusone_0_f20f000f() {
    // Thumb encoding (32): 0xF20F000F
    // Test aarch32_ADR_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, i=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_16_poweroftwo_0_f20f0010() {
    // Thumb encoding (32): 0xF20F0010
    // Test aarch32_ADR_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm8=16, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adr_t3_a_field_imm8_31_poweroftwominusone_0_f20f001f() {
    // Thumb encoding (32): 0xF20F001F
    // Test aarch32_ADR_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rd=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_32_poweroftwo_0_f20f0020() {
    // Thumb encoding (32): 0xF20F0020
    // Test aarch32_ADR_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm8=32, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adr_t3_a_field_imm8_63_poweroftwominusone_0_f20f003f() {
    // Thumb encoding (32): 0xF20F003F
    // Test aarch32_ADR_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm8=63, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_64_poweroftwo_0_f20f0040() {
    // Thumb encoding (32): 0xF20F0040
    // Test aarch32_ADR_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=64, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_127_poweroftwominusone_0_f20f007f() {
    // Thumb encoding (32): 0xF20F007F
    // Test aarch32_ADR_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_128_poweroftwo_0_f20f0080() {
    // Thumb encoding (32): 0xF20F0080
    // Test aarch32_ADR_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm8=128, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_adr_t3_a_field_imm8_255_max_0_f20f00ff() {
    // Thumb encoding (32): 0xF20F00FF
    // Test aarch32_ADR_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: i=0, imm3=0, Rd=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_adr_t3_a_combo_0_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A field combination: i=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adr_t3_a_invalid_0_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adr_t3_a_invalid_1_0_f20f0000() {
    // Thumb encoding (32): 0xF20F0000
    // Test aarch32_ADR_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_0_028f2820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x028F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x42E, "W0 should be 0x42E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_0_828f2820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x828F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x828F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x42E, "X0 should be 0x000000000000042E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_1_028f0020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x028F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_1_828f0020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x828F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x828F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000000000003C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_2_028f0420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C2, "W0 should be 0x3C2");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_2_828f0420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C2, "X0 should be 0x00000000000003C2");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_3_02bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x02BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_3_82bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x82BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_4_02fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_4_82fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_5_028f0420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_5_828f0420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000000000003C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_6_028f0420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1, "W0 should be 0x3C1");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_6_828f0420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1, "X0 should be 0x00000000000003C1");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_7_028f0420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_7_828f0420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x80000000000003C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_8_028f0420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800003C0, "W0 should be 0x800003C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_8_828f0420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x800003C0,
        "X0 should be 0x00000000800003C0"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_9_028f0420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_9_828f0420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000000000003C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_10_028f0420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x028F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_10_828f0420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x828F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000001000003C0");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_32_rd31_sp_028f283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x028F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(1070), message: "SP should be 0x42E" }
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adr_a1_a_add_oracle_64_rd31_sp_828f283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x828F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x828F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(1070), message: "SP should be 0x42E" }
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_0_228f2820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x228F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x228F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x42E, "W0 should be 0x42E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_0_a28f2820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA28F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA28F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x42E, "X0 should be 0x000000000000042E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_1_228f0020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x228F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x228F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_1_a28f0020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA28F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA28F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000000000003C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_2_228f0420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C2, "W0 should be 0x3C2");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_2_a28f0420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C2, "X0 should be 0x00000000000003C2");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_3_22bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x22BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_3_a2bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_4_22fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_4_a2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_5_228f0420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_5_a28f0420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000000000003C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_6_228f0420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1, "W0 should be 0x3C1");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_6_a28f0420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1, "X0 should be 0x00000000000003C1");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_7_228f0420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_7_a28f0420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x80000000000003C0");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_8_228f0420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800003C0, "W0 should be 0x800003C0");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_8_a28f0420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x800003C0,
        "X0 should be 0x00000000800003C0"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_9_228f0420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_9_a28f0420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000000000003C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_10_228f0420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x228F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "W0 should be 0x3C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_10_a28f0420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0, "X0 should be 0x00000001000003C0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_32_rd31_zr_228f283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x228F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x228F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adr_a1_a_adds_oracle_64_rd31_zr_a28f283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA28F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA28F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_0_428f2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x428F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x428F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC9A, "W0 should be 0xFFFFFC9A");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_0_c28f2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC28F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC28F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC9A,
        "X0 should be 0xFFFFFFFFFFFFFC9A"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_1_428f0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x428F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x428F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC40, "W0 should be 0xFFFFFC40");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_1_c28f0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC28F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC28F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC40,
        "X0 should be 0xFFFFFFFFFFFFFC40"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_2_428f0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC40, "W0 should be 0xFFFFFC40");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_2_c28f0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC40,
        "X0 should be 0xFFFFFFFFFFFFFC40"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_3_42bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x42BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_3_c2bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_4_42fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_4_c2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_5_428f0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_5_c28f0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0xFFFFFFFFFFFFFC3E"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_6_428f0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3F, "W0 should be 0xFFFFFC3F");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_6_c28f0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3F,
        "X0 should be 0xFFFFFFFFFFFFFC3F"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_7_428f0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_7_c28f0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0x7FFFFFFFFFFFFC3E"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_8_428f0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFC3E, "W0 should be 0x7FFFFC3E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_8_c28f0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFC3E,
        "X0 should be 0x000000007FFFFC3E"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_9_428f0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_9_c28f0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0xFFFFFFFFFFFFFC3E"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_10_428f0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x428F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_10_c28f0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0x00000000FFFFFC3E"
    );
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_32_rd31_sp_428f283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x428F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x428F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4294966426), message: "SP should be 0xFFFFFC9A" }
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adr_a1_a_sub_oracle_64_rd31_sp_c28f283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC28F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC28F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073709550746), message: "SP should be 0xFFFFFFFFFFFFFC9A" }
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_0_628f2820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x628F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x628F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC9A, "W0 should be 0xFFFFFC9A");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_0_e28f2820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE28F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE28F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC9A,
        "X0 should be 0xFFFFFFFFFFFFFC9A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_1_628f0020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x628F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x628F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC40, "W0 should be 0xFFFFFC40");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_1_e28f0020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE28F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE28F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC40,
        "X0 should be 0xFFFFFFFFFFFFFC40"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_2_628f0420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC40, "W0 should be 0xFFFFFC40");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_2_e28f0420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC40,
        "X0 should be 0xFFFFFFFFFFFFFC40"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_3_62bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x62BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_3_e2bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_4_62fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_4_e2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_5_628f0420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_5_e28f0420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0xFFFFFFFFFFFFFC3E"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_6_628f0420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3F, "W0 should be 0xFFFFFC3F");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_6_e28f0420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3F,
        "X0 should be 0xFFFFFFFFFFFFFC3F"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_7_628f0420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_7_e28f0420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0x7FFFFFFFFFFFFC3E"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_8_628f0420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFC3E, "W0 should be 0x7FFFFC3E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_8_e28f0420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFC3E,
        "X0 should be 0x000000007FFFFC3E"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_9_628f0420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_9_e28f0420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0xFFFFFFFFFFFFFC3E"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_10_628f0420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x628F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFC3E, "W0 should be 0xFFFFFC3E");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_10_e28f0420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE28F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFC3E,
        "X0 should be 0x00000000FFFFFC3E"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_32_rd31_zr_628f283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x628F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x628F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adr_a1_a_subs_oracle_64_rd31_zr_e28f283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE28F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE28F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_0_0_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_0_64_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_0_7fffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_0_80000000_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_0_ffffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_1_0_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_1_64_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_1_7fffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_1_80000000_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_1_ffffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_2_0_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_2_64_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_2_7fffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_2_80000000_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_2_ffffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_3_0_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_3_64_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_3_7fffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_3_80000000_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_3_ffffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_4_0_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_4_64_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_4_7fffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_4_80000000_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADR_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a1_a_a32_add_sub_imm_4_ffffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_0_024f2820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x024F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3CA064, "W0 should be 0x3CA064");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_0_824f2820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x824F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x824F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3CA064, "X0 should be 0x00000000003CA064");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_1_024f0020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x024F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0000, "W0 should be 0x3C0000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_1_824f0020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x824F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x824F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0000, "X0 should be 0x00000000003C0000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_2_024f0420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1001, "W0 should be 0x3C1001");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_2_824f0420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1001, "X0 should be 0x00000000003C1001");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_3_027ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_3_827ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_4_027ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_4_827ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_5_024f0420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_5_824f0420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x00000000003C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_6_024f0420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1000, "W0 should be 0x3C1000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_6_824f0420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1000, "X0 should be 0x00000000003C1000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_7_024f0420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_7_824f0420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x80000000003C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_8_024f0420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x803C0FFF, "W0 should be 0x803C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_8_824f0420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x803C0FFF,
        "X0 should be 0x00000000803C0FFF"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_9_024f0420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_9_824f0420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x00000000003C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_10_024f0420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x024F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_10_824f0420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x824F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x00000001003C0FFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_32_rd31_sp_024f283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x024F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(3973220), message: "SP should be 0x3CA064" }
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adr_a2_a_add_oracle_64_rd31_sp_824f283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x824F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x824F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(3973220), message: "SP should be 0x3CA064" }
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_0_224f2820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x224F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x224F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3CA064, "W0 should be 0x3CA064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_0_a24f2820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA24F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA24F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3CA064, "X0 should be 0x00000000003CA064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_1_224f0020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x224F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x224F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0000, "W0 should be 0x3C0000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_1_a24f0020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA24F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA24F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0000, "X0 should be 0x00000000003C0000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_2_224f0420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1001, "W0 should be 0x3C1001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_2_a24f0420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1001, "X0 should be 0x00000000003C1001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_3_227ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_3_a27ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_4_227ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_4_a27ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_5_224f0420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_5_a24f0420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x00000000003C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_6_224f0420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1000, "W0 should be 0x3C1000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_6_a24f0420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C1000, "X0 should be 0x00000000003C1000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_7_224f0420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_7_a24f0420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x80000000003C0FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_8_224f0420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x803C0FFF, "W0 should be 0x803C0FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_8_a24f0420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x803C0FFF,
        "X0 should be 0x00000000803C0FFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_9_224f0420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_9_a24f0420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x00000000003C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_10_224f0420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x224F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "W0 should be 0x3C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_10_a24f0420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3C0FFF, "X0 should be 0x00000001003C0FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_32_rd31_zr_224f283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x224F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x224F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adr_a2_a_adds_oracle_64_rd31_zr_a24f283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA24F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA24F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_0_424f2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x424F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x424F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC36064, "W0 should be 0xFFC36064");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_0_c24f2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC24F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC24F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC36064,
        "X0 should be 0xFFFFFFFFFFC36064"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_1_424f0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x424F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x424F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC40000, "W0 should be 0xFFC40000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_1_c24f0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC24F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC24F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC40000,
        "X0 should be 0xFFFFFFFFFFC40000"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_2_424f0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3F001, "W0 should be 0xFFC3F001");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_2_c24f0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3F001,
        "X0 should be 0xFFFFFFFFFFC3F001"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_3_427ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_3_c27ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_4_427ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_4_c27ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_5_424f0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_5_c24f0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0xFFFFFFFFFFC3EFFF"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_6_424f0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3F000, "W0 should be 0xFFC3F000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_6_c24f0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3F000,
        "X0 should be 0xFFFFFFFFFFC3F000"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_7_424f0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_7_c24f0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0x7FFFFFFFFFC3EFFF"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_8_424f0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FC3EFFF, "W0 should be 0x7FC3EFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_8_c24f0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FC3EFFF,
        "X0 should be 0x000000007FC3EFFF"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_9_424f0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_9_c24f0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0xFFFFFFFFFFC3EFFF"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_10_424f0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x424F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_10_c24f0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0x00000000FFC3EFFF"
    );
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_32_rd31_sp_424f283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x424F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x424F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4290994276), message: "SP should be 0xFFC36064" }
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adr_a2_a_sub_oracle_64_rd31_sp_c24f283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC24F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC24F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073705578596), message: "SP should be 0xFFFFFFFFFFC36064" }
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_0_624f2820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x624F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x624F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC36064, "W0 should be 0xFFC36064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_0_e24f2820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE24F2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE24F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC36064,
        "X0 should be 0xFFFFFFFFFFC36064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_1_624f0020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x624F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x624F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC40000, "W0 should be 0xFFC40000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_1_e24f0020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE24F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE24F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC40000,
        "X0 should be 0xFFFFFFFFFFC40000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_2_624f0420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3F001, "W0 should be 0xFFC3F001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_2_e24f0420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3F001,
        "X0 should be 0xFFFFFFFFFFC3F001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_3_627ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_3_e27ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_4_627ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_4_e27ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_5_624f0420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_5_e24f0420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0xFFFFFFFFFFC3EFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_6_624f0420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3F000, "W0 should be 0xFFC3F000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_6_e24f0420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3F000,
        "X0 should be 0xFFFFFFFFFFC3F000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_7_624f0420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_7_e24f0420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0x7FFFFFFFFFC3EFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_8_624f0420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FC3EFFF, "W0 should be 0x7FC3EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_8_e24f0420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FC3EFFF,
        "X0 should be 0x000000007FC3EFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_9_624f0420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_9_e24f0420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0xFFFFFFFFFFC3EFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_10_624f0420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x624F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFC3EFFF, "W0 should be 0xFFC3EFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_10_e24f0420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE24F0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFC3EFFF,
        "X0 should be 0x00000000FFC3EFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_32_rd31_zr_624f283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x624F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x624F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adr_a2_a_subs_oracle_64_rd31_zr_e24f283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE24F283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE24F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_0_0_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF6, "R0 should be 0xFFFFFFF6");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_0_64_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "R0 should be 0x0000005A");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_0_7fffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF5, "R0 should be 0x7FFFFFF5");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_0_80000000_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF6, "R0 should be 0x7FFFFFF6");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_0_ffffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_1_0_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF01, "R0 should be 0xFFFFFF01");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_1_64_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF65, "R0 should be 0xFFFFFF65");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_1_7fffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF00, "R0 should be 0x7FFFFF00");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_1_80000000_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF01, "R0 should be 0x7FFFFF01");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_1_ffffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_2_0_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFE0, "R0 should be 0xFFFFFFE0");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_2_64_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x44, "R0 should be 0x00000044");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_2_7fffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFDF, "R0 should be 0x7FFFFFDF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_2_80000000_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFE0, "R0 should be 0x7FFFFFE0");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_2_ffffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_3_0_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000000, "R0 should be 0xF1000000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_3_64_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000064, "R0 should be 0xF1000064");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_3_7fffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x70FFFFFF, "R0 should be 0x70FFFFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_3_80000000_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x71000000, "R0 should be 0x71000000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_3_ffffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_4_0_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_4_64_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_4_7fffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_4_80000000_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADR_A2_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adr_a2_a_a32_add_sub_imm_4_ffffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_32_0_a0020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_64_0_a0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_32_1_a0020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_64_1_a0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_32_2_a0020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_64_2_a0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_32_3_a0020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_64_3_a0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_32_4_a0020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_64_4_a0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_32_5_a0020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_adr_t1_a_lslv_oracle_64_5_a0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_adr_t1_a_t16_oracle_0_a0000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_adr_t1_a_t16_oracle_1_a0000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_adr_t1_a_t16_oracle_2_a0000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADR_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_adr_t1_a_t16_oracle_3_a0000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_ADR_T3_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_adr_t3_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

// ============================================================================
// aarch32_SETPAN_A Tests
// ============================================================================

/// Provenance: aarch32_SETPAN_A1_A
/// ASL: `field imm1 9 +: 1`
/// Requirement: FieldBoundary { field: "imm1", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_setpan_a1_a_field_imm1_0_zero_0_f1100000() {
    // Encoding: 0xF1100000
    // Test aarch32_SETPAN_A1_A field imm1 = 0 (Zero)
    // ISET: A32
    // Fields: imm1=0
    let encoding: u32 = 0xF1100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SETPAN_A1_A
/// ASL: `field imm1 9 +: 1`
/// Requirement: FieldBoundary { field: "imm1", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_setpan_a1_a_field_imm1_1_poweroftwo_0_f1100200() {
    // Encoding: 0xF1100200
    // Test aarch32_SETPAN_A1_A field imm1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm1=1
    let encoding: u32 = 0xF1100200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SETPAN_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm1=0 (immediate value 0)
#[test]
fn test_aarch32_setpan_a1_a_combo_0_0_f1100000() {
    // Encoding: 0xF1100000
    // Test aarch32_SETPAN_A1_A field combination: imm1=0
    // ISET: A32
    // Fields: imm1=0
    let encoding: u32 = 0xF1100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SETPAN_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HavePANExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HavePANExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_setpan_a1_a_invalid_0_0_f1100000() {
    // Encoding: 0xF1100000
    // Test aarch32_SETPAN_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HavePANExt" }, args: [] } }
    // ISET: A32
    // Fields: imm1=0
    let encoding: u32 = 0xF1100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SETPAN_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_setpan_a1_a_invalid_1_0_f1100000() {
    // Encoding: 0xF1100000
    // Test aarch32_SETPAN_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: imm1=0
    let encoding: u32 = 0xF1100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `field imm1 19 +: 1`
/// Requirement: FieldBoundary { field: "imm1", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_setpan_t1_a_field_imm1_0_zero_0_b6000000() {
    // Thumb encoding (32): 0xB6000000
    // Test aarch32_SETPAN_T1_A field imm1 = 0 (Zero)
    // ISET: T32
    // Fields: imm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `field imm1 19 +: 1`
/// Requirement: FieldBoundary { field: "imm1", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_setpan_t1_a_field_imm1_1_poweroftwo_0_b6080000() {
    // Thumb encoding (32): 0xB6080000
    // Test aarch32_SETPAN_T1_A field imm1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm1=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm1=0 (immediate value 0)
#[test]
fn test_aarch32_setpan_t1_a_combo_0_0_b6000000() {
    // Thumb encoding (32): 0xB6000000
    // Test aarch32_SETPAN_T1_A field combination: imm1=0
    // ISET: T32
    // Fields: imm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_setpan_t1_a_invalid_0_0_b6000000() {
    // Thumb encoding (32): 0xB6000000
    // Test aarch32_SETPAN_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: imm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_setpan_t1_a_invalid_1_0_b6000000() {
    // Thumb encoding (32): 0xB6000000
    // Test aarch32_SETPAN_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HavePANExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HavePANExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_setpan_t1_a_invalid_2_0_b6000000() {
    // Thumb encoding (32): 0xB6000000
    // Test aarch32_SETPAN_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HavePANExt" }, args: [] } }
    // ISET: T32
    // Fields: imm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_setpan_t1_a_invalid_3_0_b6000000() {
    // Thumb encoding (32): 0xB6000000
    // Test aarch32_SETPAN_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB6000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_32_0_b6020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_64_0_b6020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_32_1_b6020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_64_1_b6020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_32_2_b6020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_64_2_b6020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_32_3_b6020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_64_3_b6020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_32_4_b6020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_64_4_b6020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_32_5_b6020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_setpan_t1_a_lslv_oracle_64_5_b6020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_setpan_t1_a_t16_oracle_0_b6000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_setpan_t1_a_t16_oracle_1_b6000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_setpan_t1_a_t16_oracle_2_b6000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SETPAN_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_setpan_t1_a_t16_oracle_3_b6000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_CRC32_A Tests
// ============================================================================

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_0_min_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, sz=0, Rd=0, Rn=0, C=0, cond=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_1_poweroftwo_240_11000040() {
    // Encoding: 0x11000040
    // Test aarch32_CRC32_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, sz=0, Rd=0, cond=1, Rn=0, C=0
    let encoding: u32 = 0x11000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_2_poweroftwo_240_21000040() {
    // Encoding: 0x21000040
    // Test aarch32_CRC32_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rd=0, C=0, sz=0, Rm=0
    let encoding: u32 = 0x21000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_3_poweroftwo_240_31000040() {
    // Encoding: 0x31000040
    // Test aarch32_CRC32_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, cond=3, Rd=0, Rm=0, C=0, Rn=0
    let encoding: u32 = 0x31000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_4_poweroftwo_240_41000040() {
    // Encoding: 0x41000040
    // Test aarch32_CRC32_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, cond=4, Rd=0, C=0, Rn=0, Rm=0
    let encoding: u32 = 0x41000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_5_poweroftwo_240_51000040() {
    // Encoding: 0x51000040
    // Test aarch32_CRC32_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sz=0, cond=5, C=0, Rn=0, Rm=0
    let encoding: u32 = 0x51000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_6_poweroftwo_240_61000040() {
    // Encoding: 0x61000040
    // Test aarch32_CRC32_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, C=0, cond=6, Rn=0, sz=0, Rm=0
    let encoding: u32 = 0x61000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_7_poweroftwo_240_71000040() {
    // Encoding: 0x71000040
    // Test aarch32_CRC32_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, C=0, Rd=0, Rn=0, Rm=0, cond=7
    let encoding: u32 = 0x71000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_8_poweroftwo_240_81000040() {
    // Encoding: 0x81000040
    // Test aarch32_CRC32_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, Rm=0, Rd=0, Rn=0, cond=8, C=0
    let encoding: u32 = 0x81000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_9_poweroftwo_240_91000040() {
    // Encoding: 0x91000040
    // Test aarch32_CRC32_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, sz=0, Rn=0, Rm=0, C=0, Rd=0
    let encoding: u32 = 0x91000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_10_poweroftwo_240_a1000040() {
    // Encoding: 0xA1000040
    // Test aarch32_CRC32_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=10, Rd=0, C=0, sz=0
    let encoding: u32 = 0xA1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_11_poweroftwo_240_b1000040() {
    // Encoding: 0xB1000040
    // Test aarch32_CRC32_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, Rd=0, C=0, Rm=0, cond=11, Rn=0
    let encoding: u32 = 0xB1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_12_poweroftwo_240_c1000040() {
    // Encoding: 0xC1000040
    // Test aarch32_CRC32_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rn=0, Rm=0, sz=0, C=0
    let encoding: u32 = 0xC1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_13_poweroftwo_240_d1000040() {
    // Encoding: 0xD1000040
    // Test aarch32_CRC32_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, sz=0, Rn=0, Rm=0, C=0, Rd=0
    let encoding: u32 = 0xD1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_14_poweroftwo_240_e1000040() {
    // Encoding: 0xE1000040
    // Test aarch32_CRC32_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, sz=0, Rn=0, cond=14, C=0, Rd=0
    let encoding: u32 = 0xE1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_crc32_a1_a_field_cond_15_max_240_f1000040() {
    // Encoding: 0xF1000040
    // Test aarch32_CRC32_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=15, sz=0, C=0, Rd=0
    let encoding: u32 = 0xF1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz 21 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_crc32_a1_a_field_sz_0_min_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field sz = 0 (Min)
    // ISET: A32
    // Fields: sz=0, Rd=0, Rm=0, Rn=0, cond=0, C=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz 21 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_crc32_a1_a_field_sz_1_poweroftwo_240_01200040() {
    // Encoding: 0x01200040
    // Test aarch32_CRC32_A1_A field sz = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, Rn=0, sz=1, C=0
    let encoding: u32 = 0x01200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz 21 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_crc32_a1_a_field_sz_2_poweroftwo_240_01400040() {
    // Encoding: 0x01400040
    // Test aarch32_CRC32_A1_A field sz = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, sz=2, cond=0, Rd=0, C=0, Rn=0
    let encoding: u32 = 0x01400040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz 21 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_crc32_a1_a_field_sz_3_max_240_01600040() {
    // Encoding: 0x01600040
    // Test aarch32_CRC32_A1_A field sz = 3 (Max)
    // ISET: A32
    // Fields: Rd=0, Rm=0, C=0, sz=3, cond=0, Rn=0
    let encoding: u32 = 0x01600040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_crc32_a1_a_field_rn_0_min_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, sz=0, cond=0, C=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_crc32_a1_a_field_rn_1_poweroftwo_240_01010040() {
    // Encoding: 0x01010040
    // Test aarch32_CRC32_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: C=0, cond=0, sz=0, Rd=0, Rm=0, Rn=1
    let encoding: u32 = 0x01010040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_crc32_a1_a_field_rd_0_min_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Rm=0, sz=0, C=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_crc32_a1_a_field_rd_1_poweroftwo_240_01001040() {
    // Encoding: 0x01001040
    // Test aarch32_CRC32_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Rd=1, sz=0, C=0
    let encoding: u32 = 0x01001040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field C 9 +: 1`
/// Requirement: FieldBoundary { field: "C", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_crc32_a1_a_field_c_0_min_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field C = 0 (Min)
    // ISET: A32
    // Fields: cond=0, sz=0, Rm=0, Rd=0, Rn=0, C=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field C 9 +: 1`
/// Requirement: FieldBoundary { field: "C", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_crc32_a1_a_field_c_1_max_240_01000240() {
    // Encoding: 0x01000240
    // Test aarch32_CRC32_A1_A field C = 1 (Max)
    // ISET: A32
    // Fields: C=1, cond=0, sz=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x01000240;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_crc32_a1_a_field_rm_0_min_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: sz=0, cond=0, Rd=0, Rm=0, C=0, Rn=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_crc32_a1_a_field_rm_1_poweroftwo_240_01000041() {
    // Encoding: 0x01000041
    // Test aarch32_CRC32_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: sz=0, Rd=0, cond=0, Rn=0, C=0, Rm=1
    let encoding: u32 = 0x01000041;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_crc32_a1_a_combo_0_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A field combination: cond=0, sz=0, Rn=0, Rd=0, C=0, Rm=0
    // ISET: A32
    // Fields: sz=0, Rn=0, Rd=0, Rm=0, cond=0, C=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_crc32_a1_a_special_cond_0_condition_eq_576_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, sz=0, C=0, Rm=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_crc32_a1_a_special_cond_1_condition_ne_576_11000040() {
    // Encoding: 0x11000040
    // Test aarch32_CRC32_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: sz=0, Rm=0, Rn=0, C=0, cond=1, Rd=0
    let encoding: u32 = 0x11000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_crc32_a1_a_special_cond_2_condition_cs_hs_576_21000040() {
    // Encoding: 0x21000040
    // Test aarch32_CRC32_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rm=0, sz=0, Rd=0, cond=2, C=0
    let encoding: u32 = 0x21000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_crc32_a1_a_special_cond_3_condition_cc_lo_576_31000040() {
    // Encoding: 0x31000040
    // Test aarch32_CRC32_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, cond=3, C=0, Rn=0, Rm=0, sz=0
    let encoding: u32 = 0x31000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_crc32_a1_a_special_cond_4_condition_mi_576_41000040() {
    // Encoding: 0x41000040
    // Test aarch32_CRC32_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, C=0, sz=0, Rn=0, cond=4, Rd=0
    let encoding: u32 = 0x41000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_crc32_a1_a_special_cond_5_condition_pl_576_51000040() {
    // Encoding: 0x51000040
    // Test aarch32_CRC32_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: C=0, Rm=0, Rd=0, sz=0, Rn=0, cond=5
    let encoding: u32 = 0x51000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_crc32_a1_a_special_cond_6_condition_vs_576_61000040() {
    // Encoding: 0x61000040
    // Test aarch32_CRC32_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=6, sz=0, Rd=0, C=0
    let encoding: u32 = 0x61000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_crc32_a1_a_special_cond_7_condition_vc_576_71000040() {
    // Encoding: 0x71000040
    // Test aarch32_CRC32_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, sz=0, cond=7, Rd=0, Rm=0, C=0
    let encoding: u32 = 0x71000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_crc32_a1_a_special_cond_8_condition_hi_576_81000040() {
    // Encoding: 0x81000040
    // Test aarch32_CRC32_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: C=0, sz=0, cond=8, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x81000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_crc32_a1_a_special_cond_9_condition_ls_576_91000040() {
    // Encoding: 0x91000040
    // Test aarch32_CRC32_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: sz=0, cond=9, C=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x91000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_crc32_a1_a_special_cond_10_condition_ge_576_a1000040() {
    // Encoding: 0xA1000040
    // Test aarch32_CRC32_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: sz=0, Rd=0, Rm=0, cond=10, C=0, Rn=0
    let encoding: u32 = 0xA1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_crc32_a1_a_special_cond_11_condition_lt_576_b1000040() {
    // Encoding: 0xB1000040
    // Test aarch32_CRC32_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rm=0, C=0, sz=0, Rn=0
    let encoding: u32 = 0xB1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_crc32_a1_a_special_cond_12_condition_gt_576_c1000040() {
    // Encoding: 0xC1000040
    // Test aarch32_CRC32_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=12, sz=0, Rn=0, C=0
    let encoding: u32 = 0xC1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_crc32_a1_a_special_cond_13_condition_le_576_d1000040() {
    // Encoding: 0xD1000040
    // Test aarch32_CRC32_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: C=0, Rm=0, Rd=0, Rn=0, cond=13, sz=0
    let encoding: u32 = 0xD1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_crc32_a1_a_special_cond_14_condition_al_576_e1000040() {
    // Encoding: 0xE1000040
    // Test aarch32_CRC32_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=14, sz=0, C=0
    let encoding: u32 = 0xE1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_crc32_a1_a_special_cond_15_condition_nv_576_f1000040() {
    // Encoding: 0xF1000040
    // Test aarch32_CRC32_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=15, sz=0, C=0
    let encoding: u32 = 0xF1000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_crc32_a1_a_special_sz_0_size_variant_0_576_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A special value sz = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, Rd=0, C=0, sz=0, cond=0, Rn=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_crc32_a1_a_special_sz_1_size_variant_1_576_01200040() {
    // Encoding: 0x01200040
    // Test aarch32_CRC32_A1_A special value sz = 1 (Size variant 1)
    // ISET: A32
    // Fields: C=0, Rn=0, Rd=0, Rm=0, cond=0, sz=1
    let encoding: u32 = 0x01200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "sz", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_crc32_a1_a_special_sz_2_size_variant_2_576_01400040() {
    // Encoding: 0x01400040
    // Test aarch32_CRC32_A1_A special value sz = 2 (Size variant 2)
    // ISET: A32
    // Fields: Rd=0, Rm=0, sz=2, C=0, cond=0, Rn=0
    let encoding: u32 = 0x01400040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `field sz = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "sz", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_crc32_a1_a_special_sz_3_size_variant_3_576_01600040() {
    // Encoding: 0x01600040
    // Test aarch32_CRC32_A1_A special value sz = 3 (Size variant 3)
    // ISET: A32
    // Fields: C=0, Rn=0, Rm=0, cond=0, sz=3, Rd=0
    let encoding: u32 = 0x01600040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveCRCExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveCRCExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_crc32_a1_a_invalid_0_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveCRCExt" }, args: [] } }
    // ISET: A32
    // Fields: sz=0, Rm=0, cond=0, C=0, Rn=0, Rd=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_crc32_a1_a_invalid_1_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Rd=0, Rn=0, sz=0, C=0, Rm=0, cond=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_a1_a_invalid_2_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, C=0, Rn=0, Rm=0, cond=0, sz=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_a1_a_invalid_3_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: sz=0, Rm=0, Rd=0, cond=0, C=0, Rn=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitInt(64) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitInt(64) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_a1_a_invalid_4_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitInt(64) }
    // ISET: A32
    // Fields: cond=0, C=0, sz=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_a1_a_invalid_5_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, sz=0, C=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_a1_a_invalid_6_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: Rd=0, sz=0, cond=0, Rn=0, Rm=0, C=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_a1_a_invalid_7_240_01000040() {
    // Encoding: 0x01000040
    // Test aarch32_CRC32_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, sz=0, C=0, Rn=0, cond=0, Rm=0
    let encoding: u32 = 0x01000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field C 20 +: 1`
/// Requirement: FieldBoundary { field: "C", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_crc32_t1_a_field_c_0_min_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A field C = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, sz=0, Rd=0, C=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field C 20 +: 1`
/// Requirement: FieldBoundary { field: "C", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_crc32_t1_a_field_c_1_max_f080_fad0f080() {
    // Thumb encoding (32): 0xFAD0F080
    // Test aarch32_CRC32_T1_A field C = 1 (Max)
    // ISET: T32
    // Fields: sz=0, Rm=0, Rd=0, C=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAD0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_crc32_t1_a_field_rn_0_min_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, C=0, Rn=0, Rd=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_crc32_t1_a_field_rn_1_poweroftwo_f080_fac1f080() {
    // Thumb encoding (32): 0xFAC1F080
    // Test aarch32_CRC32_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: C=0, sz=0, Rd=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC1F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_crc32_t1_a_field_rd_0_min_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, sz=0, Rm=0, C=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_crc32_t1_a_field_rd_1_poweroftwo_f080_fac0f180() {
    // Thumb encoding (32): 0xFAC0F180
    // Test aarch32_CRC32_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: C=0, Rn=0, Rm=0, Rd=1, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz 4 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_crc32_t1_a_field_sz_0_min_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A field sz = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, sz=0, C=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz 4 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_crc32_t1_a_field_sz_1_poweroftwo_f080_fac0f090() {
    // Thumb encoding (32): 0xFAC0F090
    // Test aarch32_CRC32_T1_A field sz = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, sz=1, Rm=0, C=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz 4 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_crc32_t1_a_field_sz_2_poweroftwo_f080_fac0f0a0() {
    // Thumb encoding (32): 0xFAC0F0A0
    // Test aarch32_CRC32_T1_A field sz = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, sz=2, C=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz 4 +: 2`
/// Requirement: FieldBoundary { field: "sz", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_crc32_t1_a_field_sz_3_max_f080_fac0f0b0() {
    // Thumb encoding (32): 0xFAC0F0B0
    // Test aarch32_CRC32_T1_A field sz = 3 (Max)
    // ISET: T32
    // Fields: sz=3, Rm=0, Rn=0, C=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_crc32_t1_a_field_rm_0_min_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, C=0, Rn=0, Rd=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_crc32_t1_a_field_rm_1_poweroftwo_f080_fac0f081() {
    // Thumb encoding (32): 0xFAC0F081
    // Test aarch32_CRC32_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, sz=0, C=0, Rm=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// C=0 (minimum value)
#[test]
fn test_aarch32_crc32_t1_a_combo_0_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A field combination: C=0, Rn=0, Rd=0, sz=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, sz=0, C=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_crc32_t1_a_special_sz_0_size_variant_0_61568_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A special value sz = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Rd=0, C=0, Rn=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_crc32_t1_a_special_sz_1_size_variant_1_61568_fac0f090() {
    // Thumb encoding (32): 0xFAC0F090
    // Test aarch32_CRC32_T1_A special value sz = 1 (Size variant 1)
    // ISET: T32
    // Fields: sz=1, Rn=0, Rm=0, Rd=0, C=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "sz", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_crc32_t1_a_special_sz_2_size_variant_2_61568_fac0f0a0() {
    // Thumb encoding (32): 0xFAC0F0A0
    // Test aarch32_CRC32_T1_A special value sz = 2 (Size variant 2)
    // ISET: T32
    // Fields: sz=2, Rm=0, Rd=0, Rn=0, C=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `field sz = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "sz", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_crc32_t1_a_special_sz_3_size_variant_3_61568_fac0f0b0() {
    // Thumb encoding (32): 0xFAC0F0B0
    // Test aarch32_CRC32_T1_A special value sz = 3 (Size variant 3)
    // ISET: T32
    // Fields: Rn=0, sz=3, Rd=0, Rm=0, C=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_t1_a_invalid_0_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0, C=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_t1_a_invalid_1_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, sz=0, Rm=0, C=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveCRCExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveCRCExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_crc32_t1_a_invalid_2_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveCRCExt" }, args: [] } }
    // ISET: T32
    // Fields: Rd=0, C=0, Rn=0, Rm=0, sz=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_crc32_t1_a_invalid_3_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: C=0, Rm=0, sz=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_t1_a_invalid_4_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, C=0, sz=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_t1_a_invalid_5_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: C=0, Rd=0, sz=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitInt(64) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitInt(64) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_t1_a_invalid_6_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitInt(64) }
    // ISET: T32
    // Fields: Rm=0, Rd=0, C=0, sz=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CRC32_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_crc32_t1_a_invalid_7_f080_fac0f080() {
    // Thumb encoding (32): 0xFAC0F080
    // Test aarch32_CRC32_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: C=0, sz=0, Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAC0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SHA256SU1_A Tests
// ============================================================================

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su1_a1_a_field_d_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, Q=0, D=0, Vn=0, Vd=0, N=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su1_a1_a_field_d_1_max_c00_f3600c00() {
    // Encoding: 0xF3600C00
    // Test aarch32_SHA256SU1_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=1, M=0, N=0, Vn=0, Q=0, Vm=0
    let encoding: u32 = 0xF3600C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su1_a1_a_field_vn_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vd=0, Q=0, D=0, Vm=0, N=0, Vn=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su1_a1_a_field_vn_1_poweroftwo_c00_f3210c00() {
    // Encoding: 0xF3210C00
    // Test aarch32_SHA256SU1_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Vn=1, Vd=0, Q=0, D=0, N=0, M=0
    let encoding: u32 = 0xF3210C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su1_a1_a_field_vd_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Q=0, M=0, Vm=0, D=0, N=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su1_a1_a_field_vd_1_poweroftwo_c00_f3201c00() {
    // Encoding: 0xF3201C00
    // Test aarch32_SHA256SU1_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=0, Vd=1, Vm=0, M=0, N=0, D=0, Q=0
    let encoding: u32 = 0xF3201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su1_a1_a_field_n_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=0, Vn=0, Q=0, M=0, N=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su1_a1_a_field_n_1_max_c00_f3200c80() {
    // Encoding: 0xF3200C80
    // Test aarch32_SHA256SU1_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, Q=0, Vd=0, D=0, Vn=0, M=0, Vm=0
    let encoding: u32 = 0xF3200C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256su1_a1_a_field_q_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vn=0, Q=0, M=0, Vm=0, N=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256su1_a1_a_field_q_1_max_c00_f3200c40() {
    // Encoding: 0xF3200C40
    // Test aarch32_SHA256SU1_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: Q=1, Vd=0, N=0, Vm=0, D=0, Vn=0, M=0
    let encoding: u32 = 0xF3200C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su1_a1_a_field_m_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: D=0, Q=0, M=0, Vm=0, Vn=0, N=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su1_a1_a_field_m_1_max_c00_f3200c20() {
    // Encoding: 0xF3200C20
    // Test aarch32_SHA256SU1_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: M=1, D=0, Q=0, Vm=0, Vn=0, Vd=0, N=0
    let encoding: u32 = 0xF3200C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su1_a1_a_field_vm_0_min_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, M=0, Vn=0, D=0, Q=0, N=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su1_a1_a_field_vm_1_poweroftwo_c00_f3200c01() {
    // Encoding: 0xF3200C01
    // Test aarch32_SHA256SU1_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, N=0, Q=0, D=0, M=0, Vm=1, Vn=0
    let encoding: u32 = 0xF3200C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256su1_a1_a_combo_0_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, Vn=0, Vd=0, N=0, Q=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256su1_a1_a_special_q_0_size_variant_0_3072_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, Vn=0, N=0, Q=0, D=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256su1_a1_a_special_q_1_size_variant_1_3072_f3200c40() {
    // Encoding: 0xF3200C40
    // Test aarch32_SHA256SU1_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vm=0, N=0, Vd=0, Vn=0, Q=1, D=0, M=0
    let encoding: u32 = 0xF3200C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_a1_a_invalid_0_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: A32
    // Fields: N=0, M=0, Vm=0, Q=0, Vn=0, D=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_a1_a_invalid_1_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vn=0, Q=0, M=0, N=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_a1_a_invalid_2_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, M=0, Q=0, Vd=0, Vm=0, N=0, Vn=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_a1_a_invalid_3_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, M=0, Vm=0, Q=0, Vd=0, D=0, Vn=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_a1_a_invalid_4_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vn=0, M=0, Vm=0, N=0, D=0, Q=0, Vd=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_a1_a_invalid_5_c00_f3200c00() {
    // Encoding: 0xF3200C00
    // Test aarch32_SHA256SU1_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vn=0, N=0, Vd=0, M=0, Q=0, Vm=0
    let encoding: u32 = 0xF3200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su1_t1_a_field_d_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vn=0, Q=0, M=0, D=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su1_t1_a_field_d_1_max_c00_ff600c00() {
    // Thumb encoding (32): 0xFF600C00
    // Test aarch32_SHA256SU1_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, N=0, Q=0, Vd=0, M=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF600C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su1_t1_a_field_vn_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, Vn=0, N=0, M=0, Vm=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su1_t1_a_field_vn_1_poweroftwo_c00_ff210c00() {
    // Thumb encoding (32): 0xFF210C00
    // Test aarch32_SHA256SU1_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Q=0, Vm=0, Vd=0, D=0, N=0, Vn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF210C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su1_t1_a_field_vd_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Q=0, Vn=0, D=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su1_t1_a_field_vd_1_poweroftwo_c00_ff201c00() {
    // Thumb encoding (32): 0xFF201C00
    // Test aarch32_SHA256SU1_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, N=0, Q=0, M=0, D=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF201C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su1_t1_a_field_n_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, Vm=0, D=0, Vd=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su1_t1_a_field_n_1_max_c00_ff200c80() {
    // Thumb encoding (32): 0xFF200C80
    // Test aarch32_SHA256SU1_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: D=0, N=1, Q=0, M=0, Vd=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256su1_t1_a_field_q_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, N=0, D=0, Vn=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256su1_t1_a_field_q_1_max_c00_ff200c40() {
    // Thumb encoding (32): 0xFF200C40
    // Test aarch32_SHA256SU1_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, N=0, M=0, Vm=0, Vn=0, Q=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su1_t1_a_field_m_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vn=0, N=0, Q=0, Vd=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su1_t1_a_field_m_1_max_c00_ff200c20() {
    // Thumb encoding (32): 0xFF200C20
    // Test aarch32_SHA256SU1_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, D=0, N=0, Vn=0, Q=0, Vd=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su1_t1_a_field_vm_0_min_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: N=0, Q=0, D=0, Vm=0, M=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su1_t1_a_field_vm_1_poweroftwo_c00_ff200c01() {
    // Thumb encoding (32): 0xFF200C01
    // Test aarch32_SHA256SU1_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, Q=0, M=0, Vm=1, N=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256su1_t1_a_combo_0_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vm=0, Vd=0, Vn=0, N=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256su1_t1_a_special_q_0_size_variant_0_3072_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: N=0, Vm=0, Vd=0, Q=0, M=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256su1_t1_a_special_q_1_size_variant_1_3072_ff200c40() {
    // Thumb encoding (32): 0xFF200C40
    // Test aarch32_SHA256SU1_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Vn=0, Q=1, N=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_0_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vd=0, N=0, Q=0, M=0, Vm=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_1_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vn=0, Q=0, D=0, M=0, N=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_2_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: T32
    // Fields: Vd=0, N=0, Q=0, Vm=0, M=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_3_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: N=0, Q=0, Vd=0, Vm=0, M=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_4_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vd=0, N=0, Vn=0, D=0, Q=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_5_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, Q=0, N=0, Vd=0, Vn=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_6_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Q=0, Vn=0, D=0, M=0, N=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU1_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su1_t1_a_invalid_7_c00_ff200c00() {
    // Thumb encoding (32): 0xFF200C00
    // Test aarch32_SHA256SU1_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, Q=0, M=0, Vm=0, N=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256SU1_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_sha256su1_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

// ============================================================================
// aarch32_AESD_A Tests
// ============================================================================

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesd_a1_a_field_d_0_min_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: M=0, D=0, Vd=0, Vm=0, size=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesd_a1_a_field_d_1_max_340_f3f00340() {
    // Encoding: 0xF3F00340
    // Test aarch32_AESD_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, D=1, M=0, Vd=0, size=0
    let encoding: u32 = 0xF3F00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aesd_a1_a_field_size_0_min_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, size=0, Vd=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aesd_a1_a_field_size_1_poweroftwo_340_f3b40340() {
    // Encoding: 0xF3B40340
    // Test aarch32_AESD_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, M=0, D=0, size=1, Vd=0
    let encoding: u32 = 0xF3B40340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aesd_a1_a_field_size_2_poweroftwo_340_f3b80340() {
    // Encoding: 0xF3B80340
    // Test aarch32_AESD_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, size=2, M=0
    let encoding: u32 = 0xF3B80340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aesd_a1_a_field_size_3_max_340_f3bc0340() {
    // Encoding: 0xF3BC0340
    // Test aarch32_AESD_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: M=0, D=0, Vd=0, size=3, Vm=0
    let encoding: u32 = 0xF3BC0340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesd_a1_a_field_vd_0_min_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vm=0, D=0, size=0, M=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesd_a1_a_field_vd_1_poweroftwo_340_f3b01340() {
    // Encoding: 0xF3B01340
    // Test aarch32_AESD_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vd=1, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B01340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesd_a1_a_field_m_0_min_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesd_a1_a_field_m_1_max_340_f3b00360() {
    // Encoding: 0xF3B00360
    // Test aarch32_AESD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vd=0, M=1, Vm=0, D=0
    let encoding: u32 = 0xF3B00360;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesd_a1_a_field_vm_0_min_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: M=0, D=0, Vm=0, Vd=0, size=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesd_a1_a_field_vm_1_poweroftwo_340_f3b00341() {
    // Encoding: 0xF3B00341
    // Test aarch32_AESD_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, M=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF3B00341;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aesd_a1_a_combo_0_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aesd_a1_a_special_size_0_size_variant_0_832_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, Vd=0, size=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aesd_a1_a_special_size_1_size_variant_1_832_f3b40340() {
    // Encoding: 0xF3B40340
    // Test aarch32_AESD_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vm=0, M=0, size=1, D=0, Vd=0
    let encoding: u32 = 0xF3B40340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aesd_a1_a_special_size_2_size_variant_2_832_f3b80340() {
    // Encoding: 0xF3B80340
    // Test aarch32_AESD_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: size=2, M=0, Vm=0, Vd=0, D=0
    let encoding: u32 = 0xF3B80340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aesd_a1_a_special_size_3_size_variant_3_832_f3bc0340() {
    // Encoding: 0xF3BC0340
    // Test aarch32_AESD_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, Vm=0, size=3
    let encoding: u32 = 0xF3BC0340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_a1_a_invalid_0_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_a1_a_invalid_1_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, Vm=0, M=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_a1_a_invalid_2_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: size=0, M=0, Vd=0, D=0, Vm=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_a1_a_invalid_3_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vm=0, M=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_a1_a_invalid_4_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, D=0, size=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_a1_a_invalid_5_340_f3b00340() {
    // Encoding: 0xF3B00340
    // Test aarch32_AESD_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, D=0, M=0, size=0, Vm=0
    let encoding: u32 = 0xF3B00340;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesd_t1_a_field_d_0_min_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, size=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesd_t1_a_field_d_1_max_340_fff00340() {
    // Thumb encoding (32): 0xFFF00340
    // Test aarch32_AESD_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, Vd=0, D=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aesd_t1_a_field_size_0_min_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vm=0, M=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aesd_t1_a_field_size_1_poweroftwo_340_ffb40340() {
    // Thumb encoding (32): 0xFFB40340
    // Test aarch32_AESD_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vd=0, Vm=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB40340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aesd_t1_a_field_size_2_poweroftwo_340_ffb80340() {
    // Thumb encoding (32): 0xFFB80340
    // Test aarch32_AESD_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, Vd=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB80340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aesd_t1_a_field_size_3_max_340_ffbc0340() {
    // Thumb encoding (32): 0xFFBC0340
    // Test aarch32_AESD_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Vm=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC0340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesd_t1_a_field_vd_0_min_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, M=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesd_t1_a_field_vd_1_poweroftwo_340_ffb01340() {
    // Thumb encoding (32): 0xFFB01340
    // Test aarch32_AESD_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, Vd=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB01340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesd_t1_a_field_m_0_min_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesd_t1_a_field_m_1_max_340_ffb00360() {
    // Thumb encoding (32): 0xFFB00360
    // Test aarch32_AESD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, M=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00360;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesd_t1_a_field_vm_0_min_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesd_t1_a_field_vm_1_poweroftwo_340_ffb00341() {
    // Thumb encoding (32): 0xFFB00341
    // Test aarch32_AESD_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, size=0, M=0, Vm=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00341;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aesd_t1_a_combo_0_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vd=0, size=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aesd_t1_a_special_size_0_size_variant_0_832_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vd=0, Vm=0, D=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aesd_t1_a_special_size_1_size_variant_1_832_ffb40340() {
    // Thumb encoding (32): 0xFFB40340
    // Test aarch32_AESD_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, D=0, Vm=0, M=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB40340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aesd_t1_a_special_size_2_size_variant_2_832_ffb80340() {
    // Thumb encoding (32): 0xFFB80340
    // Test aarch32_AESD_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Vm=0, Vd=0, size=2, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB80340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aesd_t1_a_special_size_3_size_variant_3_832_ffbc0340() {
    // Thumb encoding (32): 0xFFBC0340
    // Test aarch32_AESD_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, D=0, size=3, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC0340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aesd_t1_a_invalid_0_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aesd_t1_a_invalid_1_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, Vm=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_t1_a_invalid_2_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_t1_a_invalid_3_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_t1_a_invalid_4_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: D=0, Vm=0, Vd=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_t1_a_invalid_5_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_t1_a_invalid_6_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vm=0, D=0, size=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESD_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesd_t1_a_invalid_7_340_ffb00340() {
    // Thumb encoding (32): 0xFFB00340
    // Test aarch32_AESD_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_32_0_f3b247c0() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B247C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B247C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_64_0_f3b247c0() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B247C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B247C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_32_1_f3b57be0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_64_1_f3b57be0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_32_3_f3b00340() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B00340
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_64_3_f3b00340() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B00340
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B00340;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_64_4_f3facf40() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACF40
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACF40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_aesd_a1_a_movz_oracle_64_5_f3fbd7e0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7E0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_aesd_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_aesd_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_aesd_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_aesd_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_AESD_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_aesd_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_AESE_A Tests
// ============================================================================

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aese_a1_a_field_d_0_min_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aese_a1_a_field_d_1_max_300_f3f00300() {
    // Encoding: 0xF3F00300
    // Test aarch32_AESE_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: size=0, M=0, Vm=0, D=1, Vd=0
    let encoding: u32 = 0xF3F00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aese_a1_a_field_size_0_min_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, Vm=0, M=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aese_a1_a_field_size_1_poweroftwo_300_f3b40300() {
    // Encoding: 0xF3B40300
    // Test aarch32_AESE_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, Vm=0, size=1, Vd=0
    let encoding: u32 = 0xF3B40300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aese_a1_a_field_size_2_poweroftwo_300_f3b80300() {
    // Encoding: 0xF3B80300
    // Test aarch32_AESE_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=2, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF3B80300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aese_a1_a_field_size_3_max_300_f3bc0300() {
    // Encoding: 0xF3BC0300
    // Test aarch32_AESE_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, M=0, Vm=0, size=3
    let encoding: u32 = 0xF3BC0300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aese_a1_a_field_vd_0_min_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vm=0, size=0, D=0, M=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aese_a1_a_field_vd_1_poweroftwo_300_f3b01300() {
    // Encoding: 0xF3B01300
    // Test aarch32_AESE_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, D=0, size=0, Vd=1, Vm=0
    let encoding: u32 = 0xF3B01300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aese_a1_a_field_m_0_min_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: size=0, M=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aese_a1_a_field_m_1_max_300_f3b00320() {
    // Encoding: 0xF3B00320
    // Test aarch32_AESE_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, Vm=0, size=0, M=1
    let encoding: u32 = 0xF3B00320;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aese_a1_a_field_vm_0_min_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, Vm=0, size=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aese_a1_a_field_vm_1_poweroftwo_300_f3b00301() {
    // Encoding: 0xF3B00301
    // Test aarch32_AESE_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, M=0, size=0, Vm=1, D=0
    let encoding: u32 = 0xF3B00301;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aese_a1_a_combo_0_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aese_a1_a_special_size_0_size_variant_0_768_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, Vm=0, D=0, M=0, size=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aese_a1_a_special_size_1_size_variant_1_768_f3b40300() {
    // Encoding: 0xF3B40300
    // Test aarch32_AESE_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: M=0, Vm=0, size=1, D=0, Vd=0
    let encoding: u32 = 0xF3B40300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aese_a1_a_special_size_2_size_variant_2_768_f3b80300() {
    // Encoding: 0xF3B80300
    // Test aarch32_AESE_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: M=0, D=0, Vm=0, Vd=0, size=2
    let encoding: u32 = 0xF3B80300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aese_a1_a_special_size_3_size_variant_3_768_f3bc0300() {
    // Encoding: 0xF3BC0300
    // Test aarch32_AESE_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, D=0, Vm=0, Vd=0, M=0
    let encoding: u32 = 0xF3BC0300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_a1_a_invalid_0_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: A32
    // Fields: Vm=0, M=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_a1_a_invalid_1_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_a1_a_invalid_2_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, size=0, M=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_a1_a_invalid_3_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, D=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_a1_a_invalid_4_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vd=0, size=0, M=0, Vm=0, D=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_a1_a_invalid_5_300_f3b00300() {
    // Encoding: 0xF3B00300
    // Test aarch32_AESE_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B00300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aese_t1_a_field_d_0_min_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aese_t1_a_field_d_1_max_300_fff00300() {
    // Thumb encoding (32): 0xFFF00300
    // Test aarch32_AESE_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, M=0, D=1, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aese_t1_a_field_size_0_min_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aese_t1_a_field_size_1_poweroftwo_300_ffb40300() {
    // Thumb encoding (32): 0xFFB40300
    // Test aarch32_AESE_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, M=0, size=1, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB40300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aese_t1_a_field_size_2_poweroftwo_300_ffb80300() {
    // Thumb encoding (32): 0xFFB80300
    // Test aarch32_AESE_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, size=2, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB80300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aese_t1_a_field_size_3_max_300_ffbc0300() {
    // Thumb encoding (32): 0xFFBC0300
    // Test aarch32_AESE_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC0300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aese_t1_a_field_vd_0_min_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, size=0, Vd=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aese_t1_a_field_vd_1_poweroftwo_300_ffb01300() {
    // Thumb encoding (32): 0xFFB01300
    // Test aarch32_AESE_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=1, M=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB01300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aese_t1_a_field_m_0_min_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aese_t1_a_field_m_1_max_300_ffb00320() {
    // Thumb encoding (32): 0xFFB00320
    // Test aarch32_AESE_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, M=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00320;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aese_t1_a_field_vm_0_min_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aese_t1_a_field_vm_1_poweroftwo_300_ffb00301() {
    // Thumb encoding (32): 0xFFB00301
    // Test aarch32_AESE_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=1, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00301;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aese_t1_a_combo_0_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vd=0, Vm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aese_t1_a_special_size_0_size_variant_0_768_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vm=0, M=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aese_t1_a_special_size_1_size_variant_1_768_ffb40300() {
    // Thumb encoding (32): 0xFFB40300
    // Test aarch32_AESE_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: size=1, M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB40300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aese_t1_a_special_size_2_size_variant_2_768_ffb80300() {
    // Thumb encoding (32): 0xFFB80300
    // Test aarch32_AESE_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, D=0, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB80300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aese_t1_a_special_size_3_size_variant_3_768_ffbc0300() {
    // Thumb encoding (32): 0xFFBC0300
    // Test aarch32_AESE_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, M=0, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC0300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aese_t1_a_invalid_0_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vm=0, size=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aese_t1_a_invalid_1_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, size=0, Vd=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_t1_a_invalid_2_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_t1_a_invalid_3_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Vm=0, M=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_t1_a_invalid_4_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_t1_a_invalid_5_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, size=0, D=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_t1_a_invalid_6_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, Vd=0, size=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESE_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aese_t1_a_invalid_7_300_ffb00300() {
    // Thumb encoding (32): 0xFFB00300
    // Test aarch32_AESE_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vm=0, Vd=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_32_0_f3b24780() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24780
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_64_0_f3b24780() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24780
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_32_1_f3b57ba0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_64_1_f3b57ba0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_32_3_f3b00300() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B00300
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_64_3_f3b00300() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B00300
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B00300;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_64_4_f3facf00() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACF00
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACF00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_aese_a1_a_movz_oracle_64_5_f3fbd7a0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7A0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_aese_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_aese_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_aese_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_aese_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_AESE_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_aese_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_SHA256SU0_A Tests
// ============================================================================

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su0_a1_a_field_d_0_min_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, size=0, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su0_a1_a_field_d_1_max_3c0_f3f203c0() {
    // Encoding: 0xF3F203C0
    // Test aarch32_SHA256SU0_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=0, D=1, size=0
    let encoding: u32 = 0xF3F203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256su0_a1_a_field_size_0_min_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256su0_a1_a_field_size_1_poweroftwo_3c0_f3b603c0() {
    // Encoding: 0xF3B603C0
    // Test aarch32_SHA256SU0_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, D=0, size=1
    let encoding: u32 = 0xF3B603C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_sha256su0_a1_a_field_size_2_poweroftwo_3c0_f3ba03c0() {
    // Encoding: 0xF3BA03C0
    // Test aarch32_SHA256SU0_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, Vm=0, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3BA03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_sha256su0_a1_a_field_size_3_max_3c0_f3be03c0() {
    // Encoding: 0xF3BE03C0
    // Test aarch32_SHA256SU0_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, size=3, Vd=0
    let encoding: u32 = 0xF3BE03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su0_a1_a_field_vd_0_min_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su0_a1_a_field_vd_1_poweroftwo_3c0_f3b213c0() {
    // Encoding: 0xF3B213C0
    // Test aarch32_SHA256SU0_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=1, size=0, D=0
    let encoding: u32 = 0xF3B213C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su0_a1_a_field_m_0_min_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vd=0, size=0, Vm=0, D=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su0_a1_a_field_m_1_max_3c0_f3b203e0() {
    // Encoding: 0xF3B203E0
    // Test aarch32_SHA256SU0_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vd=0, M=1, Vm=0, size=0
    let encoding: u32 = 0xF3B203E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su0_a1_a_field_vm_0_min_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su0_a1_a_field_vm_1_poweroftwo_3c0_f3b203c1() {
    // Encoding: 0xF3B203C1
    // Test aarch32_SHA256SU0_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, M=0, size=0, Vd=0, Vm=1
    let encoding: u32 = 0xF3B203C1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256su0_a1_a_combo_0_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256su0_a1_a_special_size_0_size_variant_0_960_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, Vd=0, size=0, M=0, D=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256su0_a1_a_special_size_1_size_variant_1_960_f3b603c0() {
    // Encoding: 0xF3B603C0
    // Test aarch32_SHA256SU0_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, D=0, size=1
    let encoding: u32 = 0xF3B603C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_sha256su0_a1_a_special_size_2_size_variant_2_960_f3ba03c0() {
    // Encoding: 0xF3BA03C0
    // Test aarch32_SHA256SU0_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: M=0, size=2, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3BA03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_sha256su0_a1_a_special_size_3_size_variant_3_960_f3be03c0() {
    // Encoding: 0xF3BE03C0
    // Test aarch32_SHA256SU0_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, Vm=0, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3BE03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_a1_a_invalid_0_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, Vd=0, size=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_a1_a_invalid_1_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_a1_a_invalid_2_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // ISET: A32
    // Fields: D=0, Vd=0, Vm=0, M=0, size=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_a1_a_invalid_3_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vm=0, D=0, M=0, size=0, Vd=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_a1_a_invalid_4_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_a1_a_invalid_5_3c0_f3b203c0() {
    // Encoding: 0xF3B203C0
    // Test aarch32_SHA256SU0_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, Vd=0, size=0
    let encoding: u32 = 0xF3B203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su0_t1_a_field_d_0_min_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, size=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su0_t1_a_field_d_1_max_3c0_fff203c0() {
    // Thumb encoding (32): 0xFFF203C0
    // Test aarch32_SHA256SU0_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, Vm=0, D=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256su0_t1_a_field_size_0_min_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256su0_t1_a_field_size_1_poweroftwo_3c0_ffb603c0() {
    // Thumb encoding (32): 0xFFB603C0
    // Test aarch32_SHA256SU0_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, Vd=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB603C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_sha256su0_t1_a_field_size_2_poweroftwo_3c0_ffba03c0() {
    // Thumb encoding (32): 0xFFBA03C0
    // Test aarch32_SHA256SU0_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Vm=0, M=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA03C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_sha256su0_t1_a_field_size_3_max_3c0_ffbe03c0() {
    // Thumb encoding (32): 0xFFBE03C0
    // Test aarch32_SHA256SU0_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vm=0, size=3, D=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE03C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su0_t1_a_field_vd_0_min_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su0_t1_a_field_vd_1_poweroftwo_3c0_ffb213c0() {
    // Thumb encoding (32): 0xFFB213C0
    // Test aarch32_SHA256SU0_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=1, size=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB213C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256su0_t1_a_field_m_0_min_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Vm=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256su0_t1_a_field_m_1_max_3c0_ffb203e0() {
    // Thumb encoding (32): 0xFFB203E0
    // Test aarch32_SHA256SU0_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vd=0, Vm=0, M=1, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256su0_t1_a_field_vm_0_min_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, size=0, M=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256su0_t1_a_field_vm_1_poweroftwo_3c0_ffb203c1() {
    // Thumb encoding (32): 0xFFB203C1
    // Test aarch32_SHA256SU0_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, M=0, Vm=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256su0_t1_a_combo_0_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, D=0, Vm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256su0_t1_a_special_size_0_size_variant_0_960_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Vm=0, size=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256su0_t1_a_special_size_1_size_variant_1_960_ffb603c0() {
    // Thumb encoding (32): 0xFFB603C0
    // Test aarch32_SHA256SU0_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, Vd=0, size=1, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB603C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_sha256su0_t1_a_special_size_2_size_variant_2_960_ffba03c0() {
    // Thumb encoding (32): 0xFFBA03C0
    // Test aarch32_SHA256SU0_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: M=0, Vd=0, D=0, size=2, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA03C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_sha256su0_t1_a_special_size_3_size_variant_3_960_ffbe03c0() {
    // Thumb encoding (32): 0xFFBE03C0
    // Test aarch32_SHA256SU0_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vm=0, M=0, size=3, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE03C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_0_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_1_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_2_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: T32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_3_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_4_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_5_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, D=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_6_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU0_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256su0_t1_a_invalid_7_3c0_ffb203c0() {
    // Thumb encoding (32): 0xFFB203C0
    // Test aarch32_SHA256SU0_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, M=0, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_32_0_f3b247c0() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B247C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B247C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_64_0_f3b247c0() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B247C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B247C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_32_1_f3b77be0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B77BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B77BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_64_1_f3b77be0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B77BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B77BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_32_3_f3b203c0() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B203C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_64_3_f3b203c0() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B203C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B203C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_64_4_f3facfc0() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACFC0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACFC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_sha256su0_a1_a_movz_oracle_64_5_f3fbd7e0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7E0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_sha256su0_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_sha256su0_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_sha256su0_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_sha256su0_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA256SU0_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_sha256su0_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_CSDB_A Tests
// ============================================================================

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_0_min_14_03200014() {
    // Encoding: 0x03200014
    // Test aarch32_CSDB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_1_poweroftwo_14_13200014() {
    // Encoding: 0x13200014
    // Test aarch32_CSDB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_2_poweroftwo_14_23200014() {
    // Encoding: 0x23200014
    // Test aarch32_CSDB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_3_poweroftwo_14_33200014() {
    // Encoding: 0x33200014
    // Test aarch32_CSDB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_4_poweroftwo_14_43200014() {
    // Encoding: 0x43200014
    // Test aarch32_CSDB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_5_poweroftwo_14_53200014() {
    // Encoding: 0x53200014
    // Test aarch32_CSDB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_6_poweroftwo_14_63200014() {
    // Encoding: 0x63200014
    // Test aarch32_CSDB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_7_poweroftwo_14_73200014() {
    // Encoding: 0x73200014
    // Test aarch32_CSDB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_8_poweroftwo_14_83200014() {
    // Encoding: 0x83200014
    // Test aarch32_CSDB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_9_poweroftwo_14_93200014() {
    // Encoding: 0x93200014
    // Test aarch32_CSDB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_10_poweroftwo_14_a3200014() {
    // Encoding: 0xA3200014
    // Test aarch32_CSDB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_11_poweroftwo_14_b3200014() {
    // Encoding: 0xB3200014
    // Test aarch32_CSDB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_12_poweroftwo_14_c3200014() {
    // Encoding: 0xC3200014
    // Test aarch32_CSDB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_13_poweroftwo_14_d3200014() {
    // Encoding: 0xD3200014
    // Test aarch32_CSDB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_14_poweroftwo_14_e3200014() {
    // Encoding: 0xE3200014
    // Test aarch32_CSDB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_csdb_a1_a_field_cond_15_max_14_f3200014() {
    // Encoding: 0xF3200014
    // Test aarch32_CSDB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_csdb_a1_a_combo_0_14_03200014() {
    // Encoding: 0x03200014
    // Test aarch32_CSDB_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_csdb_a1_a_special_cond_0_condition_eq_20_03200014() {
    // Encoding: 0x03200014
    // Test aarch32_CSDB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_csdb_a1_a_special_cond_1_condition_ne_20_13200014() {
    // Encoding: 0x13200014
    // Test aarch32_CSDB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_csdb_a1_a_special_cond_2_condition_cs_hs_20_23200014() {
    // Encoding: 0x23200014
    // Test aarch32_CSDB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_csdb_a1_a_special_cond_3_condition_cc_lo_20_33200014() {
    // Encoding: 0x33200014
    // Test aarch32_CSDB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_csdb_a1_a_special_cond_4_condition_mi_20_43200014() {
    // Encoding: 0x43200014
    // Test aarch32_CSDB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_csdb_a1_a_special_cond_5_condition_pl_20_53200014() {
    // Encoding: 0x53200014
    // Test aarch32_CSDB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_csdb_a1_a_special_cond_6_condition_vs_20_63200014() {
    // Encoding: 0x63200014
    // Test aarch32_CSDB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_csdb_a1_a_special_cond_7_condition_vc_20_73200014() {
    // Encoding: 0x73200014
    // Test aarch32_CSDB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_csdb_a1_a_special_cond_8_condition_hi_20_83200014() {
    // Encoding: 0x83200014
    // Test aarch32_CSDB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_csdb_a1_a_special_cond_9_condition_ls_20_93200014() {
    // Encoding: 0x93200014
    // Test aarch32_CSDB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_csdb_a1_a_special_cond_10_condition_ge_20_a3200014() {
    // Encoding: 0xA3200014
    // Test aarch32_CSDB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_csdb_a1_a_special_cond_11_condition_lt_20_b3200014() {
    // Encoding: 0xB3200014
    // Test aarch32_CSDB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_csdb_a1_a_special_cond_12_condition_gt_20_c3200014() {
    // Encoding: 0xC3200014
    // Test aarch32_CSDB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_csdb_a1_a_special_cond_13_condition_le_20_d3200014() {
    // Encoding: 0xD3200014
    // Test aarch32_CSDB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_csdb_a1_a_special_cond_14_condition_al_20_e3200014() {
    // Encoding: 0xE3200014
    // Test aarch32_CSDB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_csdb_a1_a_special_cond_15_condition_nv_20_f3200014() {
    // Encoding: 0xF3200014
    // Test aarch32_CSDB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_csdb_a1_a_invalid_0_14_03200014() {
    // Encoding: 0x03200014
    // Test aarch32_CSDB_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_csdb_a1_a_invalid_1_14_03200014() {
    // Encoding: 0x03200014
    // Test aarch32_CSDB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200014;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CSDB_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_csdb_t1_a_basic_encoding_f3a08014() {
    // Thumb encoding (32): 0xF3A08014
    // Test aarch32_CSDB_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08014;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_CSDB_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_csdb_t1_a_invalid_0_8014_f3a08014() {
    // Thumb encoding (32): 0xF3A08014
    // Test aarch32_CSDB_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08014;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CSDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_csdb_t1_a_invalid_1_8014_f3a08014() {
    // Thumb encoding (32): 0xF3A08014
    // Test aarch32_CSDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08014;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_CSDB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_csdb_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

// ============================================================================
// aarch32_AESMC_A Tests
// ============================================================================

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesmc_a1_a_field_d_0_min_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, Vm=0, size=0, M=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesmc_a1_a_field_d_1_max_380_f3f00380() {
    // Encoding: 0xF3F00380
    // Test aarch32_AESMC_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Vm=0, M=0, Vd=0, size=0
    let encoding: u32 = 0xF3F00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aesmc_a1_a_field_size_0_min_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, Vd=0, size=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aesmc_a1_a_field_size_1_poweroftwo_380_f3b40380() {
    // Encoding: 0xF3B40380
    // Test aarch32_AESMC_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, D=0, Vd=0, M=0, size=1
    let encoding: u32 = 0xF3B40380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aesmc_a1_a_field_size_2_poweroftwo_380_f3b80380() {
    // Encoding: 0xF3B80380
    // Test aarch32_AESMC_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, size=2, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3B80380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aesmc_a1_a_field_size_3_max_380_f3bc0380() {
    // Encoding: 0xF3BC0380
    // Test aarch32_AESMC_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, D=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF3BC0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesmc_a1_a_field_vd_0_min_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, size=0, D=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesmc_a1_a_field_vd_1_poweroftwo_380_f3b01380() {
    // Encoding: 0xF3B01380
    // Test aarch32_AESMC_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vm=0, D=0, M=0, Vd=1
    let encoding: u32 = 0xF3B01380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesmc_a1_a_field_m_0_min_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, Vm=0, D=0, M=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesmc_a1_a_field_m_1_max_380_f3b003a0() {
    // Encoding: 0xF3B003A0
    // Test aarch32_AESMC_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vd=0, M=1, D=0, Vm=0
    let encoding: u32 = 0xF3B003A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesmc_a1_a_field_vm_0_min_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, M=0, Vm=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesmc_a1_a_field_vm_1_poweroftwo_380_f3b00381() {
    // Encoding: 0xF3B00381
    // Test aarch32_AESMC_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, size=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xF3B00381;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aesmc_a1_a_combo_0_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vd=0, Vm=0, D=0, M=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aesmc_a1_a_special_size_0_size_variant_0_896_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, Vm=0, D=0, M=0, size=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aesmc_a1_a_special_size_1_size_variant_1_896_f3b40380() {
    // Encoding: 0xF3B40380
    // Test aarch32_AESMC_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: M=0, Vd=0, D=0, size=1, Vm=0
    let encoding: u32 = 0xF3B40380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aesmc_a1_a_special_size_2_size_variant_2_896_f3b80380() {
    // Encoding: 0xF3B80380
    // Test aarch32_AESMC_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vm=0, M=0, Vd=0, D=0, size=2
    let encoding: u32 = 0xF3B80380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aesmc_a1_a_special_size_3_size_variant_3_896_f3bc0380() {
    // Encoding: 0xF3BC0380
    // Test aarch32_AESMC_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: D=0, Vd=0, size=3, M=0, Vm=0
    let encoding: u32 = 0xF3BC0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_a1_a_invalid_0_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, size=0, Vm=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_a1_a_invalid_1_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, D=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_a1_a_invalid_2_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: D=0, Vm=0, M=0, Vd=0, size=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_a1_a_invalid_3_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Vm=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_a1_a_invalid_4_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, Vd=0, size=0, M=0, Vm=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_a1_a_invalid_5_380_f3b00380() {
    // Encoding: 0xF3B00380
    // Test aarch32_AESMC_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, D=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesmc_t1_a_field_d_0_min_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesmc_t1_a_field_d_1_max_380_fff00380() {
    // Thumb encoding (32): 0xFFF00380
    // Test aarch32_AESMC_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, M=0, Vd=0, D=1, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aesmc_t1_a_field_size_0_min_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, M=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aesmc_t1_a_field_size_1_poweroftwo_380_ffb40380() {
    // Thumb encoding (32): 0xFFB40380
    // Test aarch32_AESMC_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, size=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB40380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aesmc_t1_a_field_size_2_poweroftwo_380_ffb80380() {
    // Thumb encoding (32): 0xFFB80380
    // Test aarch32_AESMC_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, size=2, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB80380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aesmc_t1_a_field_size_3_max_380_ffbc0380() {
    // Thumb encoding (32): 0xFFBC0380
    // Test aarch32_AESMC_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, D=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC0380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesmc_t1_a_field_vd_0_min_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vm=0, size=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesmc_t1_a_field_vd_1_poweroftwo_380_ffb01380() {
    // Thumb encoding (32): 0xFFB01380
    // Test aarch32_AESMC_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, D=0, M=0, size=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB01380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesmc_t1_a_field_m_0_min_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesmc_t1_a_field_m_1_max_380_ffb003a0() {
    // Thumb encoding (32): 0xFFB003A0
    // Test aarch32_AESMC_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, M=1, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesmc_t1_a_field_vm_0_min_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: M=0, size=0, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesmc_t1_a_field_vm_1_poweroftwo_380_ffb00381() {
    // Thumb encoding (32): 0xFFB00381
    // Test aarch32_AESMC_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, M=0, size=0, Vm=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00381;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aesmc_t1_a_combo_0_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: M=0, Vm=0, Vd=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aesmc_t1_a_special_size_0_size_variant_0_896_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aesmc_t1_a_special_size_1_size_variant_1_896_ffb40380() {
    // Thumb encoding (32): 0xFFB40380
    // Test aarch32_AESMC_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vm=0, M=0, D=0, size=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB40380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aesmc_t1_a_special_size_2_size_variant_2_896_ffb80380() {
    // Thumb encoding (32): 0xFFB80380
    // Test aarch32_AESMC_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, Vm=0, size=2
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB80380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aesmc_t1_a_special_size_3_size_variant_3_896_ffbc0380() {
    // Thumb encoding (32): 0xFFBC0380
    // Test aarch32_AESMC_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: size=3, D=0, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC0380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aesmc_t1_a_invalid_0_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: D=0, Vm=0, size=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aesmc_t1_a_invalid_1_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: size=0, Vm=0, M=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_t1_a_invalid_2_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_t1_a_invalid_3_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_t1_a_invalid_4_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: Vd=0, size=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_t1_a_invalid_5_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, size=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_t1_a_invalid_6_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vm=0, M=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESMC_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesmc_t1_a_invalid_7_380_ffb00380() {
    // Thumb encoding (32): 0xFFB00380
    // Test aarch32_AESMC_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: M=0, Vd=0, D=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_32_0_f3b24780() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24780
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_64_0_f3b24780() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24780
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_32_1_f3b57ba0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_64_1_f3b57ba0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_32_3_f3b00380() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B00380
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_64_3_f3b00380() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B00380
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B00380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_64_4_f3facf80() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACF80
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACF80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_aesmc_a1_a_movz_oracle_64_5_f3fbd7a0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7A0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_aesmc_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_aesmc_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_aesmc_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_aesmc_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_AESMC_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_aesmc_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_SMLALBB_A Tests
// ============================================================================

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, N=0, Rn=0, RdLo=0, M=0, RdHi=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_1_poweroftwo_80_11400080() {
    // Encoding: 0x11400080
    // Test aarch32_SMLALBB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, N=0, cond=1, Rm=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x11400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_2_poweroftwo_80_21400080() {
    // Encoding: 0x21400080
    // Test aarch32_SMLALBB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, RdHi=0, Rm=0, N=0, RdLo=0, M=0, Rn=0
    let encoding: u32 = 0x21400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_3_poweroftwo_80_31400080() {
    // Encoding: 0x31400080
    // Test aarch32_SMLALBB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, N=0, Rm=0, Rn=0, cond=3, RdLo=0, RdHi=0
    let encoding: u32 = 0x31400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_4_poweroftwo_80_41400080() {
    // Encoding: 0x41400080
    // Test aarch32_SMLALBB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=4, RdLo=0, M=0, N=0, Rm=0, Rn=0
    let encoding: u32 = 0x41400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_5_poweroftwo_80_51400080() {
    // Encoding: 0x51400080
    // Test aarch32_SMLALBB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=5, Rm=0, M=0, N=0, Rn=0, RdHi=0
    let encoding: u32 = 0x51400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_6_poweroftwo_80_61400080() {
    // Encoding: 0x61400080
    // Test aarch32_SMLALBB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, RdHi=0, cond=6, RdLo=0, Rm=0, N=0
    let encoding: u32 = 0x61400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_7_poweroftwo_80_71400080() {
    // Encoding: 0x71400080
    // Test aarch32_SMLALBB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rm=0, M=0, N=0, RdLo=0, Rn=0, RdHi=0
    let encoding: u32 = 0x71400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_8_poweroftwo_80_81400080() {
    // Encoding: 0x81400080
    // Test aarch32_SMLALBB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=8, RdLo=0, RdHi=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x81400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_9_poweroftwo_80_91400080() {
    // Encoding: 0x91400080
    // Test aarch32_SMLALBB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, N=0, cond=9, Rn=0, RdHi=0, Rm=0, M=0
    let encoding: u32 = 0x91400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_10_poweroftwo_80_a1400080() {
    // Encoding: 0xA1400080
    // Test aarch32_SMLALBB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, M=0, N=0, RdHi=0, cond=10, Rn=0, RdLo=0
    let encoding: u32 = 0xA1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_11_poweroftwo_80_b1400080() {
    // Encoding: 0xB1400080
    // Test aarch32_SMLALBB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, cond=11, RdLo=0, Rm=0, M=0, N=0
    let encoding: u32 = 0xB1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_12_poweroftwo_80_c1400080() {
    // Encoding: 0xC1400080
    // Test aarch32_SMLALBB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, RdHi=0, N=0, RdLo=0, Rm=0, Rn=0, cond=12
    let encoding: u32 = 0xC1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_13_poweroftwo_80_d1400080() {
    // Encoding: 0xD1400080
    // Test aarch32_SMLALBB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, Rn=0, M=0, RdLo=0, N=0, cond=13
    let encoding: u32 = 0xD1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_14_poweroftwo_80_e1400080() {
    // Encoding: 0xE1400080
    // Test aarch32_SMLALBB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=14, RdLo=0, M=0, Rn=0, RdHi=0, Rm=0
    let encoding: u32 = 0xE1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlalbb_a1_a_field_cond_15_max_80_f1400080() {
    // Encoding: 0xF1400080
    // Test aarch32_SMLALBB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rm=0, N=0, M=0, Rn=0, RdLo=0, RdHi=0
    let encoding: u32 = 0xF1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdhi_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, Rm=0, N=0, RdLo=0, M=0, cond=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdhi_1_poweroftwo_80_01410080() {
    // Encoding: 0x01410080
    // Test aarch32_SMLALBB_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdHi=1, RdLo=0, cond=0, M=0, Rm=0, N=0
    let encoding: u32 = 0x01410080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdhi_7_poweroftwominusone_80_01470080() {
    // Encoding: 0x01470080
    // Test aarch32_SMLALBB_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdHi=7, RdLo=0, Rm=0, M=0, Rn=0, cond=0, N=0
    let encoding: u32 = 0x01470080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdhi_15_max_80_014f0080() {
    // Encoding: 0x014F0080
    // Test aarch32_SMLALBB_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: cond=0, RdLo=0, RdHi=15, N=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x014F0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdlo_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: cond=0, RdLo=0, N=0, Rn=0, Rm=0, RdHi=0, M=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdlo_1_poweroftwo_80_01401080() {
    // Encoding: 0x01401080
    // Test aarch32_SMLALBB_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, RdHi=0, RdLo=1, Rm=0, N=0, M=0
    let encoding: u32 = 0x01401080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdlo_7_poweroftwominusone_80_01407080() {
    // Encoding: 0x01407080
    // Test aarch32_SMLALBB_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: M=0, RdHi=0, RdLo=7, Rn=0, cond=0, N=0, Rm=0
    let encoding: u32 = 0x01407080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rdlo_15_max_80_0140f080() {
    // Encoding: 0x0140F080
    // Test aarch32_SMLALBB_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: RdHi=0, M=0, cond=0, Rn=0, Rm=0, RdLo=15, N=0
    let encoding: u32 = 0x0140F080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rm_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, M=0, N=0, RdHi=0, RdLo=0, cond=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rm_1_poweroftwo_80_01400180() {
    // Encoding: 0x01400180
    // Test aarch32_SMLALBB_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, RdHi=0, M=0, cond=0, Rn=0, N=0, RdLo=0
    let encoding: u32 = 0x01400180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_a1_a_field_m_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: RdHi=0, M=0, RdLo=0, cond=0, N=0, Rn=0, Rm=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlalbb_a1_a_field_m_1_max_80_014000c0() {
    // Encoding: 0x014000C0
    // Test aarch32_SMLALBB_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: N=0, Rn=0, RdLo=0, RdHi=0, cond=0, M=1, Rm=0
    let encoding: u32 = 0x014000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_a1_a_field_n_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: M=0, N=0, RdHi=0, Rm=0, cond=0, RdLo=0, Rn=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlalbb_a1_a_field_n_1_max_80_014000a0() {
    // Encoding: 0x014000A0
    // Test aarch32_SMLALBB_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: N=1, Rm=0, cond=0, M=0, Rn=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x014000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rn_0_min_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: M=0, N=0, RdHi=0, cond=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlalbb_a1_a_field_rn_1_poweroftwo_80_01400081() {
    // Encoding: 0x01400081
    // Test aarch32_SMLALBB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, M=0, RdHi=0, cond=0, N=0, Rn=1
    let encoding: u32 = 0x01400081;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlalbb_a1_a_combo_0_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A field combination: cond=0, RdHi=0, RdLo=0, Rm=0, M=0, N=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, M=0, RdHi=0, cond=0, RdLo=0, N=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_0_condition_eq_128_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, M=0, Rn=0, RdLo=0, Rm=0, N=0, RdHi=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_1_condition_ne_128_11400080() {
    // Encoding: 0x11400080
    // Test aarch32_SMLALBB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, N=0, Rn=0, RdLo=0, RdHi=0, M=0, cond=1
    let encoding: u32 = 0x11400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_2_condition_cs_hs_128_21400080() {
    // Encoding: 0x21400080
    // Test aarch32_SMLALBB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdLo=0, M=0, RdHi=0, cond=2, N=0
    let encoding: u32 = 0x21400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_3_condition_cc_lo_128_31400080() {
    // Encoding: 0x31400080
    // Test aarch32_SMLALBB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: M=0, N=0, RdLo=0, Rm=0, Rn=0, cond=3, RdHi=0
    let encoding: u32 = 0x31400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_4_condition_mi_128_41400080() {
    // Encoding: 0x41400080
    // Test aarch32_SMLALBB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: M=0, RdHi=0, N=0, Rn=0, Rm=0, RdLo=0, cond=4
    let encoding: u32 = 0x41400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_5_condition_pl_128_51400080() {
    // Encoding: 0x51400080
    // Test aarch32_SMLALBB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, M=0, Rm=0, RdHi=0, N=0, cond=5, RdLo=0
    let encoding: u32 = 0x51400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_6_condition_vs_128_61400080() {
    // Encoding: 0x61400080
    // Test aarch32_SMLALBB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, N=0, cond=6, RdLo=0, Rm=0, M=0
    let encoding: u32 = 0x61400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_7_condition_vc_128_71400080() {
    // Encoding: 0x71400080
    // Test aarch32_SMLALBB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: RdLo=0, M=0, RdHi=0, Rn=0, N=0, cond=7, Rm=0
    let encoding: u32 = 0x71400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_8_condition_hi_128_81400080() {
    // Encoding: 0x81400080
    // Test aarch32_SMLALBB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, RdHi=0, Rm=0, M=0, RdLo=0, N=0
    let encoding: u32 = 0x81400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_9_condition_ls_128_91400080() {
    // Encoding: 0x91400080
    // Test aarch32_SMLALBB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: RdHi=0, cond=9, N=0, Rn=0, RdLo=0, M=0, Rm=0
    let encoding: u32 = 0x91400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_10_condition_ge_128_a1400080() {
    // Encoding: 0xA1400080
    // Test aarch32_SMLALBB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: M=0, N=0, Rn=0, cond=10, RdLo=0, RdHi=0, Rm=0
    let encoding: u32 = 0xA1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_11_condition_lt_128_b1400080() {
    // Encoding: 0xB1400080
    // Test aarch32_SMLALBB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=11, RdHi=0, M=0, N=0, RdLo=0
    let encoding: u32 = 0xB1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_12_condition_gt_128_c1400080() {
    // Encoding: 0xC1400080
    // Test aarch32_SMLALBB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, N=0, Rn=0, M=0, cond=12, RdHi=0
    let encoding: u32 = 0xC1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_13_condition_le_128_d1400080() {
    // Encoding: 0xD1400080
    // Test aarch32_SMLALBB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rm=0, M=0, RdHi=0, N=0, Rn=0, RdLo=0
    let encoding: u32 = 0xD1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_14_condition_al_128_e1400080() {
    // Encoding: 0xE1400080
    // Test aarch32_SMLALBB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: M=0, RdLo=0, N=0, Rm=0, Rn=0, cond=14, RdHi=0
    let encoding: u32 = 0xE1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlalbb_a1_a_special_cond_15_condition_nv_128_f1400080() {
    // Encoding: 0xF1400080
    // Test aarch32_SMLALBB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: RdLo=0, N=0, cond=15, M=0, Rn=0, RdHi=0, Rm=0
    let encoding: u32 = 0xF1400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_a1_a_invalid_0_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: RdLo=0, cond=0, RdHi=0, Rm=0, M=0, N=0, Rn=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_a1_a_invalid_1_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: RdLo=0, cond=0, M=0, Rm=0, RdHi=0, Rn=0, N=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_a1_a_invalid_2_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: N=0, RdLo=0, RdHi=0, Rm=0, Rn=0, M=0, cond=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_a1_a_invalid_3_80_01400080() {
    // Encoding: 0x01400080
    // Test aarch32_SMLALBB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: RdLo=0, cond=0, Rm=0, Rn=0, N=0, M=0, RdHi=0
    let encoding: u32 = 0x01400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rn_0_min_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, M=0, RdHi=0, N=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rn_1_poweroftwo_80_fbc10080() {
    // Thumb encoding (32): 0xFBC10080
    // Test aarch32_SMLALBB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, M=0, N=0, RdLo=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC10080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdlo_0_min_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rn=0, Rm=0, N=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdlo_1_poweroftwo_80_fbc01080() {
    // Thumb encoding (32): 0xFBC01080
    // Test aarch32_SMLALBB_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, M=0, Rn=0, Rm=0, RdLo=1, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC01080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdlo_7_poweroftwominusone_80_fbc07080() {
    // Thumb encoding (32): 0xFBC07080
    // Test aarch32_SMLALBB_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: RdLo=7, Rm=0, N=0, RdHi=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC07080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdlo_15_max_80_fbc0f080() {
    // Thumb encoding (32): 0xFBC0F080
    // Test aarch32_SMLALBB_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: RdLo=15, RdHi=0, Rm=0, M=0, N=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdhi_0_min_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, RdHi=0, RdLo=0, N=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdhi_1_poweroftwo_80_fbc00180() {
    // Thumb encoding (32): 0xFBC00180
    // Test aarch32_SMLALBB_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, M=0, Rm=0, RdLo=0, Rn=0, RdHi=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdhi_7_poweroftwominusone_80_fbc00780() {
    // Thumb encoding (32): 0xFBC00780
    // Test aarch32_SMLALBB_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdLo=0, N=0, M=0, RdHi=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rdhi_15_max_80_fbc00f80() {
    // Thumb encoding (32): 0xFBC00F80
    // Test aarch32_SMLALBB_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: N=0, Rm=0, M=0, RdLo=0, RdHi=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00F80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_t1_a_field_n_0_min_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: N=0, Rn=0, RdHi=0, RdLo=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlalbb_t1_a_field_n_1_max_80_fbc000a0() {
    // Thumb encoding (32): 0xFBC000A0
    // Test aarch32_SMLALBB_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, M=0, RdHi=0, Rm=0, N=1, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlalbb_t1_a_field_m_0_min_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, N=0, M=0, Rm=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlalbb_t1_a_field_m_1_max_80_fbc00090() {
    // Thumb encoding (32): 0xFBC00090
    // Test aarch32_SMLALBB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, M=1, RdHi=0, Rm=0, RdLo=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rm_0_min_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, Rm=0, RdHi=0, N=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlalbb_t1_a_field_rm_1_poweroftwo_80_fbc00081() {
    // Thumb encoding (32): 0xFBC00081
    // Test aarch32_SMLALBB_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, N=0, M=0, Rn=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlalbb_t1_a_combo_0_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A field combination: Rn=0, RdLo=0, RdHi=0, N=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, M=0, RdHi=0, Rm=0, RdLo=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_t1_a_invalid_0_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: M=0, Rn=0, RdHi=0, RdLo=0, Rm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_t1_a_invalid_1_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, RdLo=0, N=0, RdHi=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_t1_a_invalid_2_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=0, RdHi=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALBB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlalbb_t1_a_invalid_3_80_fbc00080() {
    // Thumb encoding (32): 0xFBC00080
    // Test aarch32_SMLALBB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: N=0, Rm=0, RdHi=0, M=0, Rn=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_PSSBB_A Tests
// ============================================================================

/// Provenance: aarch32_PSSBB_A1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_pssbb_a1_a_basic_encoding_f5700044() {
    // Encoding: 0xF5700044
    // Test aarch32_PSSBB_A1_A basic encoding
    // ISET: A32
    let encoding: u32 = 0xF5700044;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PSSBB_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_pssbb_t1_a_basic_encoding_f3b08044() {
    // Thumb encoding (32): 0xF3B08044
    // Test aarch32_PSSBB_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08044;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PSSBB_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pssbb_t1_a_invalid_0_8044_f3b08044() {
    // Thumb encoding (32): 0xF3B08044
    // Test aarch32_PSSBB_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08044;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_PSSBB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pssbb_t1_a_invalid_1_8044_f3b08044() {
    // Thumb encoding (32): 0xF3B08044
    // Test aarch32_PSSBB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08044;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SHA1M_A Tests
// ============================================================================

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1m_a1_a_field_d_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, Q=0, Vm=0, Vd=0, N=0, M=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1m_a1_a_field_d_1_max_c00_f2600c00() {
    // Encoding: 0xF2600C00
    // Test aarch32_SHA1M_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, M=0, Vn=0, Vm=0, N=0, Q=0, Vd=0
    let encoding: u32 = 0xF2600C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1m_a1_a_field_vn_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: N=0, Q=0, Vd=0, Vn=0, Vm=0, M=0, D=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1m_a1_a_field_vn_1_poweroftwo_c00_f2210c00() {
    // Encoding: 0xF2210C00
    // Test aarch32_SHA1M_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, N=0, Vm=0, D=0, Vn=1, M=0, Vd=0
    let encoding: u32 = 0xF2210C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1m_a1_a_field_vd_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: N=0, D=0, Vn=0, M=0, Q=0, Vd=0, Vm=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1m_a1_a_field_vd_1_poweroftwo_c00_f2201c00() {
    // Encoding: 0xF2201C00
    // Test aarch32_SHA1M_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, N=0, Vn=0, Q=0, M=0, Vm=0, Vd=1
    let encoding: u32 = 0xF2201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1m_a1_a_field_n_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, Q=0, M=0, Vd=0, Vm=0, N=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1m_a1_a_field_n_1_max_c00_f2200c80() {
    // Encoding: 0xF2200C80
    // Test aarch32_SHA1M_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, Q=0, Vm=0, N=1, D=0, Vd=0, M=0
    let encoding: u32 = 0xF2200C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1m_a1_a_field_q_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, M=0, Q=0, Vd=0, Vm=0, D=0, N=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1m_a1_a_field_q_1_max_c00_f2200c40() {
    // Encoding: 0xF2200C40
    // Test aarch32_SHA1M_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, Vm=0, D=0, N=0, M=0, Vd=0, Q=1
    let encoding: u32 = 0xF2200C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1m_a1_a_field_m_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Q=0, Vn=0, M=0, Vm=0, D=0, N=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1m_a1_a_field_m_1_max_c00_f2200c20() {
    // Encoding: 0xF2200C20
    // Test aarch32_SHA1M_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Q=0, D=0, M=1, Vm=0, Vn=0, Vd=0, N=0
    let encoding: u32 = 0xF2200C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1m_a1_a_field_vm_0_min_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, N=0, Vm=0, Vn=0, M=0, Vd=0, Q=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1m_a1_a_field_vm_1_poweroftwo_c00_f2200c01() {
    // Encoding: 0xF2200C01
    // Test aarch32_SHA1M_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=1, N=0, D=0, Vn=0, Q=0
    let encoding: u32 = 0xF2200C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1m_a1_a_combo_0_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, M=0, Vn=0, N=0, Q=0, Vd=0, D=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1m_a1_a_special_q_0_size_variant_0_3072_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: D=0, Vd=0, Vm=0, Vn=0, Q=0, N=0, M=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1m_a1_a_special_q_1_size_variant_1_3072_f2200c40() {
    // Encoding: 0xF2200C40
    // Test aarch32_SHA1M_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vn=0, M=0, D=0, Q=1, Vd=0, Vm=0, N=0
    let encoding: u32 = 0xF2200C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_a1_a_invalid_0_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: A32
    // Fields: Q=0, N=0, D=0, Vd=0, Vn=0, M=0, Vm=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_a1_a_invalid_1_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, N=0, Vn=0, M=0, Q=0, Vm=0, D=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_a1_a_invalid_2_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: M=0, D=0, Vd=0, N=0, Q=0, Vn=0, Vm=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_a1_a_invalid_3_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, Vn=0, D=0, N=0, Q=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_a1_a_invalid_4_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, Q=0, Vm=0, Vn=0, Vd=0, N=0, M=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_a1_a_invalid_5_c00_f2200c00() {
    // Encoding: 0xF2200C00
    // Test aarch32_SHA1M_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, Vd=0, M=0, Q=0, Vm=0, D=0, Vn=0
    let encoding: u32 = 0xF2200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1m_t1_a_field_d_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: N=0, Vn=0, M=0, Vm=0, Vd=0, Q=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1m_t1_a_field_d_1_max_c00_ef600c00() {
    // Thumb encoding (32): 0xEF600C00
    // Test aarch32_SHA1M_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, M=0, Q=0, Vm=0, D=1, N=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF600C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1m_t1_a_field_vn_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: N=0, Vn=0, Q=0, M=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1m_t1_a_field_vn_1_poweroftwo_c00_ef210c00() {
    // Thumb encoding (32): 0xEF210C00
    // Test aarch32_SHA1M_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Q=0, Vm=0, Vd=0, Vn=1, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF210C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1m_t1_a_field_vd_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Vd=0, N=0, Q=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1m_t1_a_field_vd_1_poweroftwo_c00_ef201c00() {
    // Thumb encoding (32): 0xEF201C00
    // Test aarch32_SHA1M_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, N=0, Q=0, Vm=0, M=0, Vn=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF201C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1m_t1_a_field_n_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Q=0, N=0, Vd=0, Vn=0, Vm=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1m_t1_a_field_n_1_max_c00_ef200c80() {
    // Thumb encoding (32): 0xEF200C80
    // Test aarch32_SHA1M_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, D=0, Vn=0, Q=0, N=1, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1m_t1_a_field_q_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, Vm=0, N=0, D=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1m_t1_a_field_q_1_max_c00_ef200c40() {
    // Thumb encoding (32): 0xEF200C40
    // Test aarch32_SHA1M_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, M=0, N=0, Vm=0, Vn=0, Q=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1m_t1_a_field_m_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, Vn=0, Q=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1m_t1_a_field_m_1_max_c00_ef200c20() {
    // Thumb encoding (32): 0xEF200C20
    // Test aarch32_SHA1M_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Q=0, Vm=0, D=0, Vd=0, Vn=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1m_t1_a_field_vm_0_min_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, Vm=0, N=0, M=0, Q=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1m_t1_a_field_vm_1_poweroftwo_c00_ef200c01() {
    // Thumb encoding (32): 0xEF200C01
    // Test aarch32_SHA1M_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=1, Q=0, D=0, M=0, Vd=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1m_t1_a_combo_0_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, Q=0, D=0, Vm=0, N=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1m_t1_a_special_q_0_size_variant_0_3072_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, Q=0, M=0, Vd=0, N=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1m_t1_a_special_q_1_size_variant_1_3072_ef200c40() {
    // Thumb encoding (32): 0xEF200C40
    // Test aarch32_SHA1M_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vn=0, Q=1, Vm=0, D=0, Vd=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1m_t1_a_invalid_0_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vn=0, N=0, Vd=0, Q=0, D=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1m_t1_a_invalid_1_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: D=0, M=0, Vd=0, Q=0, N=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_t1_a_invalid_2_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: T32
    // Fields: M=0, Vn=0, Q=0, Vm=0, N=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_t1_a_invalid_3_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: N=0, Vn=0, Vd=0, D=0, M=0, Q=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_t1_a_invalid_4_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, N=0, Vd=0, Q=0, Vn=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_t1_a_invalid_5_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, M=0, D=0, N=0, Vm=0, Q=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_t1_a_invalid_6_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Q=0, D=0, Vn=0, Vd=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1M_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1m_t1_a_invalid_7_c00_ef200c00() {
    // Thumb encoding (32): 0xEF200C00
    // Test aarch32_SHA1M_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, Vn=0, N=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_64_0_d2401c20() {
    // Test EOR 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0xD2401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFF00,
        "X0 should be 0xFFFFFFFFFFFFFF00"
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_64_1_d2403c20() {
    // Test EOR 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0xD2403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF0000,
        "X0 should be 0xFFFFFFFFFFFF0000"
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_64_2_d2407c20() {
    // Test EOR 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0xD2407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_64_3_d2400020() {
    // Test EOR 64-bit: single bit mask (oracle)
    // Encoding: 0xD2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0xD2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xCAFEBABF,
        "X0 should be 0xDEADBEEFCAFEBABF"
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_64_4_d240f820() {
    // Test EOR 64-bit: all but MSB (oracle)
    // Encoding: 0xD240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xD240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x55555555,
        "X0 should be 0xD555555555555555"
    );
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_32_0_52001c20() {
    // Test EOR 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x52001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "W0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_32_1_52003c20() {
    // Test EOR 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x52003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF0000, "W0 should be 0xFFFF0000");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_sha1m_a1_a_eor_oracle_32_2_52000020() {
    // Test EOR 32-bit: single bit mask (oracle)
    // Encoding: 0x52000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x52000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDEADBEEE, "W0 should be 0xDEADBEEE");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_0_0_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_0_ff_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF5, "R0 should be 0x000000F5");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_0_aaaaaaaa_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAA0, "R0 should be 0xAAAAAAA0");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_0_55555555_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5555555F, "R0 should be 0x5555555F");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_0_ffffffff_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_1_0_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_1_ff_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_1_aaaaaaaa_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAA55, "R0 should be 0xAAAAAA55");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_1_55555555_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x555555AA, "R0 should be 0x555555AA");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_1_ffffffff_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_2_0_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_2_ff_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDF, "R0 should be 0x000000DF");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_2_aaaaaaaa_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAA8A, "R0 should be 0xAAAAAA8A");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_2_55555555_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555575, "R0 should be 0x55555575");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_2_ffffffff_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_3_0_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_3_ff_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0000FF, "R0 should be 0x0F0000FF");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_3_aaaaaaaa_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA5AAAAAA, "R0 should be 0xA5AAAAAA");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_3_55555555_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A555555, "R0 should be 0x5A555555");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_3_ffffffff_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_4_0_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_4_ff_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_4_aaaaaaaa_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAAA, "R0 should be 0xAAAAAAAA");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_4_55555555_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555555, "R0 should be 0x55555555");
}

/// Provenance: aarch32_SHA1M_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1m_a1_a_a32_logical_imm_4_ffffffff_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_SB_A Tests
// ============================================================================

/// Provenance: aarch32_SB_A1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_sb_a1_a_basic_encoding_f5700070() {
    // Encoding: 0xF5700070
    // Test aarch32_SB_A1_A basic encoding
    // ISET: A32
    let encoding: u32 = 0xF5700070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SB_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_sb_t1_a_basic_encoding_f3b08070() {
    // Thumb encoding (32): 0xF3B08070
    // Test aarch32_SB_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SB_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sb_t1_a_invalid_0_8070_f3b08070() {
    // Thumb encoding (32): 0xF3B08070
    // Test aarch32_SB_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sb_t1_a_invalid_1_8070_f3b08070() {
    // Thumb encoding (32): 0xF3B08070
    // Test aarch32_SB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SEL_A Tests
// ============================================================================

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sel_a1_a_field_cond_0_min_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sel_a1_a_field_cond_1_poweroftwo_b0_168000b0() {
    // Encoding: 0x168000B0
    // Test aarch32_SEL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x168000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sel_a1_a_field_cond_2_poweroftwo_b0_268000b0() {
    // Encoding: 0x268000B0
    // Test aarch32_SEL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=2, Rn=0, Rd=0
    let encoding: u32 = 0x268000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sel_a1_a_field_cond_3_poweroftwo_b0_368000b0() {
    // Encoding: 0x368000B0
    // Test aarch32_SEL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x368000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sel_a1_a_field_cond_4_poweroftwo_b0_468000b0() {
    // Encoding: 0x468000B0
    // Test aarch32_SEL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=4, Rm=0
    let encoding: u32 = 0x468000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sel_a1_a_field_cond_5_poweroftwo_b0_568000b0() {
    // Encoding: 0x568000B0
    // Test aarch32_SEL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=5
    let encoding: u32 = 0x568000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sel_a1_a_field_cond_6_poweroftwo_b0_668000b0() {
    // Encoding: 0x668000B0
    // Test aarch32_SEL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rn=0, Rd=0
    let encoding: u32 = 0x668000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sel_a1_a_field_cond_7_poweroftwo_b0_768000b0() {
    // Encoding: 0x768000B0
    // Test aarch32_SEL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=7
    let encoding: u32 = 0x768000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sel_a1_a_field_cond_8_poweroftwo_b0_868000b0() {
    // Encoding: 0x868000B0
    // Test aarch32_SEL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x868000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sel_a1_a_field_cond_9_poweroftwo_b0_968000b0() {
    // Encoding: 0x968000B0
    // Test aarch32_SEL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x968000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sel_a1_a_field_cond_10_poweroftwo_b0_a68000b0() {
    // Encoding: 0xA68000B0
    // Test aarch32_SEL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0xA68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sel_a1_a_field_cond_11_poweroftwo_b0_b68000b0() {
    // Encoding: 0xB68000B0
    // Test aarch32_SEL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=11
    let encoding: u32 = 0xB68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sel_a1_a_field_cond_12_poweroftwo_b0_c68000b0() {
    // Encoding: 0xC68000B0
    // Test aarch32_SEL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rn=0, Rd=0
    let encoding: u32 = 0xC68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sel_a1_a_field_cond_13_poweroftwo_b0_d68000b0() {
    // Encoding: 0xD68000B0
    // Test aarch32_SEL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rm=0, Rn=0
    let encoding: u32 = 0xD68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sel_a1_a_field_cond_14_poweroftwo_b0_e68000b0() {
    // Encoding: 0xE68000B0
    // Test aarch32_SEL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xE68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sel_a1_a_field_cond_15_max_b0_f68000b0() {
    // Encoding: 0xF68000B0
    // Test aarch32_SEL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=15, Rn=0, Rm=0
    let encoding: u32 = 0xF68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sel_a1_a_field_rn_0_min_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sel_a1_a_field_rn_1_poweroftwo_b0_068100b0() {
    // Encoding: 0x068100B0
    // Test aarch32_SEL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, Rn=1
    let encoding: u32 = 0x068100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sel_a1_a_field_rd_0_min_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sel_a1_a_field_rd_1_poweroftwo_b0_068010b0() {
    // Encoding: 0x068010B0
    // Test aarch32_SEL_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, Rd=1
    let encoding: u32 = 0x068010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sel_a1_a_field_rm_0_min_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sel_a1_a_field_rm_1_poweroftwo_b0_068000b1() {
    // Encoding: 0x068000B1
    // Test aarch32_SEL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Rm=1
    let encoding: u32 = 0x068000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sel_a1_a_combo_0_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A field combination: cond=0, Rn=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sel_a1_a_special_cond_0_condition_eq_176_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sel_a1_a_special_cond_1_condition_ne_176_168000b0() {
    // Encoding: 0x168000B0
    // Test aarch32_SEL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=1, Rm=0
    let encoding: u32 = 0x168000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sel_a1_a_special_cond_2_condition_cs_hs_176_268000b0() {
    // Encoding: 0x268000B0
    // Test aarch32_SEL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, cond=2, Rn=0, Rd=0
    let encoding: u32 = 0x268000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sel_a1_a_special_cond_3_condition_cc_lo_176_368000b0() {
    // Encoding: 0x368000B0
    // Test aarch32_SEL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x368000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sel_a1_a_special_cond_4_condition_mi_176_468000b0() {
    // Encoding: 0x468000B0
    // Test aarch32_SEL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=4, Rm=0
    let encoding: u32 = 0x468000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sel_a1_a_special_cond_5_condition_pl_176_568000b0() {
    // Encoding: 0x568000B0
    // Test aarch32_SEL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=5, Rn=0
    let encoding: u32 = 0x568000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sel_a1_a_special_cond_6_condition_vs_176_668000b0() {
    // Encoding: 0x668000B0
    // Test aarch32_SEL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, cond=6, Rm=0, Rn=0
    let encoding: u32 = 0x668000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sel_a1_a_special_cond_7_condition_vc_176_768000b0() {
    // Encoding: 0x768000B0
    // Test aarch32_SEL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=7
    let encoding: u32 = 0x768000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sel_a1_a_special_cond_8_condition_hi_176_868000b0() {
    // Encoding: 0x868000B0
    // Test aarch32_SEL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=8, Rm=0
    let encoding: u32 = 0x868000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sel_a1_a_special_cond_9_condition_ls_176_968000b0() {
    // Encoding: 0x968000B0
    // Test aarch32_SEL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=9
    let encoding: u32 = 0x968000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sel_a1_a_special_cond_10_condition_ge_176_a68000b0() {
    // Encoding: 0xA68000B0
    // Test aarch32_SEL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=10, Rn=0
    let encoding: u32 = 0xA68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sel_a1_a_special_cond_11_condition_lt_176_b68000b0() {
    // Encoding: 0xB68000B0
    // Test aarch32_SEL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0xB68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sel_a1_a_special_cond_12_condition_gt_176_c68000b0() {
    // Encoding: 0xC68000B0
    // Test aarch32_SEL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=12
    let encoding: u32 = 0xC68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sel_a1_a_special_cond_13_condition_le_176_d68000b0() {
    // Encoding: 0xD68000B0
    // Test aarch32_SEL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0xD68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sel_a1_a_special_cond_14_condition_al_176_e68000b0() {
    // Encoding: 0xE68000B0
    // Test aarch32_SEL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=14
    let encoding: u32 = 0xE68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sel_a1_a_special_cond_15_condition_nv_176_f68000b0() {
    // Encoding: 0xF68000B0
    // Test aarch32_SEL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rm=0, Rd=0
    let encoding: u32 = 0xF68000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sel_a1_a_invalid_0_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SEL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sel_a1_a_invalid_1_b0_068000b0() {
    // Encoding: 0x068000B0
    // Test aarch32_SEL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x068000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sel_t1_a_field_rn_0_min_f080_faa0f080() {
    // Thumb encoding (32): 0xFAA0F080
    // Test aarch32_SEL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sel_t1_a_field_rn_1_poweroftwo_f080_faa1f080() {
    // Thumb encoding (32): 0xFAA1F080
    // Test aarch32_SEL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA1F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sel_t1_a_field_rd_0_min_f080_faa0f080() {
    // Thumb encoding (32): 0xFAA0F080
    // Test aarch32_SEL_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sel_t1_a_field_rd_1_poweroftwo_f080_faa0f180() {
    // Thumb encoding (32): 0xFAA0F180
    // Test aarch32_SEL_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sel_t1_a_field_rm_0_min_f080_faa0f080() {
    // Thumb encoding (32): 0xFAA0F080
    // Test aarch32_SEL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sel_t1_a_field_rm_1_poweroftwo_f080_faa0f081() {
    // Thumb encoding (32): 0xFAA0F081
    // Test aarch32_SEL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_sel_t1_a_combo_0_f080_faa0f080() {
    // Thumb encoding (32): 0xFAA0F080
    // Test aarch32_SEL_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sel_t1_a_invalid_0_f080_faa0f080() {
    // Thumb encoding (32): 0xFAA0F080
    // Test aarch32_SEL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SEL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sel_t1_a_invalid_1_f080_faa0f080() {
    // Thumb encoding (32): 0xFAA0F080
    // Test aarch32_SEL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAA0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_AESIMC_A Tests
// ============================================================================

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesimc_a1_a_field_d_0_min_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesimc_a1_a_field_d_1_max_3c0_f3f003c0() {
    // Encoding: 0xF3F003C0
    // Test aarch32_AESIMC_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, size=0, M=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3F003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aesimc_a1_a_field_size_0_min_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vm=0, D=0, M=0, Vd=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aesimc_a1_a_field_size_1_poweroftwo_3c0_f3b403c0() {
    // Encoding: 0xF3B403C0
    // Test aarch32_AESIMC_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vd=0, size=1, M=0, Vm=0
    let encoding: u32 = 0xF3B403C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aesimc_a1_a_field_size_2_poweroftwo_3c0_f3b803c0() {
    // Encoding: 0xF3B803C0
    // Test aarch32_AESIMC_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, Vm=0, size=2
    let encoding: u32 = 0xF3B803C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aesimc_a1_a_field_size_3_max_3c0_f3bc03c0() {
    // Encoding: 0xF3BC03C0
    // Test aarch32_AESIMC_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: D=0, size=3, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3BC03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesimc_a1_a_field_vd_0_min_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, size=0, Vd=0, D=0, M=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesimc_a1_a_field_vd_1_poweroftwo_3c0_f3b013c0() {
    // Encoding: 0xF3B013C0
    // Test aarch32_AESIMC_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=1, size=0, D=0
    let encoding: u32 = 0xF3B013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesimc_a1_a_field_m_0_min_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, size=0, Vm=0, D=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesimc_a1_a_field_m_1_max_3c0_f3b003e0() {
    // Encoding: 0xF3B003E0
    // Test aarch32_AESIMC_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, M=1, Vm=0
    let encoding: u32 = 0xF3B003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesimc_a1_a_field_vm_0_min_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, size=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesimc_a1_a_field_vm_1_poweroftwo_3c0_f3b003c1() {
    // Encoding: 0xF3B003C1
    // Test aarch32_AESIMC_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, D=0, Vm=1, size=0, Vd=0
    let encoding: u32 = 0xF3B003C1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aesimc_a1_a_combo_0_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aesimc_a1_a_special_size_0_size_variant_0_960_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aesimc_a1_a_special_size_1_size_variant_1_960_f3b403c0() {
    // Encoding: 0xF3B403C0
    // Test aarch32_AESIMC_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: M=0, Vm=0, size=1, Vd=0, D=0
    let encoding: u32 = 0xF3B403C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aesimc_a1_a_special_size_2_size_variant_2_960_f3b803c0() {
    // Encoding: 0xF3B803C0
    // Test aarch32_AESIMC_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: Vm=0, size=2, D=0, M=0, Vd=0
    let encoding: u32 = 0xF3B803C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aesimc_a1_a_special_size_3_size_variant_3_960_f3bc03c0() {
    // Encoding: 0xF3BC03C0
    // Test aarch32_AESIMC_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: M=0, size=3, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF3BC03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_a1_a_invalid_0_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: A32
    // Fields: Vm=0, size=0, M=0, D=0, Vd=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_a1_a_invalid_1_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, M=0, Vd=0, size=0, Vm=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_a1_a_invalid_2_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_a1_a_invalid_3_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, size=0, M=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_a1_a_invalid_4_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vm=0, size=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_a1_a_invalid_5_3c0_f3b003c0() {
    // Encoding: 0xF3B003C0
    // Test aarch32_AESIMC_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, size=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF3B003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesimc_t1_a_field_d_0_min_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vm=0, M=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesimc_t1_a_field_d_1_max_3c0_fff003c0() {
    // Thumb encoding (32): 0xFFF003C0
    // Test aarch32_AESIMC_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, D=1, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_aesimc_t1_a_field_size_0_min_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_aesimc_t1_a_field_size_1_poweroftwo_3c0_ffb403c0() {
    // Thumb encoding (32): 0xFFB403C0
    // Test aarch32_AESIMC_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vd=0, Vm=0, D=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB403C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_aesimc_t1_a_field_size_2_poweroftwo_3c0_ffb803c0() {
    // Thumb encoding (32): 0xFFB803C0
    // Test aarch32_AESIMC_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, size=2, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB803C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_aesimc_t1_a_field_size_3_max_3c0_ffbc03c0() {
    // Thumb encoding (32): 0xFFBC03C0
    // Test aarch32_AESIMC_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: M=0, Vd=0, size=3, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC03C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesimc_t1_a_field_vd_0_min_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: size=0, M=0, Vd=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesimc_t1_a_field_vd_1_poweroftwo_3c0_ffb013c0() {
    // Thumb encoding (32): 0xFFB013C0
    // Test aarch32_AESIMC_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, Vd=1, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB013C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_aesimc_t1_a_field_m_0_min_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_aesimc_t1_a_field_m_1_max_3c0_ffb003e0() {
    // Thumb encoding (32): 0xFFB003E0
    // Test aarch32_AESIMC_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, Vm=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_aesimc_t1_a_field_vm_0_min_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, size=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_aesimc_t1_a_field_vm_1_poweroftwo_3c0_ffb003c1() {
    // Thumb encoding (32): 0xFFB003C1
    // Test aarch32_AESIMC_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=1, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_aesimc_t1_a_combo_0_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, M=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_aesimc_t1_a_special_size_0_size_variant_0_960_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: size=0, D=0, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_aesimc_t1_a_special_size_1_size_variant_1_960_ffb403c0() {
    // Thumb encoding (32): 0xFFB403C0
    // Test aarch32_AESIMC_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, Vm=0, size=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB403C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_aesimc_t1_a_special_size_2_size_variant_2_960_ffb803c0() {
    // Thumb encoding (32): 0xFFB803C0
    // Test aarch32_AESIMC_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, D=0, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB803C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_aesimc_t1_a_special_size_3_size_variant_3_960_ffbc03c0() {
    // Thumb encoding (32): 0xFFBC03C0
    // Test aarch32_AESIMC_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, Vm=0, size=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBC03C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aesimc_t1_a_invalid_0_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: M=0, D=0, Vm=0, Vd=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_aesimc_t1_a_invalid_1_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vd=0, Vm=0, D=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveAESExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_t1_a_invalid_2_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveAESExt" }, args: [] } }
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_t1_a_invalid_3_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, Vd=0, size=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_t1_a_invalid_4_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // ISET: T32
    // Fields: M=0, Vd=0, D=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_t1_a_invalid_5_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_t1_a_invalid_6_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESIMC_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_aesimc_t1_a_invalid_7_3c0_ffb003c0() {
    // Thumb encoding (32): 0xFFB003C0
    // Test aarch32_AESIMC_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_32_0_f3b247c0() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B247C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B247C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_64_0_f3b247c0() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B247C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B247C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_32_1_f3b57be0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_64_1_f3b57be0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_32_3_f3b003c0() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B003C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_64_3_f3b003c0() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B003C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B003C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_64_4_f3facfc0() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACFC0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACFC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_aesimc_a1_a_movz_oracle_64_5_f3fbd7e0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7E0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_aesimc_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_aesimc_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_aesimc_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_aesimc_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_AESIMC_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_aesimc_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_SHA1H_A Tests
// ============================================================================

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1h_a1_a_field_d_0_min_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, D=0, size=0, M=0, Vm=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1h_a1_a_field_d_1_max_2c0_f3f102c0() {
    // Encoding: 0xF3F102C0
    // Test aarch32_SHA1H_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Vm=0, Vd=0, M=0, size=0
    let encoding: u32 = 0xF3F102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1h_a1_a_field_size_0_min_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1h_a1_a_field_size_1_poweroftwo_2c0_f3b502c0() {
    // Encoding: 0xF3B502C0
    // Test aarch32_SHA1H_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, M=0, size=1, Vm=0
    let encoding: u32 = 0xF3B502C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_sha1h_a1_a_field_size_2_poweroftwo_2c0_f3b902c0() {
    // Encoding: 0xF3B902C0
    // Test aarch32_SHA1H_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: size=2, M=0, Vd=0, Vm=0, D=0
    let encoding: u32 = 0xF3B902C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_sha1h_a1_a_field_size_3_max_2c0_f3bd02c0() {
    // Encoding: 0xF3BD02C0
    // Test aarch32_SHA1H_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: M=0, size=3, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF3BD02C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1h_a1_a_field_vd_0_min_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, size=0, Vd=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1h_a1_a_field_vd_1_poweroftwo_2c0_f3b112c0() {
    // Encoding: 0xF3B112C0
    // Test aarch32_SHA1H_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, D=0, M=0, Vd=1, Vm=0
    let encoding: u32 = 0xF3B112C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1h_a1_a_field_m_0_min_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, Vm=0, D=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1h_a1_a_field_m_1_max_2c0_f3b102e0() {
    // Encoding: 0xF3B102E0
    // Test aarch32_SHA1H_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vm=0, size=0, M=1, Vd=0
    let encoding: u32 = 0xF3B102E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1h_a1_a_field_vm_0_min_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vd=0, M=0, Vm=0, size=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1h_a1_a_field_vm_1_poweroftwo_2c0_f3b102c1() {
    // Encoding: 0xF3B102C1
    // Test aarch32_SHA1H_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vd=0, D=0, size=0, Vm=1
    let encoding: u32 = 0xF3B102C1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1h_a1_a_combo_0_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: size=0, Vm=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1h_a1_a_special_size_0_size_variant_0_704_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1h_a1_a_special_size_1_size_variant_1_704_f3b502c0() {
    // Encoding: 0xF3B502C0
    // Test aarch32_SHA1H_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, size=1, D=0, Vm=0, M=0
    let encoding: u32 = 0xF3B502C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_sha1h_a1_a_special_size_2_size_variant_2_704_f3b902c0() {
    // Encoding: 0xF3B902C0
    // Test aarch32_SHA1H_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: M=0, D=0, size=2, Vm=0, Vd=0
    let encoding: u32 = 0xF3B902C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_sha1h_a1_a_special_size_3_size_variant_3_704_f3bd02c0() {
    // Encoding: 0xF3BD02C0
    // Test aarch32_SHA1H_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, M=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3BD02C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_a1_a_invalid_0_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: A32
    // Fields: size=0, M=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_a1_a_invalid_1_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vm=0, Vd=0, M=0, size=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_a1_a_invalid_2_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_a1_a_invalid_3_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: size=0, Vd=0, M=0, Vm=0, D=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_a1_a_invalid_4_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vm=0, D=0, size=0, M=0, Vd=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_a1_a_invalid_5_2c0_f3b102c0() {
    // Encoding: 0xF3B102C0
    // Test aarch32_SHA1H_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, M=0, size=0
    let encoding: u32 = 0xF3B102C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1h_t1_a_field_d_0_min_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1h_t1_a_field_d_1_max_2c0_fff102c0() {
    // Thumb encoding (32): 0xFFF102C0
    // Test aarch32_SHA1H_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: size=0, Vd=0, M=0, D=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1h_t1_a_field_size_0_min_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, Vm=0, M=0, size=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1h_t1_a_field_size_1_poweroftwo_2c0_ffb502c0() {
    // Thumb encoding (32): 0xFFB502C0
    // Test aarch32_SHA1H_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=1, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB502C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_sha1h_t1_a_field_size_2_poweroftwo_2c0_ffb902c0() {
    // Thumb encoding (32): 0xFFB902C0
    // Test aarch32_SHA1H_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: size=2, Vd=0, D=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB902C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_sha1h_t1_a_field_size_3_max_2c0_ffbd02c0() {
    // Thumb encoding (32): 0xFFBD02C0
    // Test aarch32_SHA1H_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, M=0, Vd=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBD02C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1h_t1_a_field_vd_0_min_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1h_t1_a_field_vd_1_poweroftwo_2c0_ffb112c0() {
    // Thumb encoding (32): 0xFFB112C0
    // Test aarch32_SHA1H_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: size=0, Vm=0, D=0, Vd=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB112C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1h_t1_a_field_m_0_min_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vd=0, size=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1h_t1_a_field_m_1_max_2c0_ffb102e0() {
    // Thumb encoding (32): 0xFFB102E0
    // Test aarch32_SHA1H_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: M=1, size=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1h_t1_a_field_vm_0_min_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, D=0, size=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1h_t1_a_field_vm_1_poweroftwo_2c0_ffb102c1() {
    // Thumb encoding (32): 0xFFB102C1
    // Test aarch32_SHA1H_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=1, size=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1h_t1_a_combo_0_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1h_t1_a_special_size_0_size_variant_0_704_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, size=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1h_t1_a_special_size_1_size_variant_1_704_ffb502c0() {
    // Thumb encoding (32): 0xFFB502C0
    // Test aarch32_SHA1H_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: M=0, Vd=0, D=0, size=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB502C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_sha1h_t1_a_special_size_2_size_variant_2_704_ffb902c0() {
    // Thumb encoding (32): 0xFFB902C0
    // Test aarch32_SHA1H_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: Vd=0, size=2, M=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB902C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_sha1h_t1_a_special_size_3_size_variant_3_704_ffbd02c0() {
    // Thumb encoding (32): 0xFFBD02C0
    // Test aarch32_SHA1H_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, size=3, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBD02C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1h_t1_a_invalid_0_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vm=0, D=0, size=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1h_t1_a_invalid_1_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Vm=0, D=0, size=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_t1_a_invalid_2_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_t1_a_invalid_3_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_t1_a_invalid_4_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // ISET: T32
    // Fields: size=0, M=0, D=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_t1_a_invalid_5_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_t1_a_invalid_6_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: size=0, M=0, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1H_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1h_t1_a_invalid_7_2c0_ffb102c0() {
    // Thumb encoding (32): 0xFFB102C0
    // Test aarch32_SHA1H_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Vm=0, D=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_32_0_f3b346c0() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B346C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B346C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_64_0_f3b346c0() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B346C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B346C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_32_1_f3b57be0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_64_1_f3b57be0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B57BE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B57BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_32_3_f3b102c0() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B102C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_64_3_f3b102c0() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B102C0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B102C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_64_4_f3fbcfc0() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FBCFC0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBCFC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_sha1h_a1_a_movz_oracle_64_5_f3fbd7e0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7E0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_sha1h_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_sha1h_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_sha1h_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_sha1h_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA1H_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_sha1h_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_SRS_AS Tests
// ============================================================================

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_a1_as_field_p_0_min_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_SRS_A1_AS field P = 0 (Min)
    // ISET: A32
    // Fields: mode=0, U=0, P=0, W=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_srs_a1_as_field_p_1_max_0_f9400000() {
    // Encoding: 0xF9400000
    // Test aarch32_SRS_A1_AS field P = 1 (Max)
    // ISET: A32
    // Fields: W=0, mode=0, U=0, P=1
    let encoding: u32 = 0xF9400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_a1_as_field_u_0_min_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_SRS_A1_AS field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, mode=0, P=0, W=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_srs_a1_as_field_u_1_max_0_f8c00000() {
    // Encoding: 0xF8C00000
    // Test aarch32_SRS_A1_AS field U = 1 (Max)
    // ISET: A32
    // Fields: mode=0, P=0, W=0, U=1
    let encoding: u32 = 0xF8C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_a1_as_field_w_0_min_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_SRS_A1_AS field W = 0 (Min)
    // ISET: A32
    // Fields: W=0, P=0, U=0, mode=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_srs_a1_as_field_w_1_max_0_f8600000() {
    // Encoding: 0xF8600000
    // Test aarch32_SRS_A1_AS field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, mode=0, P=0, U=0
    let encoding: u32 = 0xF8600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_a1_as_field_mode_0_min_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_SRS_A1_AS field mode = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, W=0, mode=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_srs_a1_as_field_mode_1_poweroftwo_0_f8400001() {
    // Encoding: 0xF8400001
    // Test aarch32_SRS_A1_AS field mode = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, P=0, mode=1
    let encoding: u32 = 0xF8400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_srs_a1_as_field_mode_15_poweroftwominusone_0_f840000f() {
    // Encoding: 0xF840000F
    // Test aarch32_SRS_A1_AS field mode = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, W=0, mode=15, U=0
    let encoding: u32 = 0xF840000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_srs_a1_as_field_mode_31_max_0_f840001f() {
    // Encoding: 0xF840001F
    // Test aarch32_SRS_A1_AS field mode = 31 (Max)
    // ISET: A32
    // Fields: P=0, W=0, mode=31, U=0
    let encoding: u32 = 0xF840001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_srs_a1_as_combo_0_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_SRS_A1_AS field combination: P=0, U=0, W=0, mode=0
    // ISET: A32
    // Fields: P=0, U=0, mode=0, W=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_t1_as_field_w_0_min_0_e8000000() {
    // Thumb encoding (32): 0xE8000000
    // Test aarch32_SRS_T1_AS field W = 0 (Min)
    // ISET: T32
    // Fields: mode=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_srs_t1_as_field_w_1_max_0_e8200000() {
    // Thumb encoding (32): 0xE8200000
    // Test aarch32_SRS_T1_AS field W = 1 (Max)
    // ISET: T32
    // Fields: W=1, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_t1_as_field_mode_0_min_0_e8000000() {
    // Thumb encoding (32): 0xE8000000
    // Test aarch32_SRS_T1_AS field mode = 0 (Min)
    // ISET: T32
    // Fields: mode=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_srs_t1_as_field_mode_1_poweroftwo_0_e8000001() {
    // Thumb encoding (32): 0xE8000001
    // Test aarch32_SRS_T1_AS field mode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: mode=1, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_srs_t1_as_field_mode_15_poweroftwominusone_0_e800000f() {
    // Thumb encoding (32): 0xE800000F
    // Test aarch32_SRS_T1_AS field mode = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: mode=15, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE800000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_srs_t1_as_field_mode_31_max_0_e800001f() {
    // Thumb encoding (32): 0xE800001F
    // Test aarch32_SRS_T1_AS field mode = 31 (Max)
    // ISET: T32
    // Fields: W=0, mode=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE800001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_srs_t1_as_combo_0_0_e8000000() {
    // Thumb encoding (32): 0xE8000000
    // Test aarch32_SRS_T1_AS field combination: W=0, mode=0
    // ISET: T32
    // Fields: mode=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_t2_as_field_w_0_min_0_e9800000() {
    // Thumb encoding (32): 0xE9800000
    // Test aarch32_SRS_T2_AS field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_srs_t2_as_field_w_1_max_0_e9a00000() {
    // Thumb encoding (32): 0xE9A00000
    // Test aarch32_SRS_T2_AS field W = 1 (Max)
    // ISET: T32
    // Fields: W=1, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_srs_t2_as_field_mode_0_min_0_e9800000() {
    // Thumb encoding (32): 0xE9800000
    // Test aarch32_SRS_T2_AS field mode = 0 (Min)
    // ISET: T32
    // Fields: W=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_srs_t2_as_field_mode_1_poweroftwo_0_e9800001() {
    // Thumb encoding (32): 0xE9800001
    // Test aarch32_SRS_T2_AS field mode = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, mode=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_srs_t2_as_field_mode_15_poweroftwominusone_0_e980000f() {
    // Thumb encoding (32): 0xE980000F
    // Test aarch32_SRS_T2_AS field mode = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: mode=15, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE980000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field mode 0 +: 5`
/// Requirement: FieldBoundary { field: "mode", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_srs_t2_as_field_mode_31_max_0_e980001f() {
    // Thumb encoding (32): 0xE980001F
    // Test aarch32_SRS_T2_AS field mode = 31 (Max)
    // ISET: T32
    // Fields: W=0, mode=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE980001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_srs_t2_as_combo_0_0_e9800000() {
    // Thumb encoding (32): 0xE9800000
    // Test aarch32_SRS_T2_AS field combination: W=0, mode=0
    // ISET: T32
    // Fields: W=0, mode=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_a1_as_store_0_f8400000() {
    // Test aarch32_SRS_A1_AS memory store: 8 bytes
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_a1_as_store_1_f8400000() {
    // Test aarch32_SRS_A1_AS memory store: 8 bytes
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_a1_as_store_2_f8400000() {
    // Test aarch32_SRS_A1_AS memory store: 8 bytes
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_a1_as_store_3_f8400000() {
    // Test aarch32_SRS_A1_AS memory store: 8 bytes
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_srs_a1_as_exception_0_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Undefined
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_1_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_2_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_3_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_4_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_srs_a1_as_exception_5_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Undefined
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_6_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_7_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_8_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_a1_as_exception_9_f8400000() {
    // Test aarch32_SRS_A1_AS exception: Unpredictable
    // Encoding: 0xF8400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t1_as_store_0_e8000000() {
    // Test aarch32_SRS_T1_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t1_as_store_1_e8000000() {
    // Test aarch32_SRS_T1_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t1_as_store_2_e8000000() {
    // Test aarch32_SRS_T1_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t1_as_store_3_e8000000() {
    // Test aarch32_SRS_T1_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_srs_t1_as_exception_0_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_1_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_2_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_3_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_4_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_srs_t1_as_exception_5_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_6_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_7_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_8_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t1_as_exception_9_e8000000() {
    // Test aarch32_SRS_T1_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t2_as_store_0_e9800000() {
    // Test aarch32_SRS_T2_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t2_as_store_1_e9800000() {
    // Test aarch32_SRS_T2_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t2_as_store_2_e9800000() {
    // Test aarch32_SRS_T2_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_srs_t2_as_store_3_e9800000() {
    // Test aarch32_SRS_T2_AS memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_srs_t2_as_exception_0_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_1_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_2_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_3_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_4_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_srs_t2_as_exception_5_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_6_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_7_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_8_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SRS_T2_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_srs_t2_as_exception_9_e9800000() {
    // Test aarch32_SRS_T2_AS exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE9800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_UMAAL_A Tests
// ============================================================================

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_0_min_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, cond=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_1_poweroftwo_90_10400090() {
    // Encoding: 0x10400090
    // Test aarch32_UMAAL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rm=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x10400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_2_poweroftwo_90_20400090() {
    // Encoding: 0x20400090
    // Test aarch32_UMAAL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, cond=2
    let encoding: u32 = 0x20400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_3_poweroftwo_90_30400090() {
    // Encoding: 0x30400090
    // Test aarch32_UMAAL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, RdLo=0, Rm=0, Rn=0, RdHi=0
    let encoding: u32 = 0x30400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_4_poweroftwo_90_40400090() {
    // Encoding: 0x40400090
    // Test aarch32_UMAAL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, RdHi=0, Rn=0, RdLo=0, Rm=0
    let encoding: u32 = 0x40400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_5_poweroftwo_90_50400090() {
    // Encoding: 0x50400090
    // Test aarch32_UMAAL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, cond=5, RdLo=0, Rn=0
    let encoding: u32 = 0x50400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_6_poweroftwo_90_60400090() {
    // Encoding: 0x60400090
    // Test aarch32_UMAAL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, RdHi=0, cond=6, Rn=0
    let encoding: u32 = 0x60400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_7_poweroftwo_90_70400090() {
    // Encoding: 0x70400090
    // Test aarch32_UMAAL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rm=0, Rn=0, RdLo=0, RdHi=0
    let encoding: u32 = 0x70400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_8_poweroftwo_90_80400090() {
    // Encoding: 0x80400090
    // Test aarch32_UMAAL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, Rn=0, RdLo=0, cond=8, Rm=0
    let encoding: u32 = 0x80400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_9_poweroftwo_90_90400090() {
    // Encoding: 0x90400090
    // Test aarch32_UMAAL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, RdLo=0, RdHi=0, Rm=0
    let encoding: u32 = 0x90400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_10_poweroftwo_90_a0400090() {
    // Encoding: 0xA0400090
    // Test aarch32_UMAAL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rm=0, RdHi=0, RdLo=0, Rn=0
    let encoding: u32 = 0xA0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_11_poweroftwo_90_b0400090() {
    // Encoding: 0xB0400090
    // Test aarch32_UMAAL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=11, RdLo=0, Rn=0, Rm=0
    let encoding: u32 = 0xB0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_12_poweroftwo_90_c0400090() {
    // Encoding: 0xC0400090
    // Test aarch32_UMAAL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=12, RdHi=0, RdLo=0
    let encoding: u32 = 0xC0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_13_poweroftwo_90_d0400090() {
    // Encoding: 0xD0400090
    // Test aarch32_UMAAL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, RdLo=0, RdHi=0, Rn=0, Rm=0
    let encoding: u32 = 0xD0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_14_poweroftwo_90_e0400090() {
    // Encoding: 0xE0400090
    // Test aarch32_UMAAL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, RdHi=0, cond=14, Rm=0
    let encoding: u32 = 0xE0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_umaal_a1_a_field_cond_15_max_90_f0400090() {
    // Encoding: 0xF0400090
    // Test aarch32_UMAAL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, RdHi=0, Rm=0, Rn=0, RdLo=0
    let encoding: u32 = 0xF0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umaal_a1_a_field_rdhi_0_min_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, cond=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umaal_a1_a_field_rdhi_1_poweroftwo_90_00410090() {
    // Encoding: 0x00410090
    // Test aarch32_UMAAL_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, Rn=0, RdHi=1, cond=0
    let encoding: u32 = 0x00410090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umaal_a1_a_field_rdhi_7_poweroftwominusone_90_00470090() {
    // Encoding: 0x00470090
    // Test aarch32_UMAAL_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdHi=7, cond=0, Rm=0, RdLo=0, Rn=0
    let encoding: u32 = 0x00470090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umaal_a1_a_field_rdhi_15_max_90_004f0090() {
    // Encoding: 0x004F0090
    // Test aarch32_UMAAL_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: cond=0, RdHi=15, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x004F0090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umaal_a1_a_field_rdlo_0_min_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, cond=0, RdHi=0, Rm=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umaal_a1_a_field_rdlo_1_poweroftwo_90_00401090() {
    // Encoding: 0x00401090
    // Test aarch32_UMAAL_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, RdHi=0, RdLo=1, Rn=0, Rm=0
    let encoding: u32 = 0x00401090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umaal_a1_a_field_rdlo_7_poweroftwominusone_90_00407090() {
    // Encoding: 0x00407090
    // Test aarch32_UMAAL_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdLo=7, cond=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x00407090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umaal_a1_a_field_rdlo_15_max_90_0040f090() {
    // Encoding: 0x0040F090
    // Test aarch32_UMAAL_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, RdLo=15, RdHi=0, Rn=0, cond=0
    let encoding: u32 = 0x0040F090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umaal_a1_a_field_rm_0_min_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rm=0, RdLo=0, RdHi=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umaal_a1_a_field_rm_1_poweroftwo_90_00400190() {
    // Encoding: 0x00400190
    // Test aarch32_UMAAL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=0, Rn=0, RdLo=0, Rm=1
    let encoding: u32 = 0x00400190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umaal_a1_a_field_rn_0_min_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, RdHi=0, Rn=0, RdLo=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umaal_a1_a_field_rn_1_poweroftwo_90_00400091() {
    // Encoding: 0x00400091
    // Test aarch32_UMAAL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, RdHi=0, Rm=0, Rn=1, RdLo=0
    let encoding: u32 = 0x00400091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_umaal_a1_a_combo_0_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A field combination: cond=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_umaal_a1_a_special_cond_0_condition_eq_144_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, RdLo=0, RdHi=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_umaal_a1_a_special_cond_1_condition_ne_144_10400090() {
    // Encoding: 0x10400090
    // Test aarch32_UMAAL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, cond=1, Rn=0
    let encoding: u32 = 0x10400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_umaal_a1_a_special_cond_2_condition_cs_hs_144_20400090() {
    // Encoding: 0x20400090
    // Test aarch32_UMAAL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rm=0, cond=2, Rn=0
    let encoding: u32 = 0x20400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_umaal_a1_a_special_cond_3_condition_cc_lo_144_30400090() {
    // Encoding: 0x30400090
    // Test aarch32_UMAAL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rm=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x30400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_umaal_a1_a_special_cond_4_condition_mi_144_40400090() {
    // Encoding: 0x40400090
    // Test aarch32_UMAAL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, cond=4, RdLo=0, Rm=0
    let encoding: u32 = 0x40400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_umaal_a1_a_special_cond_5_condition_pl_144_50400090() {
    // Encoding: 0x50400090
    // Test aarch32_UMAAL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=5, Rm=0, RdHi=0
    let encoding: u32 = 0x50400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_umaal_a1_a_special_cond_6_condition_vs_144_60400090() {
    // Encoding: 0x60400090
    // Test aarch32_UMAAL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: RdLo=0, cond=6, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x60400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_umaal_a1_a_special_cond_7_condition_vc_144_70400090() {
    // Encoding: 0x70400090
    // Test aarch32_UMAAL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rm=0, RdHi=0, cond=7, RdLo=0
    let encoding: u32 = 0x70400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_umaal_a1_a_special_cond_8_condition_hi_144_80400090() {
    // Encoding: 0x80400090
    // Test aarch32_UMAAL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, cond=8, Rn=0, RdLo=0
    let encoding: u32 = 0x80400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_umaal_a1_a_special_cond_9_condition_ls_144_90400090() {
    // Encoding: 0x90400090
    // Test aarch32_UMAAL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, cond=9, Rn=0, RdLo=0
    let encoding: u32 = 0x90400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_umaal_a1_a_special_cond_10_condition_ge_144_a0400090() {
    // Encoding: 0xA0400090
    // Test aarch32_UMAAL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, RdHi=0, Rn=0, Rm=0, RdLo=0
    let encoding: u32 = 0xA0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_umaal_a1_a_special_cond_11_condition_lt_144_b0400090() {
    // Encoding: 0xB0400090
    // Test aarch32_UMAAL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rm=0, Rn=0, RdHi=0, RdLo=0
    let encoding: u32 = 0xB0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_umaal_a1_a_special_cond_12_condition_gt_144_c0400090() {
    // Encoding: 0xC0400090
    // Test aarch32_UMAAL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, RdLo=0, Rm=0, Rn=0, RdHi=0
    let encoding: u32 = 0xC0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_umaal_a1_a_special_cond_13_condition_le_144_d0400090() {
    // Encoding: 0xD0400090
    // Test aarch32_UMAAL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: RdHi=0, cond=13, Rn=0, Rm=0, RdLo=0
    let encoding: u32 = 0xD0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_umaal_a1_a_special_cond_14_condition_al_144_e0400090() {
    // Encoding: 0xE0400090
    // Test aarch32_UMAAL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, RdHi=0, Rn=0, cond=14
    let encoding: u32 = 0xE0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_umaal_a1_a_special_cond_15_condition_nv_144_f0400090() {
    // Encoding: 0xF0400090
    // Test aarch32_UMAAL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, cond=15, Rm=0, RdHi=0
    let encoding: u32 = 0xF0400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_a1_a_invalid_0_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: RdHi=0, Rn=0, RdLo=0, cond=0, Rm=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_a1_a_invalid_1_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: RdLo=0, cond=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_a1_a_invalid_2_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: Rn=0, RdLo=0, Rm=0, cond=0, RdHi=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_a1_a_invalid_3_90_00400090() {
    // Encoding: 0x00400090
    // Test aarch32_UMAAL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: RdLo=0, cond=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x00400090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umaal_t1_a_field_rn_0_min_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umaal_t1_a_field_rn_1_poweroftwo_60_fbe10060() {
    // Thumb encoding (32): 0xFBE10060
    // Test aarch32_UMAAL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, RdHi=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE10060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umaal_t1_a_field_rdlo_0_min_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umaal_t1_a_field_rdlo_1_poweroftwo_60_fbe01060() {
    // Thumb encoding (32): 0xFBE01060
    // Test aarch32_UMAAL_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdHi=0, RdLo=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE01060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umaal_t1_a_field_rdlo_7_poweroftwominusone_60_fbe07060() {
    // Thumb encoding (32): 0xFBE07060
    // Test aarch32_UMAAL_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: RdLo=7, Rn=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE07060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umaal_t1_a_field_rdlo_15_max_60_fbe0f060() {
    // Thumb encoding (32): 0xFBE0F060
    // Test aarch32_UMAAL_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, RdHi=0, Rm=0, RdLo=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE0F060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umaal_t1_a_field_rdhi_0_min_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, Rn=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umaal_t1_a_field_rdhi_1_poweroftwo_60_fbe00160() {
    // Thumb encoding (32): 0xFBE00160
    // Test aarch32_UMAAL_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, RdHi=1, Rn=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00160;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umaal_t1_a_field_rdhi_7_poweroftwominusone_60_fbe00760() {
    // Thumb encoding (32): 0xFBE00760
    // Test aarch32_UMAAL_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=0, RdHi=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00760;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umaal_t1_a_field_rdhi_15_max_60_fbe00f60() {
    // Thumb encoding (32): 0xFBE00F60
    // Test aarch32_UMAAL_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=15, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00F60;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umaal_t1_a_field_rm_0_min_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umaal_t1_a_field_rm_1_poweroftwo_60_fbe00061() {
    // Thumb encoding (32): 0xFBE00061
    // Test aarch32_UMAAL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, RdHi=0, RdLo=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00061;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_umaal_t1_a_combo_0_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A field combination: Rn=0, RdLo=0, RdHi=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, RdLo=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_t1_a_invalid_0_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: RdHi=0, Rm=0, RdLo=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_t1_a_invalid_1_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, RdLo=0, Rm=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_t1_a_invalid_2_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umaal_t1_a_invalid_3_60_fbe00060() {
    // Thumb encoding (32): 0xFBE00060
    // Test aarch32_UMAAL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdLo=0, Rn=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00060;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_umaal_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_umaal_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_umaal_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_umaal_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_umaal_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_UMAAL_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_umaal_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_ERET_AS Tests
// ============================================================================

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_eret_a1_a_field_cond_0_min_60_01600060() {
    // Encoding: 0x01600060
    // Test aarch32_ERET_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x01600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_eret_a1_a_field_cond_1_poweroftwo_60_11600060() {
    // Encoding: 0x11600060
    // Test aarch32_ERET_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x11600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_eret_a1_a_field_cond_2_poweroftwo_60_21600060() {
    // Encoding: 0x21600060
    // Test aarch32_ERET_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x21600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_eret_a1_a_field_cond_3_poweroftwo_60_31600060() {
    // Encoding: 0x31600060
    // Test aarch32_ERET_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x31600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_eret_a1_a_field_cond_4_poweroftwo_60_41600060() {
    // Encoding: 0x41600060
    // Test aarch32_ERET_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x41600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_eret_a1_a_field_cond_5_poweroftwo_60_51600060() {
    // Encoding: 0x51600060
    // Test aarch32_ERET_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x51600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_eret_a1_a_field_cond_6_poweroftwo_60_61600060() {
    // Encoding: 0x61600060
    // Test aarch32_ERET_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x61600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_eret_a1_a_field_cond_7_poweroftwo_60_71600060() {
    // Encoding: 0x71600060
    // Test aarch32_ERET_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x71600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_eret_a1_a_field_cond_8_poweroftwo_60_81600060() {
    // Encoding: 0x81600060
    // Test aarch32_ERET_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x81600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_eret_a1_a_field_cond_9_poweroftwo_60_91600060() {
    // Encoding: 0x91600060
    // Test aarch32_ERET_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x91600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_eret_a1_a_field_cond_10_poweroftwo_60_a1600060() {
    // Encoding: 0xA1600060
    // Test aarch32_ERET_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_eret_a1_a_field_cond_11_poweroftwo_60_b1600060() {
    // Encoding: 0xB1600060
    // Test aarch32_ERET_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_eret_a1_a_field_cond_12_poweroftwo_60_c1600060() {
    // Encoding: 0xC1600060
    // Test aarch32_ERET_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_eret_a1_a_field_cond_13_poweroftwo_60_d1600060() {
    // Encoding: 0xD1600060
    // Test aarch32_ERET_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_eret_a1_a_field_cond_14_poweroftwo_60_e1600060() {
    // Encoding: 0xE1600060
    // Test aarch32_ERET_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_eret_a1_a_field_cond_15_max_60_f1600060() {
    // Encoding: 0xF1600060
    // Test aarch32_ERET_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_eret_a1_a_combo_0_60_01600060() {
    // Encoding: 0x01600060
    // Test aarch32_ERET_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x01600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_eret_a1_a_special_cond_0_condition_eq_96_01600060() {
    // Encoding: 0x01600060
    // Test aarch32_ERET_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x01600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_eret_a1_a_special_cond_1_condition_ne_96_11600060() {
    // Encoding: 0x11600060
    // Test aarch32_ERET_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x11600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_eret_a1_a_special_cond_2_condition_cs_hs_96_21600060() {
    // Encoding: 0x21600060
    // Test aarch32_ERET_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x21600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_eret_a1_a_special_cond_3_condition_cc_lo_96_31600060() {
    // Encoding: 0x31600060
    // Test aarch32_ERET_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x31600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_eret_a1_a_special_cond_4_condition_mi_96_41600060() {
    // Encoding: 0x41600060
    // Test aarch32_ERET_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x41600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_eret_a1_a_special_cond_5_condition_pl_96_51600060() {
    // Encoding: 0x51600060
    // Test aarch32_ERET_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x51600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_eret_a1_a_special_cond_6_condition_vs_96_61600060() {
    // Encoding: 0x61600060
    // Test aarch32_ERET_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x61600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_eret_a1_a_special_cond_7_condition_vc_96_71600060() {
    // Encoding: 0x71600060
    // Test aarch32_ERET_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x71600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_eret_a1_a_special_cond_8_condition_hi_96_81600060() {
    // Encoding: 0x81600060
    // Test aarch32_ERET_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x81600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_eret_a1_a_special_cond_9_condition_ls_96_91600060() {
    // Encoding: 0x91600060
    // Test aarch32_ERET_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x91600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_eret_a1_a_special_cond_10_condition_ge_96_a1600060() {
    // Encoding: 0xA1600060
    // Test aarch32_ERET_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_eret_a1_a_special_cond_11_condition_lt_96_b1600060() {
    // Encoding: 0xB1600060
    // Test aarch32_ERET_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_eret_a1_a_special_cond_12_condition_gt_96_c1600060() {
    // Encoding: 0xC1600060
    // Test aarch32_ERET_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_eret_a1_a_special_cond_13_condition_le_96_d1600060() {
    // Encoding: 0xD1600060
    // Test aarch32_ERET_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_eret_a1_a_special_cond_14_condition_al_96_e1600060() {
    // Encoding: 0xE1600060
    // Test aarch32_ERET_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_eret_a1_a_special_cond_15_condition_nv_96_f1600060() {
    // Encoding: 0xF1600060
    // Test aarch32_ERET_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF1600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ERET_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_eret_t1_a_basic_encoding_f3de8000() {
    // Thumb encoding (32): 0xF3DE8000
    // Test aarch32_ERET_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3DE8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ERET_T1_A
/// ASL: `Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eret_t1_a_invalid_0_8000_f3de8000() {
    // Thumb encoding (32): 0xF3DE8000
    // Test aarch32_ERET_T1_A invalid encoding: Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3DE8000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ERET_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eret_t1_a_invalid_1_8000_f3de8000() {
    // Thumb encoding (32): 0xF3DE8000
    // Test aarch32_ERET_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3DE8000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ERET_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eret_a1_a_exception_0_01600060() {
    // Test aarch32_ERET_A1_A exception: Unpredictable
    // Encoding: 0x01600060
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x01600060;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_ERET_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eret_t1_a_exception_0_f3de8000() {
    // Test aarch32_ERET_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3DE8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SSBB_A Tests
// ============================================================================

/// Provenance: aarch32_SSBB_A1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_ssbb_a1_a_basic_encoding_f5700040() {
    // Encoding: 0xF5700040
    // Test aarch32_SSBB_A1_A basic encoding
    // ISET: A32
    let encoding: u32 = 0xF5700040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SSBB_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_ssbb_t1_a_basic_encoding_f3b08040() {
    // Thumb encoding (32): 0xF3B08040
    // Test aarch32_SSBB_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SSBB_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssbb_t1_a_invalid_0_8040_f3b08040() {
    // Thumb encoding (32): 0xF3B08040
    // Test aarch32_SSBB_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SSBB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssbb_t1_a_invalid_1_8040_f3b08040() {
    // Thumb encoding (32): 0xF3B08040
    // Test aarch32_SSBB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3B08040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SHA1P_A Tests
// ============================================================================

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1p_a1_a_field_d_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Vd=0, D=0, N=0, Q=0, M=0, Vm=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1p_a1_a_field_d_1_max_c00_f2500c00() {
    // Encoding: 0xF2500C00
    // Test aarch32_SHA1P_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, Vd=0, Q=0, N=0, Vm=0, M=0, D=1
    let encoding: u32 = 0xF2500C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1p_a1_a_field_vn_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, N=0, D=0, Vn=0, Vd=0, Q=0, M=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1p_a1_a_field_vn_1_poweroftwo_c00_f2110c00() {
    // Encoding: 0xF2110C00
    // Test aarch32_SHA1P_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, D=0, Vn=1, Vd=0, Q=0, M=0, Vm=0
    let encoding: u32 = 0xF2110C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1p_a1_a_field_vd_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vd=0, M=0, N=0, Vm=0, D=0, Vn=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1p_a1_a_field_vd_1_poweroftwo_c00_f2101c00() {
    // Encoding: 0xF2101C00
    // Test aarch32_SHA1P_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: D=0, Vm=0, Vd=1, Q=0, Vn=0, N=0, M=0
    let encoding: u32 = 0xF2101C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1p_a1_a_field_n_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Q=0, Vm=0, D=0, M=0, Vn=0, N=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1p_a1_a_field_n_1_max_c00_f2100c80() {
    // Encoding: 0xF2100C80
    // Test aarch32_SHA1P_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Q=0, Vn=0, D=0, M=0, Vd=0, Vm=0, N=1
    let encoding: u32 = 0xF2100C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1p_a1_a_field_q_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vm=0, N=0, Vd=0, Vn=0, Q=0, M=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1p_a1_a_field_q_1_max_c00_f2100c40() {
    // Encoding: 0xF2100C40
    // Test aarch32_SHA1P_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, Vm=0, Vd=0, D=0, M=0, Q=1, N=0
    let encoding: u32 = 0xF2100C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1p_a1_a_field_m_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Vd=0, D=0, M=0, N=0, Q=0, Vm=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1p_a1_a_field_m_1_max_c00_f2100c20() {
    // Encoding: 0xF2100C20
    // Test aarch32_SHA1P_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, D=0, Q=0, N=0, M=1, Vd=0, Vm=0
    let encoding: u32 = 0xF2100C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1p_a1_a_field_vm_0_min_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, N=0, Q=0, M=0, Vn=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1p_a1_a_field_vm_1_poweroftwo_c00_f2100c01() {
    // Encoding: 0xF2100C01
    // Test aarch32_SHA1P_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Vn=0, M=0, D=0, Q=0, Vm=1, Vd=0
    let encoding: u32 = 0xF2100C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1p_a1_a_combo_0_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vm=0, D=0, Vn=0, Vd=0, N=0, M=0, Q=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1p_a1_a_special_q_0_size_variant_0_3072_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vd=0, D=0, N=0, Q=0, M=0, Vm=0, Vn=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1p_a1_a_special_q_1_size_variant_1_3072_f2100c40() {
    // Encoding: 0xF2100C40
    // Test aarch32_SHA1P_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: N=0, D=0, Vm=0, M=0, Vd=0, Vn=0, Q=1
    let encoding: u32 = 0xF2100C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_a1_a_invalid_0_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: A32
    // Fields: M=0, Vn=0, N=0, Q=0, Vm=0, Vd=0, D=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_a1_a_invalid_1_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Vn=0, Vd=0, D=0, N=0, Q=0, Vm=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_a1_a_invalid_2_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, N=0, Vm=0, Vn=0, Vd=0, Q=0, M=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_a1_a_invalid_3_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, N=0, Vm=0, M=0, Q=0, Vd=0, D=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_a1_a_invalid_4_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vm=0, N=0, M=0, Vn=0, Q=0, D=0, Vd=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_a1_a_invalid_5_c00_f2100c00() {
    // Encoding: 0xF2100C00
    // Test aarch32_SHA1P_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, Vm=0, D=0, Vd=0, Vn=0, N=0, M=0
    let encoding: u32 = 0xF2100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1p_t1_a_field_d_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vn=0, Vd=0, Vm=0, D=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1p_t1_a_field_d_1_max_c00_ef500c00() {
    // Thumb encoding (32): 0xEF500C00
    // Test aarch32_SHA1P_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: D=1, N=0, Q=0, Vn=0, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF500C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1p_t1_a_field_vn_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, Vd=0, Vn=0, N=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1p_t1_a_field_vn_1_poweroftwo_c00_ef110c00() {
    // Thumb encoding (32): 0xEF110C00
    // Test aarch32_SHA1P_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, Q=0, M=0, D=0, Vm=0, N=0, Vn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF110C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1p_t1_a_field_vd_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: N=0, M=0, Vm=0, Q=0, Vd=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1p_t1_a_field_vd_1_poweroftwo_c00_ef101c00() {
    // Thumb encoding (32): 0xEF101C00
    // Test aarch32_SHA1P_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, Vd=1, Q=0, M=0, D=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF101C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1p_t1_a_field_n_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, M=0, Vm=0, D=0, Vd=0, Q=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1p_t1_a_field_n_1_max_c00_ef100c80() {
    // Thumb encoding (32): 0xEF100C80
    // Test aarch32_SHA1P_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, D=0, Vd=0, N=1, Q=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1p_t1_a_field_q_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Q=0, N=0, M=0, D=0, Vm=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1p_t1_a_field_q_1_max_c00_ef100c40() {
    // Thumb encoding (32): 0xEF100C40
    // Test aarch32_SHA1P_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: M=0, D=0, Vm=0, Vd=0, N=0, Q=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1p_t1_a_field_m_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vm=0, Q=0, Vn=0, Vd=0, N=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1p_t1_a_field_m_1_max_c00_ef100c20() {
    // Thumb encoding (32): 0xEF100C20
    // Test aarch32_SHA1P_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Vn=0, Vd=0, M=1, Vm=0, Q=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1p_t1_a_field_vm_0_min_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, Vn=0, Vm=0, N=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1p_t1_a_field_vm_1_poweroftwo_c00_ef100c01() {
    // Thumb encoding (32): 0xEF100C01
    // Test aarch32_SHA1P_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, N=0, Vm=1, Vn=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1p_t1_a_combo_0_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vd=0, N=0, Vm=0, M=0, Vn=0, D=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1p_t1_a_special_q_0_size_variant_0_3072_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, N=0, Vn=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1p_t1_a_special_q_1_size_variant_1_3072_ef100c40() {
    // Thumb encoding (32): 0xEF100C40
    // Test aarch32_SHA1P_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vn=0, M=0, Q=1, D=0, Vm=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1p_t1_a_invalid_0_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: N=0, Vn=0, D=0, Q=0, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1p_t1_a_invalid_1_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Q=0, Vm=0, Vn=0, Vd=0, D=0, M=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_t1_a_invalid_2_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: T32
    // Fields: Vm=0, Vd=0, Q=0, N=0, M=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_t1_a_invalid_3_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, Vm=0, D=0, Q=0, N=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_t1_a_invalid_4_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vm=0, Vd=0, Vn=0, N=0, Q=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_t1_a_invalid_5_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: N=0, Q=0, M=0, Vm=0, D=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_t1_a_invalid_6_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: M=0, Vm=0, Vd=0, Q=0, D=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1P_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1p_t1_a_invalid_7_c00_ef100c00() {
    // Thumb encoding (32): 0xEF100C00
    // Test aarch32_SHA1P_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, D=0, N=0, Q=0, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0x92401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0x92403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0x92407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // Encoding: 0x92400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // Encoding: 0x9240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x12001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x12003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_sha1p_a1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // Encoding: 0x12000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_0_0_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_0_ff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_0_aaaaaaaa_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_0_55555555_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_0_ffffffff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_1_0_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_1_ff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_1_aaaaaaaa_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAA, "R0 should be 0x000000AA");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_1_55555555_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55, "R0 should be 0x00000055");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_1_ffffffff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_2_0_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_2_ff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_2_aaaaaaaa_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_2_55555555_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_2_ffffffff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_3_0_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_3_ff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_3_aaaaaaaa_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA000000, "R0 should be 0x0A000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_3_55555555_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5000000, "R0 should be 0x05000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_3_ffffffff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_4_0_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_4_ff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_4_aaaaaaaa_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_4_55555555_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1P_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1p_a1_a_a32_logical_imm_4_ffffffff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_USAD8_A Tests
// ============================================================================

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_0_min_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_1_poweroftwo_f010_1780f010() {
    // Encoding: 0x1780F010
    // Test aarch32_USAD8_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=1
    let encoding: u32 = 0x1780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_2_poweroftwo_f010_2780f010() {
    // Encoding: 0x2780F010
    // Test aarch32_USAD8_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=2, Rm=0, Rn=0
    let encoding: u32 = 0x2780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_3_poweroftwo_f010_3780f010() {
    // Encoding: 0x3780F010
    // Test aarch32_USAD8_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=3
    let encoding: u32 = 0x3780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_4_poweroftwo_f010_4780f010() {
    // Encoding: 0x4780F010
    // Test aarch32_USAD8_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=4
    let encoding: u32 = 0x4780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_5_poweroftwo_f010_5780f010() {
    // Encoding: 0x5780F010
    // Test aarch32_USAD8_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rd=0, Rn=0
    let encoding: u32 = 0x5780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_6_poweroftwo_f010_6780f010() {
    // Encoding: 0x6780F010
    // Test aarch32_USAD8_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x6780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_7_poweroftwo_f010_7780f010() {
    // Encoding: 0x7780F010
    // Test aarch32_USAD8_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x7780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_8_poweroftwo_f010_8780f010() {
    // Encoding: 0x8780F010
    // Test aarch32_USAD8_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=8, Rn=0
    let encoding: u32 = 0x8780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_9_poweroftwo_f010_9780f010() {
    // Encoding: 0x9780F010
    // Test aarch32_USAD8_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=9, Rn=0
    let encoding: u32 = 0x9780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_10_poweroftwo_f010_a780f010() {
    // Encoding: 0xA780F010
    // Test aarch32_USAD8_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0xA780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_11_poweroftwo_f010_b780f010() {
    // Encoding: 0xB780F010
    // Test aarch32_USAD8_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xB780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_12_poweroftwo_f010_c780f010() {
    // Encoding: 0xC780F010
    // Test aarch32_USAD8_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0xC780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_13_poweroftwo_f010_d780f010() {
    // Encoding: 0xD780F010
    // Test aarch32_USAD8_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xD780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_14_poweroftwo_f010_e780f010() {
    // Encoding: 0xE780F010
    // Test aarch32_USAD8_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=14, Rn=0, Rm=0
    let encoding: u32 = 0xE780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_usad8_a1_a_field_cond_15_max_f010_f780f010() {
    // Encoding: 0xF780F010
    // Test aarch32_USAD8_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15, Rn=0
    let encoding: u32 = 0xF780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usad8_a1_a_field_rd_0_min_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usad8_a1_a_field_rd_1_poweroftwo_f010_0781f010() {
    // Encoding: 0x0781F010
    // Test aarch32_USAD8_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=1, cond=0, Rn=0
    let encoding: u32 = 0x0781F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usad8_a1_a_field_rm_0_min_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usad8_a1_a_field_rm_1_poweroftwo_f010_0780f110() {
    // Encoding: 0x0780F110
    // Test aarch32_USAD8_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x0780F110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usad8_a1_a_field_rn_0_min_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usad8_a1_a_field_rn_1_poweroftwo_f010_0780f011() {
    // Encoding: 0x0780F011
    // Test aarch32_USAD8_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=1, Rd=0, cond=0
    let encoding: u32 = 0x0780F011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_usad8_a1_a_combo_0_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A field combination: cond=0, Rd=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_usad8_a1_a_special_cond_0_condition_eq_61456_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_usad8_a1_a_special_cond_1_condition_ne_61456_1780f010() {
    // Encoding: 0x1780F010
    // Test aarch32_USAD8_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x1780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_usad8_a1_a_special_cond_2_condition_cs_hs_61456_2780f010() {
    // Encoding: 0x2780F010
    // Test aarch32_USAD8_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, cond=2, Rd=0, Rn=0
    let encoding: u32 = 0x2780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_usad8_a1_a_special_cond_3_condition_cc_lo_61456_3780f010() {
    // Encoding: 0x3780F010
    // Test aarch32_USAD8_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=3, Rn=0
    let encoding: u32 = 0x3780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_usad8_a1_a_special_cond_4_condition_mi_61456_4780f010() {
    // Encoding: 0x4780F010
    // Test aarch32_USAD8_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=4
    let encoding: u32 = 0x4780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_usad8_a1_a_special_cond_5_condition_pl_61456_5780f010() {
    // Encoding: 0x5780F010
    // Test aarch32_USAD8_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rn=0, Rd=0
    let encoding: u32 = 0x5780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_usad8_a1_a_special_cond_6_condition_vs_61456_6780f010() {
    // Encoding: 0x6780F010
    // Test aarch32_USAD8_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=6
    let encoding: u32 = 0x6780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_usad8_a1_a_special_cond_7_condition_vc_61456_7780f010() {
    // Encoding: 0x7780F010
    // Test aarch32_USAD8_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x7780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_usad8_a1_a_special_cond_8_condition_hi_61456_8780f010() {
    // Encoding: 0x8780F010
    // Test aarch32_USAD8_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, cond=8, Rn=0, Rm=0
    let encoding: u32 = 0x8780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_usad8_a1_a_special_cond_9_condition_ls_61456_9780f010() {
    // Encoding: 0x9780F010
    // Test aarch32_USAD8_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=9, Rm=0
    let encoding: u32 = 0x9780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_usad8_a1_a_special_cond_10_condition_ge_61456_a780f010() {
    // Encoding: 0xA780F010
    // Test aarch32_USAD8_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rn=0, Rm=0
    let encoding: u32 = 0xA780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_usad8_a1_a_special_cond_11_condition_lt_61456_b780f010() {
    // Encoding: 0xB780F010
    // Test aarch32_USAD8_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=11, Rm=0
    let encoding: u32 = 0xB780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_usad8_a1_a_special_cond_12_condition_gt_61456_c780f010() {
    // Encoding: 0xC780F010
    // Test aarch32_USAD8_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=12
    let encoding: u32 = 0xC780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_usad8_a1_a_special_cond_13_condition_le_61456_d780f010() {
    // Encoding: 0xD780F010
    // Test aarch32_USAD8_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rn=0, Rm=0
    let encoding: u32 = 0xD780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_usad8_a1_a_special_cond_14_condition_al_61456_e780f010() {
    // Encoding: 0xE780F010
    // Test aarch32_USAD8_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=14, Rd=0
    let encoding: u32 = 0xE780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_usad8_a1_a_special_cond_15_condition_nv_61456_f780f010() {
    // Encoding: 0xF780F010
    // Test aarch32_USAD8_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rd=0, Rm=0
    let encoding: u32 = 0xF780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usad8_a1_a_invalid_0_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USAD8_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usad8_a1_a_invalid_1_f010_0780f010() {
    // Encoding: 0x0780F010
    // Test aarch32_USAD8_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x0780F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usad8_t1_a_field_rn_0_min_f000_fb70f000() {
    // Thumb encoding (32): 0xFB70F000
    // Test aarch32_USAD8_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usad8_t1_a_field_rn_1_poweroftwo_f000_fb71f000() {
    // Thumb encoding (32): 0xFB71F000
    // Test aarch32_USAD8_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB71F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usad8_t1_a_field_rd_0_min_f000_fb70f000() {
    // Thumb encoding (32): 0xFB70F000
    // Test aarch32_USAD8_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usad8_t1_a_field_rd_1_poweroftwo_f000_fb70f100() {
    // Thumb encoding (32): 0xFB70F100
    // Test aarch32_USAD8_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usad8_t1_a_field_rm_0_min_f000_fb70f000() {
    // Thumb encoding (32): 0xFB70F000
    // Test aarch32_USAD8_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usad8_t1_a_field_rm_1_poweroftwo_f000_fb70f001() {
    // Thumb encoding (32): 0xFB70F001
    // Test aarch32_USAD8_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_usad8_t1_a_combo_0_f000_fb70f000() {
    // Thumb encoding (32): 0xFB70F000
    // Test aarch32_USAD8_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usad8_t1_a_invalid_0_f000_fb70f000() {
    // Thumb encoding (32): 0xFB70F000
    // Test aarch32_USAD8_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_USAD8_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usad8_t1_a_invalid_1_f000_fb70f000() {
    // Thumb encoding (32): 0xFB70F000
    // Test aarch32_USAD8_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB70F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SHA1SU1_A Tests
// ============================================================================

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su1_a1_a_field_d_0_min_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, size=0, M=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su1_a1_a_field_d_1_max_380_f3f20380() {
    // Encoding: 0xF3F20380
    // Test aarch32_SHA1SU1_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: D=1, Vd=0, size=0, M=0, Vm=0
    let encoding: u32 = 0xF3F20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1su1_a1_a_field_size_0_min_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A field size = 0 (Min)
    // ISET: A32
    // Fields: size=0, D=0, Vm=0, Vd=0, M=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1su1_a1_a_field_size_1_poweroftwo_380_f3b60380() {
    // Encoding: 0xF3B60380
    // Test aarch32_SHA1SU1_A1_A field size = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, size=1, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3B60380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_sha1su1_a1_a_field_size_2_poweroftwo_380_f3ba0380() {
    // Encoding: 0xF3BA0380
    // Test aarch32_SHA1SU1_A1_A field size = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, D=0, size=2, M=0, Vm=0
    let encoding: u32 = 0xF3BA0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_sha1su1_a1_a_field_size_3_max_380_f3be0380() {
    // Encoding: 0xF3BE0380
    // Test aarch32_SHA1SU1_A1_A field size = 3 (Max)
    // ISET: A32
    // Fields: size=3, Vd=0, M=0, Vm=0, D=0
    let encoding: u32 = 0xF3BE0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su1_a1_a_field_vd_0_min_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=0, D=0, size=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su1_a1_a_field_vd_1_poweroftwo_380_f3b21380() {
    // Encoding: 0xF3B21380
    // Test aarch32_SHA1SU1_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: size=0, Vm=0, D=0, M=0, Vd=1
    let encoding: u32 = 0xF3B21380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su1_a1_a_field_m_0_min_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, size=0, Vd=0, M=0, D=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su1_a1_a_field_m_1_max_380_f3b203a0() {
    // Encoding: 0xF3B203A0
    // Test aarch32_SHA1SU1_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: size=0, Vm=0, D=0, M=1, Vd=0
    let encoding: u32 = 0xF3B203A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su1_a1_a_field_vm_0_min_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su1_a1_a_field_vm_1_poweroftwo_380_f3b20381() {
    // Encoding: 0xF3B20381
    // Test aarch32_SHA1SU1_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, D=0, M=0, size=0, Vd=0
    let encoding: u32 = 0xF3B20381;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1su1_a1_a_combo_0_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: A32
    // Fields: D=0, size=0, Vm=0, Vd=0, M=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1su1_a1_a_special_size_0_size_variant_0_896_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A special value size = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, size=0, Vd=0, D=0, M=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1su1_a1_a_special_size_1_size_variant_1_896_f3b60380() {
    // Encoding: 0xF3B60380
    // Test aarch32_SHA1SU1_A1_A special value size = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vd=0, size=1, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3B60380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_sha1su1_a1_a_special_size_2_size_variant_2_896_f3ba0380() {
    // Encoding: 0xF3BA0380
    // Test aarch32_SHA1SU1_A1_A special value size = 2 (Size variant 2)
    // ISET: A32
    // Fields: M=0, size=2, Vd=0, Vm=0, D=0
    let encoding: u32 = 0xF3BA0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_sha1su1_a1_a_special_size_3_size_variant_3_896_f3be0380() {
    // Encoding: 0xF3BE0380
    // Test aarch32_SHA1SU1_A1_A special value size = 3 (Size variant 3)
    // ISET: A32
    // Fields: size=3, M=0, Vd=0, D=0, Vm=0
    let encoding: u32 = 0xF3BE0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_a1_a_invalid_0_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: A32
    // Fields: M=0, size=0, Vd=0, Vm=0, D=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_a1_a_invalid_1_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Vm=0, size=0, D=0, Vd=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_a1_a_invalid_2_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // ISET: A32
    // Fields: size=0, D=0, Vd=0, M=0, Vm=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_a1_a_invalid_3_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, size=0, Vd=0, Vm=0, M=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_a1_a_invalid_4_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: M=0, size=0, D=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_a1_a_invalid_5_380_f3b20380() {
    // Encoding: 0xF3B20380
    // Test aarch32_SHA1SU1_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, size=0, D=0
    let encoding: u32 = 0xF3B20380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su1_t1_a_field_d_0_min_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su1_t1_a_field_d_1_max_380_fff20380() {
    // Thumb encoding (32): 0xFFF20380
    // Test aarch32_SHA1SU1_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, size=0, Vd=0, D=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFF20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1su1_t1_a_field_size_0_min_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A field size = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, Vd=0, size=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1su1_t1_a_field_size_1_poweroftwo_380_ffb60380() {
    // Thumb encoding (32): 0xFFB60380
    // Test aarch32_SHA1SU1_T1_A field size = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=1, Vd=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB60380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch32_sha1su1_t1_a_field_size_2_poweroftwo_380_ffba0380() {
    // Thumb encoding (32): 0xFFBA0380
    // Test aarch32_SHA1SU1_T1_A field size = 2 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=0, Vd=0, D=0, size=2, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA0380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size 18 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch32_sha1su1_t1_a_field_size_3_max_380_ffbe0380() {
    // Thumb encoding (32): 0xFFBE0380
    // Test aarch32_SHA1SU1_T1_A field size = 3 (Max)
    // ISET: T32
    // Fields: size=3, M=0, Vm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE0380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su1_t1_a_field_vd_0_min_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: D=0, size=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su1_t1_a_field_vd_1_poweroftwo_380_ffb21380() {
    // Thumb encoding (32): 0xFFB21380
    // Test aarch32_SHA1SU1_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, size=0, M=0, Vm=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB21380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su1_t1_a_field_m_0_min_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, size=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su1_t1_a_field_m_1_max_380_ffb203a0() {
    // Thumb encoding (32): 0xFFB203A0
    // Test aarch32_SHA1SU1_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, size=0, M=1, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB203A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su1_t1_a_field_vm_0_min_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: size=0, Vd=0, Vm=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su1_t1_a_field_vm_1_poweroftwo_380_ffb20381() {
    // Thumb encoding (32): 0xFFB20381
    // Test aarch32_SHA1SU1_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vm=1, Vd=0, size=0, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20381;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1su1_t1_a_combo_0_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A field combination: D=0, size=0, Vd=0, M=0, Vm=0
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1su1_t1_a_special_size_0_size_variant_0_896_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A special value size = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, M=0, size=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1su1_t1_a_special_size_1_size_variant_1_896_ffb60380() {
    // Thumb encoding (32): 0xFFB60380
    // Test aarch32_SHA1SU1_T1_A special value size = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vd=0, size=1, M=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB60380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch32_sha1su1_t1_a_special_size_2_size_variant_2_896_ffba0380() {
    // Thumb encoding (32): 0xFFBA0380
    // Test aarch32_SHA1SU1_T1_A special value size = 2 (Size variant 2)
    // ISET: T32
    // Fields: size=2, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBA0380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch32_sha1su1_t1_a_special_size_3_size_variant_3_896_ffbe0380() {
    // Thumb encoding (32): 0xFFBE0380
    // Test aarch32_SHA1SU1_T1_A special value size = 3 (Size variant 3)
    // ISET: T32
    // Fields: M=0, D=0, size=3, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFBE0380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_0_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: D=0, M=0, Vd=0, Vm=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_1_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Vm=0, Vd=0, D=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_2_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: T32
    // Fields: Vd=0, D=0, Vm=0, M=0, size=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_3_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: size=0, Vd=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_4_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // ISET: T32
    // Fields: M=0, Vm=0, size=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_5_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, Vd=0, M=0, size=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_6_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: size=0, M=0, Vd=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU1_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su1_t1_a_invalid_7_380_ffb20380() {
    // Thumb encoding (32): 0xFFB20380
    // Test aarch32_SHA1SU1_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, size=0, Vm=0, Vd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFFB20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// lower 16 bits (32)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_32_0_f3b24780() {
    // Test MOVZ 32-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24780
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "W0 should be 0x00001234");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0x1234, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// lower 16 bits (64)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_64_0_f3b24780() {
    // Test MOVZ 64-bit: lower 16 bits (oracle)
    // Encoding: 0xF3B24780
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B24780;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1234, "X0 should be 0x0000000000001234");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shifted 16 bits (32)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_32_1_f3b77ba0() {
    // Test MOVZ 32-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B77BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B77BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xABCD0000, "W0 should be 0xABCD0000");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0xABCD, LSL #16`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 16 bits (64)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_64_1_f3b77ba0() {
    // Test MOVZ 64-bit: shifted 16 bits (oracle)
    // Encoding: 0xF3B77BA0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B77BA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xABCD0000,
        "X0 should be 0x00000000ABCD0000"
    );
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm16 (32)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_32_2_f3bfffe0() {
    // Test MOVZ 32-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0xFFFF, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm16 (64)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_64_2_f3bfffe0() {
    // Test MOVZ 64-bit: max imm16 (oracle)
    // Encoding: 0xF3BFFFE0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3BFFFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero imm16 (32)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_32_3_f3b20380() {
    // Test MOVZ 32-bit: zero imm16 (oracle)
    // Encoding: 0xF3B20380
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0x0000, LSL #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero imm16 (64)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_64_3_f3b20380() {
    // Test MOVZ 64-bit: zero imm16 (oracle)
    // Encoding: 0xF3B20380
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3B20380;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0x5678, LSL #32`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 32 bits (64)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_64_4_f3facf80() {
    // Test MOVZ 64-bit: shifted 32 bits (oracle)
    // Encoding: 0xF3FACF80
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FACF80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000567800000000");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOVZ X0, #0xDEAD, LSL #48`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shifted 48 bits (64)
#[test]
fn test_aarch32_sha1su1_a1_a_movz_oracle_64_5_f3fbd7a0() {
    // Test MOVZ 64-bit: shifted 48 bits (oracle)
    // Encoding: 0xF3FBD7A0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3FBD7A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xDEAD000000000000");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOV R0, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate
#[test]
fn test_aarch32_sha1su1_a1_a_a32_mov_imm_0_f3a0000a() {
    // Test A32 MOV: small immediate (oracle)
    // Encoding: 0xF3A0000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOV R0, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8
#[test]
fn test_aarch32_sha1su1_a1_a_a32_mov_imm_1_f3a000ff() {
    // Test A32 MOV: max imm8 (oracle)
    // Encoding: 0xF3A000FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOV R0, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2
#[test]
fn test_aarch32_sha1su1_a1_a_a32_mov_imm_2_f3a00180() {
    // Test A32 MOV: rotated by 2 (oracle)
    // Encoding: 0xF3A00180
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOV R0, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8
#[test]
fn test_aarch32_sha1su1_a1_a_a32_mov_imm_3_f3a0040f() {
    // Test A32 MOV: rotated by 8 (oracle)
    // Encoding: 0xF3A0040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A0040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA1SU1_A1_A
/// ASL: `MOV R0, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate
#[test]
fn test_aarch32_sha1su1_a1_a_a32_mov_imm_4_f3a00000() {
    // Test A32 MOV: zero immediate (oracle)
    // Encoding: 0xF3A00000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_SHA1SU0_A Tests
// ============================================================================

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su0_a1_a_field_d_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, N=0, D=0, Vn=0, Q=0, M=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su0_a1_a_field_d_1_max_c00_f2700c00() {
    // Encoding: 0xF2700C00
    // Test aarch32_SHA1SU0_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: M=0, Q=0, Vm=0, D=1, Vn=0, N=0, Vd=0
    let encoding: u32 = 0xF2700C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su0_a1_a_field_vn_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vn=0, M=0, Q=0, Vm=0, Vd=0, N=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su0_a1_a_field_vn_1_poweroftwo_c00_f2310c00() {
    // Encoding: 0xF2310C00
    // Test aarch32_SHA1SU0_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, N=0, Q=0, Vn=1, M=0
    let encoding: u32 = 0xF2310C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su0_a1_a_field_vd_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: N=0, Vm=0, Vn=0, D=0, Vd=0, Q=0, M=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su0_a1_a_field_vd_1_poweroftwo_c00_f2301c00() {
    // Encoding: 0xF2301C00
    // Test aarch32_SHA1SU0_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Q=0, Vm=0, D=0, Vd=1, N=0, Vn=0
    let encoding: u32 = 0xF2301C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su0_a1_a_field_n_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, D=0, N=0, Q=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su0_a1_a_field_n_1_max_c00_f2300c80() {
    // Encoding: 0xF2300C80
    // Test aarch32_SHA1SU0_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, N=1, Vn=0, M=0, D=0, Vd=0, Q=0
    let encoding: u32 = 0xF2300C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1su0_a1_a_field_q_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: N=0, M=0, Vn=0, Q=0, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1su0_a1_a_field_q_1_max_c00_f2300c40() {
    // Encoding: 0xF2300C40
    // Test aarch32_SHA1SU0_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, Vd=0, Vn=0, N=0, Q=1, M=0, D=0
    let encoding: u32 = 0xF2300C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su0_a1_a_field_m_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: N=0, Q=0, Vn=0, M=0, Vm=0, Vd=0, D=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su0_a1_a_field_m_1_max_c00_f2300c20() {
    // Encoding: 0xF2300C20
    // Test aarch32_SHA1SU0_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, M=1, N=0, Q=0, Vm=0, Vn=0, D=0
    let encoding: u32 = 0xF2300C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su0_a1_a_field_vm_0_min_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vm=0, M=0, Vd=0, D=0, Vn=0, N=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su0_a1_a_field_vm_1_poweroftwo_c00_f2300c01() {
    // Encoding: 0xF2300C01
    // Test aarch32_SHA1SU0_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=0, Q=0, Vm=1, N=0, Vn=0, M=0, D=0
    let encoding: u32 = 0xF2300C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1su0_a1_a_combo_0_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vm=0, N=0, D=0, Vn=0, Vd=0, Q=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1su0_a1_a_special_q_0_size_variant_0_3072_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: M=0, Vm=0, Vn=0, Q=0, D=0, Vd=0, N=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1su0_a1_a_special_q_1_size_variant_1_3072_f2300c40() {
    // Encoding: 0xF2300C40
    // Test aarch32_SHA1SU0_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Q=1, Vd=0, Vn=0, M=0, D=0, Vm=0, N=0
    let encoding: u32 = 0xF2300C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_a1_a_invalid_0_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: A32
    // Fields: M=0, D=0, N=0, Vn=0, Vm=0, Q=0, Vd=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_a1_a_invalid_1_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, M=0, Vm=0, Vn=0, D=0, N=0, Q=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_a1_a_invalid_2_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, N=0, Q=0, M=0, Vm=0, Vd=0, Vn=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_a1_a_invalid_3_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, Vd=0, Vn=0, M=0, Vm=0, N=0, D=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_a1_a_invalid_4_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vd=0, N=0, M=0, D=0, Vm=0, Q=0, Vn=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_a1_a_invalid_5_c00_f2300c00() {
    // Encoding: 0xF2300C00
    // Test aarch32_SHA1SU0_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, N=0, Vd=0, Vm=0, M=0, D=0, Vn=0
    let encoding: u32 = 0xF2300C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su0_t1_a_field_d_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: M=0, Vn=0, D=0, N=0, Q=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su0_t1_a_field_d_1_max_c00_ef700c00() {
    // Thumb encoding (32): 0xEF700C00
    // Test aarch32_SHA1SU0_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: N=0, Q=0, D=1, M=0, Vm=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF700C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su0_t1_a_field_vn_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: N=0, Q=0, Vn=0, Vd=0, M=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su0_t1_a_field_vn_1_poweroftwo_c00_ef310c00() {
    // Thumb encoding (32): 0xEF310C00
    // Test aarch32_SHA1SU0_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=1, D=0, Vd=0, Vm=0, M=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF310C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su0_t1_a_field_vd_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vd=0, N=0, D=0, Vn=0, Q=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su0_t1_a_field_vd_1_poweroftwo_c00_ef301c00() {
    // Thumb encoding (32): 0xEF301C00
    // Test aarch32_SHA1SU0_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, Vd=1, D=0, M=0, Vm=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF301C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su0_t1_a_field_n_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Q=0, Vm=0, Vd=0, M=0, N=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su0_t1_a_field_n_1_max_c00_ef300c80() {
    // Thumb encoding (32): 0xEF300C80
    // Test aarch32_SHA1SU0_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, D=0, Q=0, N=1, M=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1su0_t1_a_field_q_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, Q=0, M=0, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1su0_t1_a_field_q_1_max_c00_ef300c40() {
    // Thumb encoding (32): 0xEF300C40
    // Test aarch32_SHA1SU0_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, D=0, M=0, N=0, Q=1, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1su0_t1_a_field_m_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: N=0, D=0, Vn=0, M=0, Q=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1su0_t1_a_field_m_1_max_c00_ef300c20() {
    // Thumb encoding (32): 0xEF300C20
    // Test aarch32_SHA1SU0_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Vn=0, N=0, Vd=0, Q=0, M=1, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1su0_t1_a_field_vm_0_min_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, D=0, N=0, Q=0, M=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1su0_t1_a_field_vm_1_poweroftwo_c00_ef300c01() {
    // Thumb encoding (32): 0xEF300C01
    // Test aarch32_SHA1SU0_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=0, N=0, D=0, M=0, Vn=0, Vm=1, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1su0_t1_a_combo_0_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vm=0, D=0, N=0, Vd=0, Q=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1su0_t1_a_special_q_0_size_variant_0_3072_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: Q=0, D=0, N=0, M=0, Vm=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1su0_t1_a_special_q_1_size_variant_1_3072_ef300c40() {
    // Thumb encoding (32): 0xEF300C40
    // Test aarch32_SHA1SU0_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vn=0, N=0, M=0, Vm=0, D=0, Q=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_0_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: D=0, N=0, Q=0, Vd=0, Vn=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_1_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: N=0, Vn=0, Vd=0, Q=0, Vm=0, M=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_2_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: T32
    // Fields: Vd=0, Vn=0, N=0, D=0, Q=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_3_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: D=0, N=0, M=0, Vn=0, Q=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_4_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, Vm=0, Vd=0, N=0, Q=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_5_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, M=0, D=0, Vd=0, N=0, Q=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_6_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vd=0, Q=0, Vn=0, Vm=0, M=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU0_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1su0_t1_a_invalid_7_c00_ef300c00() {
    // Thumb encoding (32): 0xEF300C00
    // Test aarch32_SHA1SU0_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, M=0, Q=0, D=0, Vn=0, Vm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_64_0_d2401c20() {
    // Test EOR 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0xD2401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFF00,
        "X0 should be 0xFFFFFFFFFFFFFF00"
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_64_1_d2403c20() {
    // Test EOR 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0xD2403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF0000,
        "X0 should be 0xFFFFFFFFFFFF0000"
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_64_2_d2407c20() {
    // Test EOR 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0xD2407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_64_3_d2400020() {
    // Test EOR 64-bit: single bit mask (oracle)
    // Encoding: 0xD2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0xD2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xCAFEBABF,
        "X0 should be 0xDEADBEEFCAFEBABF"
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_64_4_d240f820() {
    // Test EOR 64-bit: all but MSB (oracle)
    // Encoding: 0xD240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xD240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x55555555,
        "X0 should be 0xD555555555555555"
    );
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_32_0_52001c20() {
    // Test EOR 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x52001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "W0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_32_1_52003c20() {
    // Test EOR 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x52003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF0000, "W0 should be 0xFFFF0000");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_sha1su0_a1_a_eor_oracle_32_2_52000020() {
    // Test EOR 32-bit: single bit mask (oracle)
    // Encoding: 0x52000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x52000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDEADBEEE, "W0 should be 0xDEADBEEE");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_0_0_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_0_ff_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF5, "R0 should be 0x000000F5");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_0_aaaaaaaa_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAA0, "R0 should be 0xAAAAAAA0");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_0_55555555_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5555555F, "R0 should be 0x5555555F");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_0_ffffffff_f221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0xF221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_1_0_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_1_ff_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_1_aaaaaaaa_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAA55, "R0 should be 0xAAAAAA55");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_1_55555555_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x555555AA, "R0 should be 0x555555AA");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_1_ffffffff_f22100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0xF22100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF22100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_2_0_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_2_ff_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDF, "R0 should be 0x000000DF");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_2_aaaaaaaa_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAA8A, "R0 should be 0xAAAAAA8A");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_2_55555555_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555575, "R0 should be 0x55555575");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_2_ffffffff_f2210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0xF2210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_3_0_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_3_ff_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0000FF, "R0 should be 0x0F0000FF");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_3_aaaaaaaa_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA5AAAAAA, "R0 should be 0xA5AAAAAA");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_3_55555555_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A555555, "R0 should be 0x5A555555");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_3_ffffffff_f221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0xF221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_4_0_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_4_ff_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_4_aaaaaaaa_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAAA, "R0 should be 0xAAAAAAAA");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_4_55555555_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555555, "R0 should be 0x55555555");
}

/// Provenance: aarch32_SHA1SU0_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1su0_a1_a_a32_logical_imm_4_ffffffff_f2210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0xF2210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

// ============================================================================
// aarch32_UDF_A Tests
// ============================================================================

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_udf_a1_a_field_cond_0_min_f0_07f000f0() {
    // Encoding: 0x07F000F0
    // Test aarch32_UDF_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=0
    let encoding: u32 = 0x07F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_udf_a1_a_field_cond_1_poweroftwo_f0_17f000f0() {
    // Encoding: 0x17F000F0
    // Test aarch32_UDF_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, imm12=0, imm4=0
    let encoding: u32 = 0x17F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_udf_a1_a_field_cond_2_poweroftwo_f0_27f000f0() {
    // Encoding: 0x27F000F0
    // Test aarch32_UDF_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm12=0, imm4=0
    let encoding: u32 = 0x27F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_udf_a1_a_field_cond_3_poweroftwo_f0_37f000f0() {
    // Encoding: 0x37F000F0
    // Test aarch32_UDF_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm12=0, imm4=0
    let encoding: u32 = 0x37F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_udf_a1_a_field_cond_4_poweroftwo_f0_47f000f0() {
    // Encoding: 0x47F000F0
    // Test aarch32_UDF_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, imm12=0, imm4=0
    let encoding: u32 = 0x47F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_udf_a1_a_field_cond_5_poweroftwo_f0_57f000f0() {
    // Encoding: 0x57F000F0
    // Test aarch32_UDF_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=5, imm4=0
    let encoding: u32 = 0x57F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_udf_a1_a_field_cond_6_poweroftwo_f0_67f000f0() {
    // Encoding: 0x67F000F0
    // Test aarch32_UDF_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, imm12=0, imm4=0
    let encoding: u32 = 0x67F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_udf_a1_a_field_cond_7_poweroftwo_f0_77f000f0() {
    // Encoding: 0x77F000F0
    // Test aarch32_UDF_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, imm12=0, imm4=0
    let encoding: u32 = 0x77F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_udf_a1_a_field_cond_8_poweroftwo_f0_87f000f0() {
    // Encoding: 0x87F000F0
    // Test aarch32_UDF_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=8
    let encoding: u32 = 0x87F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_udf_a1_a_field_cond_9_poweroftwo_f0_97f000f0() {
    // Encoding: 0x97F000F0
    // Test aarch32_UDF_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, imm12=0, imm4=0
    let encoding: u32 = 0x97F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_udf_a1_a_field_cond_10_poweroftwo_f0_a7f000f0() {
    // Encoding: 0xA7F000F0
    // Test aarch32_UDF_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=10, imm12=0
    let encoding: u32 = 0xA7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_udf_a1_a_field_cond_11_poweroftwo_f0_b7f000f0() {
    // Encoding: 0xB7F000F0
    // Test aarch32_UDF_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm4=0, imm12=0
    let encoding: u32 = 0xB7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_udf_a1_a_field_cond_12_poweroftwo_f0_c7f000f0() {
    // Encoding: 0xC7F000F0
    // Test aarch32_UDF_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm4=0, imm12=0
    let encoding: u32 = 0xC7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_udf_a1_a_field_cond_13_poweroftwo_f0_d7f000f0() {
    // Encoding: 0xD7F000F0
    // Test aarch32_UDF_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=13
    let encoding: u32 = 0xD7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_udf_a1_a_field_cond_14_poweroftwo_f0_e7f000f0() {
    // Encoding: 0xE7F000F0
    // Test aarch32_UDF_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=14, imm4=0
    let encoding: u32 = 0xE7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_udf_a1_a_field_cond_15_max_f0_f7f000f0() {
    // Encoding: 0xF7F000F0
    // Test aarch32_UDF_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=15
    let encoding: u32 = 0xF7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_udf_a1_a_field_imm12_0_zero_f0_07f000f0() {
    // Encoding: 0x07F000F0
    // Test aarch32_UDF_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=0
    let encoding: u32 = 0x07F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_udf_a1_a_field_imm12_1_poweroftwo_f0_07f001f0() {
    // Encoding: 0x07F001F0
    // Test aarch32_UDF_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, cond=0, imm4=0
    let encoding: u32 = 0x07F001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_udf_a1_a_field_imm12_3_poweroftwominusone_f0_07f003f0() {
    // Encoding: 0x07F003F0
    // Test aarch32_UDF_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=3
    let encoding: u32 = 0x07F003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_4_poweroftwo_f0_07f004f0() {
    // Encoding: 0x07F004F0
    // Test aarch32_UDF_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, imm4=0, cond=0
    let encoding: u32 = 0x07F004F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_udf_a1_a_field_imm12_7_poweroftwominusone_f0_07f007f0() {
    // Encoding: 0x07F007F0
    // Test aarch32_UDF_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=7, cond=0
    let encoding: u32 = 0x07F007F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_8_poweroftwo_f0_07f008f0() {
    // Encoding: 0x07F008F0
    // Test aarch32_UDF_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, imm4=0, cond=0
    let encoding: u32 = 0x07F008F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_udf_a1_a_field_imm12_15_poweroftwominusone_f0_07f00ff0() {
    // Encoding: 0x07F00FF0
    // Test aarch32_UDF_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=15, imm4=0
    let encoding: u32 = 0x07F00FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_16_poweroftwo_f0_07f010f0() {
    // Encoding: 0x07F010F0
    // Test aarch32_UDF_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=16, imm4=0, cond=0
    let encoding: u32 = 0x07F010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_udf_a1_a_field_imm12_31_poweroftwominusone_f0_07f01ff0() {
    // Encoding: 0x07F01FF0
    // Test aarch32_UDF_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, imm12=31, cond=0
    let encoding: u32 = 0x07F01FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_32_poweroftwo_f0_07f020f0() {
    // Encoding: 0x07F020F0
    // Test aarch32_UDF_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4=0, imm12=32
    let encoding: u32 = 0x07F020F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_udf_a1_a_field_imm12_63_poweroftwominusone_f0_07f03ff0() {
    // Encoding: 0x07F03FF0
    // Test aarch32_UDF_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, imm4=0, cond=0
    let encoding: u32 = 0x07F03FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_64_poweroftwo_f0_07f040f0() {
    // Encoding: 0x07F040F0
    // Test aarch32_UDF_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=64, cond=0, imm4=0
    let encoding: u32 = 0x07F040F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_udf_a1_a_field_imm12_127_poweroftwominusone_f0_07f07ff0() {
    // Encoding: 0x07F07FF0
    // Test aarch32_UDF_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, imm4=0, cond=0
    let encoding: u32 = 0x07F07FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_128_poweroftwo_f0_07f080f0() {
    // Encoding: 0x07F080F0
    // Test aarch32_UDF_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=128, imm4=0, cond=0
    let encoding: u32 = 0x07F080F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_udf_a1_a_field_imm12_255_poweroftwominusone_f0_07f0fff0() {
    // Encoding: 0x07F0FFF0
    // Test aarch32_UDF_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=255
    let encoding: u32 = 0x07F0FFF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_256_poweroftwo_f0_07f100f0() {
    // Encoding: 0x07F100F0
    // Test aarch32_UDF_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=256, imm4=0
    let encoding: u32 = 0x07F100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_udf_a1_a_field_imm12_511_poweroftwominusone_f0_07f1fff0() {
    // Encoding: 0x07F1FFF0
    // Test aarch32_UDF_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, cond=0, imm4=0
    let encoding: u32 = 0x07F1FFF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_512_poweroftwo_f0_07f200f0() {
    // Encoding: 0x07F200F0
    // Test aarch32_UDF_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=512
    let encoding: u32 = 0x07F200F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_udf_a1_a_field_imm12_1023_poweroftwominusone_f0_07f3fff0() {
    // Encoding: 0x07F3FFF0
    // Test aarch32_UDF_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=1023, imm4=0, cond=0
    let encoding: u32 = 0x07F3FFF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_1024_poweroftwo_f0_07f400f0() {
    // Encoding: 0x07F400F0
    // Test aarch32_UDF_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=1024
    let encoding: u32 = 0x07F400F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_2047_poweroftwominusone_f0_07f7fff0() {
    // Encoding: 0x07F7FFF0
    // Test aarch32_UDF_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4=0, cond=0, imm12=2047
    let encoding: u32 = 0x07F7FFF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_2048_poweroftwo_f0_07f800f0() {
    // Encoding: 0x07F800F0
    // Test aarch32_UDF_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, cond=0, imm4=0
    let encoding: u32 = 0x07F800F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm12 8 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_udf_a1_a_field_imm12_4095_max_f0_07fffff0() {
    // Encoding: 0x07FFFFF0
    // Test aarch32_UDF_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, imm4=0, cond=0
    let encoding: u32 = 0x07FFFFF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_udf_a1_a_field_imm4_0_zero_f0_07f000f0() {
    // Encoding: 0x07F000F0
    // Test aarch32_UDF_A1_A field imm4 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x07F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_udf_a1_a_field_imm4_1_poweroftwo_f0_07f000f1() {
    // Encoding: 0x07F000F1
    // Test aarch32_UDF_A1_A field imm4 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4=1, imm12=0
    let encoding: u32 = 0x07F000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_udf_a1_a_field_imm4_3_poweroftwominusone_f0_07f000f3() {
    // Encoding: 0x07F000F3
    // Test aarch32_UDF_A1_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=3
    let encoding: u32 = 0x07F000F3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_udf_a1_a_field_imm4_4_poweroftwo_f0_07f000f4() {
    // Encoding: 0x07F000F4
    // Test aarch32_UDF_A1_A field imm4 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=0, imm4=4
    let encoding: u32 = 0x07F000F4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_udf_a1_a_field_imm4_7_poweroftwominusone_f0_07f000f7() {
    // Encoding: 0x07F000F7
    // Test aarch32_UDF_A1_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=0, imm4=7, cond=0
    let encoding: u32 = 0x07F000F7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_udf_a1_a_field_imm4_8_poweroftwo_f0_07f000f8() {
    // Encoding: 0x07F000F8
    // Test aarch32_UDF_A1_A field imm4 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, imm4=8, cond=0
    let encoding: u32 = 0x07F000F8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field imm4 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_udf_a1_a_field_imm4_15_max_f0_07f000ff() {
    // Encoding: 0x07F000FF
    // Test aarch32_UDF_A1_A field imm4 = 15 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=15
    let encoding: u32 = 0x07F000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_udf_a1_a_combo_0_f0_07f000f0() {
    // Encoding: 0x07F000F0
    // Test aarch32_UDF_A1_A field combination: cond=0, imm12=0, imm4=0
    // ISET: A32
    // Fields: cond=0, imm12=0, imm4=0
    let encoding: u32 = 0x07F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_udf_a1_a_special_cond_0_condition_eq_240_07f000f0() {
    // Encoding: 0x07F000F0
    // Test aarch32_UDF_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=0
    let encoding: u32 = 0x07F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_udf_a1_a_special_cond_1_condition_ne_240_17f000f0() {
    // Encoding: 0x17F000F0
    // Test aarch32_UDF_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, cond=1, imm4=0
    let encoding: u32 = 0x17F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_udf_a1_a_special_cond_2_condition_cs_hs_240_27f000f0() {
    // Encoding: 0x27F000F0
    // Test aarch32_UDF_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, imm12=0, imm4=0
    let encoding: u32 = 0x27F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_udf_a1_a_special_cond_3_condition_cc_lo_240_37f000f0() {
    // Encoding: 0x37F000F0
    // Test aarch32_UDF_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm4=0, imm12=0, cond=3
    let encoding: u32 = 0x37F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_udf_a1_a_special_cond_4_condition_mi_240_47f000f0() {
    // Encoding: 0x47F000F0
    // Test aarch32_UDF_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm12=0, cond=4, imm4=0
    let encoding: u32 = 0x47F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_udf_a1_a_special_cond_5_condition_pl_240_57f000f0() {
    // Encoding: 0x57F000F0
    // Test aarch32_UDF_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm4=0, imm12=0
    let encoding: u32 = 0x57F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_udf_a1_a_special_cond_6_condition_vs_240_67f000f0() {
    // Encoding: 0x67F000F0
    // Test aarch32_UDF_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm12=0, imm4=0
    let encoding: u32 = 0x67F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_udf_a1_a_special_cond_7_condition_vc_240_77f000f0() {
    // Encoding: 0x77F000F0
    // Test aarch32_UDF_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm4=0, cond=7, imm12=0
    let encoding: u32 = 0x77F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_udf_a1_a_special_cond_8_condition_hi_240_87f000f0() {
    // Encoding: 0x87F000F0
    // Test aarch32_UDF_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm12=0, cond=8, imm4=0
    let encoding: u32 = 0x87F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_udf_a1_a_special_cond_9_condition_ls_240_97f000f0() {
    // Encoding: 0x97F000F0
    // Test aarch32_UDF_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, imm12=0, imm4=0
    let encoding: u32 = 0x97F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_udf_a1_a_special_cond_10_condition_ge_240_a7f000f0() {
    // Encoding: 0xA7F000F0
    // Test aarch32_UDF_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, imm4=0, imm12=0
    let encoding: u32 = 0xA7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_udf_a1_a_special_cond_11_condition_lt_240_b7f000f0() {
    // Encoding: 0xB7F000F0
    // Test aarch32_UDF_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm4=0, cond=11, imm12=0
    let encoding: u32 = 0xB7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_udf_a1_a_special_cond_12_condition_gt_240_c7f000f0() {
    // Encoding: 0xC7F000F0
    // Test aarch32_UDF_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm4=0, cond=12, imm12=0
    let encoding: u32 = 0xC7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_udf_a1_a_special_cond_13_condition_le_240_d7f000f0() {
    // Encoding: 0xD7F000F0
    // Test aarch32_UDF_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm12=0, imm4=0, cond=13
    let encoding: u32 = 0xD7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_udf_a1_a_special_cond_14_condition_al_240_e7f000f0() {
    // Encoding: 0xE7F000F0
    // Test aarch32_UDF_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, imm12=0, imm4=0
    let encoding: u32 = 0xE7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_udf_a1_a_special_cond_15_condition_nv_240_f7f000f0() {
    // Encoding: 0xF7F000F0
    // Test aarch32_UDF_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, imm12=0, imm4=0
    let encoding: u32 = 0xF7F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_udf_t1_a_field_imm8_0_zero_0_de000000() {
    // Thumb encoding (32): 0xDE000000
    // Test aarch32_UDF_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_udf_t1_a_field_imm8_1_poweroftwo_0_de010000() {
    // Thumb encoding (32): 0xDE010000
    // Test aarch32_UDF_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_udf_t1_a_field_imm8_3_poweroftwominusone_0_de030000() {
    // Thumb encoding (32): 0xDE030000
    // Test aarch32_UDF_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_4_poweroftwo_0_de040000() {
    // Thumb encoding (32): 0xDE040000
    // Test aarch32_UDF_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_udf_t1_a_field_imm8_7_poweroftwominusone_0_de070000() {
    // Thumb encoding (32): 0xDE070000
    // Test aarch32_UDF_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_8_poweroftwo_0_de080000() {
    // Thumb encoding (32): 0xDE080000
    // Test aarch32_UDF_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_udf_t1_a_field_imm8_15_poweroftwominusone_0_de0f0000() {
    // Thumb encoding (32): 0xDE0F0000
    // Test aarch32_UDF_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE0F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_16_poweroftwo_0_de100000() {
    // Thumb encoding (32): 0xDE100000
    // Test aarch32_UDF_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_udf_t1_a_field_imm8_31_poweroftwominusone_0_de1f0000() {
    // Thumb encoding (32): 0xDE1F0000
    // Test aarch32_UDF_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE1F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_32_poweroftwo_0_de200000() {
    // Thumb encoding (32): 0xDE200000
    // Test aarch32_UDF_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_udf_t1_a_field_imm8_63_poweroftwominusone_0_de3f0000() {
    // Thumb encoding (32): 0xDE3F0000
    // Test aarch32_UDF_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE3F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_64_poweroftwo_0_de400000() {
    // Thumb encoding (32): 0xDE400000
    // Test aarch32_UDF_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_127_poweroftwominusone_0_de7f0000() {
    // Thumb encoding (32): 0xDE7F0000
    // Test aarch32_UDF_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE7F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_128_poweroftwo_0_de800000() {
    // Thumb encoding (32): 0xDE800000
    // Test aarch32_UDF_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_udf_t1_a_field_imm8_255_max_0_deff0000() {
    // Thumb encoding (32): 0xDEFF0000
    // Test aarch32_UDF_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDEFF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_udf_t1_a_combo_0_0_de000000() {
    // Thumb encoding (32): 0xDE000000
    // Test aarch32_UDF_T1_A field combination: imm8=0
    // ISET: T32
    // Fields: imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xDE000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_udf_t2_a_field_imm4_0_zero_a000_f7f0a000() {
    // Thumb encoding (32): 0xF7F0A000
    // Test aarch32_UDF_T2_A field imm4 = 0 (Zero)
    // ISET: T32
    // Fields: imm12=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_udf_t2_a_field_imm4_1_poweroftwo_a000_f7f1a000() {
    // Thumb encoding (32): 0xF7F1A000
    // Test aarch32_UDF_T2_A field imm4 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F1A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_udf_t2_a_field_imm4_3_poweroftwominusone_a000_f7f3a000() {
    // Thumb encoding (32): 0xF7F3A000
    // Test aarch32_UDF_T2_A field imm4 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=3, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F3A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_udf_t2_a_field_imm4_4_poweroftwo_a000_f7f4a000() {
    // Thumb encoding (32): 0xF7F4A000
    // Test aarch32_UDF_T2_A field imm4 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=4, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F4A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_udf_t2_a_field_imm4_7_poweroftwominusone_a000_f7f7a000() {
    // Thumb encoding (32): 0xF7F7A000
    // Test aarch32_UDF_T2_A field imm4 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=0, imm4=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F7A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_udf_t2_a_field_imm4_8_poweroftwo_a000_f7f8a000() {
    // Thumb encoding (32): 0xF7F8A000
    // Test aarch32_UDF_T2_A field imm4 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, imm4=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F8A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_udf_t2_a_field_imm4_15_max_a000_f7ffa000() {
    // Thumb encoding (32): 0xF7FFA000
    // Test aarch32_UDF_T2_A field imm4 = 15 (Max)
    // ISET: T32
    // Fields: imm4=15, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7FFA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_udf_t2_a_field_imm12_0_zero_a000_f7f0a000() {
    // Thumb encoding (32): 0xF7F0A000
    // Test aarch32_UDF_T2_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: imm4=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_udf_t2_a_field_imm12_1_poweroftwo_a000_f7f0a001() {
    // Thumb encoding (32): 0xF7F0A001
    // Test aarch32_UDF_T2_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_udf_t2_a_field_imm12_3_poweroftwominusone_a000_f7f0a003() {
    // Thumb encoding (32): 0xF7F0A003
    // Test aarch32_UDF_T2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=3, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_4_poweroftwo_a000_f7f0a004() {
    // Thumb encoding (32): 0xF7F0A004
    // Test aarch32_UDF_T2_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=4, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_udf_t2_a_field_imm12_7_poweroftwominusone_a000_f7f0a007() {
    // Thumb encoding (32): 0xF7F0A007
    // Test aarch32_UDF_T2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=7, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_8_poweroftwo_a000_f7f0a008() {
    // Thumb encoding (32): 0xF7F0A008
    // Test aarch32_UDF_T2_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_udf_t2_a_field_imm12_15_poweroftwominusone_a000_f7f0a00f() {
    // Thumb encoding (32): 0xF7F0A00F
    // Test aarch32_UDF_T2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_16_poweroftwo_a000_f7f0a010() {
    // Thumb encoding (32): 0xF7F0A010
    // Test aarch32_UDF_T2_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_udf_t2_a_field_imm12_31_poweroftwominusone_a000_f7f0a01f() {
    // Thumb encoding (32): 0xF7F0A01F
    // Test aarch32_UDF_T2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_32_poweroftwo_a000_f7f0a020() {
    // Thumb encoding (32): 0xF7F0A020
    // Test aarch32_UDF_T2_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_udf_t2_a_field_imm12_63_poweroftwominusone_a000_f7f0a03f() {
    // Thumb encoding (32): 0xF7F0A03F
    // Test aarch32_UDF_T2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A03F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_64_poweroftwo_a000_f7f0a040() {
    // Thumb encoding (32): 0xF7F0A040
    // Test aarch32_UDF_T2_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_udf_t2_a_field_imm12_127_poweroftwominusone_a000_f7f0a07f() {
    // Thumb encoding (32): 0xF7F0A07F
    // Test aarch32_UDF_T2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A07F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_128_poweroftwo_a000_f7f0a080() {
    // Thumb encoding (32): 0xF7F0A080
    // Test aarch32_UDF_T2_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=128, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_udf_t2_a_field_imm12_255_poweroftwominusone_a000_f7f0a0ff() {
    // Thumb encoding (32): 0xF7F0A0FF
    // Test aarch32_UDF_T2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A0FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_256_poweroftwo_a000_f7f0a100() {
    // Thumb encoding (32): 0xF7F0A100
    // Test aarch32_UDF_T2_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_udf_t2_a_field_imm12_511_poweroftwominusone_a000_f7f0a1ff() {
    // Thumb encoding (32): 0xF7F0A1FF
    // Test aarch32_UDF_T2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A1FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_512_poweroftwo_a000_f7f0a200() {
    // Thumb encoding (32): 0xF7F0A200
    // Test aarch32_UDF_T2_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_udf_t2_a_field_imm12_1023_poweroftwominusone_a000_f7f0a3ff() {
    // Thumb encoding (32): 0xF7F0A3FF
    // Test aarch32_UDF_T2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A3FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_1024_poweroftwo_a000_f7f0a400() {
    // Thumb encoding (32): 0xF7F0A400
    // Test aarch32_UDF_T2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm4=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_2047_poweroftwominusone_a000_f7f0a7ff() {
    // Thumb encoding (32): 0xF7F0A7FF
    // Test aarch32_UDF_T2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm4=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A7FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_2048_poweroftwo_a000_f7f0a800() {
    // Thumb encoding (32): 0xF7F0A800
    // Test aarch32_UDF_T2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_udf_t2_a_field_imm12_4095_max_a000_f7f0afff() {
    // Thumb encoding (32): 0xF7F0AFFF
    // Test aarch32_UDF_T2_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: imm4=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0AFFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_aarch32_udf_t2_a_combo_0_a000_f7f0a000() {
    // Thumb encoding (32): 0xF7F0A000
    // Test aarch32_UDF_T2_A field combination: imm4=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, imm4=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF7F0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDF_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_udf_a1_a_exception_0_07f000f0() {
    // Test aarch32_UDF_A1_A exception: Undefined
    // Encoding: 0x07F000F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x07F000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_32_0_de020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_64_0_de020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_32_1_de020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_64_1_de020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_32_2_de020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_64_2_de020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_32_3_de020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_64_3_de020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_32_4_de020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_64_4_de020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_32_5_de020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_udf_t1_a_lslv_oracle_64_5_de020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_udf_t1_a_t16_oracle_0_de000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_udf_t1_a_t16_oracle_1_de000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_udf_t1_a_t16_oracle_2_de000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_udf_t1_a_t16_oracle_3_de000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_UDF_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_udf_t1_a_exception_0_de000000() {
    // Test aarch32_UDF_T1_A exception: Undefined
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_UDF_T2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_udf_t2_a_exception_0_f7f0a000() {
    // Test aarch32_UDF_T2_A exception: Undefined
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF7F0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SHA1C_A Tests
// ============================================================================

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1c_a1_a_field_d_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Q=0, Vm=0, Vn=0, D=0, M=0, N=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1c_a1_a_field_d_1_max_c00_f2400c00() {
    // Encoding: 0xF2400C00
    // Test aarch32_SHA1C_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, N=0, Vd=0, D=1, M=0, Q=0, Vm=0
    let encoding: u32 = 0xF2400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1c_a1_a_field_vn_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: M=0, Q=0, Vm=0, D=0, Vn=0, Vd=0, N=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1c_a1_a_field_vn_1_poweroftwo_c00_f2010c00() {
    // Encoding: 0xF2010C00
    // Test aarch32_SHA1C_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Vn=1, Vm=0, Q=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xF2010C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1c_a1_a_field_vd_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vn=0, Vd=0, M=0, D=0, N=0, Vm=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1c_a1_a_field_vd_1_poweroftwo_c00_f2001c00() {
    // Encoding: 0xF2001C00
    // Test aarch32_SHA1C_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, D=0, Vn=0, M=0, N=0, Q=0, Vm=0
    let encoding: u32 = 0xF2001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1c_a1_a_field_n_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: M=0, Vm=0, Vd=0, Q=0, Vn=0, D=0, N=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1c_a1_a_field_n_1_max_c00_f2000c80() {
    // Encoding: 0xF2000C80
    // Test aarch32_SHA1C_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Q=0, M=0, Vm=0, Vd=0, D=0, Vn=0, N=1
    let encoding: u32 = 0xF2000C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1c_a1_a_field_q_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vm=0, Vd=0, Vn=0, M=0, Q=0, N=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1c_a1_a_field_q_1_max_c00_f2000c40() {
    // Encoding: 0xF2000C40
    // Test aarch32_SHA1C_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: D=0, N=0, M=0, Vd=0, Vm=0, Q=1, Vn=0
    let encoding: u32 = 0xF2000C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1c_a1_a_field_m_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Q=0, Vm=0, D=0, N=0, M=0, Vd=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1c_a1_a_field_m_1_max_c00_f2000c20() {
    // Encoding: 0xF2000C20
    // Test aarch32_SHA1C_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: M=1, Vm=0, D=0, Vn=0, N=0, Q=0, Vd=0
    let encoding: u32 = 0xF2000C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1c_a1_a_field_vm_0_min_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, N=0, M=0, Q=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1c_a1_a_field_vm_1_poweroftwo_c00_f2000c01() {
    // Encoding: 0xF2000C01
    // Test aarch32_SHA1C_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Q=0, N=0, Vm=1, M=0, D=0, Vd=0, Vn=0
    let encoding: u32 = 0xF2000C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1c_a1_a_combo_0_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: M=0, Vd=0, Vm=0, Vn=0, D=0, N=0, Q=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1c_a1_a_special_q_0_size_variant_0_3072_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, N=0, Vn=0, Vd=0, D=0, Q=0, M=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1c_a1_a_special_q_1_size_variant_1_3072_f2000c40() {
    // Encoding: 0xF2000C40
    // Test aarch32_SHA1C_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Q=1, D=0, Vd=0, M=0, Vn=0, N=0, Vm=0
    let encoding: u32 = 0xF2000C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_a1_a_invalid_0_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: A32
    // Fields: Q=0, D=0, Vn=0, M=0, Vd=0, Vm=0, N=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_a1_a_invalid_1_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, D=0, N=0, M=0, Vm=0, Q=0, Vn=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_a1_a_invalid_2_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: D=0, N=0, Q=0, M=0, Vn=0, Vd=0, Vm=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_a1_a_invalid_3_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, Vd=0, Q=0, D=0, Vn=0, M=0, Vm=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_a1_a_invalid_4_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, N=0, Q=0, Vn=0, Vm=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_a1_a_invalid_5_c00_f2000c00() {
    // Encoding: 0xF2000C00
    // Test aarch32_SHA1C_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vm=0, N=0, M=0, D=0, Vn=0, Vd=0, Q=0
    let encoding: u32 = 0xF2000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1c_t1_a_field_d_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: N=0, Vm=0, Vd=0, D=0, Vn=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1c_t1_a_field_d_1_max_c00_ef400c00() {
    // Thumb encoding (32): 0xEF400C00
    // Test aarch32_SHA1C_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: M=0, Vd=0, Vn=0, N=0, D=1, Q=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF400C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1c_t1_a_field_vn_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: D=0, Vd=0, N=0, Q=0, M=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1c_t1_a_field_vn_1_poweroftwo_c00_ef010c00() {
    // Thumb encoding (32): 0xEF010C00
    // Test aarch32_SHA1C_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Q=0, Vd=0, D=0, M=0, Vn=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF010C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1c_t1_a_field_vd_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: M=0, N=0, D=0, Vn=0, Q=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1c_t1_a_field_vd_1_poweroftwo_c00_ef001c00() {
    // Thumb encoding (32): 0xEF001C00
    // Test aarch32_SHA1C_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Q=0, M=0, Vn=0, Vm=0, D=0, Vd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF001C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1c_t1_a_field_n_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Q=0, M=0, Vn=0, N=0, Vm=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1c_t1_a_field_n_1_max_c00_ef000c80() {
    // Thumb encoding (32): 0xEF000C80
    // Test aarch32_SHA1C_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Q=0, D=0, N=1, Vm=0, M=0, Vn=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha1c_t1_a_field_q_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: N=0, Q=0, M=0, Vm=0, Vn=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha1c_t1_a_field_q_1_max_c00_ef000c40() {
    // Thumb encoding (32): 0xEF000C40
    // Test aarch32_SHA1C_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, N=0, Q=1, Vn=0, M=0, D=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha1c_t1_a_field_m_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, D=0, Q=0, Vd=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha1c_t1_a_field_m_1_max_c00_ef000c20() {
    // Thumb encoding (32): 0xEF000C20
    // Test aarch32_SHA1C_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Vn=0, Vd=0, Q=0, M=1, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha1c_t1_a_field_vm_0_min_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: N=0, M=0, Vn=0, D=0, Vd=0, Q=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha1c_t1_a_field_vm_1_poweroftwo_c00_ef000c01() {
    // Thumb encoding (32): 0xEF000C01
    // Test aarch32_SHA1C_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, N=0, Q=0, M=0, Vm=1, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha1c_t1_a_combo_0_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Q=0, Vm=0, N=0, M=0, Vd=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha1c_t1_a_special_q_0_size_variant_0_3072_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: N=0, Vm=0, D=0, Vn=0, Q=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha1c_t1_a_special_q_1_size_variant_1_3072_ef000c40() {
    // Thumb encoding (32): 0xEF000C40
    // Test aarch32_SHA1C_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vm=0, Vd=0, Vn=0, N=0, Q=1, D=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1c_t1_a_invalid_0_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: M=0, Vm=0, D=0, N=0, Vn=0, Q=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha1c_t1_a_invalid_1_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Q=0, M=0, Vm=0, N=0, Vd=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA1Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_t1_a_invalid_2_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA1Ext" }, args: [] } }
    // ISET: T32
    // Fields: D=0, Vn=0, N=0, Q=0, Vd=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_t1_a_invalid_3_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, M=0, Vn=0, D=0, N=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_t1_a_invalid_4_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vn=0, D=0, Q=0, N=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_t1_a_invalid_5_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vn=0, N=0, M=0, D=0, Q=0, Vm=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_t1_a_invalid_6_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, Q=0, Vn=0, Vd=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1C_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha1c_t1_a_invalid_7_c00_ef000c00() {
    // Thumb encoding (32): 0xEF000C00
    // Test aarch32_SHA1C_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: M=0, Vm=0, D=0, Vn=0, Vd=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0x92401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0x92403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0x92407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // Encoding: 0x92400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // Encoding: 0x9240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x12001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x12003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_sha1c_a1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // Encoding: 0x12000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_0_0_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_0_ff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_0_aaaaaaaa_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_0_55555555_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_0_ffffffff_f201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0xF201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_1_0_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_1_ff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_1_aaaaaaaa_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAA, "R0 should be 0x000000AA");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_1_55555555_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55, "R0 should be 0x00000055");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_1_ffffffff_f20100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0xF20100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF20100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_2_0_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_2_ff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_2_aaaaaaaa_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_2_55555555_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_2_ffffffff_f2010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0xF2010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_3_0_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_3_ff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_3_aaaaaaaa_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA000000, "R0 should be 0x0A000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_3_55555555_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5000000, "R0 should be 0x05000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_3_ffffffff_f201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0xF201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_4_0_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_4_ff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_4_aaaaaaaa_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_4_55555555_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA1C_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sha1c_a1_a_a32_logical_imm_4_ffffffff_f2010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0xF2010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_PKH_A Tests
// ============================================================================

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_0_min_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm5=0, Rm=0, tb=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_1_poweroftwo_10_16800010() {
    // Encoding: 0x16800010
    // Test aarch32_PKH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: tb=0, imm5=0, cond=1, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x16800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_2_poweroftwo_10_26800010() {
    // Encoding: 0x26800010
    // Test aarch32_PKH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, tb=0, Rm=0, Rd=0, Rn=0, cond=2
    let encoding: u32 = 0x26800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_3_poweroftwo_10_36800010() {
    // Encoding: 0x36800010
    // Test aarch32_PKH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm5=0, tb=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x36800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_4_poweroftwo_10_46800010() {
    // Encoding: 0x46800010
    // Test aarch32_PKH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, Rm=0, cond=4, tb=0
    let encoding: u32 = 0x46800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_5_poweroftwo_10_56800010() {
    // Encoding: 0x56800010
    // Test aarch32_PKH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rm=0, tb=0, cond=5, Rn=0
    let encoding: u32 = 0x56800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_6_poweroftwo_10_66800010() {
    // Encoding: 0x66800010
    // Test aarch32_PKH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rd=0, imm5=0, Rm=0, tb=0
    let encoding: u32 = 0x66800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_7_poweroftwo_10_76800010() {
    // Encoding: 0x76800010
    // Test aarch32_PKH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, tb=0, Rn=0, imm5=0, Rm=0, Rd=0
    let encoding: u32 = 0x76800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_8_poweroftwo_10_86800010() {
    // Encoding: 0x86800010
    // Test aarch32_PKH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, cond=8, Rm=0, tb=0
    let encoding: u32 = 0x86800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_9_poweroftwo_10_96800010() {
    // Encoding: 0x96800010
    // Test aarch32_PKH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, tb=0, Rn=0, Rd=0, imm5=0, Rm=0
    let encoding: u32 = 0x96800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_10_poweroftwo_10_a6800010() {
    // Encoding: 0xA6800010
    // Test aarch32_PKH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, imm5=0, cond=10, Rn=0, tb=0
    let encoding: u32 = 0xA6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_11_poweroftwo_10_b6800010() {
    // Encoding: 0xB6800010
    // Test aarch32_PKH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: tb=0, Rn=0, Rd=0, cond=11, imm5=0, Rm=0
    let encoding: u32 = 0xB6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_12_poweroftwo_10_c6800010() {
    // Encoding: 0xC6800010
    // Test aarch32_PKH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, tb=0, Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_13_poweroftwo_10_d6800010() {
    // Encoding: 0xD6800010
    // Test aarch32_PKH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, tb=0, Rn=0, cond=13, Rm=0, Rd=0
    let encoding: u32 = 0xD6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_14_poweroftwo_10_e6800010() {
    // Encoding: 0xE6800010
    // Test aarch32_PKH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: tb=0, Rm=0, Rn=0, cond=14, Rd=0, imm5=0
    let encoding: u32 = 0xE6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_pkh_a1_a_field_cond_15_max_10_f6800010() {
    // Encoding: 0xF6800010
    // Test aarch32_PKH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm5=0, tb=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0xF6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pkh_a1_a_field_rn_0_min_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm5=0, cond=0, tb=0, Rn=0, Rm=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pkh_a1_a_field_rn_1_poweroftwo_10_06810010() {
    // Encoding: 0x06810010
    // Test aarch32_PKH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=1, tb=0, Rm=0, cond=0
    let encoding: u32 = 0x06810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pkh_a1_a_field_rd_0_min_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, imm5=0, tb=0, Rm=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pkh_a1_a_field_rd_1_poweroftwo_10_06801010() {
    // Encoding: 0x06801010
    // Test aarch32_PKH_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rd=1, Rn=0, Rm=0, cond=0, tb=0
    let encoding: u32 = 0x06801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_0_zero_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, Rd=0, tb=0, cond=0, imm5=0, Rm=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_1_poweroftwo_10_06800090() {
    // Encoding: 0x06800090
    // Test aarch32_PKH_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, imm5=1, Rd=0, tb=0, cond=0
    let encoding: u32 = 0x06800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_3_poweroftwominusone_10_06800190() {
    // Encoding: 0x06800190
    // Test aarch32_PKH_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, Rn=0, imm5=3, tb=0
    let encoding: u32 = 0x06800190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_4_poweroftwo_10_06800210() {
    // Encoding: 0x06800210
    // Test aarch32_PKH_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, imm5=4, tb=0, cond=0, Rn=0
    let encoding: u32 = 0x06800210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_7_poweroftwominusone_10_06800390() {
    // Encoding: 0x06800390
    // Test aarch32_PKH_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm5=7, Rm=0, cond=0, tb=0, Rd=0
    let encoding: u32 = 0x06800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_8_poweroftwo_10_06800410() {
    // Encoding: 0x06800410
    // Test aarch32_PKH_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, tb=0, imm5=8, Rm=0
    let encoding: u32 = 0x06800410;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_15_poweroftwominusone_10_06800790() {
    // Encoding: 0x06800790
    // Test aarch32_PKH_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=0, imm5=15, tb=0
    let encoding: u32 = 0x06800790;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_16_poweroftwo_10_06800810() {
    // Encoding: 0x06800810
    // Test aarch32_PKH_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm5=16, Rm=0, tb=0
    let encoding: u32 = 0x06800810;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_pkh_a1_a_field_imm5_31_max_10_06800f90() {
    // Encoding: 0x06800F90
    // Test aarch32_PKH_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, tb=0, Rn=0, cond=0, imm5=31, Rm=0
    let encoding: u32 = 0x06800F90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field tb 6 +: 1`
/// Requirement: FieldBoundary { field: "tb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pkh_a1_a_field_tb_0_min_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field tb = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, imm5=0, tb=0, Rm=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field tb 6 +: 1`
/// Requirement: FieldBoundary { field: "tb", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pkh_a1_a_field_tb_1_max_10_06800050() {
    // Encoding: 0x06800050
    // Test aarch32_PKH_A1_A field tb = 1 (Max)
    // ISET: A32
    // Fields: tb=1, Rd=0, cond=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0x06800050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pkh_a1_a_field_rm_0_min_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: tb=0, cond=0, Rn=0, imm5=0, Rm=0, Rd=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pkh_a1_a_field_rm_1_poweroftwo_10_06800011() {
    // Encoding: 0x06800011
    // Test aarch32_PKH_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, tb=0, Rd=0, Rm=1, cond=0
    let encoding: u32 = 0x06800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_pkh_a1_a_combo_0_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A field combination: cond=0, Rn=0, Rd=0, imm5=0, tb=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rm=0, Rn=0, cond=0, tb=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_pkh_a1_a_special_cond_0_condition_eq_16_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: tb=0, Rn=0, Rd=0, imm5=0, cond=0, Rm=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_pkh_a1_a_special_cond_1_condition_ne_16_16800010() {
    // Encoding: 0x16800010
    // Test aarch32_PKH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=1, Rd=0, imm5=0, tb=0
    let encoding: u32 = 0x16800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_pkh_a1_a_special_cond_2_condition_cs_hs_16_26800010() {
    // Encoding: 0x26800010
    // Test aarch32_PKH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, imm5=0, Rm=0, tb=0, Rd=0, Rn=0
    let encoding: u32 = 0x26800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_pkh_a1_a_special_cond_3_condition_cc_lo_16_36800010() {
    // Encoding: 0x36800010
    // Test aarch32_PKH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm5=0, Rn=0, cond=3, Rd=0, tb=0, Rm=0
    let encoding: u32 = 0x36800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_pkh_a1_a_special_cond_4_condition_mi_16_46800010() {
    // Encoding: 0x46800010
    // Test aarch32_PKH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rd=0, tb=0, Rm=0, imm5=0, Rn=0
    let encoding: u32 = 0x46800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_pkh_a1_a_special_cond_5_condition_pl_16_56800010() {
    // Encoding: 0x56800010
    // Test aarch32_PKH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm5=0, tb=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x56800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_pkh_a1_a_special_cond_6_condition_vs_16_66800010() {
    // Encoding: 0x66800010
    // Test aarch32_PKH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=6, imm5=0, tb=0
    let encoding: u32 = 0x66800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_pkh_a1_a_special_cond_7_condition_vc_16_76800010() {
    // Encoding: 0x76800010
    // Test aarch32_PKH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm5=0, Rd=0, tb=0, Rm=0, cond=7, Rn=0
    let encoding: u32 = 0x76800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_pkh_a1_a_special_cond_8_condition_hi_16_86800010() {
    // Encoding: 0x86800010
    // Test aarch32_PKH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm5=0, tb=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x86800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_pkh_a1_a_special_cond_9_condition_ls_16_96800010() {
    // Encoding: 0x96800010
    // Test aarch32_PKH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, tb=0, Rn=0, cond=9, imm5=0
    let encoding: u32 = 0x96800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_pkh_a1_a_special_cond_10_condition_ge_16_a6800010() {
    // Encoding: 0xA6800010
    // Test aarch32_PKH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, Rn=0, tb=0, Rm=0, cond=10, Rd=0
    let encoding: u32 = 0xA6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_pkh_a1_a_special_cond_11_condition_lt_16_b6800010() {
    // Encoding: 0xB6800010
    // Test aarch32_PKH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, imm5=0, tb=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0xB6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_pkh_a1_a_special_cond_12_condition_gt_16_c6800010() {
    // Encoding: 0xC6800010
    // Test aarch32_PKH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, imm5=0, Rn=0, Rm=0, tb=0
    let encoding: u32 = 0xC6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_pkh_a1_a_special_cond_13_condition_le_16_d6800010() {
    // Encoding: 0xD6800010
    // Test aarch32_PKH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm5=0, Rd=0, tb=0, Rm=0, Rn=0
    let encoding: u32 = 0xD6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_pkh_a1_a_special_cond_14_condition_al_16_e6800010() {
    // Encoding: 0xE6800010
    // Test aarch32_PKH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: tb=0, Rm=0, Rd=0, cond=14, Rn=0, imm5=0
    let encoding: u32 = 0xE6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_pkh_a1_a_special_cond_15_condition_nv_16_f6800010() {
    // Encoding: 0xF6800010
    // Test aarch32_PKH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: tb=0, imm5=0, Rm=0, cond=15, Rd=0, Rn=0
    let encoding: u32 = 0xF6800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pkh_a1_a_invalid_0_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: tb=0, Rn=0, cond=0, Rd=0, imm5=0, Rm=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_PKH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pkh_a1_a_invalid_1_10_06800010() {
    // Encoding: 0x06800010
    // Test aarch32_PKH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, Rm=0, imm5=0, cond=0, Rn=0, tb=0
    let encoding: u32 = 0x06800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_pkh_t1_a_field_s_0_min_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm2=0, Rn=0, Rm=0, T=0, Rd=0, imm3=0, tb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_pkh_t1_a_field_s_1_max_0_ead00000() {
    // Thumb encoding (32): 0xEAD00000
    // Test aarch32_PKH_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, S=1, imm2=0, Rn=0, T=0, Rd=0, Rm=0, tb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAD00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pkh_t1_a_field_rn_0_min_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, S=0, T=0, Rm=0, Rd=0, tb=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pkh_t1_a_field_rn_1_poweroftwo_0_eac10000() {
    // Thumb encoding (32): 0xEAC10000
    // Test aarch32_PKH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, T=0, tb=0, imm2=0, S=0, Rn=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pkh_t1_a_field_imm3_0_zero_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, Rm=0, imm3=0, tb=0, S=0, T=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pkh_t1_a_field_imm3_1_poweroftwo_0_eac01000() {
    // Thumb encoding (32): 0xEAC01000
    // Test aarch32_PKH_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=1, Rd=0, imm2=0, T=0, S=0, tb=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_pkh_t1_a_field_imm3_3_poweroftwominusone_0_eac03000() {
    // Thumb encoding (32): 0xEAC03000
    // Test aarch32_PKH_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: tb=0, T=0, S=0, Rd=0, Rm=0, Rn=0, imm3=3, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_pkh_t1_a_field_imm3_7_max_0_eac07000() {
    // Thumb encoding (32): 0xEAC07000
    // Test aarch32_PKH_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rn=0, S=0, Rm=0, Rd=0, T=0, imm3=7, imm2=0, tb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pkh_t1_a_field_rd_0_min_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, T=0, Rm=0, tb=0, Rn=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pkh_t1_a_field_rd_1_poweroftwo_0_eac00100() {
    // Thumb encoding (32): 0xEAC00100
    // Test aarch32_PKH_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: T=0, imm3=0, Rn=0, S=0, tb=0, imm2=0, Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_pkh_t1_a_field_imm2_0_zero_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, tb=0, Rn=0, S=0, T=0, imm3=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_pkh_t1_a_field_imm2_1_poweroftwo_0_eac00040() {
    // Thumb encoding (32): 0xEAC00040
    // Test aarch32_PKH_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: tb=0, imm2=1, imm3=0, T=0, Rd=0, Rm=0, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_pkh_t1_a_field_imm2_3_max_0_eac000c0() {
    // Thumb encoding (32): 0xEAC000C0
    // Test aarch32_PKH_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, tb=0, Rm=0, T=0, Rd=0, S=0, imm2=3, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field tb 5 +: 1`
/// Requirement: FieldBoundary { field: "tb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pkh_t1_a_field_tb_0_min_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field tb = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm2=0, T=0, Rm=0, Rn=0, tb=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field tb 5 +: 1`
/// Requirement: FieldBoundary { field: "tb", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pkh_t1_a_field_tb_1_max_0_eac00020() {
    // Thumb encoding (32): 0xEAC00020
    // Test aarch32_PKH_T1_A field tb = 1 (Max)
    // ISET: T32
    // Fields: S=0, Rd=0, imm3=0, T=0, Rn=0, tb=1, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field T 4 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_pkh_t1_a_field_t_0_min_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field T = 0 (Min)
    // ISET: T32
    // Fields: T=0, tb=0, imm2=0, S=0, imm3=0, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field T 4 +: 1`
/// Requirement: FieldBoundary { field: "T", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_pkh_t1_a_field_t_1_max_0_eac00010() {
    // Thumb encoding (32): 0xEAC00010
    // Test aarch32_PKH_T1_A field T = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm3=0, T=1, S=0, imm2=0, tb=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_pkh_t1_a_field_rm_0_min_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, T=0, Rm=0, Rd=0, tb=0, S=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_pkh_t1_a_field_rm_1_poweroftwo_0_eac00001() {
    // Thumb encoding (32): 0xEAC00001
    // Test aarch32_PKH_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: T=0, imm2=0, Rm=1, imm3=0, S=0, Rd=0, tb=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_pkh_t1_a_combo_0_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, tb=0, T=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, T=0, imm2=0, S=0, Rd=0, imm3=0, tb=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_pkh_t1_a_special_s_0_size_variant_0_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rd=0, T=0, Rn=0, S=0, Rm=0, tb=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_pkh_t1_a_special_s_1_size_variant_1_0_ead00000() {
    // Thumb encoding (32): 0xEAD00000
    // Test aarch32_PKH_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rd=0, imm2=0, Rn=0, tb=0, Rm=0, S=1, T=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAD00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "S" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "T" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"S\" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"T\" }) } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_pkh_t1_a_invalid_0_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "S" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "T" }) } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rd=0, tb=0, T=0, imm3=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_pkh_t1_a_invalid_1_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: tb=0, Rn=0, imm3=0, imm2=0, Rd=0, Rm=0, T=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pkh_t1_a_invalid_2_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0, S=0, Rd=0, imm3=0, T=0, tb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_PKH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_pkh_t1_a_invalid_3_0_eac00000() {
    // Thumb encoding (32): 0xEAC00000
    // Test aarch32_PKH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: tb=0, Rm=0, S=0, Rn=0, imm2=0, Rd=0, T=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEAC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SHA256H_A Tests
// ============================================================================

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h_a1_a_field_d_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: D=0, Vn=0, Vd=0, N=0, Q=0, Vm=0, M=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h_a1_a_field_d_1_max_c00_f3400c00() {
    // Encoding: 0xF3400C00
    // Test aarch32_SHA256H_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, N=0, D=1, Q=0, M=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h_a1_a_field_vn_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: N=0, M=0, D=0, Vm=0, Q=0, Vn=0, Vd=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h_a1_a_field_vn_1_poweroftwo_c00_f3010c00() {
    // Encoding: 0xF3010C00
    // Test aarch32_SHA256H_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Vm=0, D=0, Vd=0, Q=0, N=0, Vn=1
    let encoding: u32 = 0xF3010C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h_a1_a_field_vd_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, N=0, Vn=0, D=0, Vd=0, M=0, Q=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h_a1_a_field_vd_1_poweroftwo_c00_f3001c00() {
    // Encoding: 0xF3001C00
    // Test aarch32_SHA256H_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vd=1, D=0, Q=0, Vn=0, M=0, Vm=0, N=0
    let encoding: u32 = 0xF3001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h_a1_a_field_n_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, Vm=0, M=0, D=0, N=0, Vd=0, Q=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h_a1_a_field_n_1_max_c00_f3000c80() {
    // Encoding: 0xF3000C80
    // Test aarch32_SHA256H_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, M=0, N=1, Q=0, Vm=0, Vd=0, D=0
    let encoding: u32 = 0xF3000C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256h_a1_a_field_q_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: M=0, D=0, Vn=0, Vm=0, Vd=0, N=0, Q=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256h_a1_a_field_q_1_max_c00_f3000c40() {
    // Encoding: 0xF3000C40
    // Test aarch32_SHA256H_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: D=0, Vn=0, Vd=0, Q=1, M=0, N=0, Vm=0
    let encoding: u32 = 0xF3000C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h_a1_a_field_m_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, M=0, D=0, N=0, Q=0, Vn=0, Vm=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h_a1_a_field_m_1_max_c00_f3000c20() {
    // Encoding: 0xF3000C20
    // Test aarch32_SHA256H_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, N=0, Q=0, M=1, D=0, Vm=0, Vd=0
    let encoding: u32 = 0xF3000C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h_a1_a_field_vm_0_min_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: Vd=0, Vn=0, D=0, Vm=0, N=0, Q=0, M=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h_a1_a_field_vm_1_poweroftwo_c00_f3000c01() {
    // Encoding: 0xF3000C01
    // Test aarch32_SHA256H_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, D=0, N=0, Vn=0, M=0, Vd=0, Q=0
    let encoding: u32 = 0xF3000C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256h_a1_a_combo_0_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: Q=0, D=0, Vd=0, Vn=0, N=0, Vm=0, M=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256h_a1_a_special_q_0_size_variant_0_3072_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vm=0, D=0, Q=0, N=0, M=0, Vd=0, Vn=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256h_a1_a_special_q_1_size_variant_1_3072_f3000c40() {
    // Encoding: 0xF3000C40
    // Test aarch32_SHA256H_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: Vm=0, Vn=0, N=0, Q=1, Vd=0, M=0, D=0
    let encoding: u32 = 0xF3000C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_a1_a_invalid_0_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: A32
    // Fields: N=0, Vd=0, Q=0, Vm=0, Vn=0, M=0, D=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_a1_a_invalid_1_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, Q=0, Vd=0, N=0, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_a1_a_invalid_2_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vn=0, Vm=0, N=0, Q=0, D=0, Vd=0, M=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_a1_a_invalid_3_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vn=0, Q=0, M=0, N=0, Vm=0, D=0, Vd=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_a1_a_invalid_4_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vm=0, Vd=0, D=0, M=0, N=0, Vn=0, Q=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_a1_a_invalid_5_c00_f3000c00() {
    // Encoding: 0xF3000C00
    // Test aarch32_SHA256H_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: N=0, M=0, D=0, Q=0, Vn=0, Vd=0, Vm=0
    let encoding: u32 = 0xF3000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h_t1_a_field_d_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Vd=0, D=0, N=0, Q=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h_t1_a_field_d_1_max_c00_ff400c00() {
    // Thumb encoding (32): 0xFF400C00
    // Test aarch32_SHA256H_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: M=0, Vn=0, Vm=0, D=1, Vd=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF400C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h_t1_a_field_vn_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Q=0, D=0, Vd=0, N=0, Vm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h_t1_a_field_vn_1_poweroftwo_c00_ff010c00() {
    // Thumb encoding (32): 0xFF010C00
    // Test aarch32_SHA256H_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: D=0, Vd=0, Q=0, Vm=0, Vn=1, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF010C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h_t1_a_field_vd_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Q=0, D=0, Vd=0, Vn=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h_t1_a_field_vd_1_poweroftwo_c00_ff001c00() {
    // Thumb encoding (32): 0xFF001C00
    // Test aarch32_SHA256H_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vd=1, Q=0, M=0, Vm=0, D=0, N=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF001C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h_t1_a_field_n_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Q=0, D=0, Vd=0, Vn=0, N=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h_t1_a_field_n_1_max_c00_ff000c80() {
    // Thumb encoding (32): 0xFF000C80
    // Test aarch32_SHA256H_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, Vn=0, Q=0, D=0, N=1, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256h_t1_a_field_q_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, D=0, Q=0, Vm=0, M=0, N=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256h_t1_a_field_q_1_max_c00_ff000c40() {
    // Thumb encoding (32): 0xFF000C40
    // Test aarch32_SHA256H_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: Vd=0, M=0, D=0, N=0, Vn=0, Q=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h_t1_a_field_m_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, D=0, Vm=0, M=0, Vd=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h_t1_a_field_m_1_max_c00_ff000c20() {
    // Thumb encoding (32): 0xFF000C20
    // Test aarch32_SHA256H_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vn=0, N=0, Q=0, Vm=0, M=1, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h_t1_a_field_vm_0_min_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, M=0, Q=0, Vd=0, N=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h_t1_a_field_vm_1_poweroftwo_c00_ff000c01() {
    // Thumb encoding (32): 0xFF000C01
    // Test aarch32_SHA256H_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, D=0, Q=0, M=0, Vm=1, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256h_t1_a_combo_0_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: N=0, Vn=0, Vd=0, Q=0, D=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256h_t1_a_special_q_0_size_variant_0_3072_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: M=0, N=0, Vd=0, Vm=0, Q=0, D=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256h_t1_a_special_q_1_size_variant_1_3072_ff000c40() {
    // Thumb encoding (32): 0xFF000C40
    // Test aarch32_SHA256H_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: Vm=0, Vn=0, Q=1, D=0, N=0, M=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256h_t1_a_invalid_0_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: D=0, Vn=0, N=0, Q=0, M=0, Vd=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256h_t1_a_invalid_1_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: N=0, M=0, Q=0, Vm=0, Vn=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_t1_a_invalid_2_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: T32
    // Fields: N=0, M=0, Vm=0, Vd=0, D=0, Vn=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_t1_a_invalid_3_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, D=0, Vd=0, N=0, Q=0, Vn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_t1_a_invalid_4_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vd=0, D=0, Vn=0, N=0, Q=0, M=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_t1_a_invalid_5_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, Vn=0, D=0, Vd=0, Q=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_t1_a_invalid_6_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, N=0, Vd=0, Q=0, M=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h_t1_a_invalid_7_c00_ff000c00() {
    // Thumb encoding (32): 0xFF000C00
    // Test aarch32_SHA256H_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, N=0, Q=0, M=0, Vm=0, Vn=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xF);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_sha256h_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_sha256h_t1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sha256h_t1_a_t32_oracle_0_ff000c00() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sha256h_t1_a_t32_oracle_1_ff000c00() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sha256h_t1_a_t32_oracle_2_ff000c00() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SHA256H_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sha256h_t1_a_t32_oracle_3_ff000c00() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xFF000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

// ============================================================================
// aarch32_ESB_A Tests
// ============================================================================

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_esb_a1_a_field_cond_0_min_10_03200010() {
    // Encoding: 0x03200010
    // Test aarch32_ESB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_esb_a1_a_field_cond_1_poweroftwo_10_13200010() {
    // Encoding: 0x13200010
    // Test aarch32_ESB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_esb_a1_a_field_cond_2_poweroftwo_10_23200010() {
    // Encoding: 0x23200010
    // Test aarch32_ESB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_esb_a1_a_field_cond_3_poweroftwo_10_33200010() {
    // Encoding: 0x33200010
    // Test aarch32_ESB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_esb_a1_a_field_cond_4_poweroftwo_10_43200010() {
    // Encoding: 0x43200010
    // Test aarch32_ESB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_esb_a1_a_field_cond_5_poweroftwo_10_53200010() {
    // Encoding: 0x53200010
    // Test aarch32_ESB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_esb_a1_a_field_cond_6_poweroftwo_10_63200010() {
    // Encoding: 0x63200010
    // Test aarch32_ESB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_esb_a1_a_field_cond_7_poweroftwo_10_73200010() {
    // Encoding: 0x73200010
    // Test aarch32_ESB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_esb_a1_a_field_cond_8_poweroftwo_10_83200010() {
    // Encoding: 0x83200010
    // Test aarch32_ESB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_esb_a1_a_field_cond_9_poweroftwo_10_93200010() {
    // Encoding: 0x93200010
    // Test aarch32_ESB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_esb_a1_a_field_cond_10_poweroftwo_10_a3200010() {
    // Encoding: 0xA3200010
    // Test aarch32_ESB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_esb_a1_a_field_cond_11_poweroftwo_10_b3200010() {
    // Encoding: 0xB3200010
    // Test aarch32_ESB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_esb_a1_a_field_cond_12_poweroftwo_10_c3200010() {
    // Encoding: 0xC3200010
    // Test aarch32_ESB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_esb_a1_a_field_cond_13_poweroftwo_10_d3200010() {
    // Encoding: 0xD3200010
    // Test aarch32_ESB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_esb_a1_a_field_cond_14_poweroftwo_10_e3200010() {
    // Encoding: 0xE3200010
    // Test aarch32_ESB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_esb_a1_a_field_cond_15_max_10_f3200010() {
    // Encoding: 0xF3200010
    // Test aarch32_ESB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_esb_a1_a_combo_0_10_03200010() {
    // Encoding: 0x03200010
    // Test aarch32_ESB_A1_A field combination: cond=0
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_esb_a1_a_special_cond_0_condition_eq_16_03200010() {
    // Encoding: 0x03200010
    // Test aarch32_ESB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_esb_a1_a_special_cond_1_condition_ne_16_13200010() {
    // Encoding: 0x13200010
    // Test aarch32_ESB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1
    let encoding: u32 = 0x13200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_esb_a1_a_special_cond_2_condition_cs_hs_16_23200010() {
    // Encoding: 0x23200010
    // Test aarch32_ESB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2
    let encoding: u32 = 0x23200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_esb_a1_a_special_cond_3_condition_cc_lo_16_33200010() {
    // Encoding: 0x33200010
    // Test aarch32_ESB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3
    let encoding: u32 = 0x33200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_esb_a1_a_special_cond_4_condition_mi_16_43200010() {
    // Encoding: 0x43200010
    // Test aarch32_ESB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4
    let encoding: u32 = 0x43200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_esb_a1_a_special_cond_5_condition_pl_16_53200010() {
    // Encoding: 0x53200010
    // Test aarch32_ESB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5
    let encoding: u32 = 0x53200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_esb_a1_a_special_cond_6_condition_vs_16_63200010() {
    // Encoding: 0x63200010
    // Test aarch32_ESB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6
    let encoding: u32 = 0x63200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_esb_a1_a_special_cond_7_condition_vc_16_73200010() {
    // Encoding: 0x73200010
    // Test aarch32_ESB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7
    let encoding: u32 = 0x73200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_esb_a1_a_special_cond_8_condition_hi_16_83200010() {
    // Encoding: 0x83200010
    // Test aarch32_ESB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8
    let encoding: u32 = 0x83200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_esb_a1_a_special_cond_9_condition_ls_16_93200010() {
    // Encoding: 0x93200010
    // Test aarch32_ESB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9
    let encoding: u32 = 0x93200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_esb_a1_a_special_cond_10_condition_ge_16_a3200010() {
    // Encoding: 0xA3200010
    // Test aarch32_ESB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10
    let encoding: u32 = 0xA3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_esb_a1_a_special_cond_11_condition_lt_16_b3200010() {
    // Encoding: 0xB3200010
    // Test aarch32_ESB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11
    let encoding: u32 = 0xB3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_esb_a1_a_special_cond_12_condition_gt_16_c3200010() {
    // Encoding: 0xC3200010
    // Test aarch32_ESB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12
    let encoding: u32 = 0xC3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_esb_a1_a_special_cond_13_condition_le_16_d3200010() {
    // Encoding: 0xD3200010
    // Test aarch32_ESB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13
    let encoding: u32 = 0xD3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_esb_a1_a_special_cond_14_condition_al_16_e3200010() {
    // Encoding: 0xE3200010
    // Test aarch32_ESB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14
    let encoding: u32 = 0xE3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_esb_a1_a_special_cond_15_condition_nv_16_f3200010() {
    // Encoding: 0xF3200010
    // Test aarch32_ESB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15
    let encoding: u32 = 0xF3200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"cond\" }), rhs: LitBits([true, true, true, false]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_esb_a1_a_invalid_0_10_03200010() {
    // Encoding: 0x03200010
    // Test aarch32_ESB_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "cond" }), rhs: LitBits([true, true, true, false]) }
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_esb_a1_a_invalid_1_10_03200010() {
    // Encoding: 0x03200010
    // Test aarch32_ESB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0
    let encoding: u32 = 0x03200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ESB_T1_A
/// ASL: `fixed encoding (no variable fields)`
/// Requirement: BasicEncoding
/// instruction with no variable fields
#[test]
fn test_aarch32_esb_t1_a_basic_encoding_f3a08010() {
    // Thumb encoding (32): 0xF3A08010
    // Test aarch32_ESB_T1_A basic encoding
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ESB_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_esb_t1_a_invalid_0_8010_f3a08010() {
    // Thumb encoding (32): 0xF3A08010
    // Test aarch32_ESB_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08010;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ESB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_esb_t1_a_invalid_1_8010_f3a08010() {
    // Thumb encoding (32): 0xF3A08010
    // Test aarch32_ESB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A08010;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_ESB_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_esb_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

// ============================================================================
// aarch32_SHA256H2_A Tests
// ============================================================================

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h2_a1_a_field_d_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field D = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vm=0, Vd=0, N=0, Vn=0, M=0, D=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h2_a1_a_field_d_1_max_c00_f3500c00() {
    // Encoding: 0xF3500C00
    // Test aarch32_SHA256H2_A1_A field D = 1 (Max)
    // ISET: A32
    // Fields: Vn=0, Vd=0, Vm=0, M=0, Q=0, D=1, N=0
    let encoding: u32 = 0xF3500C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h2_a1_a_field_vn_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field Vn = 0 (Min)
    // ISET: A32
    // Fields: Vm=0, Vd=0, N=0, Q=0, D=0, Vn=0, M=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h2_a1_a_field_vn_1_poweroftwo_c00_f3110c00() {
    // Encoding: 0xF3110C00
    // Test aarch32_SHA256H2_A1_A field Vn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vn=1, Vm=0, Q=0, Vd=0, D=0, N=0, M=0
    let encoding: u32 = 0xF3110C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h2_a1_a_field_vd_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field Vd = 0 (Min)
    // ISET: A32
    // Fields: Q=0, Vm=0, Vd=0, N=0, M=0, Vn=0, D=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h2_a1_a_field_vd_1_poweroftwo_c00_f3101c00() {
    // Encoding: 0xF3101C00
    // Test aarch32_SHA256H2_A1_A field Vd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Q=0, Vn=0, Vd=1, D=0, M=0, Vm=0
    let encoding: u32 = 0xF3101C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h2_a1_a_field_n_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Vn=0, N=0, Vd=0, Q=0, Vm=0, M=0, D=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h2_a1_a_field_n_1_max_c00_f3100c80() {
    // Encoding: 0xF3100C80
    // Test aarch32_SHA256H2_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, N=1, D=0, Vn=0, M=0, Vd=0, Q=0
    let encoding: u32 = 0xF3100C80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256h2_a1_a_field_q_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field Q = 0 (Min)
    // ISET: A32
    // Fields: N=0, M=0, Vd=0, Q=0, Vm=0, D=0, Vn=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256h2_a1_a_field_q_1_max_c00_f3100c40() {
    // Encoding: 0xF3100C40
    // Test aarch32_SHA256H2_A1_A field Q = 1 (Max)
    // ISET: A32
    // Fields: Vm=0, Vd=0, Vn=0, D=0, N=0, Q=1, M=0
    let encoding: u32 = 0xF3100C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h2_a1_a_field_m_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Q=0, M=0, Vn=0, D=0, Vm=0, N=0, Vd=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h2_a1_a_field_m_1_max_c00_f3100c20() {
    // Encoding: 0xF3100C20
    // Test aarch32_SHA256H2_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Vd=0, N=0, Q=0, M=1, Vm=0, Vn=0, D=0
    let encoding: u32 = 0xF3100C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h2_a1_a_field_vm_0_min_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field Vm = 0 (Min)
    // ISET: A32
    // Fields: M=0, N=0, Vn=0, Vm=0, Q=0, D=0, Vd=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h2_a1_a_field_vm_1_poweroftwo_c00_f3100c01() {
    // Encoding: 0xF3100C01
    // Test aarch32_SHA256H2_A1_A field Vm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Vm=1, Vd=0, N=0, Vn=0, Q=0, M=0, D=0
    let encoding: u32 = 0xF3100C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256h2_a1_a_combo_0_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: A32
    // Fields: Vn=0, Vd=0, N=0, Q=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256h2_a1_a_special_q_0_size_variant_0_3072_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A special value Q = 0 (Size variant 0)
    // ISET: A32
    // Fields: Vn=0, Vd=0, Vm=0, M=0, Q=0, D=0, N=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256h2_a1_a_special_q_1_size_variant_1_3072_f3100c40() {
    // Encoding: 0xF3100C40
    // Test aarch32_SHA256H2_A1_A special value Q = 1 (Size variant 1)
    // ISET: A32
    // Fields: M=0, Vn=0, Q=1, Vd=0, D=0, Vm=0, N=0
    let encoding: u32 = 0xF3100C40;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_a1_a_invalid_0_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: A32
    // Fields: Vm=0, D=0, Q=0, N=0, Vn=0, Vd=0, M=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_a1_a_invalid_1_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Vd=0, N=0, Vn=0, Q=0, M=0, D=0, Vm=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_a1_a_invalid_2_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Vm=0, D=0, Q=0, Vd=0, Vn=0, N=0, M=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_a1_a_invalid_3_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: Q=0, Vm=0, Vn=0, N=0, M=0, Vd=0, D=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_a1_a_invalid_4_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: N=0, Vd=0, Q=0, M=0, Vm=0, D=0, Vn=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_a1_a_invalid_5_c00_f3100c00() {
    // Encoding: 0xF3100C00
    // Test aarch32_SHA256H2_A1_A invalid encoding: Unconditional UNDEFINED
    // ISET: A32
    // Fields: D=0, Vm=0, Q=0, M=0, Vn=0, Vd=0, N=0
    let encoding: u32 = 0xF3100C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for A32 encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h2_t1_a_field_d_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field D = 0 (Min)
    // ISET: T32
    // Fields: D=0, N=0, M=0, Vm=0, Q=0, Vd=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field D 22 +: 1`
/// Requirement: FieldBoundary { field: "D", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h2_t1_a_field_d_1_max_c00_ff500c00() {
    // Thumb encoding (32): 0xFF500C00
    // Test aarch32_SHA256H2_T1_A field D = 1 (Max)
    // ISET: T32
    // Fields: Q=0, Vm=0, M=0, D=1, Vn=0, Vd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF500C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h2_t1_a_field_vn_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field Vn = 0 (Min)
    // ISET: T32
    // Fields: D=0, M=0, Vm=0, N=0, Vd=0, Q=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Vn 16 +: 4`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h2_t1_a_field_vn_1_poweroftwo_c00_ff110c00() {
    // Thumb encoding (32): 0xFF110C00
    // Test aarch32_SHA256H2_T1_A field Vn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Vm=0, Vn=1, D=0, N=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF110C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h2_t1_a_field_vd_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field Vd = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, Vm=0, M=0, Q=0, D=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Vd 12 +: 4`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h2_t1_a_field_vd_1_poweroftwo_c00_ff101c00() {
    // Thumb encoding (32): 0xFF101C00
    // Test aarch32_SHA256H2_T1_A field Vd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Vn=0, Vd=1, N=0, M=0, Q=0, Vm=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF101C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h2_t1_a_field_n_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, N=0, D=0, M=0, Vm=0, Vd=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field N 7 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h2_t1_a_field_n_1_max_c00_ff100c80() {
    // Thumb encoding (32): 0xFF100C80
    // Test aarch32_SHA256H2_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Vm=0, Vn=0, Vd=0, D=0, Q=0, N=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sha256h2_t1_a_field_q_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field Q = 0 (Min)
    // ISET: T32
    // Fields: Vm=0, M=0, Vd=0, D=0, Vn=0, N=0, Q=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Q 6 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sha256h2_t1_a_field_q_1_max_c00_ff100c40() {
    // Thumb encoding (32): 0xFF100C40
    // Test aarch32_SHA256H2_T1_A field Q = 1 (Max)
    // ISET: T32
    // Fields: D=0, Vn=0, N=0, Vd=0, M=0, Q=1, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sha256h2_t1_a_field_m_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Vn=0, Q=0, N=0, M=0, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sha256h2_t1_a_field_m_1_max_c00_ff100c20() {
    // Thumb encoding (32): 0xFF100C20
    // Test aarch32_SHA256H2_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Vn=0, Q=0, M=1, Vm=0, Vd=0, D=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_aarch32_sha256h2_t1_a_field_vm_0_min_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field Vm = 0 (Min)
    // ISET: T32
    // Fields: Q=0, D=0, M=0, Vm=0, Vd=0, Vn=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Vm 0 +: 4`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_aarch32_sha256h2_t1_a_field_vm_1_poweroftwo_c00_ff100c01() {
    // Thumb encoding (32): 0xFF100C01
    // Test aarch32_SHA256H2_T1_A field Vm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Q=0, M=0, Vd=0, Vn=0, D=0, N=0, Vm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// D=0 (minimum value)
#[test]
fn test_aarch32_sha256h2_t1_a_combo_0_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A field combination: D=0, Vn=0, Vd=0, N=0, Q=0, M=0, Vm=0
    // ISET: T32
    // Fields: Vn=0, D=0, Vd=0, Q=0, M=0, Vm=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sha256h2_t1_a_special_q_0_size_variant_0_3072_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A special value Q = 0 (Size variant 0)
    // ISET: T32
    // Fields: D=0, M=0, Q=0, Vn=0, Vm=0, N=0, Vd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sha256h2_t1_a_special_q_1_size_variant_1_3072_ff100c40() {
    // Thumb encoding (32): 0xFF100C40
    // Test aarch32_SHA256H2_T1_A special value Q = 1 (Size variant 1)
    // ISET: T32
    // Fields: D=0, N=0, Vd=0, M=0, Q=1, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }`
/// Requirement: UndefinedEncoding { condition: "Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_0_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }
    // ISET: T32
    // Fields: Vd=0, Q=0, N=0, D=0, M=0, Vm=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_1_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Q=0, Vm=0, Vn=0, Vd=0, D=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSHA256Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_2_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSHA256Ext" }, args: [] } }
    // ISET: T32
    // Fields: D=0, Q=0, Vn=0, M=0, Vd=0, N=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_3_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vd=0, M=0, Vm=0, Vn=0, Q=0, D=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_4_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Vm=0, N=0, M=0, Vd=0, D=0, Q=0, Vn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_5_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Vm=0, Vd=0, Vn=0, D=0, N=0, Q=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vd\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vn\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Vm\" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_6_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vd" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vn" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Vm" }), indices: [Single(LitInt(0))] } } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: D=0, Vn=0, Vd=0, Q=0, Vm=0, M=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_sha256h2_t1_a_invalid_7_c00_ff100c00() {
    // Thumb encoding (32): 0xFF100C00
    // Test aarch32_SHA256H2_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Q=0, M=0, N=0, Vd=0, D=0, Vn=0, Vm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (32-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_32_0_6a02003f() {
    // Test TST 32-bit: zero AND zero (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// zero AND zero (64-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_64_0_ea02003f() {
    // Test TST 64-bit: zero AND zero (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (32-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_32_1_6a02003f() {
    // Test TST 32-bit: partial overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// partial overlap (64-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_64_1_ea02003f() {
    // Test TST 64-bit: partial overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0xF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (32-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_32_2_6a02003f() {
    // Test TST 32-bit: no overlap (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// no overlap (64-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_64_2_ea02003f() {
    // Test TST 64-bit: no overlap (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (32-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_32_3_6a02003f() {
    // Test TST 32-bit: MSB set (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// MSB set (64-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_64_3_ea02003f() {
    // Test TST 64-bit: MSB set (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (32-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_32_4_6a02003f() {
    // Test TST 32-bit: all ones (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// all ones (64-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_64_4_ea02003f() {
    // Test TST 64-bit: all ones (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (32-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_32_5_6a02003f() {
    // Test TST 32-bit: alternating (no match) (oracle)
    // Encoding: 0x6A02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    set_w(&mut cpu, 2, 0x55555555);
    let encoding: u32 = 0x6A02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_A1_A
/// ASL: `TST X1, X2`
/// Requirement: FlagComputation { flag: Z, scenario: ZeroResult }
/// alternating (no match) (64-bit)
#[test]
fn test_aarch32_sha256h2_a1_a_oracle_64_5_ea02003f() {
    // Test TST 64-bit: alternating (no match) (oracle)
    // Encoding: 0xEA02003F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x55555555);
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xEA02003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be 0");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be 0");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_sha256h2_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_sha256h2_t1_a_t32_oracle_0_ff100c00() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_sha256h2_t1_a_t32_oracle_1_ff100c00() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_sha256h2_t1_a_t32_oracle_2_ff100c00() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SHA256H2_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_sha256h2_t1_a_t32_oracle_3_ff100c00() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFF100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}
